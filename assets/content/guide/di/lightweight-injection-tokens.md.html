<header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="dhuttspbij4dxycu2forvevoa">使用轻量级注入令牌优化客户应用的大小</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/guide/di/lightweight-injection-tokens.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7wxrqbve456bo02xq2ebntbz0">本页面会提供一个概念性的概述，它介绍了一种建议库开发者使用的依赖注入技术。<em>使用轻量级注入令牌</em>设计你的库，这有助于优化那些用到你库的客户应用的发布包体积。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="b14alhs5ovawpl7s6x0a797so">你可以管理组件和可注入服务之间的依赖结构，通过使用可摇树优化的提供者来优化捆绑包大小。 这通常能确保如果应用实际上从未使用某个提供的组件或服务，编译器可以从捆绑包中移除其代码。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="5sq160klp93jr0k9mymbzlthl">由于 Angular 存储注入令牌的方式，这样一个未使用的组件或服务可能仍会出现在捆绑包中。 本页面描述了一种依赖注入设计模式，通过使用轻量级注入令牌支持正确的摇树优化。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="d62oahvyowlp6o8dn7n5391jd">这种轻量级注入令牌设计模式对于库开发者来说尤其重要。它可以确保当应用只用到了你库中的某些功能时，可以从客户应用的发布包中删除未使用过的代码。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="3dszx0x27sp7ksd9s0rj77tku">当某应用用到了你的库时，你的库中可能会提供一些客户应用未用到的服务。在这种情况下，应用开发人员会期望该服务是可摇树优化的，不让这部分代码增加应用的编译后大小。由于应用开发人员既无法了解也无法解决库的摇树优化问题，因此这是库开发人员的责任。为了防止未使用的组件被保留下来，你的库应该使用轻量级注入令牌这种设计模式。</p>

  <h2 id="when-tokens-are-retained">
    <a href="#when-tokens-are-retained" class="docs-anchor" tabindex="-1" aria-label="Link to When tokens are retained" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="a7kgn5t6xeymvw6j65fqprjrr">什么时候令牌会被保留</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="2lzch2kq1agntljra8gpa2rpi">为了更好地解释令牌保留发生的条件，考虑一个提供图书馆卡组件的库。 这个组件包含一个主体，并且可以包含一个可选的标头：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-tag">&lt;<span class="hljs-name">lib-card</span>&gt;</span>;</div><div class="hljs-ln-line">  <span class="hljs-tag">&lt;<span class="hljs-name">lib-header</span>&gt;</span>…<span class="hljs-tag">&lt;/<span class="hljs-name">lib-header</span>&gt;</span>;</div><div class="hljs-ln-line"><span class="hljs-tag">&lt;/<span class="hljs-name">lib-card</span>&gt;</span>;</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="cb67w69adv5cw7c2g1m698rq3">在一个可能的实现中，
<code>&lt;lib-card&gt;</code> 组件使用 
<code>@ContentChild()</code> 或 
<code>@ContentChildren()</code> 获取 
<code>&lt;lib-header&gt;</code> 和 
<code>&lt;lib-body&gt;</code>，如下所示：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">selector</span>: <span class="hljs-string">'lib-header'</span>,</div><div class="hljs-ln-line">  …,</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LibHeaderComponent</span> {}</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">selector</span>: <span class="hljs-string">'lib-card'</span>,</div><div class="hljs-ln-line">  …,</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LibCardComponent</span> {</div><div class="hljs-ln-line highlighted">  <span class="hljs-meta">@ContentChild</span>(<span class="hljs-title class_">LibHeaderComponent</span>) <span class="hljs-attr">header</span>: <span class="hljs-title class_">LibHeaderComponent</span>|<span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="6ep9l5w8ux7a46vxvmou3k4dc">因为 
<code>&lt;lib-header&gt;</code> 是可选的，该元素可以以最小形式出现在模板中，
<code>&lt;lib-card&gt;&lt;/lib-card&gt;</code>。 在这种情况下，
<code>&lt;lib-header&gt;</code> 没有被使用，你会期望它被摇树优化，但实际情况并非如此。 这是因为 
<code>LibCardComponent</code> 实际上包含两个对 
<code>LibHeaderComponent</code> 的引用：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-meta">@ContentChild</span>(<span class="hljs-title class_">LibHeaderComponent</span>) <span class="hljs-attr">header</span>: <span class="hljs-title class_">LibHeaderComponent</span>;</div></code>
    </pre>
  </div>
  <ul class="docs-list">
    <li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="5en1k8mvdqx3k4inkuabz97dx">其中一个引用位于<em>类型位置上</em> - 即，它把 <code>LibHeaderComponent</code> 用作了类型：<code>header: LibHeaderComponent;</code>。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="7qnx74ztsnyy4ifvtz90ts8wb">另一个引用在 
<em>值位置</em>——即 LibHeaderComponent 是 
<code>@ContentChild()</code> 参数装饰器的值：
<code>@ContentChild(LibHeaderComponent)</code>。</li>

  </ul>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="5ero911xds2c35ex8l8w3u8b0">编译器在这些位置以不同方式处理令牌引用：</p>

  <ul class="docs-list">
    <li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="eglrg2abtdsdpwstvg0lsk5se">编译器在从 TypeScript 转换完后会删除这些<em>类型位置上</em>的引用，所以它们对于摇树优化没什么影响。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="9h3ofgsk04rd5r8af01jekdgd">编译器必须在运行时保留 
<em>值位置</em> 引用，这
<strong>阻止</strong>了组件的摇树优化。</li>

  </ul>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="1bhdgt3dn2wiorvn1sgbti6vh">在这个例子中，编译器保留了出现在值位置的 
<code>LibHeaderComponent</code> 令牌。 这阻止了被引用的组件被摇树优化，即使应用实际上没有在任何地方使用 
<code>&lt;lib-header&gt;</code>。 如果 
<code>LibHeaderComponent</code> 的代码、模板和样式合并后变得太大，不必要地包含它会显著增加客户端应用的大小。</p>

  <h2 id="when-to-use-the-lightweight-injection-token-pattern">
    <a href="#when-to-use-the-lightweight-injection-token-pattern" class="docs-anchor" tabindex="-1" aria-label="Link to When to use the lightweight injection token pattern" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="bw4sbfi4ghch1mq6uce18el40">何时使用轻量级注入令牌模式</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="1wel1bcz4em0ar6p28ydia5si">当某个组件被用作依赖注入的令牌时，就会出现摇树优化的问题。 这可能发生在两种情况下：</p>

  <ul class="docs-list">
    <li data-ng_translator_product="100" data-ng_translator_ref_id="p1zg1gbp8gwh7anlo3mb0332">该令牌被用在
<a href="guide/components/queries#content-queries">内容查询</a>的值位置。</li>
<li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="f4iqatho0y5upbo6sjy6adivx">该令牌用作构造函数注入的类型说明符。</li>

  </ul>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="bo9p3avs6y780grnja1o505vm">在下面的示例中，两次使用
<code>OtherComponent</code>令牌都会导致保留
<code>OtherComponent</code>，从而在不使用时无法进行摇树优化：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> {</div><div class="hljs-ln-line highlighted">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@Optional</span>() other: OtherComponent</span>) {}</div><div class="hljs-ln-line"></div><div class="hljs-ln-line highlighted">  <span class="hljs-meta">@ContentChild</span>(<span class="hljs-title class_">OtherComponent</span>) <span class="hljs-attr">other</span>: <span class="hljs-title class_">OtherComponent</span>|<span class="hljs-literal">null</span>;</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="6hnppcu7dv7uwb0nlgmxlzpbe">虽然仅用作类型说明符的令牌在转换为 JavaScript 时会被移除，但所有用于依赖注入的令牌在运行时都是必要的。 这实际上将
<code>constructor(@Optional() other: OtherComponent)</code>更改为
<code>constructor(@Optional() @Inject(OtherComponent) other)</code>。 该令牌现在处于值位置，这导致摇树优化器保留该引用。</p>

    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="eysv0ajdgk647q5r7ll8jiwd9"><strong>提示：</strong>库应该为所有服务使用
<a href="guide/di/dependency-injection#providing-dependency">可摇树优化的提供者</a>，在根级别提供依赖，而不是在组件或模块中。</p>

    </div>
    
  <h2 id="using-lightweight-injection-tokens">
    <a href="#using-lightweight-injection-tokens" class="docs-anchor" tabindex="-1" aria-label="Link to Using lightweight injection tokens" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="1hmn38j8x4mogevice8fi41fl">使用轻量级注入令牌</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="8ij2nbaojebd1ynq5s8mdm8py">轻量级注入令牌设计模式包括：使用一个小的抽象类作为注入令牌，并在稍后为它提供实际实现。该抽象类固然会被留下（不会被摇树优化掉），但它很小，对应用程序的大小没有任何重大影响。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="eejuaeg83i47bsiy86rd8xt0r">以下示例展示了这在
<code>LibHeaderComponent</code>中的工作方式：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LibHeaderToken</span> {}</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">selector</span>: <span class="hljs-string">'lib-header'</span>,</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">    {<span class="hljs-attr">provide</span>: <span class="hljs-title class_">LibHeaderToken</span>, <span class="hljs-attr">useExisting</span>: <span class="hljs-title class_">LibHeaderComponent</span>}</div><div class="hljs-ln-line">  ]</div><div class="hljs-ln-line">  …,</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LibHeaderComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LibHeaderToken</span> {}</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">selector</span>: <span class="hljs-string">'lib-card'</span>,</div><div class="hljs-ln-line">  …,</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LibCardComponent</span> {</div><div class="hljs-ln-line">  <span class="hljs-meta">@ContentChild</span>(<span class="hljs-title class_">LibHeaderToken</span>) <span class="hljs-attr">header</span>: <span class="hljs-title class_">LibHeaderToken</span>|<span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="370shk2xd0ihghj2s3o7mkdaq">在这个示例中，
<code>LibCardComponent</code>的实现不再在类型位置或值位置引用
<code>LibHeaderComponent</code>。 这使得可以完全摇树优化
<code>LibHeaderComponent</code>。 
<code>LibHeaderToken</code>被保留，但它只是一个类声明，没有具体实现。 它很小，在编译后保留时不会对应用大小产生实质性影响。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="6aewy9pzmxy03mp9qqaog2ref">不过，<code>LibHeaderComponent</code> 本身实现了抽象类 <code>LibHeaderToken</code>。你可以放心使用这个令牌作为组件定义中的提供者，让 Angular 能够正确地注入具体类型。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="9ajsbdh77jzlqk98t5sltla0a">总结一下，轻量级依赖注入令牌模式包括以下内容：</p>

    <ol class="docs-ordered-list">
      <li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="14ycx3amcb5f82tty6xlc5kjy">一个轻量级的注入令牌，它表现为一个抽象类。</li>
<li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="9yk2pbksdqk77nf1ow82ubo98">一个实现该抽象类的组件定义。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="3936xda68kpm5vjhyo996l3ae">使用
<code>@ContentChild()</code>或
<code>@ContentChildren()</code>注入轻量级模式。</li>
<li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="2pzyka2mr68w6yd83g7uvgwwq">实现轻量级注入令牌的提供者，它将轻量级注入令牌和它的实现关联起来。</li>

    </ol>
    
  <h3 id="use-the-lightweight-injection-token-for-api-definition">
    <a href="#use-the-lightweight-injection-token-for-api-definition" class="docs-anchor" tabindex="-1" aria-label="Link to Use the lightweight injection token for API definition" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="9cztsj13ynkpl5aqe70khmxa8">使用轻量级注入令牌进行 API 定义</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="1axbo4k4qetvl28sqs9wxjtur">那些注入了轻量级注入令牌的组件可能要调用注入的类中的方法。因为令牌现在是一个抽象类，并且可注入组件实现了那个抽象类，所以你还必须在作为轻量级注入令牌的抽象类中声明一个抽象方法。该方法的实现代码（及其所有相关代码）都会留在可注入组件中，但这个组件本身仍可被摇树优化。这样就能让父组件以类型安全的方式与子组件（如果存在）进行通信。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="bkqcv8v2gji1pfd06clyowjr3">例如，
<code>LibCardComponent</code>现在查询
<code>LibHeaderToken</code>而不是
<code>LibHeaderComponent</code>。 以下示例展示了该模式如何让
<code>LibCardComponent</code>与
<code>LibHeaderComponent</code>通信而不实际引用
<code>LibHeaderComponent</code>：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LibHeaderToken</span> {</div><div class="hljs-ln-line">  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">doSomething</span>(): <span class="hljs-built_in">void</span>;</div><div class="hljs-ln-line highlighted">}</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">selector</span>: <span class="hljs-string">'lib-header'</span>,</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">    {<span class="hljs-attr">provide</span>: <span class="hljs-title class_">LibHeaderToken</span>, <span class="hljs-attr">useExisting</span>: <span class="hljs-title class_">LibHeaderComponent</span>}</div><div class="hljs-ln-line">  ]</div><div class="hljs-ln-line">  …,</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LibHeaderComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LibHeaderToken</span> {</div><div class="hljs-ln-line highlighted">  <span class="hljs-title function_">doSomething</span>(): <span class="hljs-built_in">void</span> {</div><div class="hljs-ln-line highlighted">    <span class="hljs-comment">// Concrete implementation of `doSomething`</span></div><div class="hljs-ln-line highlighted">  }</div><div class="hljs-ln-line highlighted">}</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">selector</span>: <span class="hljs-string">'lib-card'</span>,</div><div class="hljs-ln-line">  …,</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LibCardComponent</span> implement <span class="hljs-title class_">AfterContentInit</span> {</div><div class="hljs-ln-line">  <span class="hljs-meta">@ContentChild</span>(<span class="hljs-title class_">LibHeaderToken</span>) <span class="hljs-attr">header</span>: <span class="hljs-title class_">LibHeaderToken</span>|<span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;</div><div class="hljs-ln-line"></div><div class="hljs-ln-line">  <span class="hljs-title function_">ngAfterContentInit</span>(): <span class="hljs-built_in">void</span> {</div><div class="hljs-ln-line">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">header</span> !== <span class="hljs-literal">null</span>) {</div><div class="hljs-ln-line highlighted">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">header</span>?.<span class="hljs-title function_">doSomething</span>();</div><div class="hljs-ln-line">    }</div><div class="hljs-ln-line">  }</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="a9jabobqv6osdvlc58u47pu38">在这个示例中，父组件查询令牌以获取子组件，并在存在时存储结果组件引用。 在调用子组件中的方法之前，父组件会检查子组件是否存在。 如果子组件已被摇树优化，就不会有运行时引用，也不会调用其方法。</p>

  <h3 id="naming-your-lightweight-injection-token">
    <a href="#naming-your-lightweight-injection-token" class="docs-anchor" tabindex="-1" aria-label="Link to Naming your lightweight injection token" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="1bebxqg84nwu3zxiojkwv58fa">为你的轻量级注入令牌命名</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="5i332s6ghhryfqthf8lc8p5w4">轻量级注入令牌只对组件有用。Angular 风格指南中建议你使用“Component”后缀命名组件。比如“LibHeaderComponent”就遵循这个约定。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="71q9qvve7hgb991jnvsxderha">你应该保持组件与其令牌之间的关系，同时仍然区分它们。 推荐的样式是使用组件基本名称加上后缀「
<code>Token</code>」来命名你的轻量级依赖注入令牌：「
<code>LibHeaderToken</code>」。</p>
