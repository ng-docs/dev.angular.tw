<header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="kf4izi5x3qitgwqhu7mxeq4r">NgModule 常見問題</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/guide/ngmodules/faq.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="c3fb4uldhk51bkfbsjmx0k7i3">NgModules 可以幫你把應用組織成一些緊密相關的程式碼區塊。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="bpz9taadi172xl2aexxrzkez7">這裡回答的是開發者常問起的關於 NgModule 的設計與實現問題。</p>

  <h2 id="what-classes-should-i-add-to-the-declarations-array">
    <a href="#what-classes-should-i-add-to-the-declarations-array" class="docs-anchor" tabindex="-1" aria-label="Link to What classes should I add to the <code>declarations</code> array?" data-ng_translator_product="100" data-ng_translator_ref_id="q3exsvks9iv8rvncl5dvzziu">我應該向 
<code>declarations</code> 陣列中新增哪些類？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="3jh5vvgg7zy1gf283hb0gtunx">將
<a href="guide/ngmodules/bootstrapping#the-declarations-array">可宣告</a>類（元件、指令和通道）新增到
<code>declarations</code>清單中。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="30ki5zqz2ulo664hv21dftwh1">在應用的
<em>僅一個</em>模組中宣告這些類。如果它們屬於某個特定模組，則在該模組中宣告它們。</p>

  <h2 id="what-is-a-declarable">
    <a href="#what-is-a-declarable" class="docs-anchor" tabindex="-1" aria-label="Link to What is a <code>declarable</code>?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="1qz7raq4d08ykuvk6qoil7zsf">什麼是可宣告物件（<code>declarable</code>）？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="6vq8oyjfuynp37omjbguafhbt">可宣告類是你可以新增到模組的
<code>declarations</code>清單中的類型別（元件、指令和通道）。它們是你唯一可以新增到
<code>declarations</code>中的類。</p>

  <h2 id="what-classes-should-i-not-add-to-declarations">
    <a href="#what-classes-should-i-not-add-to-declarations" class="docs-anchor" tabindex="-1" aria-label="Link to What classes should I <em>not</em> add to <code>declarations</code>?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="bkd6ebj6zb278gvy10l33lixo">哪些類<em>不</em>應該加到 <code>declarations</code> 中？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="equgqmg83a3kzuve6m7f083fz">僅將
<a href="guide/ngmodules/bootstrapping#the-declarations-array">可宣告</a>類新增到 NgModule 的
<code>declarations</code>清單中。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="63amf8hgfrdmdrd68iidaeb73"><em>不要</em>宣告：</p>

  <ul class="docs-list">
    <li data-ng_translator_product="100" data-ng_translator_ref_id="4ua7i9vytwz60sgfc6qammc5b">已在另一個模組中宣告的類，無論是應用程式模組、
<code>@NgModule</code>還是第三方模組。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="v1gdi33mgbmv2zde41yj96cp">從另一個模組匯入的一組指令。 例如，不要從
<code>@angular/forms</code>中宣告
<code>FORMS_DIRECTIVES</code>，因為
<code>FormsModule</code>已經宣告了它。</li>
<li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="brfx5icvv7x0vcrnc84tj3894">模組類。</li>
<li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="815a6dnctobiecpg9y3gn94qm">服務類別。</li>
<li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="2ykf7z9wowex5yyav8ajkb582">非 Angular 的類別和物件，比如：字串、數字、函式、實體模型、設定、業務邏輯和輔助類別。</li>

  </ul>
  
  <h2 id="why-list-the-same-component-in-multiple-ngmodule-properties">
    <a href="#why-list-the-same-component-in-multiple-ngmodule-properties" class="docs-anchor" tabindex="-1" aria-label="Link to Why list the same component in multiple <code>NgModule</code> properties?" data-ng_translator_product="100" data-ng_translator_ref_id="5z7invepv5ya65nk2ggsc231j">為什麼要在多個 
<code>NgModule</code> 屬性中列出相同的元件？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="29c6ac348nxw3ya54bsa276jr"><code>AppComponent</code> 經常同時列在 <code>declarations</code> 和 <code>bootstrap</code> 中。另外你還可能看到它同時列在 <code>declarations</code> 和 <code>exports</code> 中。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="a2qtmkkv0qj39pj98de9j3fm4">這看起來是多餘的，不過這些函式具有不同的功能，從它出現在一個清單中無法推斷出它也應該在另一個清單中。</p>

  <ul class="docs-list">
    <li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="2l66ya0wfi29pai0v2sjikapu"><code>AppComponent</code> 可能被宣告在此模組中，但可能不是引導元件。</li>
<li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="9aqaups5ut0rpbybn7cq5e45q"><code>AppComponent</code> 可能在此模組中引導，但可能是由另一個屬性模組宣告的。</li>
<li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="5fsdwcshy4cyq9sgytwo2gpn5">某個元件可能是從另一個應用模組中匯入的（所以你沒法宣告它）並且被當前模組重新匯出。</li>
<li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="2sl37ygwe5a1lhf4zzmd9khrs">某個元件可能被匯出，以便用在外部元件的樣板中，也可能同時被一個彈出式對話框載入。</li>

  </ul>
  
  <h2 id="what-does-quotcant-bind-to-x-since-it-isnt-a-known-property-of-yquot-mean">
    <a href="#what-does-quotcant-bind-to-x-since-it-isnt-a-known-property-of-yquot-mean" class="docs-anchor" tabindex="-1" aria-label="Link to What does &quot;Can't bind to 'x' since it isn't a known property of 'y'&quot; mean?" data-ng_translator_product="100" data-ng_translator_ref_id="3744wq1oauhi35rq6rb52a0x7">『無法繫結到 'x'，因為它不是 'y' 的已知屬性』是什麼意思？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="c4tx6pmsbwu9dm49umpn2blg3">這個錯誤通常意味著你或者忘了宣告指令『x』，或者你沒有匯入『x』所屬的模組。</p>

    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="82b878lr3wc3te2ixpdzppxdb"><strong>有幫助：</strong>也許你在應用程式子模組中宣告了"x"，但忘記將其匯出。 在將其新增到
<code>exports</code>清單之前，"x"類對其他模組不可見。</p>

    </div>
    
  <h2 id="what-should-i-import">
    <a href="#what-should-i-import" class="docs-anchor" tabindex="-1" aria-label="Link to What should I import?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="1e16cjhli11tzjn0u1x9xyhhi">我應該匯入什麼？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="bvpn2rhzhk2jwji2fgl1xjxtk">匯入那些公共（已匯出）
<a href="guide/ngmodules/bootstrapping#the-declarations-array">可宣告類</a>的NgModule，在本模組的元件樣板中需要引用這些類。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="97nltpqdy4u004oyk3x9lpbjv">這通常意味著從
<code>@angular/common</code>中匯入
<code>CommonModule</code>，以便訪問Angular指令，例如
<code>NgIf</code>和
<code>NgFor</code>。 你可以直接匯入它，也可以從另一個NgModule中
<a href="#can-i-re-export-classes-and-modules?">重新匯出</a>它。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="pt44qiqbf2q83vy7p0v2unva">僅在根
<code>AppModule</code>中匯入
<a href="#should-i-import-browsermodule-or-commonmodule?">BrowserModule</a>。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="el69da37y0oh5wofd21qptjr2">如果你的元件有雙向繫結表示式 
<code>[(ngModel)]</code>，請從 
<code>@angular/forms</code> 匯入 
<code>FormsModule</code>。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="9krtu131l9scs6cnvmdmbko6f">當你的元件使用它們的元件、指令和通道時，請匯入
<em>共享</em>和
<em>屬性</em>模組。</p>

  <h2 id="should-i-import-browsermodule-or-commonmodule">
    <a href="#should-i-import-browsermodule-or-commonmodule" class="docs-anchor" tabindex="-1" aria-label="Link to Should I import <code>BrowserModule</code> or <code>CommonModule</code>?" data-ng_translator_product="100" data-ng_translator_ref_id="52o12w2ov2e5w4rdoeyxgfhba">我應該匯入 
<code>BrowserModule</code> 還是 
<code>CommonModule</code>？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="91eflnrq3t1blg2aihboedfd9">幾乎每個瀏覽器應用的根應用程式模組
<code>AppModule</code>應匯入
<code>@angular/platform-browser</code>中的
<code>BrowserModule</code>。 
<code>BrowserModule</code>提供了啟動和執行瀏覽器應用程式所必需的服務。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="cv517ww1hmisd7k02qhc1e09w"><code>BrowserModule</code>還從
<code>@angular/common</code>中重新匯出
<code>CommonModule</code>， 這意味著
<code>AppModule</code>中的元件也可以訪問每個應用程式所需的 Angular 指令，例如
<code>NgIf</code>和
<code>NgFor</code>。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="7b1yok87ji4ivhr9g8v3wlnb5">不要在任何其他模組中匯入
<code>BrowserModule</code>。 
<em>屬性模組</em>和
<em>延遲載入模組</em>應該匯入
<code>CommonModule</code>。 它們需要常見的指令。 它們不需要重新安裝應用程式範圍的提供者。</p>

    <div class="docs-alert docs-alert-note">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="7hd1vrbyf4by9xm0upyw1mhec"><strong>注意：</strong>匯入
<code>CommonModule</code>也可以使屬性模組可以在
<em>任何</em>目標平台上使用，而不僅僅是瀏覽器。</p>

    </div>
    
  <h2 id="what-if-i-import-the-same-module-twice">
    <a href="#what-if-i-import-the-same-module-twice" class="docs-anchor" tabindex="-1" aria-label="Link to What if I import the same module twice?" data-ng_translator_product="100" data-ng_translator_ref_id="3gbzvrwrfearxbjg9hhfpmh4z">如果我兩次匯入同一個模組會怎麼樣？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="da8socz11b431clwc0yzqkwue">沒有任何問題。當三個模組全都匯入模組'A'時，Angular 只會首次遇到時載入一次模組'A'，之後就不會這麼做了。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="3sh6upa9yffe5svw7a5scvt20">無論 <code>A</code> 出現在所匯入模組的哪個層級，都會如此。如果模組'B'匯入模組'A'、模組'C'匯入模組'B'，模組'D'匯入 <code>[C, B, A]</code>，那麼'D'會觸發模組'C'的載入，'C'會觸發'B'的載入，而'B'會載入'A'。當 Angular 在'D'中想要獲取'B'和'A'時，這兩個模組已經被快取過了，可以立即使用。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="5mm3pwwsfrj6t98qtwalq4f2l">Angular 不允許模組之間出現迴圈依賴，所以不要讓模組'A'匯入模組'B'，而模組'B'又匯入模組'A'。</p>

  <h2 id="what-should-i-export">
    <a href="#what-should-i-export" class="docs-anchor" tabindex="-1" aria-label="Link to What should I export?" data-ng_translator_product="100" data-ng_translator_ref_id="1jys2rejbf25ncvnrwfes33uc">我應該匯出什麼？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="7amhzofm6rpy0iqehw0gaypvo">匯出
<a href="guide/ngmodules/bootstrapping#the-declarations-array">可宣告</a>類，這些類應該能夠在其他
<em>NgModules</em>的樣板中使用。 這些是你的
<em>公共</em>類。 如果不匯出可宣告類，則它將保持
<em>私有</em>，僅對在此 NgModule 中宣告的其他元件可見。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="ckz5wj5ncz52lydhfu8nif10z">你<em>可以</em>匯出任何可宣告類（元件、指令和通道），而不用管它是宣告在當前模組中還是某個匯入的模組中。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="781ejdqjfvkgpcsnuxddc41kq">你<em>可以</em>重新匯出整個匯入過的模組，這將導致重新匯出它們匯出的所有類。重新匯出的模組甚至不用先導入。</p>

  <h2 id="what-should-i-not-export">
    <a href="#what-should-i-not-export" class="docs-anchor" tabindex="-1" aria-label="Link to What should I <em>not</em> export?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7sxaz5f9dtv35g7up445xlkli">我<em>不應該</em>匯出什麼？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="5fe4zsjquz632od2zibqr0e3t">不要匯出以下內容：</p>

  <ul class="docs-list">
    <li><p data-ng_translator_product="100" data-ng_translator_ref_id="1pn1pmn0t6s4npr0679o256zl">只在此 NgModule 中宣告的元件、指令和通道，僅需要在此 NgModule 中的元件中使用。 如果不希望其他 NgModule 看到它，請不要匯出它。</p>
</li>
<li><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7wxrw7z34kkrfqd1h7fbh7ips">不可宣告的物件，比如服務、函式、設定、實體模型等。</p>
</li>
<li><p data-ng_translator_product="100" data-ng_translator_ref_id="3kvlid7bgretbt0ls8rdg14hp">只有路由器動態載入或引導載入的元件。 這些元件永遠不會在另一個元件的樣板中被選擇。 雖然匯出它們沒有害處，但也沒有好處。</p>
</li>
<li><p data-ng_translator_product="100" data-ng_translator_ref_id="1n8bk43w206akdmxyijcpzgx5">不具有公共（已匯出）宣告的純服務模組。 例如，重新匯出
<code>HttpClientModule</code>沒有意義，因為它不匯出任何內容。 它的唯一目的是將http服務提供者新增到整個應用程式中。</p>
</li>

  </ul>
  
  <h2 id="can-i-re-export-classes-and-modules">
    <a href="#can-i-re-export-classes-and-modules" class="docs-anchor" tabindex="-1" aria-label="Link to Can I re-export classes and modules?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="buiwj8cw8viupvbm6sikuvsyw">我可以重新匯出類別和模組嗎？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7vo4eotcdt1sxkawzhaqaei0e">毫無疑問。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="dw35su7bzz97ucr400sz7h067">模組是從其它模組中選取類並把它們重新匯出成統一、便利的新模組的最佳方式。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="a5hu8a79vlofzxykx7awn5bix">一個 NgModule 可以重新匯出整個 NgModule，這實際上重新匯出了它們所有已匯出的類。 Angular 自己的
<code>BrowserModule</code>就像這樣重新匯出了一些 NgModule：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-attr">exports</span>: [<span class="hljs-title class_">CommonModule</span>, <span class="hljs-title class_">ApplicationModule</span>]</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="w71fvfssmm57p2ifbvw5goqg">模組還能匯出一個組合，它可以包含自己的宣告、某些匯入的類以及匯入的模組。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="9u0cyh8rienj35ksqqgnf729w">不必重新匯出純服務模組。 純服務模組不匯出另一個 NgModule 可以使用的
<a href="guide/ngmodules/bootstrapping#the-declarations-array">可宣告</a>類。 例如，重新匯出
<code>HttpClientModule</code>沒有意義，因為它不匯出任何內容。 它的唯一目的是將http服務提供者新增到整個應用程式中。</p>

  <h2 id="what-is-the-forroot-method">
    <a href="#what-is-the-forroot-method" class="docs-anchor" tabindex="-1" aria-label="Link to What is the <code>forRoot()</code> method?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7ailka1s0q96em45kmvkguv3e"><code>forRoot()</code> 方法是什麼？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="9nn39fgtnt0o5asnsqq2vv8yg"><code>forRoot()</code>靜態方法是一種慣例，使開發人員可以輕鬆設定旨在作為單例的服務和提供者。 一個很好的
<code>forRoot()</code>範例是
<code>RouterModule.forRoot()</code>方法。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="5qkxuloaarlm6dkc4r0zw8gly">有關
<code>forRoot()</code>的更多訊息，請參閱
<a href="guide/ngmodules/singleton-services#the-forroot()-pattern"><code>forRoot()</code>模式</a>部分的
<a href="guide/ngmodules/singleton-services">單例服務</a>指南。</p>

  <h2 id="why-is-a-service-provided-in-a-feature-module-visible-everywhere">
    <a href="#why-is-a-service-provided-in-a-feature-module-visible-everywhere" class="docs-anchor" tabindex="-1" aria-label="Link to Why is a service provided in a feature module visible everywhere?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7x8i2uhhe6yzusbcg6lodoqyp">為什麼在屬性模組中提供的服務在整個應用中都可見？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="9wqjvp4b2xywt7tgg8alfa4qv">在引導模組的 
<code>@NgModule.providers</code> 中列出的提供者具有應用範圍。 將服務提供者新增到 
<code>@NgModule.providers</code> 實際上是將該服務發布到整個應用。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="bmk756w9tip0w8su45jkrphvw">當你匯入一個 NgModule 時，Angular 會將該模組的服務提供者（其 
<code>providers</code> 清單的內容）新增到應用根注入器。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="2zp613wqwibz4xo78dm24fusg">這會讓該提供者對應用中所有知道該提供者令牌（token）的類都可見。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="jjyuadsw6vqy936zpfxg56ur">透過 NgModule 匯入實現的可擴充套件性是 NgModule 體系的主要目標。 將 NgModule 提供者合併到應用注入器，使模組函式庫能夠輕鬆地為整個應用增添新的服務。 透過一次性新增 
<code>HttpClientModule</code>，每個應用元件都可以發起 HTTP 請求。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="4q95kvhbuys60ew3hcudw9abh">不過，如果你期望模組的服務只對那個屬性模組內部宣告的元件可見，那麼這可能會帶來一些不受歡迎的意外。如果 <code>HeroModule</code> 提供了一個 <code>HeroService</code>，並且根模組 <code>AppModule</code> 匯入了 <code>HeroModule</code>，那麼任何知道 <code>HeroService</code><em>型別</em>的類都可能注入該服務，而不僅是在 <code>HeroModule</code> 中宣告的那些類。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="ebkuqx2ihnhustetq98tcbl92">要限制對服務的訪問，可以考慮延遲載入提供該服務的 NgModule。 參見 
<a href="#how-do-i-restrict-service-scope-to-a-module?">如何將服務範圍限制到模組？</a> 以獲取更多訊息。</p>

  <h2 id="why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module">
    <a href="#why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module" class="docs-anchor" tabindex="-1" aria-label="Link to Why is a service provided in a lazy-loaded module visible only to that module?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="8d6u7kura4lfe84h3e8wvalgh">為什麼在延遲載入模組中宣告的服務提供者只對該模組自身可見？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="8bexzr17su7zhc0eugcemu930">和啟動時就載入的模組中的提供者不同，延遲載入模組中的提供者是<em>侷限於模組</em>的。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="chieh34j3vb78e8p8zug9am2r">當 Angular 路由器延遲載入一個模組時，它會建立一個新的執行上下文。 該上下文有自己的注入器
<a href="#why-does-lazy-loading-create-a-child-injector?" title="為什麼" angular 建立一個子注入器>，它是應用注入器的直接子注入器</a>。 路由器將延遲模組的提供者以及其匯入的 NgModules 的提供者新增到這個子注入器。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="2fbequmn1q9d2dv9qzrdgomtc">這些提供者不會被擁有相同令牌的應用級別提供者的變化所影響。當路由器在延遲載入環境中建立元件時，Angular 優先使用延遲載入模組中的服務實例，而不是來自應用的根注入器的。</p>

  <h2 id="what-if-two-modules-provide-the-same-service">
    <a href="#what-if-two-modules-provide-the-same-service" class="docs-anchor" tabindex="-1" aria-label="Link to What if two modules provide the same service?" data-ng_translator_product="100" data-ng_translator_ref_id="do3ssf799zgpo4nmoqfnoh0f5">如果兩個模組提供了同一個服務會怎樣？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="by6qcb1tnswx4lhw8yia49elo">當同時載入了兩個匯入的模組，它們都列出了使用同一個令牌的提供者時，後匯入的模組會『獲勝』，這是因為這兩個提供者都被新增到了同一個注入器中。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="421l3llro1ue2it8ediw4wb6c">當 Angular 嘗試根據令牌注入服務時，它使用第二個提供者來建立並交付服務實例。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="q5hkkpdc0jgsg35m4cdz25e8"><em>每個</em>注入了該服務的類獲得的都是由第二個提供者建立的實例。即使是宣告在第一個模組中的類，它取得的實例也是來自第二個提供者的。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="9j3zdpiepeczv9zptcdxsm0gt">如果模組 A 提供了一個使用令牌'X'的服務，並且匯入的模組 B 也用令牌'X'提供了一個服務，那麼模組 A 中定義的服務『獲勝』了。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="bqb4dpedl8odmjtnooi0ng3px">由根 <code>AppModule</code> 提供的服務相對於所匯入模組中提供的服務有優先權。換句話說：<code>AppModule</code> 總會獲勝。</p>

  <h2 id="how-do-i-restrict-service-scope-to-a-module">
    <a href="#how-do-i-restrict-service-scope-to-a-module" class="docs-anchor" tabindex="-1" aria-label="Link to How do I restrict service scope to a module?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="1q7w15pbcu1wpn79wahdcx4sz">我應該如何把服務的範圍限制到模組中？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="1vecfq5rfxc2nx4slrb2g2wfg">當一個模組在應用啟動時載入時，其 
<code>@NgModule.providers</code> 具有
<em>應用範圍</em>；即，它們可以在整個應用中注入。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="4qtrgca59nk6tccf5pvjrii2o">匯入的提供者很容易被由其它匯入模組中的提供者替換掉。這雖然是故意這樣設計的，但是也可能引起意料之外的結果。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="crtszw6qizuo5wxln4enl6xe2">作為一個通用的規則，應該<em>只匯入一次</em>帶提供者的模組，最好在應用的<em>根模組</em>中。那裡也是設定、包裝和重寫這些服務的最佳位置。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="aw53ge3elpzxahjz12yq222tz">假設一個模組需要一個自定義的 
<code>HttpBackend</code>，它為所有 Http 請求新增一個特殊的標頭。 如果應用中的另一個模組也自定義了 
<code>HttpBackend</code> 或者僅僅匯入了 
<code>HttpClientModule</code>，它可能會覆蓋此模組的 
<code>HttpBackend</code> 提供者，從而失去特殊標頭。 伺服器將拒絕來自此模組的 http 請求。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="e32jzs91ek3yxodwis8qbqt4v">為避免這種問題，僅在 
<code>AppModule</code>（應用
<em>根模組</em>）中匯入 
<code>HttpClientModule</code>。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="5xa870kc62awloekk6zzids8f">如果你必須防範這種『提供者腐化』現象，那就<em>不要依賴於『啟動時載入』模組的 <code>providers</code></em>。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="6b6ldvtuq32lkddmfrldw2t8a">如果可以，延遲載入該模組。 Angular 會為一個
<a href="#why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module?">延遲載入模組</a>提供其自己的子注入器。 該模組的提供者僅在使用該注入器建立的元件樹中可見。</p>

  <h3 id="alternative-restricting-scope-to-a-component-and-its-children">
    <a href="#alternative-restricting-scope-to-a-component-and-its-children" class="docs-anchor" tabindex="-1" aria-label="Link to Alternative: Restricting scope to a component and its children" data-ng_translator_product="100" data-ng_translator_ref_id="9pti4a6mi32eoy7k3e6eypz5i">替代方案：將範圍限制在元件及其子元件</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="igncpyok3wj4woihjvc1anll">繼續同樣的例子，假設模組的元件確實需要一個私有的、自定義的 
<code>HttpBackend</code>。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="a5b9szui41owozuxtss8vx0w1">建立一個「頂級元件」，作為該模組所有元件的根。 將自定義的 
<code>HttpBackend</code> 提供者新增到頂級元件的 
<code>providers</code> 清單中，而不是模組的 
<code>providers</code> 清單中。 回想一下，Angular 為每個元件實例建立一個子注入器，並用元件自己的提供者填充該注入器。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="3aomrv3sp4v79zvrb4psayg2a">當此元件的子元件請求 
<code>HttpBackend</code> 服務時，Angular 提供的是本地 
<code>HttpBackend</code> 服務，而不是應用根注入器中提供的版本。因此，子元件可以進行設定好的 HTTP 請求，無論其他模組如何設定 
<code>HttpBackend</code>。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="eh62f44z1av1ljcc5nfvcuqgc">確保將需要訪問這個特殊設定的 
<code>HttpBackend</code> 的元件建立為此元件的子元件。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="3slihikvxpgms81csiqhav8cw">你可以將子元件嵌入到頂層元件的樣板中。或者，透過給頂層元件一個 
<code>&lt;router-outlet&gt;</code> 使其成為路由宿主。定義子路由並讓路由器將模組元件載入到該插座中。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7vwofb1tcc9bo9v7pvwq1xzoh">雖然透過在延遲載入模組中或元件中提供某個服務來限制它的訪問都是可行的方式，但在元件中提供服務可能導致這些服務出現多個實例。因此，應該優先使用延遲載入的方式。</p>

  <h2 id="should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent">
    <a href="#should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent" class="docs-anchor" tabindex="-1" aria-label="Link to Should I add application-wide providers to the root <code>AppModule</code> or the root <code>AppComponent</code>?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="8j8fqi96eaqi6tvyjfar89e1">我應該把全應用級提供者新增到根模組 <code>AppModule</code> 中還是根元件 <code>AppComponent</code> 中？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="5gs63ypve77jsdiqjvhudl2mj">透過在服務的 
<code>@Injectable()</code> 裝飾器中指定 
<code>providedIn: 'root'</code> 或在建立 
<code>InjectionToken</code> 時定義應用範圍的提供者（在提供令牌的情況下）。這種方式建立的提供者會自動用於整個應用，不需要列在任何模組中。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="2uenb234hc983c6yh2ac42yb8">如果某個提供者不能用這種方式設定（可能因為它沒有有意義的預設值），那就在根模組 <code>AppModule</code> 中註冊這些全應用級服務，而不是在 <code>AppComponent</code> 中。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="9hghs4n9ib25khz97vcgb2cgr">延遲載入模組及其元件可以注入 <code>AppModule</code> 中的服務，卻不能注入 <code>AppComponent</code> 中的。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="6g4jc5jcndny82s5ec1858w2u"><em>僅</em>在
<code>AppComponent</code>的提供者中註冊服務的情況下，該服務必須對
<code>AppComponent</code>樹外的元件隱藏。這是一種罕見的用例。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="1bmkkjdts1q393bqys0tq1ha7">更普遍地，
<a href="#should-i-add-other-providers-to-a-module-or-a-component?">優先在 NgModules 中註冊提供者</a> 而不是在元件中註冊。</p>

  <h3 id="discussion">
    <a href="#discussion" class="docs-anchor" tabindex="-1" aria-label="Link to Discussion" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="e51zlya75cbuqy3o40kio43hf">討論</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="4xiuo5idsw0ca7l7ape7cz29j">Angular 將所有啟動模組提供者註冊到應用根注入器中。根注入器建立的服務具有應用範圍，這意味著它們對整個應用可用。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="4vnwblwqdtbbptbv659mkgy3f">某些服務（如 
<code>Router</code>）只有在應用根注入器中註冊時才能工作。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="ble9ah6k0jrbb1kolxdcpcd4">相比之下，Angular 將
<code>AppComponent</code>的提供者註冊到
<code>AppComponent</code>自己的注入器中。
<code>AppComponent</code>服務僅對該組件及其元件樹可用。它們具有元件範圍。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="dsr3vuodwax3u2mpd1rdhezl1"><code>AppComponent</code>的注入器是根注入器的子級，在注入器層級中稍低一級。對於不使用路由器的應用來說，這幾乎是整個應用。但在使用路由的應用中，路由在根級別操作，這裡
<code>AppComponent</code>服務不存在。這意味著延遲載入的模組無法訪問它們。</p>

  <h2 id="should-i-add-other-providers-to-a-module-or-a-component">
    <a href="#should-i-add-other-providers-to-a-module-or-a-component" class="docs-anchor" tabindex="-1" aria-label="Link to Should I add other providers to a module or a component?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="10yvigwtmiry3t76v6ig5qrhu">我應該把其它提供者註冊到模組中還是元件中？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="be1gasxsduj9dq7xrh9fap0mq">應使用 
<code>@Injectable</code> 語法設定提供者。如果可能，應在應用根中提供（
<code>providedIn: 'root'</code>）。以這種方式設定的服務，如果僅從延遲載入的上下文中使用，則會延遲載入。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="1g4pxgcculbh5k40gsoiqkiuu">如果是否在應用範圍內可用是由使用者決定的，那麼應在模組（
<code>@NgModule.providers</code>）中註冊提供者，而不是在元件（
<code>@Component.providers</code>）中註冊。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="aun1ex6jwtmsral8ev8m9n4e9">當你<em>必須</em>把服務實例的範圍限制到某個元件及其子元件樹時，就把提供者註冊到該組件中。指令的提供者也同樣照此處理。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="brgeblsftbb346ygw7dudz8fm">比如，如果英雄編輯元件需要自己私有的快取英雄服務實例，那就應該在本元件中註冊此服務。這樣，本元件的每個新實例都會得到一份自己的快取服務實例。編輯器的改動只會作用於它自己的服務，而不會影響到應用中其它地方的英雄實例。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="14z7mj0hy9z12omi658yo3ij3"><a href="#should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent?">始終將<em>應用範圍</em>的服務註冊到根<code>AppModule</code></a>，而不是根
<code>AppComponent</code>。</p>

  <h2 id="why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module">
    <a href="#why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module" class="docs-anchor" tabindex="-1" aria-label="Link to Why is it bad if a shared module provides a service to a lazy-loaded module?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="6690idlmkoo75mgw93vpradyz">為什麼在共享模組中為延遲載入模組提供服務是個餿主意？</a>
  </h2>
  
  <h3 id="the-eagerly-loaded-scenario">
    <a href="#the-eagerly-loaded-scenario" class="docs-anchor" tabindex="-1" aria-label="Link to The eagerly loaded scenario" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="axohv88mjbupeuk35fmrwzo7l">急性載入的場景</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="8awrptwq5rmlufgto8i758mrn">當急性載入的模組提供某個服務（例如 
<code>UserService</code>）時，該服務在整個應用中都是可用的。如果根模組提供 
<code>UserService</code> 並且匯入另一個提供相同 
<code>UserService</code> 的模組，Angular 會在根應用注入器中註冊其中一個（參見 
<a href="#what-if-i-import-the-same-module-twice?">如果我兩次匯入相同的模組會怎樣？</a>）。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="9eob5zn12k9zi2om4azrae67t">然後，當某些元件注入 <code>UserService</code> 時，Angular 就會發現它已經在應用的根注入器中了，並交付這個全應用級的單例服務。這樣不會出現問題。</p>

  <h3 id="the-lazy-loaded-scenario">
    <a href="#the-lazy-loaded-scenario" class="docs-anchor" tabindex="-1" aria-label="Link to The lazy loaded scenario" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="5w1jx7br7jhy4m4z46mg948pp">延遲載入場景</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="cd2znw82mlpmducfiz6izohvp">現在，考慮一個延遲載入的模組，它也提供了一個名叫 <code>UserService</code> 的服務。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="et8zxyx3hw760c1b3vm4ewjgg">當路由器準備延遲載入某個模組的時候，它會建立一個子注入器，並且把 <code>UserService</code> 的提供者註冊到那個子注入器中。子注入器和根注入器是<em>不同</em>的。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="ehaai872834f33ihw4bgci6br">當 Angular 為該模組建立惰性元件並注入
<code>UserService</code>時，它在惰性模組的
<em>子注入器</em>中找到
<code>UserService</code>提供者，並建立
<em>新</em>的
<code>UserService</code>實例。這是一個完全不同的
<code>UserService</code>實例，而不是 Angular 在某個急性載入元件中注入的應用範圍單例版本。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="bmnkmyc6lx4jcg7twb8o75wum">這個場景導致你的應用每次都建立一個新的服務實例，而不是使用單例的服務。</p>

  <h2 id="why-does-lazy-loading-create-a-child-injector">
    <a href="#why-does-lazy-loading-create-a-child-injector" class="docs-anchor" tabindex="-1" aria-label="Link to Why does lazy loading create a child injector?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="4fr5cegjhii7hzy24nlj29foo">為什麼延遲載入模組會建立一個子注入器？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="ep7m19dfmantp2ndd67ag48nh">Angular 將
<code>@NgModule.providers</code>新增到應用根注入器，除非該 NgModule 是延遲載入的。對於延遲載入的 NgModule，Angular 會建立
<em>子注入器</em>並將模組的提供者新增到子注入器中。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="9gsyshlk10gg8a8hmye9w973l">這意味著 NgModule 的行為取決於它是在應用啟動時載入還是後來延遲載入的。忽視這種差異可能會導致不良後果（參見 
<a href="#why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module?">為什麼共享模組為延遲載入模組提供服務是有害的？</a>）。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="1t5j2yps1xc2vcvorfasc120t">為什麼 Angular 不能像主動載入模組那樣把延遲載入模組的提供者也新增到應用程式的根注入器中呢？為什麼會出現這種不一致？</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="9flamf9zx2x7qu0taw5hu6ulo">答案基於 Angular 依賴注入體系的一個基本屬性。注入器可以新增提供者，
<em>直到它首次被使用</em>。一旦注入器開始建立和提供服務，其提供者清單就會凍結；不允許新增新提供者。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="jk2jc9wnc4ih3xb56ecfcipp">當應用啟動時，Angular 首先設定根注入器及所有急性載入的 NgModule 提供者，
<em>然後</em>建立其第一個元件並注入任何提供的服務。一旦應用開始，應用根注入器就不再接受新提供者。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="1k3gydge0qrbh7xqsz99577rl">時間過去，應用邏輯觸發某個 NgModule 的延遲載入。Angular 必須將延遲載入模組的提供者新增到某個注入器中。它無法將它們新增到應用根注入器，因為該注入器已關閉以接受新提供者。所以 Angular 為延遲載入模組上下文建立一個新的子注入器。</p>

  <h2 id="how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded">
    <a href="#how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded" class="docs-anchor" tabindex="-1" aria-label="Link to How can I tell if an NgModule or service was previously loaded?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="bn149kiy3hogx2qjpkwp6xbx2">我要如何知道一個模組或服務是否已經載入過了？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="38up7ygx6nvtsi1ou27xk85iv">某些 NgModule 及其服務應該只由根 
<code>AppModule</code> 載入一次。透過延遲載入某個模組再次匯入該模組可能會
<a href="#why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module?">產生難以檢測和診斷的錯誤行為</a>。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="yjltg6xqgaaengvva165h2a4">為了防範這種風險，可以寫一個建構式函式，它會嘗試從應用的根注入器中注入該模組或服務。如果這種注入成功了，那就說明這個類是被第二次載入的，你就可以丟擲一個錯誤，或者採取其它挽救措施。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="eypcyfltmtokqubrgd4cvz0gp">某些 NgModule（如 
<code>BrowserModule</code>）實現了這樣的防護機制。以下是一個名為 
<code>GreetingModule</code> 的 NgModule 自定義建構式函式。</p>
<div class="docs-code" header="src/app/greeting/greeting.module.ts">
    <div class="docs-code-header"><h3>src/app/greeting/greeting.module.ts</h3></div>
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-meta">@NgModule</span>({...})</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GreetingModule</span> {</div><div class="hljs-ln-line">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@Optional</span>() <span class="hljs-meta">@SkipSelf</span>() parentModule?: GreetingModule</span>) {</div><div class="hljs-ln-line">    <span class="hljs-keyword">if</span> (parentModule) {</div><div class="hljs-ln-line">      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(</div><div class="hljs-ln-line">        <span class="hljs-string">'GreetingModule is already loaded. Import it in the AppModule only'</span>);</div><div class="hljs-ln-line">    }</div><div class="hljs-ln-line">  }</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div>
  <h2 id="what-kinds-of-modules-should-i-have-and-how-should-i-use-them">
    <a href="#what-kinds-of-modules-should-i-have-and-how-should-i-use-them" class="docs-anchor" tabindex="-1" aria-label="Link to What kinds of modules should I have and how should I use them?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="a6yyld2ye5n3zswpwej68mtwh">有哪些型別的模組？我應該如何使用它們？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7s3ueg0s15ifs2kswa8gjnw9b">每個應用都不一樣。根據不同程度的經驗，開發者會做出不同的選擇。下列建議和指導原則廣受歡迎。</p>

  <h3 id="sharedmodule">
    <a href="#sharedmodule" class="docs-anchor" tabindex="-1" aria-label="Link to <code>SharedModule</code>"><code>SharedModule</code></a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="4b2o2re47l2sz5nwq58dgtapa"><code>SharedModule</code> 是一個常規名稱，用於包含應用中各處使用的元件、指令和通道的 
<code>NgModule</code>。此模組應該完全由 
<code>declarations</code> 組成，其中大多數應匯出。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="2b5x3ycxvhd52iuf1akyt9l4v"><code>SharedModule</code> 可以重新匯出其他小部件模組，如 
<code>CommonModule</code>、
<code>FormsModule</code> 以及包含你最常用的 UI 控制元件的 NgModule。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="6xxqta36yuqdky29pigrq8gg"><code>SharedModule</code>不應有
<code>providers</code>，原因如
<a href="#why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module?">前面解釋</a>。它的匯入或重新匯出的模組也不應有
<code>providers</code>。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="4efwrl8gzlgnrob9bnmklyv12">在你的
<em>屬性</em>模組中匯入 
<code>SharedModule</code>。</p>

  <h3 id="feature-modules">
    <a href="#feature-modules" class="docs-anchor" tabindex="-1" aria-label="Link to Feature Modules" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="6fljutr1i4kb9wann6aj1uskb">屬性模組</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="3vorvyzb1qgpu2ljhgfd8carr">屬性模組是你圍繞特定的應用業務領域建立的模組，比如使用者工作流、小工具集等。它們包含指定的屬性，併為你的應用提供支援，比如路由、服務、視窗部件等。要對你的應用中可能會有哪些屬性模組有個概念，考慮如果你要把與特定功能（比如搜尋）有關的檔案放進一個目錄下，該目錄的內容就可能是一個名叫 <code>SearchModule</code> 的屬性模組。它將會包含構成搜尋功能的全部元件、路由和樣板。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="eh6dysrtsxc6t2kitb60vqznd">欲瞭解更多訊息，請參見
<a href="guide/ngmodules/feature-modules">屬性模組</a>和
<a href="guide/ngmodules/module-types">模組型別</a></p>

  <h2 id="whats-the-difference-between-ngmodules-and-javascript-modules">
    <a href="#whats-the-difference-between-ngmodules-and-javascript-modules" class="docs-anchor" tabindex="-1" aria-label="Link to What's the difference between NgModules and JavaScript Modules?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="61z9e97qlnd1yb5jeq5lpwdsg">在 NgModule 和 JavaScript 模組之間有什麼不同？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="58ugd7lznfuwrxhwpl57b5c1v">在 Angular 應用中，NgModule 會和 JavaScript 的模組一起工作。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="a2yuazsehv0lu1ukrznukxnaf">在現代 JavaScript 中，每個檔案都是一個模組（參見 Exploring ES6 網站的
<a href="https://exploringjs.com/es6/ch_modules.html" target="_blank">模組</a>頁面）。在每個檔案中，你編寫 
<code>export</code> 語句以公開模組的一部分。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="6pc9f46yplqmx3f52ier9tzbv">一個 Angular NgModule 是一個帶有 
<code>@NgModule</code> 裝飾器的類 — JavaScript 模組不需要有 
<code>@NgModule</code> 裝飾器。Angular 的 
<code>NgModule</code> 有 
<code>imports</code> 和 
<code>exports</code>，它們的功能類似。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="f0fcx4qh2l2cacde8fuhxekwy">你可以<em>匯入</em>其它 NgModules，以便在當前模組的元件樣板中使用它們匯出的類。你可以<em>匯出</em>當前 NgModules 中的類，以便<em>其它</em> NgModules 可以匯入它們，並用在自己的元件樣板中。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="sfa409nyc2s32aj038y2dc8u">欲瞭解更多訊息，請參見
<a href="guide/ngmodules/vs-jsmodule">JavaScript 模組與 NgModules</a>。</p>

  <h2 id="what-is-a-template-reference">
    <a href="#what-is-a-template-reference" class="docs-anchor" tabindex="-1" aria-label="Link to What is a template reference?" data-ng_translator_product="100" data-ng_translator_ref_id="7d3unzcuv2pnycnsesc7t4754">什麼是樣板引用？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="5u9j1leuv5emtkoymp1tkou6">Angular 如何在樣板中找到元件、指令和通道？</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="c23hzd5x3mfqs6vrla0enm6ss"><a href="#what-is-the-angular-compiler?">Angular 編譯器</a>在元件樣板中查詢其他元件、指令和通道。找到時，這就是一個樣板引用。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="dh2htgezwcf8qtyqg1itwjfd8">當 Angular 編譯器在樣板中找到元件或指令時，是因為它可以將該組件或指令的
<em>選擇器</em>與樣板中的某些 HTML 對應。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="98fcekn2j3ewz68vmywbkxnmu">如果通道的
<em>名稱</em>出現在樣板 HTML 的通道語法中，編譯器就會找到此通道。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="4j16vpk2t7nzrpw2b9w9vjexz">Angular 只會在當前模組中宣告過的那些類或被當前模組匯入的模組所匯出的那些類別中對應這些選擇器和通道名。</p>

  <h2 id="what-is-the-angular-compiler">
    <a href="#what-is-the-angular-compiler" class="docs-anchor" tabindex="-1" aria-label="Link to What is the Angular compiler?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="mmd1tmgvcr0we30ml68k78xa">什麼是 Angular 編譯器？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="1tepovsitp099jch0n8rbs9pk">Angular 編譯器將你編寫的應用程式碼轉換為高效能的 JavaScript 程式碼。
<code>@NgModule</code> 元資料在指導編譯過程中起著重要作用。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="3xs2h093co9nz4j88pyo2grd5">你編寫的程式碼不會立即執行。 例如，元件有包含自定義元素、屬性型指令、Angular 繫結宣告和某些顯然不是原生 HTML 的特有語法的樣板。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="asb0bbbhlj1tv7yw11ekor0cn">Angular 編譯器讀取樣板標記，將其與對應的元件類別程式碼結合，併發出
<em>元件工廠</em>。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="9zi4rhg77clpz5wu7y54nlrdc">元件工廠建立一個純粹的 100% JavaScript 表示形式的元件，包含其 
<code>@Component</code> 元資料中描述的所有內容：HTML、繫結指令、附著樣式。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="7ktidz70ep9xnfmbfztrsmwgs">由於指令和通道出現在元件樣板中，Angular 編譯器也將它們納入編譯後的元件程式碼中。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="d0ppglitlomezbhwcskk8zpzv"><code>@NgModule</code> 元資料告訴 Angular 編譯器哪些元件要為此模組編譯，以及如何將此模組與其他模組關聯。</p>
