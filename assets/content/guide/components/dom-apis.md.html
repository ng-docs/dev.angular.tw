<header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1" data-ng_translator_product="100" data-ng_translator_ref_id="31t9hn03hwyig11f53ryrzfu9">使用 DOM API</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/guide/components/dom-apis.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    
    <div class="docs-alert docs-alert-tip">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="dgm70qgb782h0hajisr0uqi7a"><strong>提示：</strong>本指南假定你已经阅读了
<a href="essentials">基本指南</a>。如果你是 Angular 的新手，请先阅读该指南。</p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_ref_id="cd18z8u7u6tj88vjvi2pj8k83">Angular 为你处理了大部分的 DOM 创建、更新和移除操作。然而，你可能会偶尔需要直接与某个组件的 DOM 交互。组件可以注入 ElementRef 以获取该组件宿主元素的引用：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({...})</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProfilePhoto</span> {</div><div class="hljs-ln-line">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">elementRef: ElementRef</span>) {</div><div class="hljs-ln-line">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elementRef.<span class="hljs-property">nativeElement</span>);</div><div class="hljs-ln-line">  }</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="b69e8fmx4vr7h2ly06dr95k7v"><code>nativeElement</code> 属性引用了宿主 
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element" target="_blank">Element</a> 实例。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="a0aktafct55kabu4uew29ikx8">你可以使用 Angular 的 
<code>afterRender</code> 和 
<code>afterNextRender</code> 函数来注册一个
<strong>渲染回调</strong>，该回调会在 Angular 完成页面渲染后运行。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({...})</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProfilePhoto</span> {</div><div class="hljs-ln-line">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">elementRef: ElementRef</span>) {</div><div class="hljs-ln-line">    <span class="hljs-title function_">afterRender</span>(<span class="hljs-function">() =&gt;</span> {</div><div class="hljs-ln-line">      <span class="hljs-comment">// Focus the first input element in this component.</span></div><div class="hljs-ln-line">      elementRef.<span class="hljs-property">nativeElement</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'input'</span>)?.<span class="hljs-title function_">focus</span>();</div><div class="hljs-ln-line">    });</div><div class="hljs-ln-line">  }</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="evfpnmcfwixygmxd8cqmpxbia"><code>afterRender</code> 和 
<code>afterNextRender</code> 必须在
<em>注入上下文</em>中调用，通常是在组件的构造函数中。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="fguglwr2ecvxg98ysj6khsw7"><strong>尽量避免直接操作 DOM。</strong>始终优先在组件模板中表达你的 DOM 结构，并使用绑定来更新该 DOM。</p>
<p><strong data-ng_translator_product="100" data-ng_translator_ref_id="5vk0bmummyofy8kplpi862shl">在服务器端渲染或构建时预渲染期间，渲染回调永远不会运行。</strong></p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="ek5pfhqzh6lft25rgkgu7noku"><strong>绝不要在其他 Angular 生命周期钩子中直接操作 DOM</strong>。Angular 不保证组件的 DOM 在任何时候（除了渲染回调中）是完全渲染的。此外，在其他生命周期钩子中读取或修改 DOM 会通过引起
<a href="https://web.dev/avoid-large-complex-layouts-and-layout-thrashing" target="_blank">布局抖动</a>，对页面性能产生负面影响。</p>

  <h2 id="using-a-components-renderer">
    <a href="#using-a-components-renderer" class="docs-anchor" tabindex="-1" aria-label="Link to Using a component's renderer" data-ng_translator_product="100" data-ng_translator_ref_id="eb0wmcuc92b5og2bcnegmts4g">使用组件的渲染器</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="1ofbvd2p0qvzqv4uxcv7dt6yb">组件可以注入 
<code>Renderer2</code> 的实例以执行某些与其他 Angular 特性相关的 DOM 操作。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="d88f39e7bucuprivbpzp9px1j">由组件的 
<code>Renderer2</code> 创建的任何 DOM 元素都会参与该组件的
<a href="guide/components/styling#style-scoping">样式封装</a>。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="cs3wfot0wxyrhyq933lisxtrr">某些 
<code>Renderer2</code> API 也与 Angular 的动画系统相关。你可以使用 
<code>setProperty</code> 方法来更新合成动画属性，并使用 
<code>listen</code> 方法为合成动画事件添加事件监听器。详情请参阅
<a href="guide/animations">动画指南</a>。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="9ndvagnimgie6mm1iymhyz693">除了这两个狭隘的用例之外，使用 
<code>Renderer2</code> 与使用原生 DOM API 没有区别。
<code>Renderer2</code> API 不支持在服务器端渲染或构建时预渲染上下文中进行 DOM 操作。</p>

  <h2 id="when-to-use-dom-apis">
    <a href="#when-to-use-dom-apis" class="docs-anchor" tabindex="-1" aria-label="Link to When to use DOM APIs" data-ng_translator_product="100" data-ng_translator_ref_id="bydkvutc3u736qnykdamatnji">何时使用 DOM API</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="d54yzzdqb0nhav2fwwowpqbcf">虽然 Angular 处理了大部分的渲染问题，但某些行为仍可能需要使用 DOM API。一些常见的用例包括：</p>

  <ul class="docs-list">
    <li data-ng_translator_product="100" data-ng_translator_ref_id="9y0iw2r27lz1mqzturxq0wteo">管理元素焦点</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="99nrpn6fsss4bp1a4098rbese">测量元素几何形状，例如使用 
<code>getBoundingClientRect</code></li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="9y2jsawyb3opfsnruu8fr26vk">读取元素的文本内容</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="65xum0yn9ggxxindfnal0vuc8">设置本机观察器，例如 
<a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" target="_blank"><code>MutationObserver</code></a>、
<a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver" target="_blank"><code>ResizeObserver</code></a> 或 
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" target="_blank"><code>IntersectionObserver</code></a>。</li>

  </ul>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="44xfv9jxj3iiq7208c9cddbx9">避免插入、移除和修改 DOM 元素。特别是，
<strong>绝不要直接设置元素的 <code>innerHTML</code> 属性</strong>，这会使你的应用易受
<a href="https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting" target="_blank">跨站脚本（XSS）攻击</a>的威胁。Angular 的模板绑定（包括 
<code>innerHTML</code> 的绑定）包含有助于防范 XSS 攻击的安全措施。详情请参阅
<a href="best-practices/security">安全指南</a>。</p>
