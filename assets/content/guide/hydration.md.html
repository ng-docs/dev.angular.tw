<header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="f56gmhqyrur87h9p9zanu9nib">水合</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/guide/hydration.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    
  <h2 id="what-is-hydration">
    <a href="#what-is-hydration" class="docs-anchor" tabindex="-1" aria-label="Link to What is hydration" data-ng_translator_product="100" data-ng_translator_ref_id="56lwflegdeq058j9zh4ahngi8">什么是水合</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="bsbdzaok6hlbaw1l6q3fwo8w8">水合是一个在客户端恢复服务器端渲染的应用的过程。这包括复用服务器渲染的 DOM 结构、持久化应用状态、传输服务器已经检索到的应用数据等过程。</p>

  <h2 id="why-is-hydration-important">
    <a href="#why-is-hydration-important" class="docs-anchor" tabindex="-1" aria-label="Link to Why is hydration important?" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="doyri47hfufkarjwmisgnju3m">为什么水合很重要？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="6zpg7zqs8wdb23ogep5knkzir">水合通过避免额外的工作（重新创建 DOM 节点）来提高应用性能。相反，Angular 尝试在运行时将现有的 DOM 元素与应用结构匹配，并在可能的情况下复用 DOM 节点。这带来了性能提升，可以通过 
<a href="https://web.dev/learn-core-web-vitals/" target="_blank">核心网络指标（CWV）</a> 统计数据来衡量，比如减少首次输入延迟（
<a href="https://web.dev/fid/" target="_blank">FID</a>）和最大内容渲染（
<a href="https://web.dev/lcp/" target="_blank">LCP</a>），以及累计布局偏移（
<a href="https://web.dev/cls/" target="_blank">CLS</a>）。改善这些数据也会影响 SEO 性能。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="b9hvav82cxv92snmgmqfd0h8m">如果没有启用水合，服务器端渲染的 Angular 应用将会销毁并重新渲染应用的 DOM，这可能导致可见的 UI 闪烁。这种重新渲染会对 
<a href="https://web.dev/learn-core-web-vitals/" target="_blank">核心网络指标</a>（如 
<a href="https://web.dev/lcp/" target="_blank">LCP</a>）产生负面影响并导致布局偏移。启用水合可以复用现有的 DOM 并防止闪烁。</p>

  <h2 id="how-do-you-enable-hydration-in-angular">
    <a href="#how-do-you-enable-hydration-in-angular" class="docs-anchor" tabindex="-1" aria-label="Link to How do you enable hydration in Angular" data-ng_translator_product="100" data-ng_translator_ref_id="d9ty3va4fr29pqlne5uo7cu3m">如何在 Angular 中启用水合</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="45eklx9v5llx9ow9q7hm62zeo">在开始水合之前，你必须有一个服务器端渲染（SSR）的应用。请先按照 
<a href="guide/ssr">Angular SSR 指南</a> 启用服务器端渲染。一旦你的应用启用了 SSR，可以通过访问主应用组件或模块并从 
<code>@angular/platform-browser</code> 导入 
<code>provideClientHydration</code> 来启用水合。然后将该提供者添加到应用的引导提供者列表中。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">import</span> {</div><div class="hljs-ln-line">  bootstrapApplication,</div><div class="hljs-ln-line">  provideClientHydration,</div><div class="hljs-ln-line">} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;</div><div class="hljs-ln-line">...</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-title function_">bootstrapApplication</span>(<span class="hljs-title class_">AppComponent</span>, {</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [<span class="hljs-title function_">provideClientHydration</span>()]</div><div class="hljs-ln-line">});</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="8a8jmdjcnvs3jlmhgcwn07rgg">如果你使用的是 NgModules，可以将 
<code>provideClientHydration</code> 添加到根应用模块的提供者列表中。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">import</span> {provideClientHydration} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;</div><div class="hljs-ln-line"><span class="hljs-keyword">import</span> {<span class="hljs-title class_">NgModule</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@NgModule</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">declarations</span>: [<span class="hljs-title class_">AppComponent</span>],</div><div class="hljs-ln-line">  <span class="hljs-attr">exports</span>: [<span class="hljs-title class_">AppComponent</span>],</div><div class="hljs-ln-line">  <span class="hljs-attr">bootstrap</span>: [<span class="hljs-title class_">AppComponent</span>],</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [<span class="hljs-title function_">provideClientHydration</span>()],</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> {}</div></code>
    </pre>
  </div>
    <div class="docs-alert docs-alert-important">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="5fqdb640qcns3k07mj3qqsn6x"><strong>重要：</strong> 确保 
<code>provideClientHydration()</code> 调用也包含在用于引导应用的 
<strong>服务器</strong> 的一组提供者中。在具有默认项目结构的应用中（由 
<code>ng new</code> 命令生成），将调用添加到根 
<code>AppModule</code> 应该就足够了，因为该模块由服务器模块导入。如果你使用自定义设置，请将 
<code>provideClientHydration()</code> 调用添加到服务器引导配置中的提供者列表中。</p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="56bgs20pili2eskzuhg3nfu0k">完成这些步骤并启动服务端后，在浏览器中加载你的应用程序。</p>

    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="e6bpsawit221v9n4clgm87g5d"><strong>提示：</strong> 在水合完全工作之前，你可能需要修复直接 DOM 操作的实例，可以通过切换到 Angular 构造或使用 
<code>ngSkipHydration</code> 来完成此操作。有关更多详细信息，请参阅
<a href="#constraints">限制</a>、
<a href="#direct-dom-manipulation">直接 DOM 操作</a>以及
<a href="#how-to-skip-hydration-for-particular-components">如何跳过特定组件的水合</a>。</p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_ref_id="2mycshpuhhz8z71531wveyx8u">在开发模式下运行应用时，可以通过打开浏览器的开发者工具并查看控制台，确认水合是否启用。你应该会看到一条包含水合相关统计信息的消息，比如水合的组件和节点数量。</p>

    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="63pja4xtudpmn2kkstqq5r6k0"><strong>提示：</strong>Angular 根据页面上渲染的所有组件（包括来自第三方库的组件）计算统计信息。</p>

    </div>
    
  <h2 id="constraints">
    <a href="#constraints" class="docs-anchor" tabindex="-1" aria-label="Link to Constraints" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="9tec8wud1c413vns0x11e6vfc">约束条件</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="6k8wvs1892pfvi8k13m1ftmxd">水合对你的应用程序施加了一些限制，这些限制在没有启用水合的情况下是不存在的。你的应用程序必须在服务端和客户端具有相同的生成的 DOM 结构。水合过程期望 DOM 树在两个地方具有相同的结构。这还包括 Angular 在服务端渲染期间生成的空白和注释节点。这些空白和注释节点必须出现在服务端渲染过程生成的 HTML 中。</p>

    <div class="docs-alert docs-alert-important">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="axc9dhln3vc8i8e3cpkxzooxl"><strong>重要：</strong>服务器端渲染操作产生的 HTML 
<strong>绝不能</strong>在服务器和客户端之间被改变。</p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="c4bif3er1x4q61nh7x15t5yib">如果服务端和客户端的 DOM 树结构不匹配，当水合过程试图将预期的内容与 DOM 中实际存在的内容相匹配时就会遇到问题。使用原生 DOM API 进行直接 DOM 操作的组件是最常见的罪魁祸首。</p>

  <h3 id="direct-dom-manipulation">
    <a href="#direct-dom-manipulation" class="docs-anchor" tabindex="-1" aria-label="Link to Direct DOM Manipulation" data-ng_translator_product="100" data-ng_translator_ref_id="bu69ibonnxfppx6xi1mft18s9">直接 DOM 操作</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="d73rt1zy4l4r5x5hjbhv00cos">如果你的组件使用原生 DOM API 操作 DOM，或者使用 
<code>innerHTML</code> 或 
<code>outerHTML</code>，水合过程将会遇到错误。具体的 DOM 操作问题包括访问 
<code>document</code>、查询特定元素以及使用 
<code>appendChild</code> 注入额外节点。分离 DOM 节点并将其移动到其他位置也会导致错误。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="a08gg55xeb6nkzrgikirg9vmi">这是因为 Angular 无法察觉这些 DOM 变化，无法在水合过程中求解它们。Angular 会期望某种结构，但在尝试进行水合时会遇到不同的结构。这种不匹配将导致水合失败，并抛出 DOM 不匹配错误（
<a href="#errors">见下文</a>）。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="6nezwp5wkk8y9ikyci4k23zd6">最好重构你的组件以避免这种 DOM 操作。如果可以，尽量使用 Angular API 来完成这项工作。如果无法重构这种行为，请使用 
<code>ngSkipHydration</code> 属性（
<a href="#how-to-skip-hydration-for-particular-components">下文描述</a>），直到你能重构为友好的水合解决方案。</p>

  <h3 id="valid-html-structure">
    <a href="#valid-html-structure" class="docs-anchor" tabindex="-1" aria-label="Link to Valid HTML structure" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="4vooeix8hv6u3yty3z1hmvkj9">有效的 HTML 结构</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="6jimybwuv26xmwkbyoqbytxhx">在某些情况下，如果你的组件模板没有有效的 HTML 结构，可能会导致在水合期间出现 DOM 不匹配错误。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="e83l4moyn85yr0t1cf3z7v0o2">例如，以下是此问题的一些最常见案例。</p>

  <ul class="docs-list">
    <li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="cw5tftrv5boofoiwmafg5zasy"><code>&lt;table&gt;</code> 标签中没有 <code>&lt;tbody&gt;</code></li>
<li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="2mfd5u2j0a1zqqzquadtkox77"><code>&lt;div&gt;</code>标签 位于 <code>&lt;p&gt;</code> 中</li>
<li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="8rj1kt6swknxkklxvan7aqbki"><code>&lt;a&gt;</code>标签 位于 <code>&lt;h1&gt;</code> 中</li>
<li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="66wcte1bh9lfb9h37vr7sy2z0"><code>&lt;a&gt;</code> 标签位于另一个 <code>&lt;a&gt;</code> 中</li>

  </ul>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="8kg85xz5dn2nypvhu79no1t7l">如果你不确定你的 HTML 是否有效，可以使用 
<a href="https://validator.w3.org/" target="_blank">语法校验器</a>来检查。</p>

  <h3 id="preserve-whitespaces-configuration">
    <a href="#preserve-whitespaces-configuration" class="docs-anchor" tabindex="-1" aria-label="Link to Preserve Whitespaces Configuration" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="aasize33idxox7la96qtmykm5">保留空白字符配置</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="89szeyq14kmaapebaksukqd83">使用水合功能时，我们建议对 <code>preserveWhitespaces</code> 使用默认设置 <code>false</code>。如果你的 tsconfig 中没有进行此设置，则该值将为 <code>false</code> 而无需更改。如果你选择通过将 <code>preserveWhitespaces: true</code> 添加到你的 tsconfig 中来启用保留空格，就可能会遇到水合问题。这在目前还不是一个受到完全支持的配置。</p>

    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="ehwsdnoe24yl00ue6zy4z1hik"><strong>提示：</strong>确保此设置在 
<code>tsconfig.server.json</code>（用于服务器）和 
<code>tsconfig.app.json</code>（用于浏览器构建）中
<strong>一致</strong>。不一致的值会导致水合中断。</p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="31q7ez65fjeapcmxcsr6yumtd">如果你选择在 tsconfig 中设置此选项，我们建议仅在 <code>tsconfig.app.json</code> 中设置它，因为默认情况下 <code>tsconfig.server.json</code> 会从 tsconfig.app.json 中继承此选项。</p>

  <h3 id="custom-or-noop-zonejs-are-not-yet-supported">
    <a href="#custom-or-noop-zonejs-are-not-yet-supported" class="docs-anchor" tabindex="-1" aria-label="Link to Custom or Noop Zone.js are not yet supported" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7o22ezmzscxy6pbzdkhprr8q1">尚不支持自定义或无操作的 Zone.js</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="bm8qiif4rv9p8vdvp6mk9gvpv">水合要依赖于来自 Zone.js 的信号来确定应用程序何时变得稳定，以便 Angular 可以在服务端上启动序列化过程或在客户端启动水合后进行清理工作（以删除无主的 DOM 节点）。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="4kq5fz6xuabofz1h22bznxt72">提供自定义或 “noop” Zone.js 实现可能会导致“稳定”事件发生在不同的时间点，从而过早或过晚触发序列化或清理。这还不是已受完全支持的配置，你可能需要在自定义 Zone.js 实现中调整 <code>onStable</code> 事件的时间。</p>

  <h2 id="errors">
    <a href="#errors" class="docs-anchor" tabindex="-1" aria-label="Link to Errors" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="5mcfu00geyug3tkj1rksyx81i">错误</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="3hzqzi2bvmaeuix11573v5t89">你可能会遇到几种与水合相关的错误，从节点不匹配到在无效宿主节点上使用 
<code>ngSkipHydration</code>。最常见的错误情况是由于使用原生 API 直接操作 DOM，导致水合无法在客户端找到或匹配服务器渲染的预期 DOM 树结构。另一种可能遇到的错误在之前的 
<a href="#valid-html-structure">有效的 HTML 结构</a> 部分中提到过。因此，确保模板中的 HTML 使用有效的结构，可以避免这个错误。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="4o6gz2rrayupnuu0mjf14hlom">有关水合相关错误的完整参考，请访问<a href="/errors">错误参考指南</a>。</p>

  <h2 id="how-to-skip-hydration-for-particular-components">
    <a href="#how-to-skip-hydration-for-particular-components" class="docs-anchor" tabindex="-1" aria-label="Link to How to skip hydration for particular components" data-ng_translator_product="100" data-ng_translator_ref_id="5b0ji8wqwcq3gxpq3wu9zsr0a">如何跳过特定组件的水合</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="a2p5foh8zd96dj8waexic8m7q">由于上述问题（如 
<a href="#direct-dom-manipulation">直接 DOM 操作</a>），某些组件在启用水合时可能无法正常工作。作为一种变通方法，你可以在组件的标签中添加 
<code>ngSkipHydration</code> 属性，以跳过整个组件的水合。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-tag">&lt;<span class="hljs-name">app-example</span> <span class="hljs-attr">ngSkipHydration</span> /&gt;</span></div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7g2h025onn9dxvycvimas41b7">或者，你可以在宿主绑定中使用 <code>ngSkipHydration</code>。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({</div><div class="hljs-ln-line">  ...</div><div class="hljs-ln-line">  <span class="hljs-attr">host</span>: {<span class="hljs-attr">ngSkipHydration</span>: <span class="hljs-string">'true'</span>},</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleComponent</span> {}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="erm8m77c1yucrrlfiovl8zvyq"><code>ngSkipHydration</code> 属性将强制 Angular 跳过对整个组件及其子组件的水合。使用此属性意味着该组件的行为就像未启用水合一样，这意味着它将自行销毁并重新渲染。</p>

    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="1buj9rahk65ptdpmwu4wreaye"><strong>提示：</strong>这将修复渲染问题，但这意味着该组件（及其子组件）将无法享受水合的好处。你需要调整组件的实现，避免破坏水合的模式（如直接 DOM 操作），以便能够移除跳过水合的注解。</p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="87jci2paincb8uz0xw9p07g4d"><code>ngSkipHydration</code> 属性只能在组件的宿主节点上使用。如果将此属性添加到其他节点，Angular 就会抛出错误。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="cn5rfnijgk1jcgolpvaxh5j68">请记住，将 <code>ngSkipHydration</code> 属性添加到根应用程序组件将有效地禁用对整个应用程序的水合。因此使用此属性时要小心谨慎，它只能作为最后的解决方案。那些破坏水合的组件应被视为需要修复的错误。</p>

  <h2 id="i18n">
    <a href="#i18n" class="docs-anchor" tabindex="-1" aria-label="Link to I18N">I18N</a>
  </h2>
  
    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="bcqyds6fqzyr6mkx3mtgxe5zi"><strong>提示：</strong>水合的国际化支持目前处于
<a href="/reference/releases#developer-preview">开发者预览</a>阶段。默认情况下，Angular 将跳过使用 i18n 控制块的组件的水合，实际上是从头重新渲染这些组件。</p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_ref_id="316pvj4vzu1tsoqwiik9szcqe">要为 i18n 控制块启用水合，可以在 
<code>provideClientHydration</code> 调用中添加 
<a href="/api/platform-browser/withI18nSupport"><code>withI18nSupport</code></a>。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">import</span> {</div><div class="hljs-ln-line">  bootstrapApplication,</div><div class="hljs-ln-line">  provideClientHydration,</div><div class="hljs-ln-line">  withI18nSupport,</div><div class="hljs-ln-line">} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;</div><div class="hljs-ln-line">...</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-title function_">bootstrapApplication</span>(<span class="hljs-title class_">AppComponent</span>, {</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [<span class="hljs-title function_">provideClientHydration</span>(<span class="hljs-title function_">withI18nSupport</span>())]</div><div class="hljs-ln-line">});</div></code>
    </pre>
  </div>
  <h2 id="third-party-libraries-with-dom-manipulation">
    <a href="#third-party-libraries-with-dom-manipulation" class="docs-anchor" tabindex="-1" aria-label="Link to Third Party Libraries with DOM Manipulation" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="d28vsnijtkkoqokk43vnkqkdf">具有 DOM 操作的第三方库</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="6rjaqsoznh1wxwu778n9cmrjc">有许多依赖于 DOM 操作才能渲染的第三方库。D3 图表就是典型。这些库在没有水合的情况下能正常工作，但在启用水合时可能会导致 DOM 不匹配错误。现在，如果你在使用这些库之一时遇到了 DOM 不匹配的错误，可以将 <code>ngSkipHydration</code> 属性添加到使用该库渲染的组件。</p>
