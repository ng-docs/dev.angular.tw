<header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="59lj2adjv35bjs3nghyd6twal">结构型指令</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/guide/directives/structural-directives.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    <p data-ng_translator_product="100" data-ng_translator_ref_id="c07neu5f75lc4zb5q56vpe4jv">结构型指令是应用于 
<code>&lt;ng-template&gt;</code> 元素的指令，这些指令有条件地或反复地渲染该 
<code>&lt;ng-template&gt;</code> 的内容。</p>

  <h2 id="example-use-case">
    <a href="#example-use-case" class="docs-anchor" tabindex="-1" aria-label="Link to Example use case" data-ng_translator_product="100" data-ng_translator_ref_id="tn3anosjsvbz9y1cm03v34fn">示例用例</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="c578o44qo0s58els5czcub1ir">在本指南中，你将构建一个结构型指令，该指令从给定的数据源获取数据，并在数据可用时渲染其模板。此指令称为 
<code>SelectDirective</code>，取自 SQL 关键字 
<code>SELECT</code>，并且与属性选择器 
<code>[select]</code> 匹配。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="ytt5a40jiip3wo98ilhamp32"><code>SelectDirective</code> 将有一个命名数据源的输入，你将其称为 
<code>selectFrom</code>。此输入的 
<code>select</code> 前缀对于 
<a href="#structural-directive-shorthand">简写语法</a> 很重要。该指令将使用提供所选数据的模板上下文实例化其 
<code>&lt;ng-template&gt;</code>。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="5stqxr1h1glhwf2amxzr7tn2a">以下是直接在 
<code>&lt;ng-template&gt;</code> 上使用此指令的示例：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> <span class="hljs-attr">select</span> <span class="hljs-attr">let-data</span> [<span class="hljs-attr">selectFrom</span>]=<span class="hljs-string">"source"</span>&gt;</span></div><div class="hljs-ln-line">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The data is: {{ data }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></div><div class="hljs-ln-line"><span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span></div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="448y9psbfhxzv0wat47vhznfm">该结构型指令可以等待数据变得可用，然后渲染其 
<code>&lt;ng-template&gt;</code>。</p>

    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="2w0l66aly3dh9l29zrfdmo8la"><strong>提示：</strong>请注意，Angular 的 
<code>&lt;ng-template&gt;</code> 元素定义了一种默认情况下不渲染任何内容的模板，如果你只是将元素包裹在 
<code>&lt;ng-template&gt;</code> 中而不应用结构型指令，这些元素将不会被渲染。</p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="eb2tuc989i4mwxx4mfvnvaba2">有关更多信息，请参阅<a href="api/core/ng-template">ng-template API</a>文档。</p>

  <h2 id="structural-directive-shorthand">
    <a href="#structural-directive-shorthand" class="docs-anchor" tabindex="-1" aria-label="Link to Structural directive shorthand" data-ng_translator_product="100" data-ng_translator_ref_id="1sihb7la17m64uvph58hqo1ci">结构型指令简写形式</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="2kn7owawumj0veb0zo9j15dd7">Angular 支持结构型指令的简写语法，这避免了显式编写 
<code>&lt;ng-template&gt;</code> 元素的需要。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="4rythfn2ujyqvkvpuxs4y9ust">可以通过在指令属性选择器前加上星号（
<code>*</code>）直接在元素上应用结构型指令，例如 
<code>*select</code>。Angular 会将结构型指令前的星号转换为包含该指令的 
<code>&lt;ng-template&gt;</code>，并包围该元素及其后代。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="1u89ij0qfxptqn97egfqsricg">你可以如下使用 
<code>SelectDirective</code>：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> *<span class="hljs-attr">select</span>=<span class="hljs-string">"let data from source"</span>&gt;</span>The data is: {{data}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="5ghm8df7qvf9i2a3s7z4jik2k">此示例显示了结构型指令简写语法（有时称为 
<em>微语法</em>）的灵活性。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="eshwva71134533rjybpdy6w7h">以这种方式使用时，只有结构型指令及其绑定会应用到 
<code>&lt;ng-template&gt;</code>。
<code>&lt;p&gt;</code> 标签上的任何其他属性或绑定都将保留不变。例如，这两种形式是等效的：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">&lt;!-- Shorthand syntax: --&gt;</span></div><div class="hljs-ln-line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"data-view"</span> *<span class="hljs-attr">select</span>=<span class="hljs-string">"let data from source"</span>&gt;</span>The data is: {{data}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-comment">&lt;!-- Long-form syntax: --&gt;</span></div><div class="hljs-ln-line"><span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> <span class="hljs-attr">select</span> <span class="hljs-attr">let-data</span> [<span class="hljs-attr">selectFrom</span>]=<span class="hljs-string">"source"</span>&gt;</span></div><div class="hljs-ln-line">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"data-view"</span>&gt;</span>The data is: {{data}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></div><div class="hljs-ln-line"><span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span></div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="djo21xe0qk2fdcv4cu7okejdt">简写语法通过一组约定进行扩展。下面定义了更详细的
<a href="#structural-directive-syntax-reference">语法</a>，但在上述示例中，此转换可以解释如下：</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="czbncwkvmyqzuylpba8580poa"><code>*select</code> 表达式的第一部分是 
<code>let data</code>，它声明了一个模板变量 
<code>data</code>。由于没有后续赋值，该模板变量绑定到模板上下文属性 
<code>$implicit</code>。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="3pd42b8i4fx592y9zdjtrr772">语法的第二部分是键-表达式对，
<code>from source</code>。
<code>from</code> 是绑定键，
<code>source</code> 是常规模板表达式。绑定键通过将其转换为 PascalCase 并在前面加上结构型指令选择器来映射到属性。键 
<code>from</code> 映射到 
<code>selectFrom</code>，然后绑定到表达式 
<code>source</code>。这就是为什么许多结构型指令的输入都带有该结构型指令选择器前缀的原因。</p>

  <h2 id="one-structural-directive-per-element">
    <a href="#one-structural-directive-per-element" class="docs-anchor" tabindex="-1" aria-label="Link to One structural directive per element" data-ng_translator_product="100" data-ng_translator_ref_id="bok1mve03gbluvbhqk2zekkor">每个元素一个结构指令</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="dvab79jgfda2tyopa3wegbw1m">使用简写语法时，你只能在每个元素上应用一个结构型指令。这是因为只有一个 
<code>&lt;ng-template&gt;</code> 元素可以展开到该指令上。多个指令将需要多个嵌套的 
<code>&lt;ng-template&gt;</code>，且不清楚哪个指令应优先。
<code>&lt;ng-container&gt;</code> 可用于在需要在同一物理 DOM 元素或组件周围应用多个结构型指令时创建包装层，这允许用户定义嵌套结构。</p>

  <h2 id="creating-a-structural-directive">
    <a href="#creating-a-structural-directive" class="docs-anchor" tabindex="-1" aria-label="Link to Creating a structural directive" data-ng_translator_product="100" data-ng_translator_ref_id="2vm1te90yw2758g6abyrc10ys">创建结构型指令</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="29ycqg3vtmv9jbm1d1hhkiloh">本节将指导你创建 
<code>SelectDirective</code>。</p>

    <ol class="docs-steps">
      
    <li>
      <span class="docs-step-number" aria-hidden="true"></span>
      
  <h3 id="generate-the-directive">
    <a href="#generate-the-directive" class="docs-anchor" tabindex="-1" aria-label="Link to Generate the directive" data-ng_translator_product="100" data-ng_translator_ref_id="6irjsuejr9yxm5wuprfn3cera">生成指令</a>
  </h3>
  
      <p data-ng_translator_product="100" data-ng_translator_ref_id="9obamq2vh4dq2sedtzqtjhwms">使用 Angular CLI，运行以下命令，其中 
<code>select</code> 是指令的名称：</p>
<div class="docs-code shell">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line">ng generate directive select</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="emieqy9ih0wwrwck1bxybcu9q">Angular 创建了指令类并指定了 CSS 选择器 
<code>[select]</code>，它在模板中标识了该指令。</p>

    </li>
    
    <li>
      <span class="docs-step-number" aria-hidden="true"></span>
      
  <h3 id="make-the-directive-structural">
    <a href="#make-the-directive-structural" class="docs-anchor" tabindex="-1" aria-label="Link to Make the directive structural" data-ng_translator_product="100" data-ng_translator_ref_id="exun1xistuk4nxlzqn5ofjxtm">将此指令变为结构型指令</a>
  </h3>
  
      <p data-ng_translator_product="100" data-ng_translator_ref_id="cxrktl6zqbwbxuzw6to9otvt9">导入 
<code>TemplateRef</code> 和 
<code>ViewContainerRef</code>。在指令构造函数中将 
<code>TemplateRef</code> 和 
<code>ViewContainerRef</code> 注入为私有变量。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">import</span> {<span class="hljs-title class_">Directive</span>, <span class="hljs-title class_">TemplateRef</span>, <span class="hljs-title class_">ViewContainerRef</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@Directive</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span>,</div><div class="hljs-ln-line">  <span class="hljs-attr">selector</span>: <span class="hljs-string">'select'</span>,</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectDirective</span> {</div><div class="hljs-ln-line">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> templateRef: TemplateRef, <span class="hljs-keyword">private</span> ViewContainerRef: ViewContainerRef</span>) {}</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div>
    </li>
    
    <li>
      <span class="docs-step-number" aria-hidden="true"></span>
      
  <h3 id="add-the-selectfrom-input">
    <a href="#add-the-selectfrom-input" class="docs-anchor" tabindex="-1" aria-label="Link to Add the 'selectFrom' input" data-ng_translator_product="100" data-ng_translator_ref_id="d62df8mpfygug00heyn3k0njy">添加 'selectFrom' 输入属性</a>
  </h3>
  
      <p data-ng_translator_product="100" data-ng_translator_ref_id="1b7uzc8kah4sgepxr4npgv9ji">添加一个 
<code>selectFrom</code> 
<code>@Input()</code> 属性。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectDirective</span> {</div><div class="hljs-ln-line">  <span class="hljs-comment">// ...</span></div><div class="hljs-ln-line"></div><div class="hljs-ln-line">  <span class="hljs-meta">@Input</span>({<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>}) selectFrom!: <span class="hljs-title class_">DataSource</span>;</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div>
    </li>
    
    <li>
      <span class="docs-step-number" aria-hidden="true"></span>
      
  <h3 id="add-the-business-logic">
    <a href="#add-the-business-logic" class="docs-anchor" tabindex="-1" aria-label="Link to Add the business logic" data-ng_translator_product="100" data-ng_translator_ref_id="6rzmh3jrpgr71o0j04qnm98bt">添加业务逻辑</a>
  </h3>
  
      <p data-ng_translator_product="100" data-ng_translator_ref_id="dv3e1812nze2c3h9wcogpzd7h">现在 
<code>SelectDirective</code> 已作为带有输入属性的结构型指令搭建好，你可以添加逻辑来获取数据并用它渲染模板：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectDirective</span> {</div><div class="hljs-ln-line">  <span class="hljs-comment">// ...</span></div><div class="hljs-ln-line"></div><div class="hljs-ln-line">  <span class="hljs-keyword">async</span> <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) {</div><div class="hljs-ln-line">    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">selectFrom</span>.<span class="hljs-title function_">load</span>();</div><div class="hljs-ln-line">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewContainerRef</span>.<span class="hljs-title function_">createEmbeddedView</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">templateRef</span>, {</div><div class="hljs-ln-line">      <span class="hljs-comment">// Create the embedded view with a context object that contains</span></div><div class="hljs-ln-line">      <span class="hljs-comment">// the data via the key `$implicit`.</span></div><div class="hljs-ln-line">      <span class="hljs-attr">$implicit</span>: data,</div><div class="hljs-ln-line">    });</div><div class="hljs-ln-line">  }</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div>
    </li>
    
    </ol>
    <p data-ng_translator_product="100" data-ng_translator_ref_id="9a3tmvoas5waacc6q73d8gv6j">就是这样 —— 
<code>SelectDirective</code> 已经运行起来了。后续步骤可能是 
<a href="#typing-the-directives-context">添加模板类型检查支持</a>。</p>

  <h2 id="structural-directive-syntax-reference">
    <a href="#structural-directive-syntax-reference" class="docs-anchor" tabindex="-1" aria-label="Link to Structural directive syntax reference" data-ng_translator_product="100" data-ng_translator_ref_id="artird410rf5om9u9awzzk2g7">结构型指令语法参考</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="cntsjh17z959elh3e219mpd9">当你编写自己的结构型指令时，请使用以下语法：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line">*:prefix=<span class="hljs-string">"( :let | :expression ) (';' | ',')? ( :let | :as | :keyExp )*"</span></div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="7r2y0siwutiukzepjpyrmrjf6">以下模式描述了结构型指令语法的每个部分：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">as</span> = :<span class="hljs-keyword">export</span> <span class="hljs-string">"as"</span> :local <span class="hljs-string">";"</span>?</div><div class="hljs-ln-line">keyExp = :key <span class="hljs-string">":"</span>? :expression (<span class="hljs-string">"as"</span> :local)? <span class="hljs-string">";"</span>?</div><div class="hljs-ln-line"><span class="hljs-keyword">let</span> = <span class="hljs-string">"let"</span> :local <span class="hljs-string">"="</span> :<span class="hljs-keyword">export</span> <span class="hljs-string">";"</span>?</div></code>
    </pre>
  </div>
  <div class="docs-table docs-scroll-track-transparent">
    <table>
      <thead>
        <tr>
<th align="left" data-ng_translator_product="100" data-ng_translator_ref_id="20l9gl2mdedoiwy798oi5zs35">关键字</th>
<th align="left" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="3prlgfrx5eo2xqncnnob4crxu">详情</th>
</tr>

      </thead>
      <tbody>
        <tr>
<td align="left"><code>prefix</code></td>
<td align="left" data-ng_translator_product="100" data-ng_translator_ref_id="1pz3gbcpzgvg2g9pvjabjz92">HTML 属性键</td>
</tr>
<tr>
<td align="left"><code>key</code></td>
<td align="left" data-ng_translator_product="100" data-ng_translator_ref_id="1pz3gbcpzgvg2g9pvjabjz92">HTML 属性键</td>
</tr>
<tr>
<td align="left"><code>local</code></td>
<td align="left" data-ng_translator_product="100" data-ng_translator_ref_id="1bnmwzm9yshcwe2s6p2z9926d">模板中使用的局部变量名</td>
</tr>
<tr>
<td align="left"><code>export</code></td>
<td align="left" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="8uo35jewtdcuxzzedrqp1ssrp">本指令以给定名称导出的值</td>
</tr>
<tr>
<td align="left"><code>expression</code></td>
<td align="left" data-ng_translator_product="100" data-ng_translator_ref_id="4bln2v7ho1pkt49htdzu90my">标准 Angular 表达式</td>
</tr>

      </tbody>
    </table>
  </div>
  
  <h3 id="how-angular-translates-shorthand">
    <a href="#how-angular-translates-shorthand" class="docs-anchor" tabindex="-1" aria-label="Link to How Angular translates shorthand" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="5oryrljo2p71zghaj3h8wfpl4">Angular 如何翻译简写形式</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="1aictm6r3lnac9h4ye98dx39c">Angular 会将结构型指令的简写形式转换为普通的绑定语法，如下所示：</p>

  <div class="docs-table docs-scroll-track-transparent">
    <table>
      <thead>
        <tr>
<th align="left" data-ng_translator_product="100" data-ng_translator_ref_id="7iki2yrykvobv9rw87y8dyy6d">简写</th>
<th align="left" data-ng_translator_product="100" data-ng_translator_ref_id="6i1o53c36480k0hdnh9mw6y64">翻译</th>
</tr>

      </thead>
      <tbody>
        <tr>
<td align="left" data-ng_translator_product="100" data-ng_translator_ref_id="2vd59p276qkls52y3l5pss1rl"><code>prefix</code> 和裸 
<code>expression</code></td>
<td align="left"><code>[prefix]="expression"</code></td>
</tr>
<tr>
<td align="left"><code>keyExp</code></td>
<td align="left" data-ng_translator_product="100" data-ng_translator_ref_id="ehj09j83kmipu0opb10ra3ihp"><code>[prefixKey]="expression"</code>（
<code>prefix</code> 被添加到 
<code>key</code> 上）</td>
</tr>
<tr>
<td align="left"><code>let local</code></td>
<td align="left"><code>let-local="export"</code></td>
</tr>

      </tbody>
    </table>
  </div>
  
  <h3 id="shorthand-examples">
    <a href="#shorthand-examples" class="docs-anchor" tabindex="-1" aria-label="Link to Shorthand examples" data-ng_translator_product="100" data-ng_translator_ref_id="5x7ip10jhqemptxvix60qu59b">简写形式示例</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="3ibhho2xv0u4v3nuzx2w4p04x">下表提供了一些简写形式示例：</p>

  <div class="docs-table docs-scroll-track-transparent">
    <table>
      <thead>
        <tr>
<th align="left" data-ng_translator_product="100" data-ng_translator_ref_id="7iki2yrykvobv9rw87y8dyy6d">简写</th>
<th align="left" data-ng_translator_product="100" data-ng_translator_ref_id="9428q8xyts1a5lfveohqr43h7">Angular 如何解释语法</th>
</tr>

      </thead>
      <tbody>
        <tr>
<td align="left"><code>*ngFor="let item of [1,2,3]"</code></td>
<td align="left"><code>&lt;ng-template ngFor let-item [ngForOf]="[1, 2, 3]"&gt;</code></td>
</tr>
<tr>
<td align="left"><code>*ngFor="let item of [1,2,3] as items; trackBy: myTrack; index as i"</code></td>
<td align="left"><code>&lt;ng-template ngFor let-item [ngForOf]="[1,2,3]" let-items="ngForOf" [ngForTrackBy]="myTrack" let-i="index"&gt;</code></td>
</tr>
<tr>
<td align="left"><code>*ngIf="exp"</code></td>
<td align="left"><code>&lt;ng-template [ngIf]="exp"&gt;</code></td>
</tr>
<tr>
<td align="left"><code>*ngIf="exp as value"</code></td>
<td align="left"><code>&lt;ng-template [ngIf]="exp" let-value="ngIf"&gt;</code></td>
</tr>

      </tbody>
    </table>
  </div>
  
  <h2 id="improving-template-type-checking-for-custom-directives">
    <a href="#improving-template-type-checking-for-custom-directives" class="docs-anchor" tabindex="-1" aria-label="Link to Improving template type checking for custom directives" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="6i5ho92crfgwkr73ox89cgcyh">改进自定义指令的模板类型检查</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="3sdtzr3kuqswykdz2djvqhmnc">你可以通过向指令定义中添加模板守卫来改进自定义指令的模板类型检查。 这些守卫帮助 Angular 模板类型检查器在编译时发现模板中的错误，这可以避免运行时错误。 可能有两种不同类型的守卫：</p>

  <ul class="docs-list">
    <li data-ng_translator_product="100" data-ng_translator_ref_id="aicmmy7kgz5q46zv79plkx37v"><code>ngTemplateGuard_(input)</code> 让你可以基于特定输入的类型控制输入表达式应如何窄化。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="26yy9yoxmcgbiqxa0be0t9yp5"><code>ngTemplateContextGuard</code> 用于根据指令本身的类型确定模板上下文对象的类型。</li>

  </ul>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="djpto13vylt6qxi1llewjsnm8">本节提供了这两种守卫的示例。 更多信息，请参见 
<a href="tools/cli/template-typecheck" title="Template" type-checking guide>模板类型检查指南</a>。</p>

  <h3 id="type-narrowing-with-template-guards">
    <a href="#type-narrowing-with-template-guards" class="docs-anchor" tabindex="-1" aria-label="Link to Type narrowing with template guards" data-ng_translator_product="100" data-ng_translator_ref_id="8ot0c4uilwx0tz3bru5xtiqjc">使用模板守卫进行类型窄化</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="c9543hk39suohe4chxn3ohzc6">模板中的结构型指令控制该模板在运行时是否被渲染。某些结构型指令希望根据输入表达式的类型进行类型窄化。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="5es6450qxneqf3vjql29wegyi">使用输入守卫可能有两种窄化：</p>

  <ul class="docs-list">
    <li data-ng_translator_product="100" data-ng_translator_ref_id="4v6wisy1fpyalsxb9saoe9zsw">基于 TypeScript 类型断言函数窄化输入表达式。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="3x7slzx8s3tmozntenda6aerd">基于输入表达式的真值与否进行窄化。</li>

  </ul>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="beqizu7p0b9xtgdmi21r4lgif">通过定义类型断言函数来窄化输入表达式：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// This directive only renders its template if the actor is a user.</span></div><div class="hljs-ln-line"><span class="hljs-comment">// You want to assert that within the template, the type of the `actor`</span></div><div class="hljs-ln-line"><span class="hljs-comment">// expression is narrowed to `User`.</span></div><div class="hljs-ln-line"><span class="hljs-meta">@Directive</span>(...)</div><div class="hljs-ln-line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ActorIsUser</span> {</div><div class="hljs-ln-line">  <span class="hljs-meta">@Input</span>() <span class="hljs-attr">actor</span>: <span class="hljs-title class_">User</span>|<span class="hljs-title class_">Robot</span>;</div><div class="hljs-ln-line"></div><div class="hljs-ln-line">  <span class="hljs-keyword">static</span> <span class="hljs-title function_">ngTemplateGuard_actor</span>(<span class="hljs-attr">dir</span>: <span class="hljs-title class_">ActorIsUser</span>, <span class="hljs-attr">expr</span>: <span class="hljs-title class_">User</span>|<span class="hljs-title class_">Robot</span>): expr is <span class="hljs-title class_">User</span> {</div><div class="hljs-ln-line">    <span class="hljs-comment">// The return statement is unnecessary in practice, but included to</span></div><div class="hljs-ln-line">    <span class="hljs-comment">// prevent TypeScript errors.</span></div><div class="hljs-ln-line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</div><div class="hljs-ln-line">  }</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="2nb6n4f6fwhtvzn2cflc09gb8">类型检查将在模板中表现为 
<code>ngTemplateGuard_actor</code> 已经对绑定到输入的表达式进行了断言。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="a8kr1sgr99y87trujsp5xw7nt">一些指令只有在输入为真值时才会渲染它们的模板。无法在类型断言函数中捕获真值的完整语义，因此可以使用字面量类型 
<code>'binding'</code> 来向模板类型检查器表示绑定表达式本身应作为守卫：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-meta">@Directive</span>(...)</div><div class="hljs-ln-line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomIf</span> {</div><div class="hljs-ln-line">  <span class="hljs-meta">@Input</span>() condition!: <span class="hljs-built_in">any</span>;</div><div class="hljs-ln-line"></div><div class="hljs-ln-line">  <span class="hljs-keyword">static</span> <span class="hljs-attr">ngTemplateGuard_condition</span>: <span class="hljs-string">'binding'</span>;</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="8v4nfq5a7m27e633c9phuojwy">模板类型检查器将在模板中表现为绑定到 
<code>condition</code> 的表达式被断言为真值。</p>

  <h3 id="typing-the-directives-context">
    <a href="#typing-the-directives-context" class="docs-anchor" tabindex="-1" aria-label="Link to Typing the directive's context" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="is6bv3kpwpp01yh3g6jxiktx">为指令的上下文指定类型</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="70cbqaa1s2ph4cv6bvj0t0y35">如果你的结构型指令为实例化的模板提供上下文，你可以通过提供静态 
<code>ngTemplateContextGuard</code> 类型断言函数在模板中正确定义其类型。此函数可以使用指令的类型推导上下文的类型，这在指令类型为泛型时非常有用。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="d87etzbb1nf571srzl7u55gqv">对于上面描述的 
<code>SelectDirective</code>，你可以实现 
<code>ngTemplateContextGuard</code> 来正确指定数据类型，即使数据源是泛型的。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// Declare an interface for the template context:</span></div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SelectTemplateContext</span>&lt;T&gt; {</div><div class="hljs-ln-line">  <span class="hljs-attr">$implicit</span>: T;</div><div class="hljs-ln-line">}</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@Directive</span>(...)</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectDirective</span>&lt;T&gt; {</div><div class="hljs-ln-line">  <span class="hljs-comment">// The directive's generic type `T` will be inferred from the `DataSource` type</span></div><div class="hljs-ln-line">  <span class="hljs-comment">// passed to the input.</span></div><div class="hljs-ln-line">  <span class="hljs-meta">@Input</span>({<span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>}) selectFrom!: <span class="hljs-title class_">DataSource</span>&lt;T&gt;;</div><div class="hljs-ln-line"></div><div class="hljs-ln-line">  <span class="hljs-comment">// Narrow the type of the context using the generic type of the directive.</span></div><div class="hljs-ln-line">  <span class="hljs-keyword">static</span> ngTemplateContextGuard&lt;T&gt;(<span class="hljs-attr">dir</span>: <span class="hljs-title class_">SelectDirective</span>&lt;T&gt;, <span class="hljs-attr">ctx</span>: <span class="hljs-built_in">any</span>): ctx is <span class="hljs-title class_">SelectTemplateContext</span>&lt;T&gt; {</div><div class="hljs-ln-line">    <span class="hljs-comment">// As before the guard body is not used at runtime, and included only to avoid</span></div><div class="hljs-ln-line">    <span class="hljs-comment">// TypeScript errors.</span></div><div class="hljs-ln-line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</div><div class="hljs-ln-line">  }</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div>