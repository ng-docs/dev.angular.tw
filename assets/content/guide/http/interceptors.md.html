<header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1" data-ng_translator_product="100" data-ng_translator_ref_id="2ce6xjxo7t687wiqhlgacnysm">拦截器</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/guide/http/interceptors.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    <p data-ng_translator_product="100" data-ng_translator_ref_id="467sflcdyp630k87k0ao323v3"><code>HttpClient</code> 支持一种称为 
<em>拦截器</em> 的中间件形式。</p>

    <div class="docs-alert docs-alert-tldr">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="ae760ja0bznt4y3l4ifsqleda"><strong>简而言之：</strong>拦截器是中间件，允许将重试、缓存、日志记录和身份验证等常见模式从单个请求中抽象出来。</p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_ref_id="d2gqbjkutf6e9ashqxd7g1i7v"><code>HttpClient</code> 支持两种拦截器：函数式和基于 DI 的。我们的建议是使用函数式拦截器，因为它们在复杂的设置中有更可预测的行为。本指南中的示例使用函数式拦截器，我们会在最后的一个章节中介绍 
<a href="#di-based-interceptors">基于 DI 的拦截器</a>。</p>

  <h2 id="interceptors">
    <a href="#interceptors" class="docs-anchor" tabindex="-1" aria-label="Link to Interceptors" data-ng_translator_product="100" data-ng_translator_ref_id="2ce6xjxo7t687wiqhlgacnysm">拦截器</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="4hi1ksbe8o550n55fom502qav">拦截器通常是你可以为每个请求运行的函数，具有广泛的能力来影响请求和响应的内容和整体流程。你可以安装多个拦截器，它们形成一个拦截器链，每个拦截器在将请求或响应转发给链中的下一个拦截器之前处理它。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="cu77m2s0qq41n9j6zv1reh74c">你可以使用拦截器实现各种常见模式，例如：</p>

  <ul class="docs-list">
    <li data-ng_translator_product="100" data-ng_translator_ref_id="2fq8xw0ch915960a3ad90ljxa">为发往特定 API 的出站请求添加身份验证标头。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="8xu32i5dxzosqu234m5d4q455">使用指数退避重试失败的请求。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="1kvks2pitnvpbcvlt3yz2n7l5">缓存响应一段时间，或者直到被变更操作使其失效。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="dbvnczlpms5mskgedtj7dw67h">自定义解析响应。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="a05fel8bdzjrj0orhhq9sa17t">测量服务器响应时间并记录。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="1luyoyparkpnkl53ejf921dq8">在网络操作进行时驱动 UI 元素（如加载动画）。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="5sjkxhb7xzng1fbyom6t42hy6">在特定时间范围内收集并批处理请求。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="8ynq2i7ywijrpvwuj2lfui21c">在可配置的截止时间或超时时间后自动使请求失败。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="d531nlg1961v14d8ed7xaahdn">定期轮询服务器并刷新结果。</li>

  </ul>
  
  <h2 id="defining-an-interceptor">
    <a href="#defining-an-interceptor" class="docs-anchor" tabindex="-1" aria-label="Link to Defining an interceptor" data-ng_translator_product="100" data-ng_translator_ref_id="cltm6go614tts46h297efqruk">定义拦截器</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="2g4vhl9r9jav2p90f3boh2p9w">拦截器的基本形式是一个函数，该函数接收传出的 
<code>HttpRequest</code> 和一个 
<code>next</code> 函数（代表拦截器链中的下一个处理步骤）。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="4bdp75a9besk8plgqcvoomsdm">例如，这个 
<code>loggingInterceptor</code> 会在转发请求之前将传出的请求 URL 记录到 
<code>console.log</code>：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loggingInterceptor</span>(<span class="hljs-params">req: HttpRequest&lt;<span class="hljs-built_in">unknown</span>&gt;, next: HttpHandlerFn</span>): <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-title class_">HttpEvent</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; {</div><div class="hljs-ln-line">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">url</span>);</div><div class="hljs-ln-line">  <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(req);</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="t0cjnvaifg0zav4sotrskbb8">为了让这个拦截器实际拦截请求，你必须配置 
<code>HttpClient</code> 使用它。</p>

  <h2 id="configuring-interceptors">
    <a href="#configuring-interceptors" class="docs-anchor" tabindex="-1" aria-label="Link to Configuring interceptors" data-ng_translator_product="100" data-ng_translator_ref_id="2aumyw11298sno3lppsyyxd6j">配置拦截器</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="2mtvkivwafc7auk8npzerzfel">通过依赖注入（DI）配置 
<code>HttpClient</code> 时，使用 
<code>withInterceptors</code> 特性声明要使用的拦截器集：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-title function_">bootstrapApplication</span>(<span class="hljs-title class_">AppComponent</span>, {<span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">  <span class="hljs-title function_">provideHttpClient</span>(</div><div class="hljs-ln-line">    <span class="hljs-title function_">withInterceptors</span>([loggingInterceptor, cachingInterceptor]),</div><div class="hljs-ln-line">  )</div><div class="hljs-ln-line">]});</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="2fp8nikirplojjf4qlbfbxytv">你配置的拦截器会按你在提供者中列出的顺序依次链式处理。在上面的例子中，
<code>loggingInterceptor</code> 会处理请求，然后将其转发给 
<code>cachingInterceptor</code>。</p>

  <h3 id="intercepting-response-events">
    <a href="#intercepting-response-events" class="docs-anchor" tabindex="-1" aria-label="Link to Intercepting response events" data-ng_translator_product="100" data-ng_translator_ref_id="9o8u0neejbxaawjjhitf7ixjg">拦截响应事件</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="7tf6nv83ka9gmk39ny4l6y5gr">拦截器可以转换 
<code>next</code> 返回的 
<code>HttpEvent</code> 的 
<code>Observable</code> 流，以访问或操纵响应。因为这个流包含所有响应事件，所以可能需要检查每个事件的 
<code>.type</code> 以识别最终的响应对象。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loggingInterceptor</span>(<span class="hljs-params">req: HttpRequest&lt;<span class="hljs-built_in">unknown</span>&gt;, next: HttpHandlerFn</span>): <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-title class_">HttpEvent</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; {</div><div class="hljs-ln-line">  <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(req).<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">tap</span>(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {</div><div class="hljs-ln-line">    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">type</span> === <span class="hljs-title class_">HttpEventType</span>.<span class="hljs-property">Response</span>) {</div><div class="hljs-ln-line">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">url</span>, <span class="hljs-string">'returned a response with status'</span>, event.<span class="hljs-property">status</span>);</div><div class="hljs-ln-line">    }</div><div class="hljs-ln-line">  }));</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div>
    <div class="docs-alert docs-alert-tip">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="h7vc368n9lnucvrn8b7dayd9"><strong>提示：</strong> 拦截器自然会将响应与其传出的请求关联，因为它们在捕获请求对象的闭包中转换响应流。</p>

    </div>
    
  <h2 id="modifying-requests">
    <a href="#modifying-requests" class="docs-anchor" tabindex="-1" aria-label="Link to Modifying requests" data-ng_translator_product="100" data-ng_translator_ref_id="8prhp5mfdttc1woc4kljbeeza">修改请求</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="85qwljw4pqnt4gseqesunzk"><code>HttpRequest</code> 和 
<code>HttpResponse</code> 实例的大多数方面是
<em>不可变的</em>，拦截器不能直接修改它们。相反，拦截器通过使用 
<code>.clone()</code> 操作克隆这些对象，并在新实例中指定要变更的属性来应用变更。这可能涉及对值本身（如 
<code>HttpHeaders</code> 或 
<code>HttpParams</code>）执行不可变更新。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="215npkhq9g4k8onqfylstsi5n">例如，向请求添加一个标头：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">const</span> reqWithHeader = req.<span class="hljs-title function_">clone</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">headers</span>: req.<span class="hljs-property">headers</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'X-New-Header'</span>, <span class="hljs-string">'new header value'</span>),</div><div class="hljs-ln-line">});</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="brdzgcyybvocxnxmc7kwylct9">这种不可变性允许大多数拦截器在同一个 
<code>HttpRequest</code> 多次提交到拦截器链时保持幂等。这可能因为一些原因发生，包括请求在失败后重试。</p>

    <div class="docs-alert docs-alert-critical">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="bqic6pztrp56hyhn947ccboao"><strong>关键：</strong> 请求或响应的主体
<strong>不</strong>受深度变更保护。如果拦截器必须变更主体，务必小心处理同一个请求上的多次运行。</p>

    </div>
    
  <h2 id="dependency-injection-in-interceptors">
    <a href="#dependency-injection-in-interceptors" class="docs-anchor" tabindex="-1" aria-label="Link to Dependency injection in interceptors" data-ng_translator_product="100" data-ng_translator_ref_id="1d1batserhfmcqyz51eqlqr14">拦截器中的依赖注入</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="5kludv1wr90wfbesszhjjfw7l">拦截器在注册它们的注入器的
<em>注入上下文</em>中运行，可以使用 Angular 的 
<code>inject</code> API 来获取依赖项。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="ags5e06dz24rjtg54cgnss4sx">例如，假设某个应用有一个名为 
<code>AuthService</code> 的服务，它为发出的请求创建认证令牌。拦截器可以注入并使用此服务：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">authInterceptor</span>(<span class="hljs-params">req: HttpRequest&lt;<span class="hljs-built_in">unknown</span>&gt;, next: HttpHandlerFn</span>) {</div><div class="hljs-ln-line">  <span class="hljs-comment">// Inject the current `AuthService` and use it to get an authentication token:</span></div><div class="hljs-ln-line">  <span class="hljs-keyword">const</span> authToken = <span class="hljs-title function_">inject</span>(<span class="hljs-title class_">AuthService</span>).<span class="hljs-title function_">getAuthToken</span>();</div><div class="hljs-ln-line"></div><div class="hljs-ln-line">  <span class="hljs-comment">// Clone the request to add the authentication header.</span></div><div class="hljs-ln-line">  <span class="hljs-keyword">const</span> newReq = req.<span class="hljs-title function_">clone</span>({<span class="hljs-attr">headers</span>: {</div><div class="hljs-ln-line">    req.<span class="hljs-property">headers</span>.<span class="hljs-title function_">append</span>(<span class="hljs-string">'X-Authentication-Token'</span>, authToken),</div><div class="hljs-ln-line">  }});</div><div class="hljs-ln-line">  <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(newReq);</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div>
  <h2 id="request-and-response-metadata">
    <a href="#request-and-response-metadata" class="docs-anchor" tabindex="-1" aria-label="Link to Request and response metadata" data-ng_translator_product="100" data-ng_translator_ref_id="cpj07c8ilarzf37urtoiigxgl">请求和响应元数据</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="b3g545ab95vjsesktrekvp1n7">通常在请求中包含一些信息很有用，这些信息不会发送到后端，而是专门为拦截器准备的。
<code>HttpRequest</code> 具有一个 
<code>.context</code> 对象，该对象将这类元数据存储为 
<code>HttpContext</code> 的一个实例。此对象作为一个类型化的映射表，键的类型为 
<code>HttpContextToken</code>。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="9ji70yv15k9arkq7iiw61ajke">为了阐明此体系如何工作，让我们使用元数据来控制某个请求是否启用缓存拦截器。</p>

  <h3 id="defining-context-tokens">
    <a href="#defining-context-tokens" class="docs-anchor" tabindex="-1" aria-label="Link to Defining context tokens" data-ng_translator_product="100" data-ng_translator_ref_id="dy72mvphewyopv7dlp7ydq1zd">定义上下文令牌</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="hp2f63n5esznokkbcjfemto4">要在某个请求的 
<code>.context</code> 映射表中存储缓存拦截器是否应缓存该请求，需要定义一个新的 
<code>HttpContextToken</code> 作为键：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHING_ENABLED</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpContextToken</span>&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-function">() =&gt;</span> <span class="hljs-literal">true</span>);</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="82gm0phqvsyqk1cdwco6xeqoc">提供的函数为没有明确设置该令牌值的请求创建默认值。使用函数可以确保如果令牌的值是对象或数组，每个请求都会获得它自己的实例。</p>

  <h3 id="reading-the-token-in-an-interceptor">
    <a href="#reading-the-token-in-an-interceptor" class="docs-anchor" tabindex="-1" aria-label="Link to Reading the token in an interceptor" data-ng_translator_product="100" data-ng_translator_ref_id="9n9y12128g3qvl5t4ecrxx5d2">在拦截器中读取令牌</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="4kzr1u7gt3iir46aku9of0okc">拦截器然后可以读取此令牌，并根据其值选择是否应用缓存逻辑：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cachingInterceptor</span>(<span class="hljs-params">req: HttpRequest&lt;<span class="hljs-built_in">unknown</span>&gt;, next: HttpHandlerFn</span>): <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-title class_">HttpEvent</span>&lt;<span class="hljs-built_in">unknown</span>&gt;&gt; {</div><div class="hljs-ln-line">  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">context</span>.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">CACHING_ENABLED</span>)) {</div><div class="hljs-ln-line">    <span class="hljs-comment">// apply caching logic</span></div><div class="hljs-ln-line">    <span class="hljs-keyword">return</span> ...;</div><div class="hljs-ln-line">  } <span class="hljs-keyword">else</span> {</div><div class="hljs-ln-line">    <span class="hljs-comment">// caching has been disabled for this request</span></div><div class="hljs-ln-line">    <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(req);</div><div class="hljs-ln-line">  }</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div>
  <h3 id="setting-context-tokens-when-making-a-request">
    <a href="#setting-context-tokens-when-making-a-request" class="docs-anchor" tabindex="-1" aria-label="Link to Setting context tokens when making a request" data-ng_translator_product="100" data-ng_translator_ref_id="6uhqxc8er61xngkr99gwmcj1n">在发出请求时设置上下文令牌</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="1pd4h30m13kxa1qz91tvojp81">通过 
<code>HttpClient</code> API 发出请求时，可以为 
<code>HttpContextToken</code> 提供值：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">const</span> data$ = http.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/sensitive/data'</span>, {</div><div class="hljs-ln-line">  <span class="hljs-attr">context</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpContext</span>().<span class="hljs-title function_">set</span>(<span class="hljs-variable constant_">CACHING_ENABLED</span>, <span class="hljs-literal">false</span>),</div><div class="hljs-ln-line">});</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="bzconqwrcz1srlhta0gg14bzh">拦截器可以从请求的 
<code>HttpContext</code> 中读取这些值。</p>

  <h3 id="the-request-context-is-mutable">
    <a href="#the-request-context-is-mutable" class="docs-anchor" tabindex="-1" aria-label="Link to The request context is mutable" data-ng_translator_product="100" data-ng_translator_ref_id="cbsro0e267i5echaey78b5wzy">请求上下文是可变的</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="73ost1rfy3cb9216qkyyps1lt">与其他 
<code>HttpRequest</code> 属性不同，关联的 
<code>HttpContext</code> 是 
<em>可变的</em>。如果某个拦截器更改了某个请求的上下文，该请求稍后被重试时，同一个拦截器在再次运行时将观察到上下文变化。如果需要，这对于在多次重试中传递状态非常有用。</p>

  <h2 id="synthetic-responses">
    <a href="#synthetic-responses" class="docs-anchor" tabindex="-1" aria-label="Link to Synthetic responses" data-ng_translator_product="100" data-ng_translator_ref_id="5kaog7rqtyrd7ncc0voyoaas7">合成响应</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="4d4io95z7thenlpcbnnjkf6ed">大多数拦截器只会在转换请求或响应的同时调用 
<code>next</code> 处理器，但这并不是严格的要求。本节讨论拦截器可能采用的几种更高级的行为。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="clrojiv6ov226wbtqsowowxk7">拦截器不需要调用 
<code>next</code>。它们可以选择通过其他机制构造响应，例如从缓存中获取响应或通过替代机制发送请求。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="9qd54gr69syhgq6004p94haut">可以使用 
<code>HttpResponse</code> 构造函数来构造响应：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">const</span> resp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpResponse</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">body</span>: <span class="hljs-string">'response body'</span>,</div><div class="hljs-ln-line">});</div></code>
    </pre>
  </div>
  <h2 id="di-based-interceptors">
    <a href="#di-based-interceptors" class="docs-anchor" tabindex="-1" aria-label="Link to DI-based interceptors" data-ng_translator_product="100" data-ng_translator_ref_id="a23s1dfegl40zlh179pzky044">基于依赖注入（DI）的拦截器</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="casv4d2pdr3b2qm90h44nlkmx"><code>HttpClient</code> 也支持拦截器，这些拦截器被定义为可注入的类，并通过 DI 系统配置。基于 DI 的拦截器的功能与函数式拦截器相同，但配置机制不同。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="1a7r3nwmin5yb7nsynw4n9xz6">基于 DI 的拦截器是一个实现 
<code>HttpInterceptor</code> 接口的可注入类：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-meta">@Injectable</span>()</div><div class="hljs-ln-line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HttpInterceptor</span> {</div><div class="hljs-ln-line">  <span class="hljs-title function_">intercept</span>(<span class="hljs-attr">req</span>: <span class="hljs-title class_">HttpRequest</span>&lt;<span class="hljs-built_in">any</span>&gt;, <span class="hljs-attr">handler</span>: <span class="hljs-title class_">HttpHandler</span>): <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-title class_">HttpEvent</span>&lt;<span class="hljs-built_in">any</span>&gt;&gt; {</div><div class="hljs-ln-line">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Request URL: '</span> + req.<span class="hljs-property">url</span>);</div><div class="hljs-ln-line">    <span class="hljs-keyword">return</span> handler.<span class="hljs-title function_">handle</span>(req);</div><div class="hljs-ln-line">  }</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="73w2atkzc0f21n864zjbkkbi3">基于 DI 的拦截器通过依赖注入的多提供者进行配置：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-title function_">bootstrapApplication</span>(<span class="hljs-title class_">AppComponent</span>, {<span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">  <span class="hljs-title function_">provideHttpClient</span>(</div><div class="hljs-ln-line">    <span class="hljs-comment">// DI-based interceptors must be explicitly enabled.</span></div><div class="hljs-ln-line">    <span class="hljs-title function_">withInterceptorsFromDi</span>(),</div><div class="hljs-ln-line">  ),</div><div class="hljs-ln-line"></div><div class="hljs-ln-line">  {<span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">HTTP_INTERCEPTORS</span>, <span class="hljs-attr">useClass</span>: <span class="hljs-title class_">LoggingInterceptor</span>, <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span>},</div><div class="hljs-ln-line">]});</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="cxqacv0e2z97p5vo677hbnbnu">基于 DI 的拦截器按照其提供者注册的顺序运行。在一个具有广泛和层次化 DI 配置的应用中，这个顺序可能很难预测。</p>
