<header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1" data-ng_translator_product="100" data-ng_translator_ref_id="brg2npit1fe3ro1pbexu2mzub">没有 ZoneJS（ Zoneless）的 Angular</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/guide/zoneless.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    
  <h2 id="why-use-zoneless">
    <a href="#why-use-zoneless" class="docs-anchor" tabindex="-1" aria-label="Link to Why use Zoneless?" data-ng_translator_product="100" data-ng_translator_ref_id="5gq2s9yenvib0qt2c8mk5gsbo">为什么使用 Zoneless？</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="b7itrkswr59cq5ez814a35552">将 ZoneJS 作为依赖项移除的主要优点是：</p>

  <ul class="docs-list">
    <li data-ng_translator_product="100" data-ng_translator_ref_id="9w801337mykgo21vg6apskn8y"><strong>性能改进</strong>：ZoneJS 使用 DOM 事件和异步任务作为应用状态
<em>可能</em>已更新的指示器，随后触发应用同步以运行变更检测，从而检测该应用的视图。ZoneJS 并不了解应用状态是否实际发生了变化，因此这种同步比必要的更频繁地触发。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="3b04fwv10xhs7a64syszvz6es"><strong>核心 Web Vitals 改善</strong>：ZoneJS 带来了相当多的开销，包括负载大小和启动时间成本。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="3se7ol999h5li3h1rzo6x4zw4"><strong>调试体验提升</strong>：ZoneJS 使得调试代码变得更加困难。使用 ZoneJS 后，堆栈跟踪更难理解。当代码因在 Angular Zone 之外而中断时，也很难理解原因。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="blt457gl40wfu7ts17z8ww0x7"><strong>更好的生态系统兼容性</strong>：ZoneJS 通过补丁浏览器 API 工作，但不会自动为每个新浏览器 API 提供补丁。有些 API 不能有效地打补丁，例如 
<code>async</code>/
<code>await</code>，需要降级以与 ZoneJS 一起工作。有时候生态系统中的某些库也与 ZoneJS 的原生 API 补丁方式不兼容。移除 ZoneJS 作为依赖项，通过减少复杂性、猴子补丁和持续维护，确保了更好的长期兼容性。</li>

  </ul>
  
  <h2 id="enabling-zoneless-in-an-application">
    <a href="#enabling-zoneless-in-an-application" class="docs-anchor" tabindex="-1" aria-label="Link to Enabling Zoneless in an application" data-ng_translator_product="100" data-ng_translator_ref_id="58z98ev3bvxrqd40g1sp8gg7s">在应用中启用 Zoneless 模式</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="5onxc1q3ify6ui63hiuv18vm4">启用 Zoneless 模式的 API 目前是实验性的。其形态或底层行为并不稳定，可能会在补丁版本中发生变化。已知特性缺口包括缺少符合工效学的 API，这会阻止应用在服务器端渲染时过早序列化。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// standalone bootstrap</span></div><div class="hljs-ln-line"><span class="hljs-title function_">bootstrapApplication</span>(<span class="hljs-title class_">MyApp</span>, {<span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">  <span class="hljs-title function_">provideExperimentalZonelessChangeDetection</span>(),</div><div class="hljs-ln-line">]});</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-comment">// NgModule bootstrap requires the provider and `ngZone: 'noop'`</span></div><div class="hljs-ln-line"><span class="hljs-title function_">platformBrowser</span>().<span class="hljs-title function_">bootstrapModule</span>(<span class="hljs-title class_">AppModule</span>, {<span class="hljs-attr">ngZone</span>: <span class="hljs-string">'noop'</span>});</div><div class="hljs-ln-line"><span class="hljs-meta">@NgModule</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [<span class="hljs-title function_">provideExperimentalZonelessChangeDetection</span>()]</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> {}</div></code>
    </pre>
  </div>
  <h2 id="requirements-for-zoneless-compatibility">
    <a href="#requirements-for-zoneless-compatibility" class="docs-anchor" tabindex="-1" aria-label="Link to Requirements for Zoneless compatibility" data-ng_translator_product="100" data-ng_translator_ref_id="3epl8nrjp92s1ie7hlg5f0w2o">Zoneless 模式兼容性要求</a>
  </h2>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="b75dqf7ekbvsh72py7geo7l3c">Angular 依赖于核心 API 的通知以确定何时运行变更检测以及在哪些视图上运行。这些通知包括：</p>

  <ul class="docs-list">
    <li data-ng_translator_product="100" data-ng_translator_ref_id="1vtowpb6c4a3kq71wc8nh9v8z"><code>ChangeDetectorRef.markForCheck</code>（由 
<code>AsyncPipe</code> 自动调用）</li>
<li><code>ComponentRef.setInput</code></li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="3jipp0b5vurddp34msi4oo4m8">更新模板中读取的信号</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="1zs6011q5xds8nhll1douqx5s">绑定的宿主或模板监听器回调</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="ddp3er8fhwk4hbwj501917372">附着由上述之一标记为脏的视图</li>

  </ul>
  
  <h3 id="onpush-compatible-components">
    <a href="#onpush-compatible-components" class="docs-anchor" tabindex="-1" aria-label="Link to <code>OnPush</code>-compatible components" data-ng_translator_product="100" data-ng_translator_ref_id="b60xc0202mwb991q1vt2ks58l">与 
<code>OnPush</code> 兼容的组件</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="bfq5c3tuqsrocopapoui3m8r2">确保组件使用上述正确通知机制的一种方法是使用 
<a href="../best-practices/skipping-subtrees#using-onpush">ChangeDetectionStrategy.OnPush</a>。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="5ihhse28lgev8fwdwauhtfl2l"><code>OnPush</code> 变更检测策略不是必要的，但它是应用组件实现 Zoneless 模式兼容的推荐步骤。库组件并不总是能够使用 
<code>ChangeDetectionStrategy.OnPush</code>。当库组件是用户组件的宿主时，用户组件可能使用 
<code>ChangeDetectionStrategy.Default</code>，此时库组件不能使用 
<code>OnPush</code>，因为这会阻止非 
<code>OnPush</code> 兼容且依赖 ZoneJS 触发变更检测的子组件刷新。组件可以使用 
<code>Default</code> 策略，只要它们在需要运行变更检测时通知 Angular（调用 
<code>markForCheck</code>、使用信号、
<code>AsyncPipe</code> 等）。</p>

  <h3 id="remove-ngzoneonmicrotaskempty-ngzoneonunstable-ngzoneisstable-or-ngzoneonstable">
    <a href="#remove-ngzoneonmicrotaskempty-ngzoneonunstable-ngzoneisstable-or-ngzoneonstable" class="docs-anchor" tabindex="-1" aria-label="Link to Remove <code>NgZone.onMicrotaskEmpty</code>, <code>NgZone.onUnstable</code>, <code>NgZone.isStable</code>, or <code>NgZone.onStable</code>" data-ng_translator_product="100" data-ng_translator_ref_id="brpxke7zjpeefzpycedpzmm3u">移除 
<code>NgZone.onMicrotaskEmpty</code>、
<code>NgZone.onUnstable</code>、
<code>NgZone.isStable</code> 或 
<code>NgZone.onStable</code></a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="2zokfg0k57cbchyovezd2vusr">应用和库需要移除 
<code>NgZone.onMicrotaskEmpty</code>、
<code>NgZone.onUnstable</code> 和 
<code>NgZone.onStable</code> 的使用。这些可观察者在应用启用 Zoneless 模式变更检测时将永远不会发出信号。同样，
<code>NgZone.isStable</code> 将始终为 
<code>true</code>，不应作为代码执行的条件。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="931aok1yevu6iawfyqumwucx1"><code>NgZone.onMicrotaskEmpty</code> 和 
<code>NgZone.onStable</code> 可观察者最常用于等待 Angular 完成变更检测后再执行任务。相应的替代方式可以是，如果需要等待单次变更检测，可以使用 
<code>afterNextRender</code>；如果有些条件可能跨越多次变更检测轮次，则可以使用 
<code>afterRender</code>。在其他情况下，这些可观察者的使用只是因为它们恰好熟悉并且时间点与所需的相似。可以改用更直接的 DOM API，例如代码需要等待某些 DOM 状态时，可以使用 
<code>MutationObserver</code>（而不是通过 Angular 的渲染钩子间接等待）。</p>

    <div class="docs-callout docs-callout-helpful">
      <h3 data-ng_translator_product="100" data-ng_translator_ref_id="cp85sakt4xr8kikwbzqpd22yi">NgZone.run 和 NgZone.runOutsideAngular 与 Zoneless 模式兼容</h3>
      <p data-ng_translator_product="100" data-ng_translator_ref_id="r4g4lwvgtlfwvl53pnbd6xo5"><code>NgZone.run</code> 和 
<code>NgZone.runOutsideAngular</code> 不需要移除即可与 Zoneless 模式应用兼容。事实上，移除这些调用可能会导致仍依赖 ZoneJS 的应用中使用的库出现性能回退。</p>

    </div>
    
  <h3 id="experimentalpendingtasks-for-server-side-rendering-ssr">
    <a href="#experimentalpendingtasks-for-server-side-rendering-ssr" class="docs-anchor" tabindex="-1" aria-label="Link to <code>ExperimentalPendingTasks</code> for Server Side Rendering (SSR)" data-ng_translator_product="100" data-ng_translator_ref_id="bm4wjsg9egxwbfuqzlrj4cgk5"><code>ExperimentalPendingTasks</code> 用于服务器端渲染（SSR）</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="312zntjcvv7gpbt37xhxxvud0">如果你在 Angular 中使用 SSR，可能知道它依赖于 ZoneJS 来帮助确定应用是否 "稳定" 并可以序列化。如果有某些异步任务应该阻止序列化，那么不使用 ZoneJS 的应用需要通过 
<code>ExperimentalPendingTasks</code> 服务让 Angular 知道这些任务的存在。序列化将等待所有待处理任务被移除的第一个时刻。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">const</span> taskService = <span class="hljs-title function_">inject</span>(<span class="hljs-title class_">ExperimentalPendingTasks</span>);</div><div class="hljs-ln-line"><span class="hljs-keyword">const</span> taskCleanup = taskService.<span class="hljs-title function_">add</span>();</div><div class="hljs-ln-line"><span class="hljs-keyword">await</span> <span class="hljs-title function_">doSomeWorkThatNeedsToBeRendered</span>();</div><div class="hljs-ln-line"><span class="hljs-title function_">taskCleanup</span>();</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="4b6on7fsi1pmxucx9x0j44d87">框架内部也使用此服务来防止在异步任务完成之前进行序列化。这些任务包括但不限于正在进行的路由导航和未完成的 
<code>HttpClient</code> 请求。</p>

  <h2 id="testing-and-debugging">
    <a href="#testing-and-debugging" class="docs-anchor" tabindex="-1" aria-label="Link to Testing and Debugging" data-ng_translator_product="100" data-ng_translator_ref_id="6jterh3k2l579gx4hl244sx5d">测试和调试</a>
  </h2>
  
  <h3 id="using-zoneless-in-testbed">
    <a href="#using-zoneless-in-testbed" class="docs-anchor" tabindex="-1" aria-label="Link to Using Zoneless in <code>TestBed</code>" data-ng_translator_product="100" data-ng_translator_ref_id="87gbbp2s1we4ej6m5xcn50pjj">在 
<code>TestBed</code> 中使用 Zoneless</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="bldv5sz14n6rjic8rc6py6ysj">Zoneless 提供者函数也可以与 
<code>TestBed</code> 一起使用，以帮助确保被测试的组件与 Zoneless 的 Angular 应用兼容。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-title class_">TestBed</span>.<span class="hljs-title function_">configureTestingModule</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [<span class="hljs-title function_">provideExperimentalZonelessChangeDetection</span>()]</div><div class="hljs-ln-line">});</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-keyword">const</span> fixture = <span class="hljs-title class_">TestBed</span>.<span class="hljs-title function_">createComponent</span>(<span class="hljs-title class_">MyComponent</span>);</div><div class="hljs-ln-line"><span class="hljs-keyword">await</span> fixture.<span class="hljs-title function_">whenStable</span>();</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="5ap7r2a8ybegsk3dsgwwl2p00">为了确保测试行为与生产代码最为相似，尽量避免使用 
<code>fixture.detectChanges()</code>。这会在 Angular 本来可能没有安排变更检测时强制运行变更检测。测试应该确保这些通知正在发生，并允许 Angular 处理何时同步状态，而不是在测试中手动强制它发生。</p>

  <h3 id="debug-mode-check-to-ensure-updates-are-detected">
    <a href="#debug-mode-check-to-ensure-updates-are-detected" class="docs-anchor" tabindex="-1" aria-label="Link to Debug-mode check to ensure updates are detected" data-ng_translator_product="100" data-ng_translator_ref_id="cse2kk80bewau97tn3gewrbuv">调试模式检查以确保更新被检测到</a>
  </h3>
  <p data-ng_translator_product="100" data-ng_translator_ref_id="1a7lwfl77rdt7oshps9q7roby">Angular 还提供了一个额外的工具，帮助验证应用是否以与 Zoneless 兼容的方式进行状态更新。
<code>provideExperimentalCheckNoChangesForDebug</code> 可用于周期性检查，确保没有绑定在没有通知的情况下被更新。如果有绑定更新而不会被 Zoneless 变更检测刷新，Angular 将抛出 
<code>ExpressionChangedAfterItHasBeenCheckedError</code>。</p>
