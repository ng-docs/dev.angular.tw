<header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1">預先編譯 (AoT) compilation</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/tools/cli/aot-compiler.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    <p>Angular 應用主要由元件及其 HTML 樣板組成。
由於瀏覽器無法直接理解 Angular 提供的元件和樣板，因此 Angular 應用需要一個編譯過程才能在瀏覽器中執行。</p>
<p>Angular 預先編譯 (AoT) 編譯器在建立階段<em>在</em>瀏覽器下載並執行該程式碼<em>之前</em>，將你的 Angular HTML 和 TypeScript 程式碼轉換為高效的 JavaScript 程式碼。
在建立過程中編譯你的應用可以在瀏覽器中提供更快的渲染。</p>
<p>本指南解釋瞭如何指定元資料並應用可用的編譯器選項，以使用 AoT 編譯器高效地編譯你的應用。</p>

    <div class="docs-alert docs-alert-helpful">
    <p><strong>提示：</strong> <a href="https://www.youtube.com/watch?v=anphffaCZrQ" target="_blank">觀看 Alex Rickabaugh 在 AngularConnect 2019 大會上講解 Angular 編譯器</a>。</p>

    </div>
    <p>以下是你可能想要使用 AoT 的一些原因。</p>

  <div class="docs-table docs-scroll-track-transparent">
    <table>
      <thead>
        <tr>
<th align="left">原因</th>
<th align="left">詳情</th>
</tr>

      </thead>
      <tbody>
        <tr>
<td align="left">更快的渲染</td>
<td align="left">使用 AoT，瀏覽器會下載應用的預編譯版本。瀏覽器載入可執行程式碼，以便它可以立即渲染應用，而無需先等待編譯應用。</td>
</tr>
<tr>
<td align="left">更少的非同步請求</td>
<td align="left">編譯器將外部 HTML 樣板和 CSS 樣式表<em>行內</em>到應用 JavaScript 中，從而消除了對這些源檔案的單獨 ajax 請求。</td>
</tr>
<tr>
<td align="left">更小的 Angular 框架下載大小</td>
<td align="left">如果應用已經編譯，則無需下載 Angular 編譯器。編譯器大約佔 Angular 本身的一半，因此省略它可以顯著減少應用的有效負載。</td>
</tr>
<tr>
<td align="left">更早地檢測樣板錯誤</td>
<td align="left">AoT 編譯器在建立步驟中檢測並報告樣板繫結錯誤，在使用者看到它們之前。</td>
</tr>
<tr>
<td align="left">更好的安全性</td>
<td align="left">AoT 將 HTML 樣板和元件編譯為 JavaScript 檔案，在它們被提供給用戶端<em>很久之前</em>。由於沒有樣板需要讀取，也沒有有風險的用戶端 HTML 或 JavaScript 求值，因此減少了注入攻擊的機會。</td>
</tr>

      </tbody>
    </table>
  </div>
  
  <h2 id="choosing-a-compiler">
    <a href="#choosing-a-compiler" class="docs-anchor" tabindex="-1" aria-label="Link to Choosing a compiler">選擇編譯器</a>
  </h2>
  <p>Angular 提供了兩種編譯你的應用的方式：</p>

  <div class="docs-table docs-scroll-track-transparent">
    <table>
      <thead>
        <tr>
<th align="left">Angular 編譯</th>
<th align="left">詳情</th>
</tr>

      </thead>
      <tbody>
        <tr>
<td align="left">即時 (JiT)</td>
<td align="left">在執行時在瀏覽器中編譯你的應用。在 Angular 8 之前，這是預設設定。</td>
</tr>
<tr>
<td align="left">預先編譯 (AoT)</td>
<td align="left">在建立時編譯你的應用和函式庫。從 Angular 9 開始，這是預設設定。</td>
</tr>

      </tbody>
    </table>
  </div>
  <p>當你執行 <code><a href="cli/build">ng build</a></code>（僅建立）或 <code><a href="cli/serve">ng serve</a></code>（建立並在本地啟動伺服器）CLI 指令時，編譯型別（JiT 或 AoT）取決於 <code>angular.json</code> 中指定的建立設定中 <code>aot</code> 屬性的值。
預設情況下，對於新的 CLI 應用，<code>aot</code> 設定為 <code>true</code>。</p>
<p>有關更多訊息，請參閱 <a href="cli">CLI command reference</a> 和 <a href="tools/cli/build">Building and serving Angular apps</a>。</p>

  <h2 id="how-aot-works">
    <a href="#how-aot-works" class="docs-anchor" tabindex="-1" aria-label="Link to How AOT works">AoT 的工作原理</a>
  </h2>
  <p>Angular AoT 編譯器提取 <strong>metadata</strong>，以解釋 Angular 應該管理的應用部分。你可以在 <strong>裝飾器</strong>（如 <code>@Component()</code> 和 <code>@Input()</code>）中顯式指定元資料，或在帶裝飾器的類別的建構式函式宣告中隱式指定。
元資料告訴 Angular 如何構造你的應用類別的實例並在執行時與它們互動。</p>
<p>在以下範例中，<code>@Component()</code> 元資料物件和類建構式函式告訴 Angular 如何建立和顯示 <code>TypicalComponent</code> 的實例。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  selector: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'app-typical'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'&lt;div&gt;A typical component for {{data.name}}&lt;/div&gt;'</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> TypicalComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">() </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> TypicalData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  private</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70"> someService</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(SomeService);</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
    </pre>
  </div><p>Angular 編譯器<em>一次性</em>提取元資料，併為 <code>TypicalComponent</code> 生成一個<em>工廠</em>。
當需要建立 <code>TypicalComponent</code> 實例時，Angular 呼叫該工廠，工廠會生成一個新的視覺化元素，該元素繫結到元件類別的新實例及其注入的依賴項。</p>

  <h3 id="compilation-phases">
    <a href="#compilation-phases" class="docs-anchor" tabindex="-1" aria-label="Link to Compilation phases">編譯階段</a>
  </h3>
  <p>AoT 編譯有三個階段。</p>

  <div class="docs-table docs-scroll-track-transparent">
    <table>
      <thead>
        <tr>
<th align="left"></th>
<th align="left">階段</th>
<th align="left">詳情</th>
</tr>

      </thead>
      <tbody>
        <tr>
<td align="left">1</td>
<td align="left">程式碼分析</td>
<td align="left">在此階段，TypeScript 編譯器和 <em>AoT 收集器</em> 建立原始碼的表示形式。收集器不嘗試解釋它收集的元資料。它儘可能地表示元資料，並在檢測到元資料語法違規時記錄錯誤。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">程式碼生成</td>
<td align="left">在此階段，編譯器的 <code>StaticReflector</code> 解釋在階段 1 中收集的元資料，對元資料執行額外的驗證，並在檢測到元資料限制違規時丟擲錯誤。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">樣板型別檢查</td>
<td align="left">在這個可選階段，Angular *樣板編譯器* 使用 TypeScript 編譯器來驗證樣板中的繫結表示式。你可以透過設定 <code>strictTemplates</code> 設定選項來顯式啟用此階段；請參閱 <a href="reference/configs/angular-compiler-options">Angular 編譯器選項</a>。</td>
</tr>

      </tbody>
    </table>
  </div>
  
  <h3 id="metadata-restrictions">
    <a href="#metadata-restrictions" class="docs-anchor" tabindex="-1" aria-label="Link to Metadata restrictions">元資料限制</a>
  </h3>
  <p>你用 TypeScript 的*子集*編寫元資料，該子集必須符合以下通用約束：</p>

  <ul class="docs-list">
    <li>將 <a href="#expression-syntax-limitations">表示式語法</a> 限制為受支援的 JavaScript 子集</li>
<li>僅在 <a href="#code-folding">程式碼摺疊</a> 後引用匯出的符號</li>
<li>僅呼叫編譯器<a href="#supported-classes-and-functions">支援的函式</a></li>
<li>輸入/輸出和數據繫結的類別成員必須是公共的或受保護的。有關為預先編譯準備應用的更多指南和說明，請參閱 <a href="https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f" target="_blank">Angular: 編寫對 AoT 友好的應用</a>。</li>

  </ul>
  
    <div class="docs-alert docs-alert-helpful">
    <p><strong>提示：</strong> 預先編譯中的錯誤通常是由於元資料不符合編譯器的要求（如下更詳細的描述）而發生的。
為了幫助理解和解決這些問題，請參閱 <a href="tools/cli/aot-metadata-errors">AoT 元資料錯誤</a>。</p>

    </div>
    
  <h3 id="configuring-aot-compilation">
    <a href="#configuring-aot-compilation" class="docs-anchor" tabindex="-1" aria-label="Link to Configuring AOT compilation">設定預先編譯</a>
  </h3>
  <p>你可以在 <a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank">TypeScript 設定檔案</a> 中提供控制編譯過程的選項。
有關可用選項的完整清單，請參閱 <a href="reference/configs/angular-compiler-options">Angular 編譯器選項</a>。</p>

  <h2 id="phase-1-code-analysis">
    <a href="#phase-1-code-analysis" class="docs-anchor" tabindex="-1" aria-label="Link to Phase 1: Code analysis">階段 1：程式碼分析</a>
  </h2>
  <p>TypeScript 編譯器執行第一階段的一些分析工作。
它發出帶有型別訊息的 <code>.d.ts</code> *型別定義檔案*，AoT 編譯器需要這些型別訊息來生成應用程式碼。
同時，AoT <strong>收集器</strong> 分析 Angular 裝飾器中記錄的元資料，並在 <strong><code>.metadata.json</code></strong> 檔案中輸出元資料訊息，每個 <code>.d.ts</code> 檔案對應一個。</p>
<p>你可以將 <code>.metadata.json</code> 視為裝飾器的元資料的整體結構的圖，它被表示為 <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank">抽象語法樹 (AST)</a>。</p>

    <div class="docs-alert docs-alert-helpful">
    <p><strong>提示：</strong> Angular 的 <a href="https://github.com/angular/angular/blob/main/packages/compiler-cli/src/metadata/schema.ts" target="_blank">schema.ts</a> 將 JSON 格式描述為 TypeScript 介面的集合。</p>

    </div>
    
  <h3 id="expression-syntax-limitations">
    <a href="#expression-syntax-limitations" class="docs-anchor" tabindex="-1" aria-label="Link to Expression syntax limitations">表示式語法限制</a>
  </h3>
  <p>AoT 收集器只理解 JavaScript 的子集。
使用以下有限的語法定義元資料物件：</p>

  <div class="docs-table docs-scroll-track-transparent">
    <table>
      <thead>
        <tr>
<th align="left">語法</th>
<th align="left">範例</th>
</tr>

      </thead>
      <tbody>
        <tr>
<td align="left">字面量物件</td>
<td align="left"><code>{cherry: true, apple: true, mincemeat: false}</code></td>
</tr>
<tr>
<td align="left">字面量陣列</td>
<td align="left"><code>['cherries', 'flour', 'sugar']</code></td>
</tr>
<tr>
<td align="left">字面量陣列中的展開</td>
<td align="left"><code>['apples', 'flour', …]</code></td>
</tr>
<tr>
<td align="left">呼叫</td>
<td align="left"><code>bake(ingredients)</code></td>
</tr>
<tr>
<td align="left">新建</td>
<td align="left"><code>new Oven()</code></td>
</tr>
<tr>
<td align="left">屬性訪問</td>
<td align="left"><code>pie.slice</code></td>
</tr>
<tr>
<td align="left">陣列索引</td>
<td align="left"><code>ingredients[0]</code></td>
</tr>
<tr>
<td align="left">標識引用</td>
<td align="left"><code>Component</code></td>
</tr>
<tr>
<td align="left">樣板字串</td>
<td align="left"><code><code>pie is ${multiplier} times better than cake</code></code></td>
</tr>
<tr>
<td align="left">字面量字串</td>
<td align="left"><code>'pi'</code></td>
</tr>
<tr>
<td align="left">字面量數字</td>
<td align="left"><code>3.14153265</code></td>
</tr>
<tr>
<td align="left">字面量布林值</td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left">字面量 null</td>
<td align="left"><code>null</code></td>
</tr>
<tr>
<td align="left">支援的字首運算符</td>
<td align="left"><code>!cake</code></td>
</tr>
<tr>
<td align="left">支援的二元運算符</td>
<td align="left"><code>a+b</code></td>
</tr>
<tr>
<td align="left">條件運算符</td>
<td align="left"><code>a ? b : c</code></td>
</tr>
<tr>
<td align="left">圓括號</td>
<td align="left"><code>(a+b)</code></td>
</tr>

      </tbody>
    </table>
  </div>
  <p>如果表示式使用不支援的語法，收集器會將錯誤節點寫入 <code>.metadata.json</code> 檔案。
如果編譯器稍後需要該元資料片段來生成應用程式碼，則會報告該錯誤。</p>

    <div class="docs-alert docs-alert-helpful">
    <p><strong>提示：</strong> 如果你希望 <code>ngc</code> 立即報告語法錯誤，而不是生成帶有錯誤的 <code>.metadata.json</code> 檔案，請在 TypeScript 設定檔案中設定 <code>strictMetadataEmit</code> 選項。</p>

    </div>
    <div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"angularCompilerOptions"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic">  …</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  "strictMetadataEmit"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> : </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">true</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
    </pre>
  </div><p>Angular 函式庫具有此選項，以確保所有 Angular <code>.metadata.json</code> 檔案都是乾淨的，並且在建立你自己的函式庫時，這樣做也是最佳實踐。</p>

  <h3 id="no-arrow-functions">
    <a href="#no-arrow-functions" class="docs-anchor" tabindex="-1" aria-label="Link to No arrow functions">沒有箭頭函式</a>
  </h3>
  <p>AoT 編譯器不支援 <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/function" target="_blank">函式表示式</a> 和 <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank">箭頭函式</a>，也稱為 *lambda* 函式。</p>
<p>考慮以下元件裝飾器：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  …</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  providers: [{provide: server, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">useFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">()}]</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span></code></pre>
    </pre>
  </div><p>AoT 收集器不支援元資料表示式中的箭頭函式 <code>() =&gt; new Server()</code>。
它生成一個錯誤節點來代替該函式。
當編譯器稍後解釋此節點時，它會報告一個錯誤，邀請你將箭頭函式轉換為*匯出函式*。</p>
<p>你可以透過轉換為以下形式來修復此錯誤：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> serverFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">() {</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">();</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  …</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  providers: [{provide: server, useFactory: serverFactory}]</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span></code></pre>
    </pre>
  </div><p>在版本 5 及更高版本中，編譯器在發出 <code>.js</code> 檔案時會自動執行此重寫。</p>

  <h3 id="code-folding">
    <a href="#code-folding" class="docs-anchor" tabindex="-1" aria-label="Link to Code folding">程式碼摺疊</a>
  </h3>
  <p>編譯器只能求解對*<strong>匯出</strong>*符號的引用。
但是，收集器可以在收集期間求值表示式，並將結果記錄在 <code>.metadata.json</code> 中，而不是原始表示式。
這允許你在表示式中有限地使用未匯出的符號。</p>
<p>例如，收集器可以求值表示式 <code>1 + 2 + 3 + 4</code> 並用結果 <code>10</code> 替換它。
這個過程稱為*摺疊*。
可以以這種方式簡化的表示式是*可摺疊的*。</p>
<p>收集器可以求值對模組本地 <code>const</code> 物件宣告和初始化的 <code>var</code> 和 <code>let</code> 物件宣告的引用，從而有效地將它們從 <code>.metadata.json</code> 檔案中移除。</p>
<p>考慮以下元件定義：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> template</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '&lt;div&gt;{{hero.name}}&lt;/div&gt;'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  selector: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'app-hero'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  template: template</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> HeroComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">() </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">hero</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Hero</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
    </pre>
  </div><p>編譯器無法引用 <code>template</code> 常數，因為它沒有匯出。
但是，收集器可以透過行內 <code>template</code> 常數的內容，將其摺疊到元資料定義中。
效果就像你寫了以下程式碼一樣：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  selector: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'app-hero'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'&lt;div&gt;{{hero.name}}&lt;/div&gt;'</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> HeroComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">() </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">hero</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Hero</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
    </pre>
  </div><p>不再有對 <code>template</code> 的引用，因此，當編譯器稍後在 <code>.metadata.json</code> 中解釋*收集器*的輸出時，沒有什麼會困擾它。</p>
<p>你可以透過在另一個表示式中包含 <code>template</code> 常數，將此範例更進一步：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> template</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '&lt;div&gt;{{hero.name}}&lt;/div&gt;'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  selector: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'app-hero'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  template: template </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '&lt;div&gt;{{hero.title}}&lt;/div&gt;'</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> HeroComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">() </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">hero</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Hero</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
    </pre>
  </div><p>收集器將此表示式簡化為其等效的*摺疊*字串：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'&lt;div&gt;{{hero.name}}&lt;/div&gt;&lt;div&gt;{{hero.title}}&lt;/div&gt;'</span></span></code></pre>
    </pre>
  </div>
  <h4 id="foldable-syntax">
    <a href="#foldable-syntax" class="docs-anchor" tabindex="-1" aria-label="Link to Foldable syntax">可摺疊的語法</a>
  </h4>
  <p>下表描述了收集器可以和不可以摺疊哪些表示式：</p>

  <div class="docs-table docs-scroll-track-transparent">
    <table>
      <thead>
        <tr>
<th align="left">語法</th>
<th align="left">可摺疊的</th>
</tr>

      </thead>
      <tbody>
        <tr>
<td align="left">字面量物件</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">字面量陣列</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">字面量陣列中的展開</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">呼叫</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">新建</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">屬性訪問</td>
<td align="left">是，如果目標是可摺疊的</td>
</tr>
<tr>
<td align="left">陣列索引</td>
<td align="left">是，如果目標和索引都是可摺疊的</td>
</tr>
<tr>
<td align="left">標識引用</td>
<td align="left">是，如果它是對本地變數的引用</td>
</tr>
<tr>
<td align="left">沒有替換的樣板</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">帶有替換的樣板</td>
<td align="left">是，如果替換是可摺疊的</td>
</tr>
<tr>
<td align="left">字面量字串</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">字面量數字</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">字面量布林值</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">字面量 null</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">支援的字首運算符</td>
<td align="left">是，如果操作數是可摺疊的</td>
</tr>
<tr>
<td align="left">支援的二元運算符</td>
<td align="left">是，如果左右操作數都是可摺疊的</td>
</tr>
<tr>
<td align="left">條件運算符</td>
<td align="left">是，如果條件是可摺疊的</td>
</tr>
<tr>
<td align="left">圓括號</td>
<td align="left">是，如果表示式是可摺疊的</td>
</tr>

      </tbody>
    </table>
  </div>
  <p>如果表示式不可摺疊，收集器會將其作為 <code>.metadata.json</code> 中的 <a href="https://en.wikipedia.org/wiki/Abstract*syntax*tree" target="_blank">AST</a> 寫入，以供編譯器求解。</p>

  <h2 id="phase-2-code-generation">
    <a href="#phase-2-code-generation" class="docs-anchor" tabindex="-1" aria-label="Link to Phase 2: code generation">階段 2：程式碼生成</a>
  </h2>
  <p>收集器不會嘗試理解它收集並輸出到 <code>.metadata.json</code> 的元資料。
它會盡其所能地表示元資料，並在檢測到元資料語法違規時記錄錯誤。
在程式碼生成階段，由編譯器來解釋 <code>.metadata.json</code>。</p>
<p>編譯器理解收集器支援的所有語法形式，但如果<em>語義</em>違反了編譯器規則，它可能會拒絕<em>語法上</em>正確的元資料。</p>

  <h3 id="public-or-protected-symbols">
    <a href="#public-or-protected-symbols" class="docs-anchor" tabindex="-1" aria-label="Link to Public or protected symbols">公共或受保護的符號</a>
  </h3>
  <p>編譯器只能引用<em>匯出的符號</em>。</p>

  <ul class="docs-list">
    <li><p>帶裝飾器的元件類別成員必須是公共的或受保護的。
  你不能把 <code>@Input()</code> 屬性設為私有的。</p>
</li>
<li><p>資料繫結的屬性（Property）也必須是公共的或受保護的</p>
</li>

  </ul>
  
  <h3 id="supported-classes-and-functions">
    <a href="#supported-classes-and-functions" class="docs-anchor" tabindex="-1" aria-label="Link to Supported classes and functions">支援的類別和函式</a>
  </h3>
  <p>只要語法有效，收集器就可以表示使用 <code>new</code> 的函式呼叫或物件建立。
但是，編譯器稍後可能會拒絕生成對<em>特定</em>函式的呼叫或建立<em>特定</em>物件。</p>
<p>編譯器只能建立某些類別的實例，僅支援核心裝飾器，並且僅支援呼叫回傳表示式的宏（函式或靜態方法）。</p>

  <div class="docs-table docs-scroll-track-transparent">
    <table>
      <thead>
        <tr>
<th align="left">編譯器操作</th>
<th align="left">詳情</th>
</tr>

      </thead>
      <tbody>
        <tr>
<td align="left">新實例</td>
<td align="left">編譯器只允許建立 <code>@angular/core</code> 中的 <code>InjectionToken</code> 類別的實例的元資料。</td>
</tr>
<tr>
<td align="left">支援的裝飾器</td>
<td align="left">編譯器僅支援 <a href="api/core#decorators"><code>@angular/core</code> 模組</a> 中的 Angular 裝飾器的元資料。</td>
</tr>
<tr>
<td align="left">函式呼叫</td>
<td align="left">工廠函式必須是匯出的、具名的函式。預先編譯器 (AoT) 不支援用於工廠函式的 lambda 表示式（『箭頭函式』）。</td>
</tr>

      </tbody>
    </table>
  </div>
  
  <h3 id="functions-and-static-method-calls">
    <a href="#functions-and-static-method-calls" class="docs-anchor" tabindex="-1" aria-label="Link to Functions and static method calls">函式和靜態方法呼叫</a>
  </h3>
  <p>收集器接受任何包含單個 <code>return</code> 語句的函式或靜態方法。
但是，編譯器僅支援以函式或靜態方法形式存在的、回傳<em>表示式</em>的宏。</p>
<p>例如，考慮以下函式：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> wrapInArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">[] {</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> [value];</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
    </pre>
  </div><p>你可以在元資料定義中呼叫 <code>wrapInArray</code>，因為它回傳的表示式的值符合編譯器限制性的 JavaScript 子集。</p>
<p>你可以像這樣使用 <code>wrapInArray()</code>：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">NgModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  declarations: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">wrapInArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(TypicalComponent)</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> TypicalModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {}</span></span></code></pre>
    </pre>
  </div><p>編譯器將此用法視為你已編寫了以下程式碼：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">NgModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  declarations: [TypicalComponent]</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> TypicalModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {}</span></span></code></pre>
    </pre>
  </div><p>Angular 的 <a href="api/router/RouterModule"><code>RouterModule</code></a> 匯出了兩個宏靜態方法 <code>forRoot</code> 和 <code>forChild</code>，以幫助宣告根路由和子路由。
檢視這些方法的<a href="https://github.com/angular/angular/blob/main/packages/router/src/router_module.ts#L139" title="RouterModule.forRoot" source code target="_blank">原始碼</a>，瞭解宏如何簡化複雜 <a href="guide/ngmodules">NgModule</a> 的設定。</p>

  <h3 id="metadata-rewriting">
    <a href="#metadata-rewriting" class="docs-anchor" tabindex="-1" aria-label="Link to Metadata rewriting">元資料重寫</a>
  </h3>
  <p>編譯器會特殊處理包含 <code>useClass</code>、<code>useValue</code>、<code>useFactory</code> 和 <code>data</code> 欄位的物件字面量，將初始化其中一個欄位的表示式轉換為匯出的變數來替代該表示式。
重寫這些表示式的過程消除了對其中內容的所有限制，因為編譯器不需要知道表示式的值 —— 它只需要能夠生成對該值的引用。</p>
<p>你可能會這樣寫：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> TypicalServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">NgModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  providers: [{provide: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">SERVER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">useFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> TypicalServer}]</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> TypicalModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {}</span></span></code></pre>
    </pre>
  </div><p>如果不進行重寫，這將是無效的，因為不支援 lambda 表示式，並且 <code>TypicalServer</code> 沒有匯出。
為了允許這樣做，編譯器會自動將其重寫為如下形式：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> TypicalServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> θ0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> TypicalServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">();</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">NgModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  providers: [{provide: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">SERVER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, useFactory: θ0}]</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> TypicalModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {}</span></span></code></pre>
    </pre>
  </div><p>這允許編譯器在工廠中生成對 <code>θ0</code> 的引用，而無需知道 <code>θ0</code> 的值包含什麼。</p>
<p>編譯器在發出 <code>.js</code> 檔案期間執行重寫。
但是，它不會重寫 <code>.d.ts</code> 檔案，因此 TypeScript 不會將其識別為匯出項。
並且它不會干擾 ES 模組的匯出 API。</p>

  <h2 id="phase-3-template-type-checking">
    <a href="#phase-3-template-type-checking" class="docs-anchor" tabindex="-1" aria-label="Link to Phase 3: Template type checking">階段 3：樣板型別檢查</a>
  </h2>
  <p>Angular 編譯器的最有用的屬性之一是能夠對樣板中的表示式進行型別檢查，並在錯誤導致執行時崩潰之前捕獲它們。
在樣板型別檢查階段，Angular 樣板編譯器使用 TypeScript 編譯器來驗證樣板中的繫結表示式。</p>
<p>透過在專案的 TypeScript 設定檔案的 <code>"angularCompilerOptions"</code> 中新增編譯器選項 <code>"fullTemplateTypeCheck"</code> 來顯式啟用此階段（請參閱<a href="reference/configs/angular-compiler-options">Angular 編譯器選項</a>）。</p>
<p>當在樣板繫結表示式中檢測到型別錯誤時，樣板驗證會生成錯誤訊息，類似於 TypeScript 編譯器針對 <code>.ts</code> 檔案中的程式碼報告型別錯誤的方式。</p>
<p>例如，考慮以下元件：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  selector: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'my-component'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'{{person.addresss.street}}'</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">  person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
    </pre>
  </div><p>這將產生以下錯誤：</p>
<div class="docs-code shell">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">my.component.ts.MyComponent.html(1,1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">): </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> Property </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'addresss'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> does not exist on type </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'Person'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">. Did you mean </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'address'</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">?</span></span></code></pre>
    </pre>
  </div><p>錯誤訊息中報告的檔案名 <code>my.component.ts.MyComponent.html</code> 是一個合成檔案，由樣板編譯器生成，其中包含 <code>MyComponent</code> 類樣板的內容。
編譯器永遠不會將此檔案寫入磁碟。
行號和列號相對於類 <code>MyComponent</code> 的 <code>@Component</code> 註解中的樣板字串而言（在本例中為 <code>MyComponent</code>）。
如果元件使用 <code>templateUrl</code> 而不是 <code>template</code>，則錯誤將在 <code>templateUrl</code> 引用的 HTML 檔案中報告，而不是在合成檔案中報告。</p>
<p>錯誤位置是包含帶有錯誤的內嵌表示式的文字節點的開頭。
如果錯誤在屬性繫結中，例如 <code>[value]="person.address.street"</code>，則錯誤位置是包含錯誤的屬性的位置。</p>
<p>驗證使用 TypeScript 型別檢查器和提供給 TypeScript 編譯器的選項來控制型別驗證的詳細程度。
例如，如果指定了 <code>strictTypeChecks</code>，則會報告錯誤</p>
<div class="docs-code shell">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">my.component.ts.MyComponent.html(1,1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">): </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> Object is possibly </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'undefined'</span></span></code></pre>
    </pre>
  </div><p>以及上面的錯誤訊息。</p>

  <h3 id="type-narrowing">
    <a href="#type-narrowing" class="docs-anchor" tabindex="-1" aria-label="Link to Type narrowing">型別窄化</a>
  </h3>
  <p><code>ngIf</code> 指令中使用的表示式用於窄化 Angular 樣板編譯器中的型別聯合，就像 <code>if</code> 表示式在 TypeScript 中所做的那樣。
例如，為了避免上面樣板中出現 <code>Object is possibly 'undefined'</code> 錯誤，請修改它，以便僅當 <code>person</code> 的值已初始化時才發出內嵌，如下所示：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  selector: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'my-component'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'&lt;span *ngIf="person"&gt; {{person.address.street}} &lt;/span&gt;'</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">  person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
    </pre>
  </div><p>使用 <code>*ngIf</code> 允許 TypeScript 編譯器推斷繫結表示式中使用的 <code>person</code> 永遠不會是 <code>undefined</code>。</p>
<p>有關輸入型別窄化的更多訊息，請參閱<a href="guide/directives/structural-directives#directive-type-checks">改進自定義指令的樣板型別檢查</a>。</p>

  <h3 id="non-null-type-assertion-operator">
    <a href="#non-null-type-assertion-operator" class="docs-anchor" tabindex="-1" aria-label="Link to Non-null type assertion operator">非空型別斷言運算子</a>
  </h3>
  <p>當使用 <code>*ngIf</code> 不方便時，或者當元件中的某些約束確保當繫結表示式被內嵌時表示式始終為非空時，可以使用非空型別斷言運算子來抑制 <code>Object is possibly 'undefined'</code> 錯誤。</p>
<p>在以下範例中，<code>person</code> 和 <code>address</code> 屬性始終一起設定，這意味著如果 <code>person</code> 為非空，則 <code>address</code> 始終為非空。
沒有方便的方法向 TypeScript 和樣板編譯器描述此約束，但在此範例中，透過使用 <code>address!.street</code> 抑制了錯誤。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  selector: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'my-component'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'&lt;span *ngIf="person"&gt; {{person.name}} lives on {{address!.street}} &lt;/span&gt;'</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">  person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">  address</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Address</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">  setData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">address</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Address</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">) {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">.person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> person;</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">.address </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> address;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
    </pre>
  </div><p>非空斷言運算子應謹慎使用，因為元件的重構可能會破壞此約束。</p>
<p>在此範例中，建議在 <code>*ngIf</code> 中包含對 <code>address</code> 的檢查，如下所示：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  selector: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'my-component'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'&lt;span *ngIf="person &amp;&amp; address"&gt; {{person.name}} lives on {{address.street}} &lt;/span&gt;'</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">  person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">  address</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Address</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">  setData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">address</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Address</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">) {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">.person </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> person;</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">.address </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> address;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
    </pre>
  </div>