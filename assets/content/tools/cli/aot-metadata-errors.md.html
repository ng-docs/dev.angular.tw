<header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7ubva5ekegcprdgv0kqjap9hb">AOT 元数据错误</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/tools/cli/aot-metadata-errors.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="dryuujvcj34rk8wuw1s30ktxu">以下是你可能会遇到的元数据错误，带有解释和建议的更正。</p>

  <h2 id="expression-form-not-supported">
    <a href="#expression-form-not-supported" class="docs-anchor" tabindex="-1" aria-label="Link to Expression form not supported" data-ng_translator_product="100" data-ng_translator_ref_id="3dulek5ot6uppv7bou77m7u11">不支持此表达式格式（Expression form not supported）</a>
  </h2>
  
    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="77slecqfxearbt3z5hw2xl1pr"><strong>提示：</strong>编译器在评估 Angular 元数据时遇到无法理解的表达式。</p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_ref_id="ddotmavc2gn6yza8k3iuqnui2">在编写 Angular 元数据时，遵循编译器的 
<a href="tools/cli/aot-compiler#expression-syntax">受限制的表达式语法</a> 可以避免此错误，并且要注意新的或不寻常的 TypeScript 特性。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// ERROR</span></div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fooish</span> { … }</div><div class="hljs-ln-line">…</div><div class="hljs-ln-line"><span class="hljs-keyword">const</span> prop = <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Fooish</span>; <span class="hljs-comment">// typeof is not valid in metadata</span></div><div class="hljs-ln-line">  …</div><div class="hljs-ln-line">  <span class="hljs-comment">// bracket notation is not valid in metadata</span></div><div class="hljs-ln-line">  { <span class="hljs-attr">provide</span>: <span class="hljs-string">'token'</span>, <span class="hljs-attr">useValue</span>: { [prop]: <span class="hljs-string">'value'</span> } };</div><div class="hljs-ln-line">  …</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="54u85983876b6lqdbwybq93yb">你可以在普通的应用代码中使用 <code>typeof</code> 和方括号标记法来指定属性名，但是这些特性不能在定义 Angular 元数据的表达式中使用。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="a117pj52oydk4w52lop1wfokt">在编写 Angular 元数据时，遵循编译器的 
<a href="tools/cli/aot-compiler#expression-syntax">受限制的表达式语法</a> 可以避免此错误，并且要注意新的或不寻常的 TypeScript 特性。</p>

  <h2 id="reference-to-a-local-non-exported-symbol">
    <a href="#reference-to-a-local-non-exported-symbol" class="docs-anchor" tabindex="-1" aria-label="Link to Reference to a local (non-exported) symbol" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="18u6us3sdhgpp4ewlcai2o99k">引用本地（未导出的）符号（Reference to a local (non-exported) symbol）</a>
  </h2>
  
    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="ch1cfc85j78yn4qeiamqj3n0d"><strong>提示：</strong>引用本地（未导出）符号 '符号名称'。考虑导出该符号。</p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_ref_id="2ea9c6sbf5juppnkwazj1xxsp">编译器遇到了对本地定义的符号的引用，该符号未导出或未初始化。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7dzuj5v4jlutmq3tm3ogu7mxg">下面就是存在该问题的 <code>provider</code> 范例。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// ERROR</span></div><div class="hljs-ln-line"><span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// neither exported nor initialized</span></div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">selector</span>: <span class="hljs-string">'my-component'</span>,</div><div class="hljs-ln-line">  <span class="hljs-attr">template</span>: … ,</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">Foo</span>, <span class="hljs-attr">useValue</span>: foo }</div><div class="hljs-ln-line">  ]</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> {}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="8s7sixxj2x77j1t1gel64dfsw">编译器会生成这个组件工厂，其中包含 <code>useValue</code> 提供者的代码。<em>那个</em>工厂模块不能访问<em>这个</em>源码模块，无法访问这个（未导出的）<code>foo</code> 变量。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="d7ckchu1w4936zkwov1vu76zt">你可以通过初始化 <code>foo</code> 来修正这个错误。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">let</span> foo = <span class="hljs-number">42</span>; <span class="hljs-comment">// initialized</span></div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="1hy4cym1iizfvwpqcan1m1rgu">编译器会将表达式 
<a href="tools/cli/aot-compiler#code-folding">折叠</a> 到提供者中，就像你写了这样。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">  { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">Foo</span>, <span class="hljs-attr">useValue</span>: <span class="hljs-number">42</span> }</div><div class="hljs-ln-line">]</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="5ugs77pyww18k58s9ctnpmy97">另外，你也可以通过导出 <code>foo</code> 来解决它，这样 <code>foo</code> 将会在运行期间你真正知道它的值的时候被赋值。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// CORRECTED</span></div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// exported</span></div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">selector</span>: <span class="hljs-string">'my-component'</span>,</div><div class="hljs-ln-line">  <span class="hljs-attr">template</span>: … ,</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">Foo</span>, <span class="hljs-attr">useValue</span>: foo }</div><div class="hljs-ln-line">  ]</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> {}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="5vmljfr3rvlvgdhrr7mdt8j8w">添加 
<code>export</code> 通常对元数据中引用的变量（如 
<code>providers</code> 和 
<code>animations</code>）有效，因为编译器可以在这些表达式中生成对导出变量的 
<em>引用</em>。它不需要这些变量的 
<em>值</em>。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="6opjdkqkkhcamlcrxhputipos">当编译器需要知道<em>真正的值</em>以生成代码时，添加 <code>export</code> 的方式就是无效的。比如这里的 <code>template</code> 属性。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// ERROR</span></div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">someTemplate</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// exported but not initialized</span></div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">selector</span>: <span class="hljs-string">'my-component'</span>,</div><div class="hljs-ln-line">  <span class="hljs-attr">template</span>: someTemplate</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> {}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="5y66jnjwv9v2pgc630yl8h19">编译器<em>现在</em>需要 
<code>template</code> 属性的值来生成组件工厂。 仅变量引用是不够的。 在声明前添加 
<code>export</code> 只会产生一个新错误，"
<a href="#only-initialized-variables"><code>只能引用已初始化的变量和常量</code></a>"。</p>

  <h2 id="only-initialized-variables-and-constants">
    <a href="#only-initialized-variables-and-constants" class="docs-anchor" tabindex="-1" aria-label="Link to Only initialized variables and constants" data-ng_translator_product="100" data-ng_translator_ref_id="bprvedijwxq3hl9ll4egk0zsr">只支持初始化过的变量和常量（Only initialized variables and constants）</a>
  </h2>
  
    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="z8yroosst7uw52v0fbuh3zt6"><strong>提示：</strong> 
<em>只有初始化的变量和常量可以被引用，因为模板编译器需要该变量的值。</em></p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="c6o8bnucpqy36z0h0srfie601">编译器发现某个到已导出的变量或静态字段的引用是没有初始化过的。而它需要根据那个变量的值来生成代码。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="7wxx0w7u9pmvjtkofpu9879hj">以下示例尝试将组件的 
<code>template</code> 属性设置为已导出但 
<em>未赋值</em> 的 
<code>someTemplate</code> 变量的值。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// ERROR</span></div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">someTemplate</span>: <span class="hljs-built_in">string</span>;</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">selector</span>: <span class="hljs-string">'my-component'</span>,</div><div class="hljs-ln-line">  <span class="hljs-attr">template</span>: someTemplate</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> {}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="4oneyif8k5kulbxrhtfrza87z">如果你从其它模块中导入了 <code>someTemplate</code>，但那个模块中忘了初始化它，就会看到这个错误。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// ERROR - not initialized there either</span></div><div class="hljs-ln-line"><span class="hljs-keyword">import</span> { someTemplate } <span class="hljs-keyword">from</span> <span class="hljs-string">'./config'</span>;</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">selector</span>: <span class="hljs-string">'my-component'</span>,</div><div class="hljs-ln-line">  <span class="hljs-attr">template</span>: someTemplate</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> {}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="a6in0zqvyf60c2bzpdcy5y6xz">编译器不能等到运行时才得到该模板的信息。它必须从源码中静态获得这个 <code>someTemplate</code> 变量的值，以便生成组件工厂，组件工厂中需要包含根据这个模板来生成元素的代码。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="8vgc43m3ssj65jzb71iag1qmc">要纠正这个错误，请在<em>同一行</em>的初始化子句中初始化这个变量的值。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// CORRECTED</span></div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> someTemplate = <span class="hljs-string">'&lt;h1&gt;Greetings from Angular&lt;/h1&gt;'</span>;</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({</div><div class="hljs-ln-line">  <span class="hljs-attr">selector</span>: <span class="hljs-string">'my-component'</span>,</div><div class="hljs-ln-line">  <span class="hljs-attr">template</span>: someTemplate</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> {}</div></code>
    </pre>
  </div>
  <h2 id="reference-to-a-non-exported-class">
    <a href="#reference-to-a-non-exported-class" class="docs-anchor" tabindex="-1" aria-label="Link to Reference to a non-exported class" data-ng_translator_product="100" data-ng_translator_ref_id="9oyv5n8nt8gltoczjjfelm4yi">引用未导出过的类（Reference to a non-exported class）</a>
  </h2>
  
    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="8p2xpl96nsickg26bbh90peaz"><strong>提示：</strong> 
<em>对未导出类<code>&lt;class name&gt;</code>的引用。</em> 
<em>考虑导出该类。</em></p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7aam8ulnuk8pm034q1u7doe1u">元数据引用了一个未导出的类。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="b5uczmc6r7j1ilv0es457xuz">例如，你可能定义了一个类并在提供者数组中用它作为注入令牌，但忘记导出该类。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// ERROR</span></div><div class="hljs-ln-line"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStrategy</span> { }</div><div class="hljs-ln-line"></div><div class="hljs-ln-line">  …</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">MyStrategy</span>, <span class="hljs-attr">useValue</span>: … }</div><div class="hljs-ln-line">  ]</div><div class="hljs-ln-line">  …</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="92qtrfi782k4fd7jjwgfa8oic">Angular会在一个单独的模块中生成类工厂，而该工厂
<a href="tools/cli/aot-compiler#exported-symbols">只能访问导出的类</a>。 要纠正此错误，请导出引用的类。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// CORRECTED</span></div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStrategy</span> { }</div><div class="hljs-ln-line"></div><div class="hljs-ln-line">  …</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">MyStrategy</span>, <span class="hljs-attr">useValue</span>: … }</div><div class="hljs-ln-line">  ]</div><div class="hljs-ln-line">  …</div></code>
    </pre>
  </div>
  <h2 id="reference-to-a-non-exported-function">
    <a href="#reference-to-a-non-exported-function" class="docs-anchor" tabindex="-1" aria-label="Link to Reference to a non-exported function" data-ng_translator_product="100" data-ng_translator_ref_id="dtp9v6ovipajzeozc0n5gg7iz">引用未导出过的函数（Reference to a non-exported function）</a>
  </h2>
  
    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="ldedxfrus1ujjenzrzkxyl18"><strong>提示：</strong> 
<em>元数据引用了一个未导出的函数。</em></p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="5x86r11utsllqop4p99g1vpvy">比如，你可能已经把某个服务提供者的 <code>useFactory</code> 属性设置成了一个局部定义但忘了导出的函数。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// ERROR</span></div><div class="hljs-ln-line"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myStrategy</span>(<span class="hljs-params"></span>) { … }</div><div class="hljs-ln-line"></div><div class="hljs-ln-line">  …</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">MyStrategy</span>, <span class="hljs-attr">useFactory</span>: myStrategy }</div><div class="hljs-ln-line">  ]</div><div class="hljs-ln-line">  …</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="6lhijnaj2pw4xy5kinxfg9ony">Angular会在一个单独的模块中生成类工厂，而该工厂
<a href="tools/cli/aot-compiler#exported-symbols">只能访问导出的函数</a>。 要纠正此错误，请导出函数。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// CORRECTED</span></div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myStrategy</span>(<span class="hljs-params"></span>) { … }</div><div class="hljs-ln-line"></div><div class="hljs-ln-line">  …</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">MyStrategy</span>, <span class="hljs-attr">useFactory</span>: myStrategy }</div><div class="hljs-ln-line">  ]</div><div class="hljs-ln-line">  …</div></code>
    </pre>
  </div>
  <h2 id="function-calls-are-not-supported">
    <a href="#function-calls-are-not-supported" class="docs-anchor" tabindex="-1" aria-label="Link to Function calls are not supported" data-ng_translator_product="100" data-ng_translator_ref_id="ewhraec9c3hvgpbupkpn7bhy1">不支持函数调用（Function calls are not supported）</a>
  </h2>
  
    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="213h3pqyn61c78a4p51ty8sba"><strong>提示：</strong> 
<em>不支持函数调用。考虑将函数或 lambda 替换为对导出函数的引用。</em></p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_ref_id="enumqpsx2elksn0gl9utj3kgq">编译器目前不支持
<a href="tools/cli/aot-compiler#function-expression">函数表达式或 lambda 函数</a>。 例如，你不能将提供者的
<code>useFactory</code>设置为匿名函数或箭头函数。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// ERROR</span></div><div class="hljs-ln-line">  …</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">MyStrategy</span>, <span class="hljs-attr">useFactory</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { … } },</div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">OtherStrategy</span>, <span class="hljs-attr">useFactory</span>: <span class="hljs-function">() =&gt;</span> { … } }</div><div class="hljs-ln-line">  ]</div><div class="hljs-ln-line">  …</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="34bn7s0rlik57m97her4y40xp">如果你在某个提供者的 <code>useValue</code> 中调用函数或方法，也会导致这个错误。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// ERROR</span></div><div class="hljs-ln-line"><span class="hljs-keyword">import</span> { calculateValue } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utilities'</span>;</div><div class="hljs-ln-line"></div><div class="hljs-ln-line">  …</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">SomeValue</span>, <span class="hljs-attr">useValue</span>: <span class="hljs-title function_">calculateValue</span>() }</div><div class="hljs-ln-line">  ]</div><div class="hljs-ln-line">  …</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="qikbuc6qz1xrlc4oxi39qi67">要改正这个问题，就要从模块中导出这个函数，并改成在服务提供者的 <code>useFactory</code> 中引用该函数。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// CORRECTED</span></div><div class="hljs-ln-line"><span class="hljs-keyword">import</span> { calculateValue } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utilities'</span>;</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myStrategy</span>(<span class="hljs-params"></span>) { … }</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">otherStrategy</span>(<span class="hljs-params"></span>) { … }</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">someValueFactory</span>(<span class="hljs-params"></span>) {</div><div class="hljs-ln-line">  <span class="hljs-keyword">return</span> <span class="hljs-title function_">calculateValue</span>();</div><div class="hljs-ln-line">}</div><div class="hljs-ln-line">  …</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">MyStrategy</span>, <span class="hljs-attr">useFactory</span>: myStrategy },</div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">OtherStrategy</span>, <span class="hljs-attr">useFactory</span>: otherStrategy },</div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">SomeValue</span>, <span class="hljs-attr">useFactory</span>: someValueFactory }</div><div class="hljs-ln-line">  ]</div><div class="hljs-ln-line">  …</div></code>
    </pre>
  </div>
  <h2 id="destructured-variable-or-constant-not-supported">
    <a href="#destructured-variable-or-constant-not-supported" class="docs-anchor" tabindex="-1" aria-label="Link to Destructured variable or constant not supported" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="e3qxudjj67h4qwrpdswxics9s">不支持解构变量或常量（Destructured variable or constant not supported）</a>
  </h2>
  
    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="2m9jj5q2gnnlq5w1w0xbm4fqu"><strong>提示：</strong> 
<em>引用导出的解构变量或常量不受模板编译器支持。考虑简化以避免解构。</em></p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_ref_id="avawm1xrncg4wm5au67llvbk7">编译器不支持对通过
<a href="https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring" target="_blank">解构</a>赋值的变量的引用。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="8fq18w42jnibzm2a9cmak4g17">比如，你不能这么写：</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// ERROR</span></div><div class="hljs-ln-line"><span class="hljs-keyword">import</span> { configuration } <span class="hljs-keyword">from</span> <span class="hljs-string">'./configuration'</span>;</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-comment">// destructured assignment to foo and bar</span></div><div class="hljs-ln-line"><span class="hljs-keyword">const</span> {foo, bar} = configuration;</div><div class="hljs-ln-line">  …</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">    {<span class="hljs-attr">provide</span>: <span class="hljs-title class_">Foo</span>, <span class="hljs-attr">useValue</span>: foo},</div><div class="hljs-ln-line">    {<span class="hljs-attr">provide</span>: <span class="hljs-title class_">Bar</span>, <span class="hljs-attr">useValue</span>: bar},</div><div class="hljs-ln-line">  ]</div><div class="hljs-ln-line">  …</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="el4xro44cn3bltwycnoemwk0q">要纠正这个错误，就要引用非解构方式的变量。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// CORRECTED</span></div><div class="hljs-ln-line"><span class="hljs-keyword">import</span> { configuration } <span class="hljs-keyword">from</span> <span class="hljs-string">'./configuration'</span>;</div><div class="hljs-ln-line">  …</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">    {<span class="hljs-attr">provide</span>: <span class="hljs-title class_">Foo</span>, <span class="hljs-attr">useValue</span>: configuration.<span class="hljs-property">foo</span>},</div><div class="hljs-ln-line">    {<span class="hljs-attr">provide</span>: <span class="hljs-title class_">Bar</span>, <span class="hljs-attr">useValue</span>: configuration.<span class="hljs-property">bar</span>},</div><div class="hljs-ln-line">  ]</div><div class="hljs-ln-line">  …</div></code>
    </pre>
  </div>
  <h2 id="could-not-resolve-type">
    <a href="#could-not-resolve-type" class="docs-anchor" tabindex="-1" aria-label="Link to Could not resolve type" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="b4qfeuvukgarfelvtnl8c15tf">无法解析类型（Could not resolve type）</a>
  </h2>
  
    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="bqooflzy6big1iu4l47j1mclu"><strong>提示：</strong> 
<em>编译器遇到了一个类型，并无法确定哪个模块导出了该类型。</em></p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="4nztnww9gl5jykprm7xhau0mx">这通常会发生在你引用环境类型时。比如，<code>Window</code> 类型就是在全局 <code>.d.ts</code> 文件中声明的环境类型。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="8cpdkuocnj1wwssmxvcw1ys1y">如果你在组件的构造函数中引用它就会导致一个错误，因为编译器必须对构造函数进行静态分析。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// ERROR</span></div><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({ })</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> {</div><div class="hljs-ln-line">  <span class="hljs-title function_">constructor</span> (<span class="hljs-keyword">private</span> <span class="hljs-attr">win</span>: <span class="hljs-title class_">Window</span>) { … }</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="atb480531cuv7du0td662omvb">TypeScript 能理解这些环境类型，所以你不用导入它们。但 Angular 编译器不理解你没有导入或导出过的类型。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="35a3dqzvzkxpn4tg40v6z6nq1">这种情况下，编译器就无法理解如何使用这个 <code>Window</code> 令牌来进行注入。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="vfqr3fxqfahumzpvd8znoatv">不要在元数据表达式中引用环境类型。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="5vpfy30mfzt30dhstwam3rzy9">如果你必须注入某个环境类型的实例，可以用以下四步来巧妙解决这个问题：</p>

    <ol class="docs-ordered-list">
      <li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7azba8pu8cpaq3f7mzubl6cu9">为环境类型的实例创建一个注入令牌。</li>
<li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="as49x53ncygxk5upognv5e526">创建一个返回该实例的工厂函数。</li>
<li data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="5wsh1apbzvey7sh9blen7a389">使用该工厂函数添加一个 <code>useFactory</code> 提供者。</li>
<li data-ng_translator_product="100" data-ng_translator_ref_id="892cwepgiw2p3g316ha1i6ero">使用
<code>@Inject</code>来注入实例。</li>

    </ol>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7e2ujetaxxophkq8txsishde0">下面的例子说明了这一点。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// CORRECTED</span></div><div class="hljs-ln-line"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Inject</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">WINDOW</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InjectionToken</span>(<span class="hljs-string">'Window'</span>);</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">_window</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>; }</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({</div><div class="hljs-ln-line">  …</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">WINDOW</span>, <span class="hljs-attr">useFactory</span>: _window }</div><div class="hljs-ln-line">  ]</div><div class="hljs-ln-line">})</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> {</div><div class="hljs-ln-line">  <span class="hljs-title function_">constructor</span> (<span class="hljs-meta">@Inject</span>(<span class="hljs-variable constant_">WINDOW</span>) <span class="hljs-keyword">private</span> <span class="hljs-attr">win</span>: <span class="hljs-title class_">Window</span>) { … }</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="7nqjqxh51rfqqmou48v1fjkt6">构造函数中的 
<code>Window</code> 类型不再是编译器的问题，因为它使用 
<code>@Inject(WINDOW)</code> 来生成注入代码。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="9haaabil5t2gk1cz0bwjsgvef">Angular 对 
<code>DOCUMENT</code> 令牌做了类似的处理，因此你可以注入浏览器的 
<code>document</code> 对象（或其抽象对象，具体取决于应用运行的平台）。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Inject</span> }   <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</div><div class="hljs-ln-line"><span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">DOCUMENT</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common'</span>;</div><div class="hljs-ln-line"></div><div class="hljs-ln-line"><span class="hljs-meta">@Component</span>({ … })</div><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> {</div><div class="hljs-ln-line">  <span class="hljs-title function_">constructor</span> (<span class="hljs-meta">@Inject</span>(<span class="hljs-variable constant_">DOCUMENT</span>) <span class="hljs-keyword">private</span> <span class="hljs-attr">doc</span>: <span class="hljs-title class_">Document</span>) { … }</div><div class="hljs-ln-line">}</div></code>
    </pre>
  </div>
  <h2 id="name-expected">
    <a href="#name-expected" class="docs-anchor" tabindex="-1" aria-label="Link to Name expected" data-ng_translator_product="100" data-ng_translator_ref_id="car89uhh3krarwl9p9uaw8sym">期望有名字（Name expected）</a>
  </h2>
  
    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="uy47gayz15tzwlohpca6fzu6"><strong>有用提示：</strong> 
<em>编译器在求值表达式时需要一个名称。</em></p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="ci084vj0h39jmgikrhjf6bzdf">如果将数字用作属性名称，则可能发生这种情况，如以下范例所示。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// ERROR</span></div><div class="hljs-ln-line"><span class="hljs-attr">provider</span>: [{ <span class="hljs-attr">provide</span>: <span class="hljs-title class_">Foo</span>, <span class="hljs-attr">useValue</span>: { <span class="hljs-number">0</span>: <span class="hljs-string">'test'</span> } }]</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="2oy2f5ul3pwf6aly2b8tj4hdw">把该属性的名字改为非数字类型。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// CORRECTED</span></div><div class="hljs-ln-line"><span class="hljs-attr">provider</span>: [{ <span class="hljs-attr">provide</span>: <span class="hljs-title class_">Foo</span>, <span class="hljs-attr">useValue</span>: { <span class="hljs-string">'0'</span>: <span class="hljs-string">'test'</span> } }]</div></code>
    </pre>
  </div>
  <h2 id="unsupported-enum-member-name">
    <a href="#unsupported-enum-member-name" class="docs-anchor" tabindex="-1" aria-label="Link to Unsupported enum member name" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="91k4pa8bmfa28ljb31gcg0w1m">不支持的枚举成员名称（Unsupported enum member name）</a>
  </h2>
  
    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="e3f8f42006r42mo2iri0toc61"><strong>有用提示：</strong> 
<em>Angular 无法确定你在元数据中引用的 <a href="https://www.typescriptlang.org/docs/handbook/enums.html" target="_blank">枚举成员</a> 的值。</em></p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="44vrhjlw85r36polyudo1x4cx">编译器可以理解简单的枚举值，但不能理解复杂的，比如从那些计算属性中派生出来的。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// ERROR</span></div><div class="hljs-ln-line"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Colors</span> {</div><div class="hljs-ln-line">  <span class="hljs-title class_">Red</span> = <span class="hljs-number">1</span>,</div><div class="hljs-ln-line">  <span class="hljs-title class_">White</span>,</div><div class="hljs-ln-line">  <span class="hljs-title class_">Blue</span> = <span class="hljs-string">"Blue"</span>.<span class="hljs-property">length</span> <span class="hljs-comment">// computed</span></div><div class="hljs-ln-line">}</div><div class="hljs-ln-line"></div><div class="hljs-ln-line">  …</div><div class="hljs-ln-line">  <span class="hljs-attr">providers</span>: [</div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">BaseColor</span>,   <span class="hljs-attr">useValue</span>: <span class="hljs-title class_">Colors</span>.<span class="hljs-property">White</span> } <span class="hljs-comment">// ok</span></div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">DangerColor</span>, <span class="hljs-attr">useValue</span>: <span class="hljs-title class_">Colors</span>.<span class="hljs-property">Red</span> }   <span class="hljs-comment">// ok</span></div><div class="hljs-ln-line">    { <span class="hljs-attr">provide</span>: <span class="hljs-title class_">StrongColor</span>, <span class="hljs-attr">useValue</span>: <span class="hljs-title class_">Colors</span>.<span class="hljs-property">Blue</span> }  <span class="hljs-comment">// bad</span></div><div class="hljs-ln-line">  ]</div><div class="hljs-ln-line">  …</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="9b6kg6vcz6z7tgibkp4qf1cpr">避免引用那些使用了复杂初始化对象或计算属性的枚举。</p>

  <h2 id="tagged-template-expressions-are-not-supported">
    <a href="#tagged-template-expressions-are-not-supported" class="docs-anchor" tabindex="-1" aria-label="Link to Tagged template expressions are not supported" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="8g7442isf97t6c4w10pzfe3so">不支持带标签的模板表达式（Tagged template expressions are not supported）</a>
  </h2>
  
    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="ahuprb16lv2dy1pmpcvajh3b3"><strong>有用提示：</strong> 
<em>元数据中不支持标记模板表达式。</em></p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_ref_id="5bdwc31hbyv7j14r0z47nsoou">编译器遇到了一个 JavaScript ES2015 
<a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals" target="_blank">标记模板表达式</a>，例如如下所示。</p>
<div class="docs-code">
    
    <pre class="docs-mini-scroll-track">      <code><div class="hljs-ln-line"><span class="hljs-comment">// ERROR</span></div><div class="hljs-ln-line"><span class="hljs-keyword">const</span> expression = <span class="hljs-string">'funky'</span>;</div><div class="hljs-ln-line"><span class="hljs-keyword">const</span> raw = <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`A tagged template <span class="hljs-subst">${expression}</span> string`</span>;</div><div class="hljs-ln-line"> …</div><div class="hljs-ln-line"> <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;'</span> + raw + <span class="hljs-string">'&lt;/div&gt;'</span></div><div class="hljs-ln-line"> …</div></code>
    </pre>
  </div><p data-ng_translator_product="100" data-ng_translator_ref_id="4peio2z1ctmy4vt2etlbxylv0"><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/raw" target="_blank"><code>String.raw()</code></a> 是 JavaScript ES2015 原生的 
<em>标记函数</em>。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="41une5bp1qaqjgdw76rhm85zx">AOT 编译器不支持带标签函数的模板表达式，避免在元数据表达式中使用它们。</p>

  <h2 id="symbol-reference-expected">
    <a href="#symbol-reference-expected" class="docs-anchor" tabindex="-1" aria-label="Link to Symbol reference expected" data-ng_translator_product="100" data-ng_translator_ref_id="15ckguihb6ocobdy4wqsag9s7">期待符号的引用（Symbol reference expected）</a>
  </h2>
  
    <div class="docs-alert docs-alert-helpful">
    <p data-ng_translator_product="100" data-ng_translator_ref_id="b8fbgr5pa2ezyh2zlcs9ixupw"><strong>有用提示：</strong> 
<em>编译器在错误信息指定的位置需要一个符号引用。</em></p>

    </div>
    <p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="dh6v9vsn475y4uq6u6buorexh">当你在类的 <code>extends</code> 子句中使用表达式时就会出现这个错误。</p>
<!--todo: Chuck: After reviewing your PR comment I'm still at a loss. See [comment there](https://github.com/angular/angular/pull/17712#discussion_r132025495). -->