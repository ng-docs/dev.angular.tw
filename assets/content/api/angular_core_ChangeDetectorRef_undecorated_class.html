<div class="api"><header class="docs-reference-header"><span class="docs-reference-category">@angular/core</span><div class="docs-reference-title"><div><h1>ChangeDetectorRef</h1><div class="docs-api-item-label" data-mode="full" data-type="undecorated_class">Class</div></div><a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/blob/main/packages/core/src/change_detection/change_detector_ref.ts#L63-L128" title="View source" aria-label="View source"><i role="presentation" aria-hidden="true" class="material-symbols-outlined">code</i></a></div><p class="docs-reference-description"></p><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="ccxhcf05bnm3isno2l815upyn">Angular 各种视图的基础类，提供变更检测功能。
变更检测树会收集要检查的所有视图。
使用这些方法从树中添加或移除视图、初始化变更检测并显式地把这些视图标记为<em>脏的</em>，意思是它们变了、需要重新渲染。</p><p></p><nav class="docs-pill-row"><a class="docs-pill" href="guide/components/lifecycle#using-change-detection-hooks" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="e8joowe7q3ufgwgkamgsvhbjw">使用变更检测钩子</a><a class="docs-pill" href="guide/components/lifecycle#defining-custom-change-detection" data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="aeske5cmve2h7h8o4yl9u3tg">自定义变更检测逻辑</a></nav></header><div data-tab="API" data-tab-url="api"><div class="docs-reference-api-tab"><div class="docs-code"><pre class="docs-mini-scroll-track"><code><div class="hljs-ln-line "><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeDetectorRef</span> {</div><button aria-describedby="jump-msg" type="button" class="hljs-ln-line " member-id="markForCheck">  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">markForCheck</span>(): <span class="hljs-built_in">void</span>;</button><button aria-describedby="jump-msg" type="button" class="hljs-ln-line " member-id="detach">  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">detach</span>(): <span class="hljs-built_in">void</span>;</button><button aria-describedby="jump-msg" type="button" class="hljs-ln-line " member-id="detectChanges">  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">detectChanges</span>(): <span class="hljs-built_in">void</span>;</button><button aria-describedby="jump-msg" type="button" class="hljs-ln-line hljs-ln-line-deprecated" member-id="checkNoChanges">  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">checkNoChanges</span>(): <span class="hljs-built_in">void</span>;</button><button aria-describedby="jump-msg" type="button" class="hljs-ln-line " member-id="reattach">  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">reattach</span>(): <span class="hljs-built_in">void</span>;</button><div class="hljs-ln-line ">}</div></code></pre></div></div></div><div data-tab="用法说明" data-tab-url="usage-notes"><div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="9jq645ywrq5w02o7oimrxsinj">下面的例子演示了如何修改默认的变更检测行为，以便在需要时执行显式变更检测。</p>
<h3 data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="f3iut46gkz9gs33izt0ocogll">使用 <code>markForCheck()</code> 和 <code>CheckOnce</code> 策略</h3>
<p data-ng_translator_product="100" data-ng_translator_ref_id="5ws34r4htcr6524utpf7v93ba">以下示例为组件设置 
<code>OnPush</code> 变更检测策略（
<code>CheckOnce</code>，而不是默认的 
<code>CheckAlways</code>），然后在间隔后强制进行第二次检查。</p>
<p><code-example path="core/ts/change_detect/change-detection.ts" region="mark-for-check"></code-example></p>
<h3 data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="at2atb0sz90zqm0nu2bnqpvok">分离开变更检测器以限制变更检测的发生频度</h3>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="b9fmlzi8jy6kmazquny1f4nfw">下面的例子定义了一个带有只读数据的大型列表，这些数据预计每秒会变化很多次。
为了提高性能，我们检测和更新列表的频率就应该比实际发生的变化少得多。
要解决这个问题，就要分离开变更检测器，并每隔五秒钟显式执行一次变更检查。</p>
<p><code-example path="core/ts/change_detect/change-detection.ts" region="detach"></code-example></p>
<h3 data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="e5xlfew2l0cv94eq24fom49xj">重新附加一个已分离的组件</h3>
<p data-ng_translator_product="100" data-ng_translator_ref_id="6cxg64nzypej0945175j1ofiz">以下示例创建一个显示实时数据的组件。当 
<code>live</code> 属性设置为 false 时，组件将其变更检测器从主变更检测器树中分离，并在属性变为 true 时重新附着。</p>
<p><code-example path="core/ts/change_detect/change-detection.ts" region="reattach"></code-example></p>
</div></div><div class="docs-reference-members-container"><div class="docs-reference-members"><div id="markForCheck" class="docs-reference-member-card" tabindex="-1"><header><div class="docs-reference-header"><h3>markForCheck</h3><div><code>void</code></div></div></header><div class="docs-reference-card-body"><div class="docs-reference-card-item "><div class="docs-function-definition"><p data-ng_translator_product="100" data-ng_translator_ref_id="8lxgtt99hrvy6715zvfc7ru5f">当一个视图使用 
<a href="api/core/ChangeDetectionStrategyOnPush "><code>ChangeDetectionStrategyOnPush </code></a>（checkOnce）变更检测策略时，会显式地将视图标记为已更改，以便可以再次检查。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="93plg3pru4hskvn8r4sak2tm1">当输入已更改或视图中发生了事件时，组件通常会标记为脏的（需要重新渲染）。调用此方法会确保即使那些触发器没有被触发，也仍然检查该组件。</p>
<!-- TODO: Add a link to a chapter on OnPush components --></div><div class="docs-return-type"><span class="docs-param-keyword">@returns</span><code>void</code></div></div></div></div><div id="detach" class="docs-reference-member-card" tabindex="-1"><header><div class="docs-reference-header"><h3>detach</h3><div><code>void</code></div></div></header><div class="docs-reference-card-body"><div class="docs-reference-card-item "><div class="docs-function-definition"><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="a05i3bq8rqn6r00ts1xirkyqr">从变更检测树中分离开视图。
已分离的视图在重新附加上去之前不会被检查。
与 <code>detectChanges()</code> 结合使用，可以实现局部变更检测。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="16sa1h9x8clcdzbrl65li8t6h">即使已分离的视图已标记为脏的，它们在重新附加上去之前也不会被检查。</p>
<!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
<!-- TODO: Add a live demo once ref.detectChanges is merged into master --></div><div class="docs-return-type"><span class="docs-param-keyword">@returns</span><code>void</code></div></div></div></div><div id="detectChanges" class="docs-reference-member-card" tabindex="-1"><header><div class="docs-reference-header"><h3>detectChanges</h3><div><code>void</code></div></div></header><div class="docs-reference-card-body"><div class="docs-reference-card-item "><div class="docs-function-definition"><p data-ng_translator_product="100" data-ng_translator_ref_id="4g2rsxppy8mc7v2zpjijj6lr2">检查此视图及其子视图。与 
<a href="api/core/ChangeDetectorRefdetach "><code>ChangeDetectorRefdetach </code></a> 结合使用，以实现局部变更检测检查。</p>
<!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
<!-- TODO: Add a live demo once ref.detectChanges is merged into master --></div><div class="docs-return-type"><span class="docs-param-keyword">@returns</span><code>void</code></div></div></div></div><div id="checkNoChanges" class="docs-reference-member-card" tabindex="-1"><header><div class="docs-reference-header"><h3>checkNoChanges</h3><div><code>void</code></div></div></header><div class="docs-reference-card-body"><div class="docs-reference-card-item docs-reference-card-item-deprecated"><div class="docs-function-definition"><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="32wevngxbqanb7kg8cuxvx7y1">检查变更检测器及其子检测器，如果检测到任何更改，则抛出异常。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="c3jozxoxehphibqhxyzttmua3">在开发模式下可用来验证正在运行的变更检测器是否引入了其它变更。在生产模式下调用它时没有任何效果。</p></div><div class="docs-return-type"><span class="docs-param-keyword">@returns</span><code>void</code></div></div></div></div><div id="reattach" class="docs-reference-member-card" tabindex="-1"><header><div class="docs-reference-header"><h3>reattach</h3><div><code>void</code></div></div></header><div class="docs-reference-card-body"><div class="docs-reference-card-item "><div class="docs-function-definition"><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="76h2kc17jby0luj8z9ueeqohe">把以前分离开的视图重新附加到变更检测树上。
视图会被默认附加到这棵树上。</p>
<!-- TODO: Add a link to a chapter on detach/reattach/local digest --></div><div class="docs-return-type"><span class="docs-param-keyword">@returns</span><code>void</code></div></div></div></div></div></div></div>