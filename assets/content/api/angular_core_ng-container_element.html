<div class="api"><header class="docs-reference-header"><span class="docs-reference-category">@angular/core</span><div class="docs-reference-title"><div><h1>ng-container</h1><div class="docs-api-item-label" data-mode="full" data-type="element">element</div></div><a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/blob/main/tools/manual_api_docs/elements/ng-container.md#L0-L0" title="View source" aria-label="View source"><i role="presentation" aria-hidden="true" class="material-symbols-outlined">code</i></a></div><p class="docs-reference-description"></p><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="cxjxek7u8i1t6h74965vl6qt5">一种特殊元素，可以在不向 DOM 添加新元素的情况下承载结构型指令。</p><p></p></header><div data-tab="说明" data-tab-url="description"><div><p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="cxjxek7u8i1t6h74965vl6qt5">一种特殊元素，可以在不向 DOM 添加新元素的情况下承载结构型指令。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="b6rukefwwngpdhmz5x4afbsov"><code>&lt;ng-container&gt;</code> 允许我们在没有任何额外元素的情况下使用结构型指令，确保应用的唯一 DOM 更改是由指令本身决定的。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="3whnvnnfx9cqstbz7ben15ojm">这不仅提高了性能（即使很微小），因为浏览器最终渲染的元素更少，而且在保持 DOM 和样式的清洁方面也是一个宝贵的资产。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="4nwyxne3g7wspkso648csl7ee">例如，它可以使我们在不破坏依赖于精确 DOM 结构的样式的情况下使用结构型指令（例如，当使用弹性容器、边距、子选择器等时）。</p>
<h2 data-ng_translator_product="100" data-ng_translator_ref_id="7n0k9ca44omk9mq238cpk3t0r">使用说明</h2>
<h3 data-ng_translator_product="100" data-ng_translator_ref_id="5r72nnl060eu94p2hf8xe1cr9">与 <code>*NgIf</code> 一起使用</h3>
<p data-ng_translator_product="100" data-ng_translator_ref_id="74jvlnyzkisqsvnpl64e6rj0d"><code>&lt;ng-container&gt;</code> 的一个常见用例是与 
<code>*ngIf</code> 结构型指令一起使用。通过使用该特殊元素，我们可以生成非常干净的模板，易于理解和使用。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="dmgmlkpk0vsne583w11zcyafr">例如，我们可能希望有一些条件显示的元素，但它们不需要都在同一个根元素下。这可以通过将它们包裹在这样的控制块中轻松实现：</p>
<code-example format="html" language="html">

<p>&lt;ng-container *ngIf="condition"&gt;
  …
&lt;/ng-container&gt;</p>
</code-example>

<p data-ng_translator_product="100" data-ng_translator_ref_id="2tbkvd8mho02mrbtj8op3pkss">这也可以与 
<code>else</code> 语句和 
<code>&lt;ng-template&gt;</code> 一起使用，像这样：</p>
<code-example format="html" language="html">

<p>&lt;ng-container *ngIf="condition; else templateA"&gt;
  …
&lt;/ng-container&gt;
&lt;ng-template #templateA&gt;
  …
&lt;/ng-template&gt;</p>
</code-example>

<h3 data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="7ffggc5ufb1qv29qpc4vqs6ac">组合使用多个结构型指令</h3>
<p data-ng_translator_product="100" data-ng_translator_ref_id="485oy3h9hmn29z3ar08fzifug">同一元素上不能使用多个结构型指令；如果需要利用多个结构型指令，建议每个结构型指令使用一个 
<code>&lt;ng-container&gt;</code>。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="4pcarkz8x5z6iu49doyckjypg">最常见的场景是 
<code>*ngIf</code> 和 
<code>*ngFor</code>。例如，假设我们有一个条目列表，但每个条目只有在满足某个条件时才会显示。我们可能会尝试这样做：</p>
<code-example format="html" language="html">

<p>&lt;ul&gt;
  &lt;li *ngFor="let item of items" *ngIf="item.isValid"&gt;
    {{ item.name }}
  &lt;/li&gt;
&lt;/ul&gt;</p>
</code-example>

<p data-ng_translator_product="100" data-ng_translator_ref_id="7m5vsn8kqjxrc5rcak26uhqz6">正如我们所说的那样，这样做是行不通的，我们可以做的是简单地将其中一个结构型指令移动到某个 
<code>&lt;ng-container&gt;</code> 元素中，然后它会包裹另一个指令，如下所示：</p>
<code-example format="html" language="html">

<p>&lt;ul&gt;
  &lt;ng-container *ngFor="let item of items"&gt;
    &lt;li *ngIf="item.isValid"&gt;
      {{ item.name }}
    &lt;/li&gt;
  &lt;/ng-container&gt;
&lt;/ul&gt;</p>
</code-example>

<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="c49o57h72jz4b6mwkvgsylisa">这会如预期般工作，但不会在 DOM 中引入任何新的不必要的元素。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="3ge1igq5fjdmox9co1nj9xynb">有关更多信息，参阅<a href="guide/structural-directives#one-per-element">每个元素只能有一个结构型指令</a>。</p>
<h3 data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="ap3kxdkjc7a2rphku5ebmkkqh">与 ngTemplateOutlet 一起使用</h3>
<p data-ng_translator_product="100" data-ng_translator_ref_id="dm1em51l0we5ksplgz3p0lazb"><code>NgTemplateOutlet</code> 指令可以应用于任何元素，但大多数情况下应用于 
<code>&lt;ng-container&gt;</code> 元素。通过将两者结合，我们可以获得非常清晰且易于遵循的 HTML 和 DOM 结构，其中不需要额外的元素，并且模板视图在需要的地方实例化。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="eco6b7vrc3w0lq9u815svlkx4">例如，想象一下我们有一个大型 HTML，其中某个小部分需要在不同的地方重复。一个简单的解决方案是定义一个包含我们重复 HTML 的 
<code>&lt;ng-template&gt;</code>，并使用 
<code>&lt;ng-container&gt;</code> 和 
<code>NgTemplateOutlet</code> 在需要的地方渲染它。</p>
<p data-ng_translator_product="100" data-ng_translator_confirmed data-ng_translator_ref_id="1dx8lddze82enpo1eydsauvw2">像这样：</p>
<code-example format="html" language="html">

<p>&lt;!-- … --&gt;</p>
<p>&lt;ng-container *ngTemplateOutlet="tmpl; context: {$implicit: 'Hello'}"&gt;
&lt;/ng-container&gt;</p>
<p>&lt;!-- … --&gt;</p>
<p>&lt;ng-container *ngTemplateOutlet="tmpl; context: {$implicit: 'World'}"&gt;
&lt;/ng-container&gt;</p>
<p>&lt;!-- … --&gt;</p>
<p>&lt;ng-template #tmpl let-text&gt;
  &lt;h1&gt;{{ text }}&lt;/h1&gt;
&lt;/ng-template&gt;</p>
</code-example>

<p data-ng_translator_product="100" data-ng_translator_ref_id="1vxuam86thacp0wpx6tke5yd6">有关 
<code>NgTemplateOutlet</code> 的更多信息，请参阅 
<a href="api/common/NgTemplateOutlet"><code>NgTemplateOutlet</code> 的 API 文档页面</a>。</p></div></div></div>