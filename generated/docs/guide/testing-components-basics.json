{"id":"guide/testing-components-basics","title":"測試元件的基礎知識","contents":"<div class=\"content\">\n  <h1 id=\"basics-of-testing-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1s9f16r2wc6phj8bf3kodn08h\">測試元件的基礎知識<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#basics-of-testing-components\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9hsxp9iw95bs3scy4ntqpbtwg\">元件與 Angular 應用的所有其它部分不同，它結合了 HTML 範本和 TypeScript 類別。事實上，元件就是由範本和類別<em>一起工作的</em>。要想對元件進行充分的測試，你應該測試它們是否如預期般協同工作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7mo0jqnepj8lt72yab1qipi64\">這些測試需要在瀏覽器 DOM 中建立該組件的宿主元素，就像 Angular 所做的那樣，然後檢查元件類別與 DOM 的互動是否如範本中描述的那樣工作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5th1ebrtj7xiyd94t1jol1g68\">Angular 的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 可以幫你做這種測試，正如你將在下面的章節中看到的那樣。但是，在很多情況下，<em>單獨測試元件類別</em>（不需要 DOM 的參與），就能以更簡單，更明顯的方式驗證元件的大部分行為。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jhe3g7pull8hzqtm08p46wf0\">如果你要試驗本指南中所講的應用，請<live-example name=\"testing\" nodownload=\"\">在瀏覽器中執行它</live-example>或<live-example name=\"testing\" downloadonly=\"\">下載並在本地執行它</live-example>。</p>\n</div>\n<p><a id=\"component-class-testing\"></a></p>\n<h2 id=\"component-class-testing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26mhq7x1mb19fody4898e6z4t\">元件類別測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#component-class-testing\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6y61bnbx1ffej8bg7z1ejaikf\">你可以像測試服務類別那樣來測試一個元件類別本身。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4j9wry43qb3nab9ae1lftlw5\">元件類別的測試應該保持非常乾淨和簡單。它應該只測試一個單元。一眼看上去，你就應該能夠理解正在測試的物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"47ms0mimli30s4p3wzodkop6d\">考慮這個 <code>LightswitchComponent</code>，當用戶單擊該按鈕時，它會開啟和關閉一個指示燈（用螢幕上的一條訊息表示）。</p>\n<code-example header=\"app/demo/demo.ts (LightswitchComp)\" path=\"testing/src/app/demo/demo.ts\" region=\"LightswitchComp\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'lightswitch-comp',\n  template: ` &lt;button type=\"button\" (click)=\"clicked()\"&gt;Click me!&lt;/button&gt;\n    &lt;span&gt;{{ message }}&lt;/span&gt;`,\n})\nexport class LightswitchComponent {\n  isOn = false;\n  clicked() {\n    this.isOn = !this.isOn;\n  }\n  get message() {\n    return `The light is ${this.isOn ? 'On' : 'Off'}`;\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d51mwvoinu32eq94rrxfe2ocu\">你可能要測試 <code>clicked()</code> 方法是否切換了燈的<em>開/關</em>狀態並正確設定了這個訊息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dj1a7vjfgpeh27vbeg9b2jukn\">這個元件類別沒有依賴。要測試這種型別的元件類別，請遵循與沒有依賴的服務相同的步驟：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1n5rdwlykyse6153qmc14keu1\">使用 new 關鍵字建立一個元件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"40ccrfc8yqxuk9ujhpw6hr5ob\">呼叫它的 API。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43e8jq71ja306uj154qrpz9ya\">對其公開狀態的期望值進行斷言。</li>\n</ol>\n<code-example header=\"app/demo/demo.spec.ts (Lightswitch tests)\" path=\"testing/src/app/demo/demo.spec.ts\" region=\"Lightswitch\">\ndescribe('LightswitchComp', () =&gt; {\n  it('#clicked() should toggle #isOn', () =&gt; {\n    const comp = new LightswitchComponent();\n    expect(comp.isOn).withContext('off at first').toBe(false);\n    comp.clicked();\n    expect(comp.isOn).withContext('on after click').toBe(true);\n    comp.clicked();\n    expect(comp.isOn).withContext('off after second click').toBe(false);\n  });\n\n  it('#clicked() should set #message to \"is on\"', () =&gt; {\n    const comp = new LightswitchComponent();\n    expect(comp.message)\n      .withContext('off at first')\n      .toMatch(/is off/i);\n    comp.clicked();\n    expect(comp.message).withContext('on after clicked').toMatch(/is on/i);\n  });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2a873c4i3s2xdl91x59rymqt\">下面是『<em>英雄之旅</em>』教學課程中的 <code>DashboardHeroComponent</code>。</p>\n<code-example header=\"app/dashboard/dashboard-hero.component.ts (component)\" path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"class\">\nexport class DashboardHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() selected = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;Hero&gt;();\n  click() {\n    this.selected.emit(this.hero);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ajd1eb1w7qeqrf7fax31vi9pz\">它出現在父元件的範本中，把一個<em>英雄</em>繫結到了 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 屬性，並監聽透過<em>所選</em><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 屬性引發的一個事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2w9vn80kgb6x0hrhk1nnevn6r\">你可以測試類別程式碼的工作方式，而無需建立 <code>DashboardHeroComponent</code> 或它的父元件。</p>\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (class tests)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"class-only\">\nit('raises the selected event when clicked', () =&gt; {\n  const comp = new DashboardHeroComponent();\n  const hero: Hero = { id: 42, name: 'Test' };\n  comp.hero = hero;\n\n  comp.selected.pipe(first()).subscribe((selectedHero: Hero) =&gt; expect(selectedHero).toBe(hero));\n  comp.click();\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"866hlzil08wdjuqd0ljn8yem6\">當元件有依賴時，你可能要使用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 來同時建立該組件及其依賴。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1rtb34ecbc7j2f8n4tpfg8w8s\">下列的 <code>WelcomeComponent</code> 依賴於 <code>UserService</code> 來了解要問候的使用者的名字。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"pg4kbvjshk6hr6fzhnxns1dk\">記得為想要測試的每個獨立元件\n<em>匯入</em>或\n<em>提供</em>。</p>\n</div>\n<code-example header=\"app/welcome/welcome.component.ts\" path=\"testing/src/app/welcome/welcome.component.ts\" region=\"class\">\nexport class WelcomeComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  welcome = '';\n  constructor(private userService: UserService) {}\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn\n      ? 'Welcome, ' + this.userService.user.name\n      : 'Please log in.';\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccfp4r32om1fgidvyc2tou2k\">你可以先建立一個能滿足本元件最低需求的 <code>UserService</code>。</p>\n<code-example header=\"app/welcome/welcome.component.spec.ts (MockUserService)\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"mock-user-service\">\nclass MockUserService {\n  isLoggedIn = true;\n  user = { name: 'Test User' };\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8210fpn915t17s5vqi8fjlxvq\">然後在 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 設定中提供並注入所有這些<strong>元件</strong>和<em>服務</em>。</p>\n<code-example header=\"app/welcome/welcome.component.spec.ts (class-only setup)\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-before-each\">\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    // provide the component-under-test and dependent service\n    providers: [WelcomeComponent, { provide: UserService, useClass: MockUserService }],\n  });\n  // inject both the component and the dependent service.\n  comp = TestBed.inject(WelcomeComponent);\n  userService = TestBed.inject(UserService);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7846jrwx151hs3jlmittzwy6\">然後，測驗元件類別，別忘了要像 Angular 執行應用時一樣<a href=\"guide/lifecycle-hooks\">呼叫生命週期鉤子方法</a>。</p>\n<code-example header=\"app/welcome/welcome.component.spec.ts (class-only tests)\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-tests\">\nit('should not have welcome message after construction', () =&gt; {\n  expect(comp.welcome).toBe('');\n});\n\nit('should welcome logged in user after Angular calls ngOnInit', () =&gt; {\n  comp.ngOnInit();\n  expect(comp.welcome).toContain(userService.user.name);\n});\n\nit('should ask user to log in if not logged in after ngOnInit', () =&gt; {\n  userService.isLoggedIn = false;\n  comp.ngOnInit();\n  expect(comp.welcome).not.toContain(userService.user.name);\n  expect(comp.welcome).toContain('log in');\n});\n\n</code-example>\n<h2 id=\"component-dom-testing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"70g2i691nvigupf7srh5fhk89\">元件 DOM 測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#component-dom-testing\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"36zjyqsn9qrin5kc223x64th4\">測試元件<em>類別</em><a href=\"guide/testing-services\">和測試服務</a>一樣簡單。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5qbkmwg82qn2bs7qg90w3we0n\">但元件不僅僅是它的類別。元件還會與 DOM 以及其他元件進行互動。<em>只對類別</em>的測試可以告訴你類別的行為。但它們無法告訴你這個元件是否能正確渲染、回應使用者輸入和手勢，或是整合到它的父元件和子元件中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6fi89fhviuu0pwx4m6wlrfc62\">以上所有<em>只對類別</em>的測試都不能回答有關元件會如何在螢幕上實際執行方面的關鍵問題。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"73w7vxvfnpp6yk1evgc1l3t7f\"><code>Lightswitch.clicked()</code> 繫結到了什麼？使用者可以呼叫它嗎？</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"axl3vwfz8cwkm3kbqyr6yeit7\"><code>Lightswitch.message</code> 是否顯示過？</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4y8rxjurpc93i1uhdh8xzd36k\">使用者能否真正選中由 <code>DashboardHeroComponent</code> 顯示的英雄？</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"77g0zx725s2lfh2ixnwcawvh0\">英雄名字是否按預期顯示的（比如大寫字母）？</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvfaj0g6zqkq76rhdzj3mxzlk\"><code>WelcomeComponent</code> 的範本是否顯示了歡迎訊息？</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cd92u27cblgx5gh3oj76us2j4\">對於上面描述的那些簡單元件來說，這些問題可能並不麻煩。但是很多元件都與範本中描述的 DOM 元素進行了複雜的互動，導致一些 HTML 會在元件狀態發生變化時出現和消失。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2xp9wkjp8ovksrnepn43991ub\">要回答這些問題，你必須建立與元件關聯的 DOM 元素，你必須檢查 DOM 以確認元件狀態是否在適當的時候正確顯示了，並且你必須模擬使用者與螢幕的互動以確定這些互動是否正確。判斷該組件的行為是否符合預期。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ppd9oamzu00goharglrfqj9x\">為了編寫這些型別的測試，你將使用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的其它屬性以及其他的測試輔助函式。</p>\n<h3 id=\"cli-generated-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ggwzep26szniu0e8orm299yt\">CLI 生成的測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#cli-generated-tests\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cs81hi4353zo6pske1n69b3t8\">當你要求 CLI 生成一個新元件時，它會預設為你建立一個初始的測試檔案。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"89e94zxyg5oz680f450ycvpi9\">比如，下列 CLI 指令會在 <code>app/banner</code> 資料夾中生成帶有行內範本和行內樣式的 <code>BannerComponent</code>：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component banner --inline-template --inline-style --module app\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"xy4shtzzakrlaoe8tjov12jb\">它還會生成一個初始測試檔案 <code>banner-external.component.spec.ts</code>，如下所示：</p>\n<code-example header=\"app/banner/banner-external.component.spec.ts (initial)\" path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v1\">\nimport { <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\n\nimport { BannerComponent } from './banner.component';\n\ndescribe('BannerComponent', () =&gt; {\n  let component: BannerComponent;\n  let fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&lt;BannerComponent&gt;;\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n    TestBed.configureTestingModule({ imports: [BannerComponent] }).compileComponents();\n  }));\n\n  beforeEach(() =&gt; {\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () =&gt; {\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e1ckicmbzs9wymz534swfuqjp\">由於 <code>compileComponents</code> 是非同步的，所以它使用從 <code>@angular/core/testing</code> 中匯入的實用工具函式 <a href=\"api/core/testing/waitForAsync\"><code>waitForAsync</code></a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"czbv5tql174rnb3d3rzcjvmbe\">欲知詳情，請參閱 <a href=\"guide/testing-components-scenarios#waitForAsync\">waitForAsync 部分。</a>。</p>\n</div>\n<h3 id=\"reduce-the-setup\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bo74wdz8ezfm08tkg4nv6wv4x\">減少設定程式碼<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#reduce-the-setup\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35fiq4uq9pjv35xg7rip3qwo4\">只有這個檔案的最後三行才是真正測試元件的，並且所有這些都斷言了 Angular 可以建立該組件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cb73anqme9w4qio8k0x1j7ijy\">該檔案的其它部分是做設定用的範本程式碼，<em>可以</em>預見，如果元件演變得更具實質性內容，就會需要更高階的測試。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ax3zhdmrntc1txk8t1j23dkpx\">下面你將學習這些高階測試屬性。現在，你可以從根本上把這個測試檔案減少到一個更容易管理的大小：</p>\n<code-example header=\"app/banner/banner-initial.component.spec.ts (minimal)\" path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v2\">\ndescribe('BannerComponent (minimal)', () =&gt; {\n  it('should create', () =&gt; {\n    TestBed.configureTestingModule({ imports: [BannerComponent] });\n    const fixture = TestBed.createComponent(BannerComponent);\n    const component = fixture.componentInstance;\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"esd9r4lur7i52hmwayhe7vixz\">在這個例子中，傳給 <code>TestBed.configureTestingModule</code> 的元資料物件只是宣告了要測試的元件 <code>BannerComponent</code>。</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"configureTestingModule\">\nTestBed.configureTestingModule({ imports: [BannerComponent] });\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"77ohya54cqt2hswayzchi1pwq\">沒有必要宣告或匯入任何其他東西。預設的測試模組預先設定了像來自 <code>@angular/platform-browser</code> 的 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 這樣的東西。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"27hcbnrfs3dd6ka7gp6twa07m\">稍後你會用 <code>imports</code>、<code>providers</code> 和更多可宣告物件的引數來呼叫 <code>TestBed.configureTestingModule()</code>，以滿足你的測試需求。可選方法 <code>override</code> 可以進一步微調此設定的各個方面。</p>\n</div>\n<p><a id=\"create-component\"></a></p>\n<h3 id=\"createcomponent\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#createcomponent\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"82vdhka1udgs1uwjueif2llg\">在設定好 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 之後，你就可以呼叫它的 <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code> 方法了。</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"createComponent\">\nconst fixture = TestBed.createComponent(BannerComponent);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6n1h6k9s648usazh7nd80o30y\"><code>TestBed.createComponent()</code> 會建立 <code>BannerComponent</code> 的實例，它把一個對應元素新增到了測試執行器的 DOM 中，並回傳一個<a href=\"guide/testing-components-basics#component-fixture\"><code>ComponentFixture</code></a> 物件。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2et46uy7zwev6z7huofxh8rb5\">呼叫 <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code> 後不能再重新設定 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cm0mpk6zcunmcvm991qo7tl98\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code> 方法會凍結當前的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 定義，並把它關閉以防止進一步的設定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3tbq9j0f70os4l92lap0t65qg\">你不能再呼叫任何 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 設定方法，無論是 <code>configureTestingModule()</code>、<code>get()</code> 還是 <code>override...</code> 方法都不行。如果你這樣做，<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 會丟擲一個錯誤。</p>\n</div>\n<p><a id=\"component-fixture\"></a></p>\n<h3 id=\"componentfixture\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#componentfixture\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dig5ymr73jnuf7e0k1qwzxf1d\"><a href=\"api/core/testing/ComponentFixture\">ComponentFixture</a> 是一個測試挽具，用於與所建立的元件及其對應的元素進行互動。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8tfo3tt1yc21309e4zsvzf1t5\">可以透過測試夾具（fixture）訪問元件實例，並用 Jasmine 的期望斷言來確認它是否存在：</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"componentInstance\">\nconst component = fixture.componentInstance;\nexpect(component).toBeDefined();\n\n</code-example>\n<h3 id=\"beforeeach\"><code>beforeEach()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#beforeeach\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6nvookuba1oyzfre1dtpyaju3\">隨著這個元件的發展，你會新增更多的測試。你不必為每個測試複製 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的設定程式碼，而是把它重構到 Jasmine 的 <code>beforeEach()</code> 和一些支援變數中：</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v3\">\ndescribe('BannerComponent (with beforeEach)', () =&gt; {\n  let component: BannerComponent;\n  let fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&lt;BannerComponent&gt;;\n\n  beforeEach(() =&gt; {\n    TestBed.configureTestingModule({ imports: [BannerComponent] });\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should create', () =&gt; {\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7143avsqkd05k0bemxhs1utw0\">現在新增一個測試程式，它從 <code>fixture.nativeElement</code> 中獲取元件的元素，並查詢預期的文字。</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-2\">\nit('should contain \"banner works!\"', () =&gt; {\n  const bannerElement: HTMLElement = fixture.nativeElement;\n  expect(bannerElement.textContent).toContain('banner works!');\n});\n\n</code-example>\n<p><a id=\"native-element\"></a></p>\n<h3 id=\"nativeelement\"><code>nativeElement</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#nativeelement\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"64lgktv8yi97sbrzw5kg7yukz\"><code><a href=\"api/core/testing/ComponentFixture#nativeElement\" class=\"code-anchor\">ComponentFixture.nativeElement</a></code> 的值是 <code>any</code> 型別的。稍後你會遇到 <code><a href=\"api/core/DebugElement#nativeElement\" class=\"code-anchor\">DebugElement.nativeElement</a></code>，它也是 <code>any</code> 型別的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6did2cp3kdy1d46zi9xuld2op\">Angular 在編譯時不知道 <code>nativeElement</code> 是什麼樣的 HTML 元素，甚至可能不是 HTML 元素。該應用可能執行在<em>非瀏覽器平台</em>（如伺服器或 <a href=\"https://developer.mozilla.org/docs/Web/API/Web_Workers_API\">Web Worker）上</a>，在那裡本元素可能具有一個縮小版的 API，甚至根本不存在。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wgfnpyhwa1uiejdlf69n0pm\">本指南中的測試都是為了在瀏覽器中執行而設計的，因此 <code>nativeElement</code> 的值始終是 <code>HTMLElement</code> 或其衍生類別之一。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92vp6ce333fjvrz61can7amzt\">知道了它是某種 <code>HTMLElement</code>，就可以用標準的 HTML <code>querySelector</code> 深入瞭解元素樹。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"687nn2akmvlqrgu5ynqsjkpk2\">這是另一個呼叫 <code>HTMLElement.querySelector</code> 來獲取段落元素並查詢橫幅文字的測試：</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-3\">\nit('should have &lt;p&gt; with \"banner works!\"', () =&gt; {\n  const bannerElement: HTMLElement = fixture.nativeElement;\n  const p = bannerElement.querySelector('p')!;\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<p><a id=\"debug-element\"></a></p>\n<h3 id=\"debugelement\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#debugelement\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5efr4jb411njcd7b8q08aocjy\">Angular 的<em>測試夾具</em>可以直接透過 <code>fixture.nativeElement</code> 提供元件的元素。</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"nativeElement\">\nconst bannerElement: HTMLElement = fixture.nativeElement;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4fgzr3iaarpttuqgv9kc04k1k\">它實際上是一個便利方法，其最終實現為 <code>fixture.debugElement.nativeElement</code>。</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"debugElement-nativeElement\">\nconst bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\nconst bannerEl: HTMLElement = bannerDe.nativeElement;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8afwu9ff9dw5styosdyhz564b\">使用這種迂迴的路徑訪問元素是有充分理由的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"er7oleoortz5bcve1tv7ha596\"><code>nativeElement</code> 的屬性依賴於其執行時環境。你可以在<em>非瀏覽器</em>平台上執行這些測試，那些平台上可能沒有 DOM，或者其模擬的 DOM 不支援完整的 <code>HTMLElement</code> API。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crgzdhlijvx88dgy8ydp938si\">Angular 依靠 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 抽象來在其支援的<em>所有平台上</em>安全地工作。Angular 不會建立 HTML 元素樹，而會建立一個 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 樹來封裝執行時平台上的<em>原生元素</em>。<code>nativeElement</code> 屬性會解開 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 並回傳特定於平台的元素物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6r6747eeb8qayewg4433v4bm2\">由於本指南的範例測試只能在瀏覽器中執行，因此 <code>nativeElement</code> 在這些測試中始終是 <code>HTMLElement</code>，你可以在測試中探索熟悉的方法和屬性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"128gs1509mvvu9rxcrpvup39b\">下面是把前述測試用 <code>fixture.debugElement.nativeElement</code> 重新實現的版本：</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-4\">\nit('should find the &lt;p&gt; with fixture.debugElement.nativeElement)', () =&gt; {\n  const bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\n  const bannerEl: HTMLElement = bannerDe.nativeElement;\n  const p = bannerEl.querySelector('p')!;\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7jhi7lu6vxgb4szl1hwixxx8l\">這些 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 還有另一些在測試中很有用的方法和屬性，你可以在本指南的其他地方看到。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1f0g1pjr8scdnha492csxbpsq\">你可以從 Angular 的 core 函式庫中匯入 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 符號。</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"import-debug-element\">\nimport { <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> } from '@angular/core';\n\n</code-example>\n<p><a id=\"by-css\"></a></p>\n<h3 id=\"bycss\"><code><a href=\"api/platform-browser/By#css\" class=\"code-anchor\">By.css()</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#bycss\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccgqecipy0wcabvdjom8cw1fa\">雖然本指南中的測試都是在瀏覽器中執行的，但有些應用可能至少要在某些時候執行在不同的平台上。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3b5e5ph4bhq5gzmvkt4rrtr9\">比如，作為最佳化策略的一部分，該組件可能會首先在服務端渲染，以便在連線不良的裝置上更快地啟動本應用。伺服器端渲染器可能不支援完整的 HTML 元素 API。如果它不支援 <code>querySelector</code>，之前的測試就會失敗。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6d8c31ievhhsflay89q96q4wx\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 提供了適用於其支援的所有平台的查詢方法。這些查詢方法接受一個<em>謂詞</em>函式，當 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 樹中的一個節點與選擇條件對應時，該函式回傳 <code>true</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"313pr0ombwhtm3nzhyek8kzjx\">你可以藉助從函式庫中為執行時平台匯入 <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 類別來建立一個<em>謂詞</em>。這裡的 <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 是從瀏覽器平台匯入的。</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"import-by\">\nimport { <a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a> } from '@angular/platform-browser';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3zujlm457ozsg31oz4zbga3e7\">下面的例子用 <code><a href=\"api/core/DebugElement#query\" class=\"code-anchor\">DebugElement.query()</a></code> 和瀏覽器的 <code>By.css</code> 方法重新實現了前面的測試。</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-5\">\nit('should find the &lt;p&gt; with fixture.debugElement.query(By.css)', () =&gt; {\n  const bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\n  const paragraphDe = bannerDe.query(By.css('p'));\n  const p: HTMLElement = paragraphDe.nativeElement;\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f1nt5wwy7nvckrhsnx387q2o0\">一些值得注意的地方：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9r1bewp7kf8xl3ognxjhoksj0\"><code><a href=\"api/platform-browser/By#css\" class=\"code-anchor\">By.css()</a></code>靜態方法使用\n<a href=\"https://developer.mozilla.org/docs/Learn/CSS/Building_blocks/Selectors\" title=\"CSS選擇器\">標準CSS選擇器</a>選擇\n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>節點。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ez7qtkq6as9vxyj2exdp49slt\">該查詢為 p 元素回傳了一個 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dyollt7kyn2tib0qmq9m44ei4\">你必須解開那個結果才能得到 p 元素。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6f5w2x9g6biuokpomso915o1c\">當你使用 CSS 選擇器進行過濾並且只測試瀏覽器<em>原生元素</em>的屬性時，用 <code>By.css</code> 方法可能會有點過度。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"tpbrnucyggwtrus72wg0qlrw\">用 <code>HTMLElement</code> 方法（比如 <code>querySelector()</code> 或 <code>querySelectorAll()</code>）進行過濾通常更簡單，更清晰。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/DebugElement\n - guide/testing\n - guide/testing-components-scenarios\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/DebugElement\n - api/core/DebugElement#nativeElement\n - api/core/DebugElement#query\n - api/core/EventEmitter\n - api/core/Input\n - api/core/OnInit\n - api/core/Output\n - api/core/createComponent\n - api/core/testing/ComponentFixture\n - api/core/testing/ComponentFixture#nativeElement\n - api/core/testing/TestBed\n - api/core/testing/waitForAsync\n - api/platform-browser/BrowserModule\n - api/platform-browser/By\n - api/platform-browser/By#css\n - guide/lifecycle-hooks\n - guide/testing-components-basics#basics-of-testing-components\n - guide/testing-components-basics#beforeeach\n - guide/testing-components-basics#bycss\n - guide/testing-components-basics#cli-generated-tests\n - guide/testing-components-basics#component-class-testing\n - guide/testing-components-basics#component-dom-testing\n - guide/testing-components-basics#component-fixture\n - guide/testing-components-basics#componentfixture\n - guide/testing-components-basics#createcomponent\n - guide/testing-components-basics#debugelement\n - guide/testing-components-basics#nativeelement\n - guide/testing-components-basics#reduce-the-setup\n - guide/testing-components-scenarios#waitForAsync\n - guide/testing-services\n - https://developer.mozilla.org/docs/Learn/CSS/Building_blocks/Selectors\n - https://developer.mozilla.org/docs/Web/API/Web_Workers_API\n-->"}