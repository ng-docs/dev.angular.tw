{"id":"guide/ngmodule-faq","title":"NgModule 常見問題解答","contents":"<div class=\"content\">\n  <h1 id=\"ngmodule-faq\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"kf4izi5x3qitgwqhu7mxeq4r\">NgModule 常見問題解答<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#ngmodule-faq\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3fb4uldhk51bkfbsjmx0k7i3\">NgModules 可以幫你把應用組織成一些緊密相關的程式碼區塊。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bpz9taadi172xl2aexxrzkez7\">這裡回答的是開發者常問起的關於 NgModule 的設計與實現問題。</p>\n<h2 id=\"what-classes-should-i-add-to-the-declarations-array\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"q3exsvks9iv8rvncl5dvzziu\">我應該把哪些類別加到 <em>declarations</em> 中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-classes-should-i-add-to-the-declarations-array\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csx13k9g53qjhpc1ora2voqwu\">把<a href=\"guide/bootstrapping#the-declarations-array\">可宣告</a>的類別（元件、指令和通道）新增到 <code>declarations</code> 清單中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"30ki5zqz2ulo664hv21dftwh1\">這些類別只能在應用程式的<em>一個並且只有一個</em>模組中宣告。只有當它們<em>從屬於</em>某個模組時，才能把在<em>此</em>模組中宣告它們。</p>\n<p><a id=\"q-declarable\"></a></p>\n<h2 id=\"what-is-a-declarable\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qz7raq4d08ykuvk6qoil7zsf\">什麼是可宣告物件（<code>declarable</code>）？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-a-declarable\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6vq8oyjfuynp37omjbguafhbt\"><em>可宣告的</em>就是元件、指令和通道這些可以被加到模組的 <code>declarations</code> 清單中的類別。它們也是<em>所有</em>能被加到 <code>declarations</code> 中的類別。</p>\n<h2 id=\"what-classes-should-i-not-add-to-declarations\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bkd6ebj6zb278gvy10l33lixo\">哪些類別<em>不</em>應該加到 <code>declarations</code> 中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-classes-should-i-not-add-to-declarations\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59fafrfr83zk6sh1frmqytzw7\">只有<a href=\"guide/bootstrapping#the-declarations-array\">可宣告的</a>類別才能加到模組的 <code>declarations</code> 清單中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63amf8hgfrdmdrd68iidaeb73\"><em>不要</em>宣告：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"15e5b5nk4grn00rxd1jbu75o6\">已經在另一個模組中宣告的類別，無論是應用程式模組、@NgModule，還是第三方模組。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a77343rm80phnkzt2omuqbc5c\">從其它模組中匯入的指令。比如，不要宣告來自 <code>@angular/forms</code> 的 FORMS_DIRECTIVES，因為 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 已經宣告過它們了。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brfx5icvv7x0vcrnc84tj3894\">模組類別。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"815a6dnctobiecpg9y3gn94qm\">服務類別。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ykf7z9wowex5yyav8ajkb582\">非 Angular 的類別和物件，比如：字串、數字、函式、實體模型、設定、業務邏輯和輔助類別。</p>\n</li>\n</ul>\n<h2 id=\"why-list-the-same-component-in-multiple-ngmodule-properties\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e258t08fosjs2omgnlf1peiiu\">為什麼要把同一個元件宣告在不同的 <em>NgModule</em> 屬性中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-list-the-same-component-in-multiple-ngmodule-properties\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29c6ac348nxw3ya54bsa276jr\"><code>AppComponent</code> 經常同時列在 <code>declarations</code> 和 <code>bootstrap</code> 中。另外你還可能看到它同時列在 <code>declarations</code> 和 <code>exports</code> 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a2qtmkkv0qj39pj98de9j3fm4\">這<em>看起來</em>是多餘的，不過這些函式具有不同的功能，從它出現在一個清單中無法推斷出它也應該在另一個清單中。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2l66ya0wfi29pai0v2sjikapu\"><code>AppComponent</code> 可能被宣告在此模組中，但可能不是引導元件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9aqaups5ut0rpbybn7cq5e45q\"><code>AppComponent</code> 可能在此模組中引導，但可能是由另一個屬性模組宣告的。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5fsdwcshy4cyq9sgytwo2gpn5\">某個元件可能是從另一個應用模組中匯入的（所以你沒法宣告它）並且被當前模組重新匯出。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2sl37ygwe5a1lhf4zzmd9khrs\">某個元件可能被匯出，以便用在外部元件的範本中，也可能同時被一個彈出式對話框載入。</li>\n</ul>\n<h2 id=\"what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3744wq1oauhi35rq6rb52a0x7\">\"<em>Can't bind to 'x' since it isn't a known property of 'y'</em>\"是什麼意思？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c4tx6pmsbwu9dm49umpn2blg3\">這個錯誤通常意味著你或者忘了宣告指令『x』，或者你沒有匯入『x』所屬的模組。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6yasvnzeguat82gtp7o62oo3r\">如果『x』其實不是屬性，或者是元件的私有屬性（比如它不帶 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 或 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 裝飾器），那麼你也同樣會遇到這個錯誤。</p>\n</div>\n<h2 id=\"what-should-i-import\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1e16cjhli11tzjn0u1x9xyhhi\">我應該匯入什麼？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-import\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eq7j83durh6vopuobe8k93cs\">匯入你需要在當前模組的元件範本中使用的那些公開的（被匯出的）<a href=\"guide/bootstrapping#the-declarations-array\">可宣告類別</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"18u5k46rd3wuuit9v5ryr9mjx\">這意味著要從 <code>@angular/common</code> 中匯入 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> 才能訪問 Angular 的內建指令，比如 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 和 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code>。你可以直接匯入它或者從<a href=\"guide/ngmodule-faq#q-reexport\">重新匯出</a>過該模組的其它模組中匯入它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"copy5teeio8zcs9w718ghm8b4\">如果你的元件有 <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 雙向繫結表示式，就要從 <code>@angular/forms</code> 中匯入 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ceebb96jrxxkiasa7cnbrr1mm\">如果當前模組中的元件包含了<em>共享</em>模組和<em>屬性</em>模組中的元件、指令和通道，就匯入這些模組。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6r55u42x2fju7dyuvev7iadjl\">只能在根模組 <code>AppModule</code> 中<a href=\"guide/ngmodule-faq#q-browser-vs-common-module\">匯入 <em>BrowserModule</em></a>。</p>\n<p><a id=\"q-browser-vs-common-module\"></a></p>\n<h2 id=\"should-i-import-browsermodule-or-commonmodule\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9u837wz2r2h61p7540rbtm3rn\">我應該匯入 <em>BrowserModule</em> 還是 <em>CommonModule</em>？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-import-browsermodule-or-commonmodule\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8k81ix1cg1zf0ifg4fmy6j2mc\">幾乎所有要在瀏覽器中使用的應用的<strong>根模組</strong>（<code>AppModule</code>）都應該從 <code>@angular/platform-browser</code> 中匯入 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ubboie4ecs6wywrh90soshdj\"><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 提供了啟動和執行瀏覽器應用的那些基本的服務提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvt7u6qyfgxqy0vrislqbu87h\"><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 還從 <code>@angular/common</code> 中重新匯出了 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>，這意味著 <code>AppModule</code> 中的元件也同樣可以訪問那些每個應用都需要的 Angular 指令，如 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 和 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cmrwgjn75wd41m8gev66rrvhf\">在其它任何模組中都<em>不要匯入</em><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>。<em>屬性模組</em>和<em>延遲載入模組</em>應該改成匯入 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>。它們需要通用的指令。它們不需要重新初始化全應用級的提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cqh2r3z2xqvyaohvimryk96yc\">屬性模組中匯入 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> 可以讓它能用在任何目標平台上，不僅是瀏覽器。那些跨平臺函式庫的作者應該喜歡這種方式的。</p>\n<p><a id=\"q-reimport\"></a></p>\n<h2 id=\"what-if-i-import-the-same-module-twice\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3gbzvrwrfearxbjg9hhfpmh4z\">如果我兩次匯入同一個模組會怎麼樣？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-if-i-import-the-same-module-twice\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"da8socz11b431clwc0yzqkwue\">沒有任何問題。當三個模組全都匯入模組'A'時，Angular 只會首次遇到時載入一次模組'A'，之後就不會這麼做了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3sh6upa9yffe5svw7a5scvt20\">無論 <code>A</code> 出現在所匯入模組的哪個層級，都會如此。如果模組'B'匯入模組'A'、模組'C'匯入模組'B'，模組'D'匯入 <code>[C, B, A]</code>，那麼'D'會觸發模組'C'的載入，'C'會觸發'B'的載入，而'B'會載入'A'。當 Angular 在'D'中想要獲取'B'和'A'時，這兩個模組已經被快取過了，可以立即使用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5mm3pwwsfrj6t98qtwalq4f2l\">Angular 不允許模組之間出現迴圈依賴，所以不要讓模組'A'匯入模組'B'，而模組'B'又匯入模組'A'。</p>\n<p><a id=\"q-reexport\"></a></p>\n<h2 id=\"what-should-i-export\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1jys2rejbf25ncvnrwfes33uc\">我應該匯出什麼？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-export\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"axq903w2uiazsgllzasxdjbb5\">匯出那些<em>其它模組</em>希望在自己的範本中引用的<a href=\"guide/bootstrapping#the-declarations-array\">可宣告類別</a>。這些也是你的<em>公共</em>類別。如果你不匯出某個類別，它就是<em>私有的</em>，只對當前模組中宣告的其它元件可見。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ckz5wj5ncz52lydhfu8nif10z\">你<em>可以</em>匯出任何可宣告類別（元件、指令和通道），而不用管它是宣告在當前模組中還是某個匯入的模組中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"781ejdqjfvkgpcsnuxddc41kq\">你<em>可以</em>重新匯出整個匯入過的模組，這將導致重新匯出它們匯出的所有類別。重新匯出的模組甚至不用先導入。</p>\n<h2 id=\"what-should-i-not-export\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7sxaz5f9dtv35g7up445xlkli\">我<em>不應該</em>匯出什麼？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-not-export\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5fe4zsjquz632od2zibqr0e3t\"><em>不要</em>匯出：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8c9xy28n81an9d1vb6xcqnbas\">那些你只想在當前模組中宣告的那些元件中使用的私有元件、指令和通道。如果你不希望任何模組看到它，就不要匯出。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wxrw7z34kkrfqd1h7fbh7ips\">不可宣告的物件，比如服務、函式、設定、實體模型等。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"algmmjn77uwkr3qoyxgulvpl4\">那些只被路由器或引導函式動態載入的元件。比如那些從來不會在其它元件的範本中出現的元件。匯出它們沒有壞處，但也沒有好處。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4dcln2h1b02u89ispfbmhd2ar\">純服務模組沒有公開（匯出）的宣告。比如，沒必要重新匯出 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，因為它不匯出任何東西。它唯一的用途是一起把 http 的那些服務提供者新增到應用中。</p>\n</li>\n</ul>\n<h2 id=\"can-i-re-export-classes-and-modules\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"buiwj8cw8viupvbm6sikuvsyw\">我可以重新匯出類別和模組嗎？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#can-i-re-export-classes-and-modules\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vo4eotcdt1sxkawzhaqaei0e\">毫無疑問。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dw35su7bzz97ucr400sz7h067\">模組是從其它模組中選取類別並把它們重新匯出成統一、便利的新模組的最佳方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dnbwzssgx8hkq5vilxyls2u8f\">模組可以重新匯出其它模組，這會導致重新匯出它們匯出的所有類別。Angular 自己的 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 就重新匯出了一組模組，比如：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nexports: [<a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/core/ApplicationModule\" class=\"code-anchor\">ApplicationModule</a>]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"w71fvfssmm57p2ifbvw5goqg\">模組還能匯出一個組合，它可以包含自己的宣告、某些匯入的類別以及匯入的模組。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eiv2oh9va5baui6qr4ede5nyn\">不要費心去匯出純服務類別。純服務類別的模組不會匯出任何可供其它模組使用的<a href=\"guide/bootstrapping#the-declarations-array\">可宣告類別</a>。比如，不用重新匯出 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，因為它沒有匯出任何東西。它唯一的用途是把那些 http 服務提供者一起新增到應用中。</p>\n<h2 id=\"what-is-the-forroot-method\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ailka1s0q96em45kmvkguv3e\"><code>forRoot()</code> 方法是什麼？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-the-forroot-method\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"etada8sj6gnpdnj5k7mu56vzg\">靜態方法 <code>forRoot()</code> 是一個約定，它可以讓開發人員更輕鬆的設定模組的想要單例使用的服務及其提供者。<code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 就是一個很好的例子。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"30d13deb2zmdbhkzeslrfeo5z\">應用把一個 <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 物件傳給 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code>，為的就是使用路由設定全應用級的 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 服務。<code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 回傳一個<a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a>物件。你把這個結果新增到根模組 <code>AppModule</code> 的 <code>imports</code> 清單中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3no3nbhumbpipna3sq4s45ufk\">只能在應用的根模組 <code>AppModule</code> 中呼叫並匯入 <code>forRoot()</code> 的結果。在其它模組，特別是延遲載入模組中，不要匯入它。要了解關於 <code>forRoot()</code> 的更多訊息，參閱<a href=\"guide/singleton-services\">單例服務</a>一章的 <a href=\"guide/singleton-services#the-forroot-pattern\">the <code>forRoot()</code> 模式</a>部分。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4p6mh79pl953skvdcxhur73y\"><strong>注意：</strong><br>\n<code>forRoot()</code> 匯入可以用於除 <code>AppModule</code> 之外的模組中。最重要的是，<code>forRoot()</code> 只應該被呼叫一次，而且匯入 <code>forRoot()</code> 的模組應該可以在根 <code>ModuleInjector</code> 中可用。\n欲知詳情，參見<a href=\"guide/hierarchical-dependency-injection#moduleinjector\">多級注入器</a>指南。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"vorscavrn82dv3lhr37qffsa\">對於服務來說，除了可以使用 <code>forRoot()</code> 外，更好的方式是在該服務的 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 裝飾器中指定 <code>providedIn: 'root'</code>，它讓該服務自動在全應用級可用，這樣它也就預設是單例的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7hfwjwzevyv3yyblm9aopsn4c\"><code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> 也提供了靜態方法 <code>forChild()</code>，用於設定延遲載入模組的路由。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2erkmskpf32s0b9xssoz3f552\"><code>forRoot()</code> 和 <code>forChild()</code> 都是約定俗成的方法名，它們分別用於在根模組和屬性模組中設定服務。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5q50e8uvvsbiktf69m23wbbjy\">當你寫類似的需要可設定的服務提供者時，請遵循這個約定。</p>\n<h2 id=\"why-is-a-service-provided-in-a-feature-module-visible-everywhere\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7x8i2uhhe6yzusbcg6lodoqyp\">為什麼服務提供者在屬性模組中的任何地方都是可見的？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-a-service-provided-in-a-feature-module-visible-everywhere\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9j8pz2fdd48x2sy9c5h8mpcdx\">列在引導模組的 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 中的服務提供者具有<strong>全應用級作用域</strong>。往 <code><a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 中新增服務提供者將導致該服務被髮布到整個應用中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8tt4suv4lgj8lb65p7x9zjetm\">當你匯入一個模組時，Angular 就會把該模組的服務提供者（也就是它的 <code>providers</code> 清單中的內容）加入該應用的<em>根注入器</em>中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zp613wqwibz4xo78dm24fusg\">這會讓該提供者對應用中所有知道該提供者令牌（token）的類別都可見。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bzgcp7w1narz6zdpyd5pcwc20\">透過 NgModule 匯入來實現可擴充套件性是 NgModule 體系的主要設計目標。把 NgModule 的提供者併入應用程式的注入器可以讓函式庫模組使用新的服務來強化應用程式變得更容易。只要新增一次 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，那麼應用中的每個元件就都可以發起 Http 請求了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4q95kvhbuys60ew3hcudw9abh\">不過，如果你期望模組的服務只對那個屬性模組內部宣告的元件可見，那麼這可能會帶來一些不受歡迎的意外。如果 <code>HeroModule</code> 提供了一個 <code>HeroService</code>，並且根模組 <code>AppModule</code> 匯入了 <code>HeroModule</code>，那麼任何知道 <code>HeroService</code><em>型別</em>的類別都可能注入該服務，而不僅是在 <code>HeroModule</code> 中宣告的那些類別。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"61xv5z9kw446i1vlfcproxu5j\">要限制對某個服務的訪問，可以考慮延遲載入提供該服務的 NgModule。參閱<a href=\"guide/ngmodule-faq#service-scope\">我要如何把服務的範圍限定為某個模組？</a>。</p>\n<p><a id=\"q-lazy-loaded-module-provider-visibility\"></a></p>\n<h2 id=\"why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8d6u7kura4lfe84h3e8wvalgh\">為什麼在延遲載入模組中宣告的服務提供者只對該模組自身可見？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8bexzr17su7zhc0eugcemu930\">和啟動時就載入的模組中的提供者不同，延遲載入模組中的提供者是<em>侷限於模組</em>的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cmdttxjscpjtx68t33ywoi5qx\">當 Angular 路由器延遲載入一個模組時，它建立了一個新的執行環境。那個環境<a href=\"guide/ngmodule-faq#q-why-child-injector\" title=\"為什麼 Angular 會建立子注入器\">擁有自己的注入器</a>，它是應用注入器的直屬子級。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7735i5x7id0zxyds8327bmcg2\">路由器把該延遲載入模組的提供者和它匯入的模組的提供者新增到這個子注入器中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2fbequmn1q9d2dv9qzrdgomtc\">這些提供者不會被擁有相同令牌的應用級別提供者的變化所影響。當路由器在延遲載入環境中建立元件時，Angular 優先使用延遲載入模組中的服務實例，而不是來自應用的根注入器的。</p>\n<h2 id=\"what-if-two-modules-provide-the-same-service\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"do3ssf799zgpo4nmoqfnoh0f5\">如果兩個模組提供了<em>同一個</em>服務會怎麼樣？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-if-two-modules-provide-the-same-service\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"by6qcb1tnswx4lhw8yia49elo\">當同時載入了兩個匯入的模組，它們都列出了使用同一個令牌的提供者時，後匯入的模組會『獲勝』，這是因為這兩個提供者都被新增到了同一個注入器中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"421l3llro1ue2it8ediw4wb6c\">當 Angular 嘗試根據令牌注入服務時，它使用第二個提供者來建立並交付服務實例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"q5hkkpdc0jgsg35m4cdz25e8\"><em>每個</em>注入了該服務的類別獲得的都是由第二個提供者建立的實例。即使是宣告在第一個模組中的類別，它取得的實例也是來自第二個提供者的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9j3zdpiepeczv9zptcdxsm0gt\">如果模組 A 提供了一個使用令牌'X'的服務，並且匯入的模組 B 也用令牌'X'提供了一個服務，那麼模組 A 中定義的服務『獲勝』了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bqb4dpedl8odmjtnooi0ng3px\">由根 <code>AppModule</code> 提供的服務相對於所匯入模組中提供的服務有優先權。換句話說：<code>AppModule</code> 總會獲勝。</p>\n<p><a id=\"service-scope\"></a></p>\n<h2 id=\"how-do-i-restrict-service-scope-to-a-module\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1q7w15pbcu1wpn79wahdcx4sz\">我應該如何把服務的範圍限制到模組中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-do-i-restrict-service-scope-to-a-module\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8odbahzsaj46y0eoxdn6pwui7\">如果一個模組在應用程式啟動時就載入，它的 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 具有<strong><em>全應用級作用域</em></strong>。它們也可用於整個應用的注入中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4qtrgca59nk6tccf5pvjrii2o\">匯入的提供者很容易被由其它匯入模組中的提供者替換掉。這雖然是故意這樣設計的，但是也可能引起意料之外的結果。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crtszw6qizuo5wxln4enl6xe2\">作為一個通用的規則，應該<em>只匯入一次</em>帶提供者的模組，最好在應用的<em>根模組</em>中。那裡也是設定、包裝和改寫這些服務的最佳位置。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2piizs62xvi01m8073tvyah9m\">假設模組需要一個定製過的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>，它為所有的 Http 請求新增一個特別的請求頭。如果應用中其它地方的另一個模組也定製了 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 或僅僅匯入了 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，它就會改寫當前模組的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 提供者，丟掉了這個特別的請求頭。這樣伺服器就會拒絕來自該模組的請求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5wbjf8jkxrrny7acm6ohn3ddu\">要消除這個問題，就只能在應用的根模組 <code>AppModule</code> 中匯入 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xa870kc62awloekk6zzids8f\">如果你必須防範這種『提供者腐化』現象，那就<em>不要依賴於『啟動時載入』模組的 <code>providers</code></em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6oz1zvjsd3fkpgqlmk0h0aprz\">只要可能，就讓模組延遲載入。Angular 給了<a href=\"guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility\">延遲載入模組</a>自己的子注入器。該模組中的提供者只對由該注入器建立的元件樹可見。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6ofjwyh7jddiv37veh0qe4h1\">如果你必須在應用程式啟動時主動載入該模組，<strong><em>就改成在元件中提供該服務</em></strong>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zb1670gnz01xvq7yr9c4koyy\">繼續看這個例子，假設某個模組的元件真的需要一個私有的、自定義的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7lqo8hkqxuu2lf0pgej8l9ime\">那就建立一個『頂層元件』來扮演該模組中所有元件的根。把這個自定義的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 提供者新增到這個頂層元件的 <code>providers</code> 清單中，而不是該模組的 <code>providers</code> 中。回憶一下，Angular 會為每個元件實例建立一個子注入器，並使用元件自己的 <code>providers</code> 來設定這個注入器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5q9lfbud1fw9bb1cr03c7rkkh\">當該元件的子元件<em>想要</em>一個 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 服務時，Angular 會提供一個區域性的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 服務，而不是應用的根注入器建立的那個。子元件將正確發起 http 請求，而不管其它模組對 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 做了什麼。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1bozk0lufm5wpgnidkfaboqbl\">確保把模組中的元件都建立成這個頂層元件的子元件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2er7pns4j00jhvo13y002vpg6\">你可以把這些子元件都嵌在頂層元件的範本中。或者，給頂層元件一個 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>，讓它作為路由的宿主。定義子路由，並讓路由器把模組中的元件載入進該路由出口（outlet）中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vwofb1tcc9bo9v7pvwq1xzoh\">雖然透過在延遲載入模組中或元件中提供某個服務來限制它的訪問都是可行的方式，但在元件中提供服務可能導致這些服務出現多個實例。因此，應該優先使用延遲載入的方式。</p>\n<p><a id=\"q-root-component-or-module\"></a></p>\n<h2 id=\"should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8j8fqi96eaqi6tvyjfar89e1\">我應該把全應用級提供者新增到根模組 <code>AppModule</code> 中還是根元件 <code>AppComponent</code> 中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b20bmnonguxkqy7rvlyxqtupk\">透過在服務的 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 裝飾器中（比如服務）指定 <code>providedIn: 'root'</code> 來定義全應用級提供者，或者 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 的構造器（比如提供令牌的地方），都可以定義全應用級提供者。透過這種方式建立的服務提供者會自動在整個應用中可用，而不用把它列在任何模組中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2uenb234hc983c6yh2ac42yb8\">如果某個提供者不能用這種方式設定（可能因為它沒有有意義的預設值），那就在根模組 <code>AppModule</code> 中註冊這些全應用級服務，而不是在 <code>AppComponent</code> 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9hghs4n9ib25khz97vcgb2cgr\">延遲載入模組及其元件可以注入 <code>AppModule</code> 中的服務，卻不能注入 <code>AppComponent</code> 中的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6g4jc5jcndny82s5ec1858w2u\"><em>只有</em>當該服務必須對 <code>AppComponent</code> 元件樹之外的元件不可見時，才應該把服務註冊進 <code>AppComponent</code> 的 <code>providers</code> 中。這是一個非常罕見的異常用法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"epi85lwd24rf57qrj2im3rb9b\">更一般地說，<a href=\"guide/ngmodule-faq#q-component-or-module\">優先把提供者註冊進模組中</a>，而不是元件中。</p>\n<h3 id=\"discussion\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e51zlya75cbuqy3o40kio43hf\">討論<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#discussion\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xiuo5idsw0ca7l7ape7cz29j\">Angular 把所有啟動期模組的提供者都註冊進了應用的根注入器中。這些服務是由根注入器中的提供者建立的，並且在整個應用中都可用。它們具有<em>應用級作用域</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5182wwhzk0dxhfxfji30o4s9w\">某些服務（比如 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>）只有當註冊進應用的根注入器時才能正常工作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ble9ah6k0jrbb1kolxdcpcd4\">相反，Angular 使用 <code>AppComponent</code> 自己的注入器註冊了 <code>AppComponent</code> 的提供者。<code>AppComponent</code> 服務只在該組件及其子元件樹中才能使用。它們具有<em>元件級作用域</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dsr3vuodwax3u2mpd1rdhezl1\"><code>AppComponent</code> 的注入器是根注入器的<em>子級</em>，注入器層次中的下一級。這對於沒有路由器的應用來說<em>幾乎是</em>整個應用了。但對那些帶路由的應用，路由操作位於頂層，那裡不存在 <code>AppComponent</code> 服務。這意味著延遲載入模組不能使用它們。</p>\n<p><a id=\"q-component-or-module\"></a></p>\n<h2 id=\"should-i-add-other-providers-to-a-module-or-a-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"10yvigwtmiry3t76v6ig5qrhu\">我應該把其它提供者註冊到模組中還是元件中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-add-other-providers-to-a-module-or-a-component\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d8c7u7i76akk70m5md1uaj1lu\">提供者應該使用 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 語法進行設定。只要可能，就應該把它們在應用的根注入器中提供（<code>providedIn: 'root'</code>）。如果它們只被延遲載入的上下文中使用，那麼這種方式設定的服務就是延遲載入的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"511y8pmgfmbyxuop7j0rdhcp1\">如果要由消費方來決定是否把它作為全應用級提供者，那麼就要在模組中（<code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>）註冊提供者，而不是元件中（<code>@Component.providers</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aun1ex6jwtmsral8ev8m9n4e9\">當你<em>必須</em>把服務實例的範圍限制到某個元件及其子元件樹時，就把提供者註冊到該組件中。指令的提供者也同樣照此處理。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brgeblsftbb346ygw7dudz8fm\">比如，如果英雄編輯元件需要自己私有的快取英雄服務實例，那就應該在本元件中註冊此服務。這樣，本元件的每個新實例都會得到一份自己的快取服務實例。編輯器的改動只會作用於它自己的服務，而不會影響到應用中其它地方的英雄實例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6chkfu57w4dz0o82a5bu741nh\"><a href=\"guide/ngmodule-faq#q-root-component-or-module\">總是在根模組 <code>AppModule</code> 中註冊<em>全應用級</em>服務</a>，而不要在根元件 <code>AppComponent</code> 中。</p>\n<p><a id=\"q-why-bad\"></a></p>\n<h2 id=\"why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6690idlmkoo75mgw93vpradyz\">為什麼在共享模組中為延遲載入模組提供服務是個餿主意？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"the-eagerly-loaded-scenario\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"axohv88mjbupeuk35fmrwzo7l\">急性載入的場景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#the-eagerly-loaded-scenario\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qzh5reetfwxhapv0ppf5lagc\">當急性載入的模組提供了服務時，比如 <code>UserService</code>，該服務是在全應用級可用的。如果根模組提供了 <code>UserService</code>，並匯入了另一個也提供了同一個 <code>UserService</code> 的模組，Angular 就會把它們中的一個註冊進應用的根注入器中（參閱<a href=\"guide/ngmodule-faq#q-reimport\">如果兩次匯入了同一個模組會怎樣？</a>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9eob5zn12k9zi2om4azrae67t\">然後，當某些元件注入 <code>UserService</code> 時，Angular 就會發現它已經在應用的根注入器中了，並交付這個全應用級的單例服務。這樣不會出現問題。</p>\n<h3 id=\"the-lazy-loaded-scenario\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5w1jx7br7jhy4m4z46mg948pp\">延遲載入場景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#the-lazy-loaded-scenario\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cd2znw82mlpmducfiz6izohvp\">現在，考慮一個延遲載入的模組，它也提供了一個名叫 <code>UserService</code> 的服務。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"et8zxyx3hw760c1b3vm4ewjgg\">當路由器準備延遲載入某個模組的時候，它會建立一個子注入器，並且把 <code>UserService</code> 的提供者註冊到那個子注入器中。子注入器和根注入器是<em>不同</em>的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehaai872834f33ihw4bgci6br\">當 Angular 建立一個延遲載入的元件並注入 <code>UserService</code> 時。這次，它會從此延遲載入模組的<em>子注入器</em>中查詢 <code>UserService</code> 的提供者，並用它建立一個 <code>UserService</code> 的新實例。這個 <code>UserService</code> 實例與 Angular 在急性載入的元件中注入的那個全應用級單例物件截然不同。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bmnkmyc6lx4jcg7twb8o75wum\">這個場景導致你的應用每次都建立一個新的服務實例，而不是使用單例的服務。</p>\n<!--todo: KW--What does this cause? I wasn't able to get the suggestion of this to work from\nthe current FAQ:\nTo demonstrate, run the <live-example name=\"ngmodule\">live example</live-example>.\nModify the `SharedModule` so that it provides the `UserService` rather than the `CoreModule`.\nThen toggle between the \"Contact\" and \"Heroes\" links a few times.\nThe username goes bonkers as the Angular creates a new `UserService` instance each time.\nI'd like to see the error so I can include it.-->\n<p><a id=\"q-why-child-injector\"></a></p>\n<h2 id=\"why-does-lazy-loading-create-a-child-injector\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4fr5cegjhii7hzy24nlj29foo\">為什麼延遲載入模組會建立一個子注入器？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-does-lazy-loading-create-a-child-injector\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4qjba4n2zh6ai12b95nfgheen\">Angular 會把 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 中的提供者新增到應用的根注入器中…… 除非該模組是延遲載入的，這種情況下，Angular 會建立一<em>子注入器</em>，並且把該模組的提供者新增到這個子注入器中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2y3dnf3zw49idfn1hhjc3oqod\">這意味著模組的行為將取決於它是在應用啟動期間載入的還是後來延遲載入的。如果疏忽了這一點，可能導致<a href=\"guide/ngmodule-faq#q-why-bad\">嚴重後果</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1t5j2yps1xc2vcvorfasc120t\">為什麼 Angular 不能像主動載入模組那樣把延遲載入模組的提供者也新增到應用程式的根注入器中呢？為什麼會出現這種不一致？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9flamf9zx2x7qu0taw5hu6ulo\">歸根結底，這來自於 Angular 依賴注入系統的一個基本特徵：在注入器還沒有被第一次使用之前，可以不斷為其新增提供者。一旦注入器已經建立和開始交付服務，它的提供者清單就被凍結了，不再接受新的提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"jk2jc9wnc4ih3xb56ecfcipp\">當應用啟動時，Angular 會首先使用所有主動載入模組中的提供者來設定根注入器，這發生在它建立第一個元件以及注入任何服務之前。一旦應用開始工作，應用的根注入器就不再接受新的提供者了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1k3gydge0qrbh7xqsz99577rl\">之後，應用邏輯開始延遲載入某個模組。Angular 必須把這個延遲載入模組中的提供者新增到<em>某個</em>注入器中。但是它無法將它們新增到應用的根注入器中，因為根注入器已經不再接受新的提供者了。於是，Angular 在延遲載入模組的上下文中建立了一個新的子注入器。</p>\n<p><a id=\"q-is-it-loaded\"></a></p>\n<h2 id=\"how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bn149kiy3hogx2qjpkwp6xbx2\">我要如何知道一個模組或服務是否已經載入過了？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gn9tgvktfpyfe0je34l7u0iw\">某些模組及其服務只能被根模組 <code>AppModule</code> 載入一次。在延遲載入模組中再次匯入這個模組會<a href=\"guide/ngmodule-faq#q-why-bad\">導致錯誤的行為</a>，這個錯誤可能非常難於檢測和診斷。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"yjltg6xqgaaengvva165h2a4\">為了防範這種風險，可以寫一個建構式函式，它會嘗試從應用的根注入器中注入該模組或服務。如果這種注入成功了，那就說明這個類別是被第二次載入的，你就可以丟擲一個錯誤，或者採取其它挽救措施。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eugu55w5devdtj8501z2pe7sn\">某些 NgModule（比如 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>）就實現了那樣一個守衛。下面是一個名叫 <code>GreetingModule</code> 的 NgModule 的 自定義建構式函式。</p>\n<code-example header=\"src/app/greeting/greeting.module.ts (Constructor)\" path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"ctor\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parentModule?: GreetingModule) {\n  if (parentModule) {\n    throw new Error(\n      'GreetingModule is already loaded. Import it in the AppModule only');\n  }\n}\n\n</code-example>\n<h2 id=\"what-kinds-of-modules-should-i-have-and-how-should-i-use-them\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6yyld2ye5n3zswpwej68mtwh\">有哪些型別的模組？我應該如何使用它們？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-kinds-of-modules-should-i-have-and-how-should-i-use-them\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7s3ueg0s15ifs2kswa8gjnw9b\">每個應用都不一樣。根據不同程度的經驗，開發者會做出不同的選擇。下列建議和指導原則廣受歡迎。</p>\n<h3 id=\"sharedmodule\"><code>SharedModule</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#sharedmodule\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ewvmki0golidh6x10g3t04cbe\">為那些可能會在應用中到處使用的元件、指令和通道建立 <code>SharedModule</code>。這種模組應該只包含 <code>declarations</code>，並且應該匯出幾乎所有 <code>declarations</code> 裡面的宣告。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43uwgxlv3pk7pk3acq4d943gq\"><code>SharedModule</code> 可以重新匯出其它小部件模組，比如 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>、<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 和提供你廣泛使用的 UI 控制元件的那些模組。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41j2qcz9gdo6k8pl6ik2bzozw\"><code>SharedModule</code><strong><em>不應該</em></strong>帶有 <code>providers</code>，原因<a href=\"guide/ngmodule-faq#q-why-bad\">在前面解釋過了</a>。它的匯入或重新匯出的模組中也不應該有 <code>providers</code>。如果你要違背這條指導原則，請務必想清楚你在做什麼，並要有充分的理由。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3sx93to3lwhibi1ttq092j950\">在任何屬性模組中（無論是你在應用啟動時主動載入的模組還是之後延遲載入的模組），你都可以隨意匯入這個 <code>SharedModule</code>。</p>\n<h3 id=\"feature-modules\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6fljutr1i4kb9wann6aj1uskb\">屬性模組<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#feature-modules\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3vorvyzb1qgpu2ljhgfd8carr\">屬性模組是你圍繞特定的應用業務領域建立的模組，比如使用者工作流、小工具集等。它們包含指定的屬性，併為你的應用提供支援，比如路由、服務、視窗部件等。要對你的應用中可能會有哪些屬性模組有個概念，考慮如果你要把與特定功能（比如搜尋）有關的檔案放進一個目錄下，該目錄的內容就可能是一個名叫 <code>SearchModule</code> 的屬性模組。它將會包含構成搜尋功能的全部元件、路由和範本。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7y54bk2ytyl4rm2l7ct2ydwms\">要了解更多，參閱<a href=\"guide/feature-modules\">屬性模組</a>和<a href=\"guide/module-types\">模組的分類</a>。</p>\n<h2 id=\"whats-the-difference-between-ngmodules-and-javascript-modules\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"61z9e97qlnd1yb5jeq5lpwdsg\">在 NgModule 和 JavaScript 模組之間有什麼不同？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#whats-the-difference-between-ngmodules-and-javascript-modules\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58ugd7lznfuwrxhwpl57b5c1v\">在 Angular 應用中，NgModule 會和 JavaScript 的模組一起工作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6dl201ve2lyndporiwf7q33jn\">在現代 JavaScript 中，每個檔案都是模組（參閱<a href=\"http://exploringjs.com/es6/ch_modules.html\">模組</a>）。在每個檔案中，你要寫一個 <code>export</code> 語句將模組的一部分公開。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7tkti2kkgop4nwy3kgyjl4kl7\">Angular 模組是一個帶有 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 裝飾器的類別，而 JavaScript 模組則沒有。Angular 的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 有自己的 <code>imports</code> 和 <code>exports</code> 來達到類似的目的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f0fcx4qh2l2cacde8fuhxekwy\">你可以<em>匯入</em>其它 NgModules，以便在當前模組的元件範本中使用它們匯出的類別。你可以<em>匯出</em>當前 NgModules 中的類別，以便<em>其它</em> NgModules 可以匯入它們，並用在自己的元件範本中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jbl4qaly3bf30ing0km2x0r\">要了解更多，參閱 <a href=\"guide/ngmodule-vs-jsmodule\">JavaScript 模組 vs. NgModules</a> 一章。</p>\n<p><a id=\"q-template-reference\"></a></p>\n<h2 id=\"how-does-angular-find-components-directives-and-pipes-in-a-template-what-is-a-template-reference\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8dv11xy1pogxw6s2i5pkip2ov\">Angular 如何查詢範本中的元件、指令和通道？什麼是 <strong>範本引用</strong> ？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-does-angular-find-components-directives-and-pipes-in-a-template-what-is-a-template-reference\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6vm6dx6d8228ksv5wkgvwdirr\"><a href=\"guide/ngmodule-faq#q-angular-compiler\">Angular 編譯器</a>在元件範本內查詢其它元件、指令和通道。一旦找到了，那就是一個『範本引用』。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dh2htgezwcf8qtyqg1itwjfd8\">Angular 編譯器透過在範本中對應元件或指令的<strong>選擇器（selector）</strong>，來查詢元件或指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"98fcekn2j3ewz68vmywbkxnmu\">編譯器透過分析範本 HTML 中的通道語法中是否出現了特定的通道名來查詢對應的通道。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4j16vpk2t7nzrpw2b9w9vjexz\">Angular 只會在當前模組中宣告過的那些類別或被當前模組匯入的模組所匯出的那些類別中對應這些選擇器和通道名。</p>\n<p><a id=\"q-angular-compiler\"></a></p>\n<h2 id=\"what-is-the-angular-compiler\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"mmd1tmgvcr0we30ml68k78xa\">什麼是 Angular 編譯器？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-the-angular-compiler\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"apa5jpwe5yhjn7rrf3fla2lg6\"><em>Angular 編譯器</em>會把你所編寫的應用程式碼轉換成高效能的 JavaScript 程式碼。在編譯過程中，<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的元資料扮演了很重要的角色。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xs2h093co9nz4j88pyo2grd5\">你寫的程式碼是無法直接執行的。比如<strong>元件</strong>。元件有一個範本，其中包含了自定義元素、屬性型指令、Angular 繫結宣告和一些顯然不屬於原生 HTML 的古怪語法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"asb0bbbhlj1tv7yw11ekor0cn\"><em>Angular 編譯器</em>讀取範本的 HTML，把它和相應的元件類別程式碼組合在一起，併產出<em>元件工廠</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"kh5rwoyvkcofb6leqnjp13jw\">元件工廠為元件建立純粹的、100% JavaScript 的表示形式，它包含了 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 元資料中描述的一切：HTML、繫結指令、附屬的樣式等。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ktidz70ep9xnfmbfztrsmwgs\">由於<strong>指令</strong>和<strong>通道</strong>都出現在元件範本中，*Angular 編譯器**也同樣會把它們組合進編譯後的元件程式碼中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7x4cnlc65uu0ehjgeippmieu5\"><code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 元資料告訴<em>Angular 編譯器</em>要為當前模組編譯哪些元件，以及如何把當前模組和其它模組連結起來。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/ngmodule-api\n - guide/providers\n - guide/singleton-services\n-->\n<!-- links from this doc:\n - api/common/CommonModule\n - api/common/NgFor\n - api/common/NgIf\n - api/common/http/HttpBackend\n - api/common/http/HttpClientModule\n - api/core/ApplicationModule\n - api/core/Component\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/ModuleWithProviders\n - api/core/NgModule\n - api/core/NgModule#providers\n - api/core/Optional\n - api/core/SkipSelf\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/BrowserModule\n - api/router/Router\n - api/router/RouterModule\n - api/router/RouterModule#forRoot\n - api/router/RouterOutlet\n - api/router/Routes\n - guide/bootstrapping#the-declarations-array\n - guide/feature-modules\n - guide/hierarchical-dependency-injection#moduleinjector\n - guide/module-types\n - guide/ngmodule-faq#can-i-re-export-classes-and-modules\n - guide/ngmodule-faq#discussion\n - guide/ngmodule-faq#feature-modules\n - guide/ngmodule-faq#how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded\n - guide/ngmodule-faq#how-do-i-restrict-service-scope-to-a-module\n - guide/ngmodule-faq#how-does-angular-find-components-directives-and-pipes-in-a-template-what-is-a-template-reference\n - guide/ngmodule-faq#ngmodule-faq\n - guide/ngmodule-faq#q-angular-compiler\n - guide/ngmodule-faq#q-browser-vs-common-module\n - guide/ngmodule-faq#q-component-or-module\n - guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility\n - guide/ngmodule-faq#q-reexport\n - guide/ngmodule-faq#q-reimport\n - guide/ngmodule-faq#q-root-component-or-module\n - guide/ngmodule-faq#q-why-bad\n - guide/ngmodule-faq#q-why-child-injector\n - guide/ngmodule-faq#service-scope\n - guide/ngmodule-faq#sharedmodule\n - guide/ngmodule-faq#should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\n - guide/ngmodule-faq#should-i-add-other-providers-to-a-module-or-a-component\n - guide/ngmodule-faq#should-i-import-browsermodule-or-commonmodule\n - guide/ngmodule-faq#the-eagerly-loaded-scenario\n - guide/ngmodule-faq#the-lazy-loaded-scenario\n - guide/ngmodule-faq#what-classes-should-i-add-to-the-declarations-array\n - guide/ngmodule-faq#what-classes-should-i-not-add-to-declarations\n - guide/ngmodule-faq#what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\n - guide/ngmodule-faq#what-if-i-import-the-same-module-twice\n - guide/ngmodule-faq#what-if-two-modules-provide-the-same-service\n - guide/ngmodule-faq#what-is-a-declarable\n - guide/ngmodule-faq#what-is-the-angular-compiler\n - guide/ngmodule-faq#what-is-the-forroot-method\n - guide/ngmodule-faq#what-kinds-of-modules-should-i-have-and-how-should-i-use-them\n - guide/ngmodule-faq#what-should-i-export\n - guide/ngmodule-faq#what-should-i-import\n - guide/ngmodule-faq#what-should-i-not-export\n - guide/ngmodule-faq#whats-the-difference-between-ngmodules-and-javascript-modules\n - guide/ngmodule-faq#why-does-lazy-loading-create-a-child-injector\n - guide/ngmodule-faq#why-is-a-service-provided-in-a-feature-module-visible-everywhere\n - guide/ngmodule-faq#why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\n - guide/ngmodule-faq#why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module\n - guide/ngmodule-faq#why-list-the-same-component-in-multiple-ngmodule-properties\n - guide/ngmodule-vs-jsmodule\n - guide/singleton-services\n - guide/singleton-services#the-forroot-pattern\n - https://exploringjs.com/es6/ch_modules.html\n-->"}