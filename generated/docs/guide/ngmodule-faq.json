{"id":"guide/ngmodule-faq","title":"NgModule 常见问题解答","contents":"<div class=\"content\">\n  <h1 id=\"ngmodule-faq\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"kf4izi5x3qitgwqhu7mxeq4r\">NgModule 常见问题解答<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#ngmodule-faq\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3fb4uldhk51bkfbsjmx0k7i3\">NgModules 可以帮你把应用组织成一些紧密相关的代码块。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bpz9taadi172xl2aexxrzkez7\">这里回答的是开发者常问起的关于 NgModule 的设计与实现问题。</p>\n<h2 id=\"what-classes-should-i-add-to-the-declarations-array\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"q3exsvks9iv8rvncl5dvzziu\">我应该把哪些类加到 <em>declarations</em> 中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-classes-should-i-add-to-the-declarations-array\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csx13k9g53qjhpc1ora2voqwu\">把<a href=\"guide/bootstrapping#the-declarations-array\">可声明</a>的类（组件、指令和管道）添加到 <code>declarations</code> 列表中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"30ki5zqz2ulo664hv21dftwh1\">这些类只能在应用程序的<em>一个并且只有一个</em>模块中声明。只有当它们<em>从属于</em>某个模块时，才能把在<em>此</em>模块中声明它们。</p>\n<p><a id=\"q-declarable\"></a></p>\n<h2 id=\"what-is-a-declarable\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qz7raq4d08ykuvk6qoil7zsf\">什么是可声明对象（<code>declarable</code>）？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-a-declarable\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6vq8oyjfuynp37omjbguafhbt\"><em>可声明的</em>就是组件、指令和管道这些可以被加到模块的 <code>declarations</code> 列表中的类。它们也是<em>所有</em>能被加到 <code>declarations</code> 中的类。</p>\n<h2 id=\"what-classes-should-i-not-add-to-declarations\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bkd6ebj6zb278gvy10l33lixo\">哪些类<em>不</em>应该加到 <code>declarations</code> 中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-classes-should-i-not-add-to-declarations\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59fafrfr83zk6sh1frmqytzw7\">只有<a href=\"guide/bootstrapping#the-declarations-array\">可声明的</a>类才能加到模块的 <code>declarations</code> 列表中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63amf8hgfrdmdrd68iidaeb73\"><em>不要</em>声明：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"15e5b5nk4grn00rxd1jbu75o6\">已经在另一个模块中声明的类，无论是应用程序模块、@NgModule，还是第三方模块。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a77343rm80phnkzt2omuqbc5c\">从其它模块中导入的指令。比如，不要声明来自 <code>@angular/forms</code> 的 FORMS_DIRECTIVES，因为 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 已经声明过它们了。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brfx5icvv7x0vcrnc84tj3894\">模块类。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"815a6dnctobiecpg9y3gn94qm\">服务类。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ykf7z9wowex5yyav8ajkb582\">非 Angular 的类和对象，比如：字符串、数字、函数、实体模型、配置、业务逻辑和辅助类。</p>\n</li>\n</ul>\n<h2 id=\"why-list-the-same-component-in-multiple-ngmodule-properties\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e258t08fosjs2omgnlf1peiiu\">为什么要把同一个组件声明在不同的 <em>NgModule</em> 属性中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-list-the-same-component-in-multiple-ngmodule-properties\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29c6ac348nxw3ya54bsa276jr\"><code>AppComponent</code> 经常同时列在 <code>declarations</code> 和 <code>bootstrap</code> 中。另外你还可能看到它同时列在 <code>declarations</code> 和 <code>exports</code> 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a2qtmkkv0qj39pj98de9j3fm4\">这<em>看起来</em>是多余的，不过这些函数具有不同的功能，从它出现在一个列表中无法推断出它也应该在另一个列表中。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2l66ya0wfi29pai0v2sjikapu\"><code>AppComponent</code> 可能被声明在此模块中，但可能不是引导组件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9aqaups5ut0rpbybn7cq5e45q\"><code>AppComponent</code> 可能在此模块中引导，但可能是由另一个特性模块声明的。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5fsdwcshy4cyq9sgytwo2gpn5\">某个组件可能是从另一个应用模块中导入的（所以你没法声明它）并且被当前模块重新导出。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2sl37ygwe5a1lhf4zzmd9khrs\">某个组件可能被导出，以便用在外部组件的模板中，也可能同时被一个弹出式对话框加载。</li>\n</ul>\n<h2 id=\"what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3744wq1oauhi35rq6rb52a0x7\">\"<em>Can't bind to 'x' since it isn't a known property of 'y'</em>\"是什么意思？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c4tx6pmsbwu9dm49umpn2blg3\">这个错误通常意味着你或者忘了声明指令“x”，或者你没有导入“x”所属的模块。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6yasvnzeguat82gtp7o62oo3r\">如果“x”其实不是属性，或者是组件的私有属性（比如它不带 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 或 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 装饰器），那么你也同样会遇到这个错误。</p>\n</div>\n<h2 id=\"what-should-i-import\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1e16cjhli11tzjn0u1x9xyhhi\">我应该导入什么？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-import\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eq7j83durh6vopuobe8k93cs\">导入你需要在当前模块的组件模板中使用的那些公开的（被导出的）<a href=\"guide/bootstrapping#the-declarations-array\">可声明类</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"18u5k46rd3wuuit9v5ryr9mjx\">这意味着要从 <code>@angular/common</code> 中导入 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> 才能访问 Angular 的内置指令，比如 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 和 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code>。你可以直接导入它或者从<a href=\"guide/ngmodule-faq#q-reexport\">重新导出</a>过该模块的其它模块中导入它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"copy5teeio8zcs9w718ghm8b4\">如果你的组件有 <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 双向绑定表达式，就要从 <code>@angular/forms</code> 中导入 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ceebb96jrxxkiasa7cnbrr1mm\">如果当前模块中的组件包含了<em>共享</em>模块和<em>特性</em>模块中的组件、指令和管道，就导入这些模块。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6r55u42x2fju7dyuvev7iadjl\">只能在根模块 <code>AppModule</code> 中<a href=\"guide/ngmodule-faq#q-browser-vs-common-module\">导入 <em>BrowserModule</em></a>。</p>\n<p><a id=\"q-browser-vs-common-module\"></a></p>\n<h2 id=\"should-i-import-browsermodule-or-commonmodule\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9u837wz2r2h61p7540rbtm3rn\">我应该导入 <em>BrowserModule</em> 还是 <em>CommonModule</em>？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-import-browsermodule-or-commonmodule\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8k81ix1cg1zf0ifg4fmy6j2mc\">几乎所有要在浏览器中使用的应用的<strong>根模块</strong>（<code>AppModule</code>）都应该从 <code>@angular/platform-browser</code> 中导入 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ubboie4ecs6wywrh90soshdj\"><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 提供了启动和运行浏览器应用的那些基本的服务提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvt7u6qyfgxqy0vrislqbu87h\"><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 还从 <code>@angular/common</code> 中重新导出了 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>，这意味着 <code>AppModule</code> 中的组件也同样可以访问那些每个应用都需要的 Angular 指令，如 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 和 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cmrwgjn75wd41m8gev66rrvhf\">在其它任何模块中都<em>不要导入</em><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>。<em>特性模块</em>和<em>惰性加载模块</em>应该改成导入 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>。它们需要通用的指令。它们不需要重新初始化全应用级的提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cqh2r3z2xqvyaohvimryk96yc\">特性模块中导入 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> 可以让它能用在任何目标平台上，不仅是浏览器。那些跨平台库的作者应该喜欢这种方式的。</p>\n<p><a id=\"q-reimport\"></a></p>\n<h2 id=\"what-if-i-import-the-same-module-twice\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3gbzvrwrfearxbjg9hhfpmh4z\">如果我两次导入同一个模块会怎么样？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-if-i-import-the-same-module-twice\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"da8socz11b431clwc0yzqkwue\">没有任何问题。当三个模块全都导入模块'A'时，Angular 只会首次遇到时加载一次模块'A'，之后就不会这么做了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3sh6upa9yffe5svw7a5scvt20\">无论 <code>A</code> 出现在所导入模块的哪个层级，都会如此。如果模块'B'导入模块'A'、模块'C'导入模块'B'，模块'D'导入 <code>[C, B, A]</code>，那么'D'会触发模块'C'的加载，'C'会触发'B'的加载，而'B'会加载'A'。当 Angular 在'D'中想要获取'B'和'A'时，这两个模块已经被缓存过了，可以立即使用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5mm3pwwsfrj6t98qtwalq4f2l\">Angular 不允许模块之间出现循环依赖，所以不要让模块'A'导入模块'B'，而模块'B'又导入模块'A'。</p>\n<p><a id=\"q-reexport\"></a></p>\n<h2 id=\"what-should-i-export\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1jys2rejbf25ncvnrwfes33uc\">我应该导出什么？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-export\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"axq903w2uiazsgllzasxdjbb5\">导出那些<em>其它模块</em>希望在自己的模板中引用的<a href=\"guide/bootstrapping#the-declarations-array\">可声明类</a>。这些也是你的<em>公共</em>类。如果你不导出某个类，它就是<em>私有的</em>，只对当前模块中声明的其它组件可见。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ckz5wj5ncz52lydhfu8nif10z\">你<em>可以</em>导出任何可声明类（组件、指令和管道），而不用管它是声明在当前模块中还是某个导入的模块中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"781ejdqjfvkgpcsnuxddc41kq\">你<em>可以</em>重新导出整个导入过的模块，这将导致重新导出它们导出的所有类。重新导出的模块甚至不用先导入。</p>\n<h2 id=\"what-should-i-not-export\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7sxaz5f9dtv35g7up445xlkli\">我<em>不应该</em>导出什么？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-not-export\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5fe4zsjquz632od2zibqr0e3t\"><em>不要</em>导出：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8c9xy28n81an9d1vb6xcqnbas\">那些你只想在当前模块中声明的那些组件中使用的私有组件、指令和管道。如果你不希望任何模块看到它，就不要导出。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wxrw7z34kkrfqd1h7fbh7ips\">不可声明的对象，比如服务、函数、配置、实体模型等。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"algmmjn77uwkr3qoyxgulvpl4\">那些只被路由器或引导函数动态加载的组件。比如那些从来不会在其它组件的模板中出现的组件。导出它们没有坏处，但也没有好处。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4dcln2h1b02u89ispfbmhd2ar\">纯服务模块没有公开（导出）的声明。比如，没必要重新导出 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，因为它不导出任何东西。它唯一的用途是一起把 http 的那些服务提供者添加到应用中。</p>\n</li>\n</ul>\n<h2 id=\"can-i-re-export-classes-and-modules\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"buiwj8cw8viupvbm6sikuvsyw\">我可以重新导出类和模块吗？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#can-i-re-export-classes-and-modules\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vo4eotcdt1sxkawzhaqaei0e\">毫无疑问。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dw35su7bzz97ucr400sz7h067\">模块是从其它模块中选取类并把它们重新导出成统一、便利的新模块的最佳方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dnbwzssgx8hkq5vilxyls2u8f\">模块可以重新导出其它模块，这会导致重新导出它们导出的所有类。Angular 自己的 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 就重新导出了一组模块，比如：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nexports: [<a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/core/ApplicationModule\" class=\"code-anchor\">ApplicationModule</a>]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"w71fvfssmm57p2ifbvw5goqg\">模块还能导出一个组合，它可以包含自己的声明、某些导入的类以及导入的模块。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eiv2oh9va5baui6qr4ede5nyn\">不要费心去导出纯服务类。纯服务类的模块不会导出任何可供其它模块使用的<a href=\"guide/bootstrapping#the-declarations-array\">可声明类</a>。比如，不用重新导出 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，因为它没有导出任何东西。它唯一的用途是把那些 http 服务提供者一起添加到应用中。</p>\n<h2 id=\"what-is-the-forroot-method\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ailka1s0q96em45kmvkguv3e\"><code>forRoot()</code> 方法是什么？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-the-forroot-method\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"etada8sj6gnpdnj5k7mu56vzg\">静态方法 <code>forRoot()</code> 是一个约定，它可以让开发人员更轻松的配置模块的想要单例使用的服务及其提供者。<code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 就是一个很好的例子。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"30d13deb2zmdbhkzeslrfeo5z\">应用把一个 <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 对象传给 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code>，为的就是使用路由配置全应用级的 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 服务。<code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 返回一个<a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a>对象。你把这个结果添加到根模块 <code>AppModule</code> 的 <code>imports</code> 列表中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3no3nbhumbpipna3sq4s45ufk\">只能在应用的根模块 <code>AppModule</code> 中调用并导入 <code>forRoot()</code> 的结果。在其它模块，特别是惰性加载模块中，不要导入它。要了解关于 <code>forRoot()</code> 的更多信息，参阅<a href=\"guide/singleton-services\">单例服务</a>一章的 <a href=\"guide/singleton-services#the-forroot-pattern\">the <code>forRoot()</code> 模式</a>部分。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4p6mh79pl953skvdcxhur73y\"><strong>注意：</strong><br>\n<code>forRoot()</code> 导入可以用于除 <code>AppModule</code> 之外的模块中。最重要的是，<code>forRoot()</code> 只应该被调用一次，而且导入 <code>forRoot()</code> 的模块应该可以在根 <code>ModuleInjector</code> 中可用。\n欲知详情，参见<a href=\"guide/hierarchical-dependency-injection#moduleinjector\">多级注入器</a>指南。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"vorscavrn82dv3lhr37qffsa\">对于服务来说，除了可以使用 <code>forRoot()</code> 外，更好的方式是在该服务的 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器中指定 <code>providedIn: 'root'</code>，它让该服务自动在全应用级可用，这样它也就默认是单例的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7hfwjwzevyv3yyblm9aopsn4c\"><code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> 也提供了静态方法 <code>forChild()</code>，用于配置惰性加载模块的路由。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2erkmskpf32s0b9xssoz3f552\"><code>forRoot()</code> 和 <code>forChild()</code> 都是约定俗成的方法名，它们分别用于在根模块和特性模块中配置服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5q50e8uvvsbiktf69m23wbbjy\">当你写类似的需要可配置的服务提供者时，请遵循这个约定。</p>\n<h2 id=\"why-is-a-service-provided-in-a-feature-module-visible-everywhere\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7x8i2uhhe6yzusbcg6lodoqyp\">为什么服务提供者在特性模块中的任何地方都是可见的？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-a-service-provided-in-a-feature-module-visible-everywhere\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9j8pz2fdd48x2sy9c5h8mpcdx\">列在引导模块的 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 中的服务提供者具有<strong>全应用级作用域</strong>。往 <code><a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 中添加服务提供者将导致该服务被发布到整个应用中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8tt4suv4lgj8lb65p7x9zjetm\">当你导入一个模块时，Angular 就会把该模块的服务提供者（也就是它的 <code>providers</code> 列表中的内容）加入该应用的<em>根注入器</em>中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zp613wqwibz4xo78dm24fusg\">这会让该提供者对应用中所有知道该提供者令牌（token）的类都可见。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bzgcp7w1narz6zdpyd5pcwc20\">通过 NgModule 导入来实现可扩展性是 NgModule 体系的主要设计目标。把 NgModule 的提供者并入应用程序的注入器可以让库模块使用新的服务来强化应用程序变得更容易。只要添加一次 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，那么应用中的每个组件就都可以发起 Http 请求了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4q95kvhbuys60ew3hcudw9abh\">不过，如果你期望模块的服务只对那个特性模块内部声明的组件可见，那么这可能会带来一些不受欢迎的意外。如果 <code>HeroModule</code> 提供了一个 <code>HeroService</code>，并且根模块 <code>AppModule</code> 导入了 <code>HeroModule</code>，那么任何知道 <code>HeroService</code><em>类型</em>的类都可能注入该服务，而不仅是在 <code>HeroModule</code> 中声明的那些类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"61xv5z9kw446i1vlfcproxu5j\">要限制对某个服务的访问，可以考虑惰性加载提供该服务的 NgModule。参阅<a href=\"guide/ngmodule-faq#service-scope\">我要如何把服务的范围限定为某个模块？</a>。</p>\n<p><a id=\"q-lazy-loaded-module-provider-visibility\"></a></p>\n<h2 id=\"why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8d6u7kura4lfe84h3e8wvalgh\">为什么在惰性加载模块中声明的服务提供者只对该模块自身可见？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8bexzr17su7zhc0eugcemu930\">和启动时就加载的模块中的提供者不同，惰性加载模块中的提供者是<em>局限于模块</em>的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cmdttxjscpjtx68t33ywoi5qx\">当 Angular 路由器惰性加载一个模块时，它创建了一个新的运行环境。那个环境<a href=\"guide/ngmodule-faq#q-why-child-injector\" title=\"为什么 Angular 会创建子注入器\">拥有自己的注入器</a>，它是应用注入器的直属子级。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7735i5x7id0zxyds8327bmcg2\">路由器把该惰性加载模块的提供者和它导入的模块的提供者添加到这个子注入器中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2fbequmn1q9d2dv9qzrdgomtc\">这些提供者不会被拥有相同令牌的应用级别提供者的变化所影响。当路由器在惰性加载环境中创建组件时，Angular 优先使用惰性加载模块中的服务实例，而不是来自应用的根注入器的。</p>\n<h2 id=\"what-if-two-modules-provide-the-same-service\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"do3ssf799zgpo4nmoqfnoh0f5\">如果两个模块提供了<em>同一个</em>服务会怎么样？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-if-two-modules-provide-the-same-service\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"by6qcb1tnswx4lhw8yia49elo\">当同时加载了两个导入的模块，它们都列出了使用同一个令牌的提供者时，后导入的模块会“获胜”，这是因为这两个提供者都被添加到了同一个注入器中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"421l3llro1ue2it8ediw4wb6c\">当 Angular 尝试根据令牌注入服务时，它使用第二个提供者来创建并交付服务实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"q5hkkpdc0jgsg35m4cdz25e8\"><em>每个</em>注入了该服务的类获得的都是由第二个提供者创建的实例。即使是声明在第一个模块中的类，它取得的实例也是来自第二个提供者的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9j3zdpiepeczv9zptcdxsm0gt\">如果模块 A 提供了一个使用令牌'X'的服务，并且导入的模块 B 也用令牌'X'提供了一个服务，那么模块 A 中定义的服务“获胜”了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bqb4dpedl8odmjtnooi0ng3px\">由根 <code>AppModule</code> 提供的服务相对于所导入模块中提供的服务有优先权。换句话说：<code>AppModule</code> 总会获胜。</p>\n<p><a id=\"service-scope\"></a></p>\n<h2 id=\"how-do-i-restrict-service-scope-to-a-module\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1q7w15pbcu1wpn79wahdcx4sz\">我应该如何把服务的范围限制到模块中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-do-i-restrict-service-scope-to-a-module\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8odbahzsaj46y0eoxdn6pwui7\">如果一个模块在应用程序启动时就加载，它的 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 具有<strong><em>全应用级作用域</em></strong>。它们也可用于整个应用的注入中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4qtrgca59nk6tccf5pvjrii2o\">导入的提供者很容易被由其它导入模块中的提供者替换掉。这虽然是故意这样设计的，但是也可能引起意料之外的结果。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crtszw6qizuo5wxln4enl6xe2\">作为一个通用的规则，应该<em>只导入一次</em>带提供者的模块，最好在应用的<em>根模块</em>中。那里也是配置、包装和改写这些服务的最佳位置。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2piizs62xvi01m8073tvyah9m\">假设模块需要一个定制过的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>，它为所有的 Http 请求添加一个特别的请求头。如果应用中其它地方的另一个模块也定制了 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 或仅仅导入了 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，它就会改写当前模块的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 提供者，丢掉了这个特别的请求头。这样服务器就会拒绝来自该模块的请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5wbjf8jkxrrny7acm6ohn3ddu\">要消除这个问题，就只能在应用的根模块 <code>AppModule</code> 中导入 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xa870kc62awloekk6zzids8f\">如果你必须防范这种“提供者腐化”现象，那就<em>不要依赖于“启动时加载”模块的 <code>providers</code></em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6oz1zvjsd3fkpgqlmk0h0aprz\">只要可能，就让模块惰性加载。Angular 给了<a href=\"guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility\">惰性加载模块</a>自己的子注入器。该模块中的提供者只对由该注入器创建的组件树可见。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6ofjwyh7jddiv37veh0qe4h1\">如果你必须在应用程序启动时主动加载该模块，<strong><em>就改成在组件中提供该服务</em></strong>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zb1670gnz01xvq7yr9c4koyy\">继续看这个例子，假设某个模块的组件真的需要一个私有的、自定义的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7lqo8hkqxuu2lf0pgej8l9ime\">那就创建一个“顶层组件”来扮演该模块中所有组件的根。把这个自定义的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 提供者添加到这个顶层组件的 <code>providers</code> 列表中，而不是该模块的 <code>providers</code> 中。回忆一下，Angular 会为每个组件实例创建一个子注入器，并使用组件自己的 <code>providers</code> 来配置这个注入器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5q9lfbud1fw9bb1cr03c7rkkh\">当该组件的子组件<em>想要</em>一个 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 服务时，Angular 会提供一个局部的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 服务，而不是应用的根注入器创建的那个。子组件将正确发起 http 请求，而不管其它模块对 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 做了什么。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1bozk0lufm5wpgnidkfaboqbl\">确保把模块中的组件都创建成这个顶层组件的子组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2er7pns4j00jhvo13y002vpg6\">你可以把这些子组件都嵌在顶层组件的模板中。或者，给顶层组件一个 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>，让它作为路由的宿主。定义子路由，并让路由器把模块中的组件加载进该路由出口（outlet）中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vwofb1tcc9bo9v7pvwq1xzoh\">虽然通过在惰性加载模块中或组件中提供某个服务来限制它的访问都是可行的方式，但在组件中提供服务可能导致这些服务出现多个实例。因此，应该优先使用惰性加载的方式。</p>\n<p><a id=\"q-root-component-or-module\"></a></p>\n<h2 id=\"should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8j8fqi96eaqi6tvyjfar89e1\">我应该把全应用级提供者添加到根模块 <code>AppModule</code> 中还是根组件 <code>AppComponent</code> 中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b20bmnonguxkqy7rvlyxqtupk\">通过在服务的 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器中（比如服务）指定 <code>providedIn: 'root'</code> 来定义全应用级提供者，或者 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 的构造器（比如提供令牌的地方），都可以定义全应用级提供者。通过这种方式创建的服务提供者会自动在整个应用中可用，而不用把它列在任何模块中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2uenb234hc983c6yh2ac42yb8\">如果某个提供者不能用这种方式配置（可能因为它没有有意义的默认值），那就在根模块 <code>AppModule</code> 中注册这些全应用级服务，而不是在 <code>AppComponent</code> 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9hghs4n9ib25khz97vcgb2cgr\">惰性加载模块及其组件可以注入 <code>AppModule</code> 中的服务，却不能注入 <code>AppComponent</code> 中的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6g4jc5jcndny82s5ec1858w2u\"><em>只有</em>当该服务必须对 <code>AppComponent</code> 组件树之外的组件不可见时，才应该把服务注册进 <code>AppComponent</code> 的 <code>providers</code> 中。这是一个非常罕见的异常用法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"epi85lwd24rf57qrj2im3rb9b\">更一般地说，<a href=\"guide/ngmodule-faq#q-component-or-module\">优先把提供者注册进模块中</a>，而不是组件中。</p>\n<h3 id=\"discussion\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e51zlya75cbuqy3o40kio43hf\">讨论<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#discussion\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xiuo5idsw0ca7l7ape7cz29j\">Angular 把所有启动期模块的提供者都注册进了应用的根注入器中。这些服务是由根注入器中的提供者创建的，并且在整个应用中都可用。它们具有<em>应用级作用域</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5182wwhzk0dxhfxfji30o4s9w\">某些服务（比如 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>）只有当注册进应用的根注入器时才能正常工作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ble9ah6k0jrbb1kolxdcpcd4\">相反，Angular 使用 <code>AppComponent</code> 自己的注入器注册了 <code>AppComponent</code> 的提供者。<code>AppComponent</code> 服务只在该组件及其子组件树中才能使用。它们具有<em>组件级作用域</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dsr3vuodwax3u2mpd1rdhezl1\"><code>AppComponent</code> 的注入器是根注入器的<em>子级</em>，注入器层次中的下一级。这对于没有路由器的应用来说<em>几乎是</em>整个应用了。但对那些带路由的应用，路由操作位于顶层，那里不存在 <code>AppComponent</code> 服务。这意味着惰性加载模块不能使用它们。</p>\n<p><a id=\"q-component-or-module\"></a></p>\n<h2 id=\"should-i-add-other-providers-to-a-module-or-a-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"10yvigwtmiry3t76v6ig5qrhu\">我应该把其它提供者注册到模块中还是组件中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-add-other-providers-to-a-module-or-a-component\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d8c7u7i76akk70m5md1uaj1lu\">提供者应该使用 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 语法进行配置。只要可能，就应该把它们在应用的根注入器中提供（<code>providedIn: 'root'</code>）。如果它们只被惰性加载的上下文中使用，那么这种方式配置的服务就是惰性加载的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"511y8pmgfmbyxuop7j0rdhcp1\">如果要由消费方来决定是否把它作为全应用级提供者，那么就要在模块中（<code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>）注册提供者，而不是组件中（<code>@Component.providers</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aun1ex6jwtmsral8ev8m9n4e9\">当你<em>必须</em>把服务实例的范围限制到某个组件及其子组件树时，就把提供者注册到该组件中。指令的提供者也同样照此处理。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brgeblsftbb346ygw7dudz8fm\">比如，如果英雄编辑组件需要自己私有的缓存英雄服务实例，那就应该在本组件中注册此服务。这样，本组件的每个新实例都会得到一份自己的缓存服务实例。编辑器的改动只会作用于它自己的服务，而不会影响到应用中其它地方的英雄实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6chkfu57w4dz0o82a5bu741nh\"><a href=\"guide/ngmodule-faq#q-root-component-or-module\">总是在根模块 <code>AppModule</code> 中注册<em>全应用级</em>服务</a>，而不要在根组件 <code>AppComponent</code> 中。</p>\n<p><a id=\"q-why-bad\"></a></p>\n<h2 id=\"why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6690idlmkoo75mgw93vpradyz\">为什么在共享模块中为惰性加载模块提供服务是个馊主意？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"the-eagerly-loaded-scenario\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"axohv88mjbupeuk35fmrwzo7l\">急性加载的场景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#the-eagerly-loaded-scenario\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qzh5reetfwxhapv0ppf5lagc\">当急性加载的模块提供了服务时，比如 <code>UserService</code>，该服务是在全应用级可用的。如果根模块提供了 <code>UserService</code>，并导入了另一个也提供了同一个 <code>UserService</code> 的模块，Angular 就会把它们中的一个注册进应用的根注入器中（参阅<a href=\"guide/ngmodule-faq#q-reimport\">如果两次导入了同一个模块会怎样？</a>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9eob5zn12k9zi2om4azrae67t\">然后，当某些组件注入 <code>UserService</code> 时，Angular 就会发现它已经在应用的根注入器中了，并交付这个全应用级的单例服务。这样不会出现问题。</p>\n<h3 id=\"the-lazy-loaded-scenario\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5w1jx7br7jhy4m4z46mg948pp\">惰性加载场景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#the-lazy-loaded-scenario\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cd2znw82mlpmducfiz6izohvp\">现在，考虑一个惰性加载的模块，它也提供了一个名叫 <code>UserService</code> 的服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"et8zxyx3hw760c1b3vm4ewjgg\">当路由器准备惰性加载某个模块的时候，它会创建一个子注入器，并且把 <code>UserService</code> 的提供者注册到那个子注入器中。子注入器和根注入器是<em>不同</em>的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehaai872834f33ihw4bgci6br\">当 Angular 创建一个惰性加载的组件并注入 <code>UserService</code> 时。这次，它会从此惰性加载模块的<em>子注入器</em>中查找 <code>UserService</code> 的提供者，并用它创建一个 <code>UserService</code> 的新实例。这个 <code>UserService</code> 实例与 Angular 在急性加载的组件中注入的那个全应用级单例对象截然不同。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bmnkmyc6lx4jcg7twb8o75wum\">这个场景导致你的应用每次都创建一个新的服务实例，而不是使用单例的服务。</p>\n<!--todo: KW--What does this cause? I wasn't able to get the suggestion of this to work from\nthe current FAQ:\nTo demonstrate, run the <live-example name=\"ngmodule\">live example</live-example>.\nModify the `SharedModule` so that it provides the `UserService` rather than the `CoreModule`.\nThen toggle between the \"Contact\" and \"Heroes\" links a few times.\nThe username goes bonkers as the Angular creates a new `UserService` instance each time.\nI'd like to see the error so I can include it.-->\n<p><a id=\"q-why-child-injector\"></a></p>\n<h2 id=\"why-does-lazy-loading-create-a-child-injector\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4fr5cegjhii7hzy24nlj29foo\">为什么惰性加载模块会创建一个子注入器？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-does-lazy-loading-create-a-child-injector\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4qjba4n2zh6ai12b95nfgheen\">Angular 会把 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 中的提供者添加到应用的根注入器中…… 除非该模块是惰性加载的，这种情况下，Angular 会创建一<em>子注入器</em>，并且把该模块的提供者添加到这个子注入器中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2y3dnf3zw49idfn1hhjc3oqod\">这意味着模块的行为将取决于它是在应用启动期间加载的还是后来惰性加载的。如果疏忽了这一点，可能导致<a href=\"guide/ngmodule-faq#q-why-bad\">严重后果</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1t5j2yps1xc2vcvorfasc120t\">为什么 Angular 不能像主动加载模块那样把惰性加载模块的提供者也添加到应用程序的根注入器中呢？为什么会出现这种不一致？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9flamf9zx2x7qu0taw5hu6ulo\">归根结底，这来自于 Angular 依赖注入系统的一个基本特征：在注入器还没有被第一次使用之前，可以不断为其添加提供者。一旦注入器已经创建和开始交付服务，它的提供者列表就被冻结了，不再接受新的提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"jk2jc9wnc4ih3xb56ecfcipp\">当应用启动时，Angular 会首先使用所有主动加载模块中的提供者来配置根注入器，这发生在它创建第一个组件以及注入任何服务之前。一旦应用开始工作，应用的根注入器就不再接受新的提供者了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1k3gydge0qrbh7xqsz99577rl\">之后，应用逻辑开始惰性加载某个模块。Angular 必须把这个惰性加载模块中的提供者添加到<em>某个</em>注入器中。但是它无法将它们添加到应用的根注入器中，因为根注入器已经不再接受新的提供者了。于是，Angular 在惰性加载模块的上下文中创建了一个新的子注入器。</p>\n<p><a id=\"q-is-it-loaded\"></a></p>\n<h2 id=\"how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bn149kiy3hogx2qjpkwp6xbx2\">我要如何知道一个模块或服务是否已经加载过了？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gn9tgvktfpyfe0je34l7u0iw\">某些模块及其服务只能被根模块 <code>AppModule</code> 加载一次。在惰性加载模块中再次导入这个模块会<a href=\"guide/ngmodule-faq#q-why-bad\">导致错误的行为</a>，这个错误可能非常难于检测和诊断。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"yjltg6xqgaaengvva165h2a4\">为了防范这种风险，可以写一个构造函数，它会尝试从应用的根注入器中注入该模块或服务。如果这种注入成功了，那就说明这个类是被第二次加载的，你就可以抛出一个错误，或者采取其它挽救措施。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eugu55w5devdtj8501z2pe7sn\">某些 NgModule（比如 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>）就实现了那样一个守卫。下面是一个名叫 <code>GreetingModule</code> 的 NgModule 的 自定义构造函数。</p>\n<code-example header=\"src/app/greeting/greeting.module.ts (Constructor)\" path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"ctor\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parentModule?: GreetingModule) {\n  if (parentModule) {\n    throw new Error(\n      'GreetingModule is already loaded. Import it in the AppModule only');\n  }\n}\n\n</code-example>\n<h2 id=\"what-kinds-of-modules-should-i-have-and-how-should-i-use-them\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6yyld2ye5n3zswpwej68mtwh\">有哪些类型的模块？我应该如何使用它们？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-kinds-of-modules-should-i-have-and-how-should-i-use-them\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7s3ueg0s15ifs2kswa8gjnw9b\">每个应用都不一样。根据不同程度的经验，开发者会做出不同的选择。下列建议和指导原则广受欢迎。</p>\n<h3 id=\"sharedmodule\"><code>SharedModule</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#sharedmodule\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ewvmki0golidh6x10g3t04cbe\">为那些可能会在应用中到处使用的组件、指令和管道创建 <code>SharedModule</code>。这种模块应该只包含 <code>declarations</code>，并且应该导出几乎所有 <code>declarations</code> 里面的声明。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43uwgxlv3pk7pk3acq4d943gq\"><code>SharedModule</code> 可以重新导出其它小部件模块，比如 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>、<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 和提供你广泛使用的 UI 控件的那些模块。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41j2qcz9gdo6k8pl6ik2bzozw\"><code>SharedModule</code><strong><em>不应该</em></strong>带有 <code>providers</code>，原因<a href=\"guide/ngmodule-faq#q-why-bad\">在前面解释过了</a>。它的导入或重新导出的模块中也不应该有 <code>providers</code>。如果你要违背这条指导原则，请务必想清楚你在做什么，并要有充分的理由。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3sx93to3lwhibi1ttq092j950\">在任何特性模块中（无论是你在应用启动时主动加载的模块还是之后惰性加载的模块），你都可以随意导入这个 <code>SharedModule</code>。</p>\n<h3 id=\"feature-modules\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6fljutr1i4kb9wann6aj1uskb\">特性模块<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#feature-modules\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3vorvyzb1qgpu2ljhgfd8carr\">特性模块是你围绕特定的应用业务领域创建的模块，比如用户工作流、小工具集等。它们包含指定的特性，并为你的应用提供支持，比如路由、服务、窗口部件等。要对你的应用中可能会有哪些特性模块有个概念，考虑如果你要把与特定功能（比如搜索）有关的文件放进一个目录下，该目录的内容就可能是一个名叫 <code>SearchModule</code> 的特性模块。它将会包含构成搜索功能的全部组件、路由和模板。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7y54bk2ytyl4rm2l7ct2ydwms\">要了解更多，参阅<a href=\"guide/feature-modules\">特性模块</a>和<a href=\"guide/module-types\">模块的分类</a>。</p>\n<h2 id=\"whats-the-difference-between-ngmodules-and-javascript-modules\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"61z9e97qlnd1yb5jeq5lpwdsg\">在 NgModule 和 JavaScript 模块之间有什么不同？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#whats-the-difference-between-ngmodules-and-javascript-modules\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58ugd7lznfuwrxhwpl57b5c1v\">在 Angular 应用中，NgModule 会和 JavaScript 的模块一起工作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6dl201ve2lyndporiwf7q33jn\">在现代 JavaScript 中，每个文件都是模块（参阅<a href=\"http://exploringjs.com/es6/ch_modules.html\">模块</a>）。在每个文件中，你要写一个 <code>export</code> 语句将模块的一部分公开。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7tkti2kkgop4nwy3kgyjl4kl7\">Angular 模块是一个带有 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 装饰器的类，而 JavaScript 模块则没有。Angular 的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 有自己的 <code>imports</code> 和 <code>exports</code> 来达到类似的目的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f0fcx4qh2l2cacde8fuhxekwy\">你可以<em>导入</em>其它 NgModules，以便在当前模块的组件模板中使用它们导出的类。你可以<em>导出</em>当前 NgModules 中的类，以便<em>其它</em> NgModules 可以导入它们，并用在自己的组件模板中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jbl4qaly3bf30ing0km2x0r\">要了解更多，参阅 <a href=\"guide/ngmodule-vs-jsmodule\">JavaScript 模块 vs. NgModules</a> 一章。</p>\n<p><a id=\"q-template-reference\"></a></p>\n<h2 id=\"how-does-angular-find-components-directives-and-pipes-in-a-template-what-is-a-template-reference\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8dv11xy1pogxw6s2i5pkip2ov\">Angular 如何查找模板中的组件、指令和管道？什么是 <strong>模板引用</strong> ？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-does-angular-find-components-directives-and-pipes-in-a-template-what-is-a-template-reference\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6vm6dx6d8228ksv5wkgvwdirr\"><a href=\"guide/ngmodule-faq#q-angular-compiler\">Angular 编译器</a>在组件模板内查找其它组件、指令和管道。一旦找到了，那就是一个“模板引用”。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dh2htgezwcf8qtyqg1itwjfd8\">Angular 编译器通过在模板中匹配组件或指令的<strong>选择器（selector）</strong>，来查找组件或指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"98fcekn2j3ewz68vmywbkxnmu\">编译器通过分析模板 HTML 中的管道语法中是否出现了特定的管道名来查找对应的管道。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4j16vpk2t7nzrpw2b9w9vjexz\">Angular 只会在当前模块中声明过的那些类或被当前模块导入的模块所导出的那些类中匹配这些选择器和管道名。</p>\n<p><a id=\"q-angular-compiler\"></a></p>\n<h2 id=\"what-is-the-angular-compiler\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"mmd1tmgvcr0we30ml68k78xa\">什么是 Angular 编译器？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-the-angular-compiler\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"apa5jpwe5yhjn7rrf3fla2lg6\"><em>Angular 编译器</em>会把你所编写的应用代码转换成高性能的 JavaScript 代码。在编译过程中，<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的元数据扮演了很重要的角色。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xs2h093co9nz4j88pyo2grd5\">你写的代码是无法直接执行的。比如<strong>组件</strong>。组件有一个模板，其中包含了自定义元素、属性型指令、Angular 绑定声明和一些显然不属于原生 HTML 的古怪语法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"asb0bbbhlj1tv7yw11ekor0cn\"><em>Angular 编译器</em>读取模板的 HTML，把它和相应的组件类代码组合在一起，并产出<em>组件工厂</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"kh5rwoyvkcofb6leqnjp13jw\">组件工厂为组件创建纯粹的、100% JavaScript 的表示形式，它包含了 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 元数据中描述的一切：HTML、绑定指令、附属的样式等。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ktidz70ep9xnfmbfztrsmwgs\">由于<strong>指令</strong>和<strong>管道</strong>都出现在组件模板中，*Angular 编译器**也同样会把它们组合进编译后的组件代码中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7x4cnlc65uu0ehjgeippmieu5\"><code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 元数据告诉<em>Angular 编译器</em>要为当前模块编译哪些组件，以及如何把当前模块和其它模块链接起来。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/ngmodule-api\n - guide/providers\n - guide/singleton-services\n-->\n<!-- links from this doc:\n - api/common/CommonModule\n - api/common/NgFor\n - api/common/NgIf\n - api/common/http/HttpBackend\n - api/common/http/HttpClientModule\n - api/core/ApplicationModule\n - api/core/Component\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/ModuleWithProviders\n - api/core/NgModule\n - api/core/NgModule#providers\n - api/core/Optional\n - api/core/SkipSelf\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/BrowserModule\n - api/router/Router\n - api/router/RouterModule\n - api/router/RouterModule#forRoot\n - api/router/RouterOutlet\n - api/router/Routes\n - guide/bootstrapping#the-declarations-array\n - guide/feature-modules\n - guide/hierarchical-dependency-injection#moduleinjector\n - guide/module-types\n - guide/ngmodule-faq#can-i-re-export-classes-and-modules\n - guide/ngmodule-faq#discussion\n - guide/ngmodule-faq#feature-modules\n - guide/ngmodule-faq#how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded\n - guide/ngmodule-faq#how-do-i-restrict-service-scope-to-a-module\n - guide/ngmodule-faq#how-does-angular-find-components-directives-and-pipes-in-a-template-what-is-a-template-reference\n - guide/ngmodule-faq#ngmodule-faq\n - guide/ngmodule-faq#q-angular-compiler\n - guide/ngmodule-faq#q-browser-vs-common-module\n - guide/ngmodule-faq#q-component-or-module\n - guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility\n - guide/ngmodule-faq#q-reexport\n - guide/ngmodule-faq#q-reimport\n - guide/ngmodule-faq#q-root-component-or-module\n - guide/ngmodule-faq#q-why-bad\n - guide/ngmodule-faq#q-why-child-injector\n - guide/ngmodule-faq#service-scope\n - guide/ngmodule-faq#sharedmodule\n - guide/ngmodule-faq#should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\n - guide/ngmodule-faq#should-i-add-other-providers-to-a-module-or-a-component\n - guide/ngmodule-faq#should-i-import-browsermodule-or-commonmodule\n - guide/ngmodule-faq#the-eagerly-loaded-scenario\n - guide/ngmodule-faq#the-lazy-loaded-scenario\n - guide/ngmodule-faq#what-classes-should-i-add-to-the-declarations-array\n - guide/ngmodule-faq#what-classes-should-i-not-add-to-declarations\n - guide/ngmodule-faq#what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\n - guide/ngmodule-faq#what-if-i-import-the-same-module-twice\n - guide/ngmodule-faq#what-if-two-modules-provide-the-same-service\n - guide/ngmodule-faq#what-is-a-declarable\n - guide/ngmodule-faq#what-is-the-angular-compiler\n - guide/ngmodule-faq#what-is-the-forroot-method\n - guide/ngmodule-faq#what-kinds-of-modules-should-i-have-and-how-should-i-use-them\n - guide/ngmodule-faq#what-should-i-export\n - guide/ngmodule-faq#what-should-i-import\n - guide/ngmodule-faq#what-should-i-not-export\n - guide/ngmodule-faq#whats-the-difference-between-ngmodules-and-javascript-modules\n - guide/ngmodule-faq#why-does-lazy-loading-create-a-child-injector\n - guide/ngmodule-faq#why-is-a-service-provided-in-a-feature-module-visible-everywhere\n - guide/ngmodule-faq#why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\n - guide/ngmodule-faq#why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module\n - guide/ngmodule-faq#why-list-the-same-component-in-multiple-ngmodule-properties\n - guide/ngmodule-vs-jsmodule\n - guide/singleton-services\n - guide/singleton-services#the-forroot-pattern\n - https://exploringjs.com/es6/ch_modules.html\n-->"}