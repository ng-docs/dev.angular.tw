{"id":"guide/http-request-data-from-server","title":"HTTP：從伺服器請求資料","contents":"<div class=\"content\">\n  <h1 id=\"http-request-data-from-a-server\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8v2ol3mkrsomdd15kuk18lfqc\">HTTP：從伺服器請求資料<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-request-data-from-server#http-request-data-from-a-server\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7mxy98pvphbio5quia8ydks5c\">使用\n<a href=\"api/common/http/HttpClient#get\"><code>HttpClient.get()</code></a>方法從伺服器獲取資料。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2a8ivevcjvln7a2plafzn0wmf\">這個非同步方法傳送一個HTTP請求，並在接收到回應時回傳一個\n<a href=\"guide/observables-in-angular\">Observable</a>，以發出請求的資料。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8thpbgce8nnsmqx5mgwkvfakk\">`get(url, options)` 方法接受兩個引數：要獲取的字串端點 URL，以及可選的設定請求的物件。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  headers?: <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a> | {[header: string]: string | string[]},\n  observe?: 'body' | 'events' | 'response',\n  params?: <a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a>|{[param: string]: string | number | boolean | ReadonlyArray&lt;string | number | boolean&gt;},\n  reportProgress?: boolean,\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  withCredentials?: boolean,\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6gnfyfqlgzdzt8qbnoy82r276\">這些重要的選項包括 <em>observe</em> 和 <em>responseType</em> 屬性。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3liy686p15pg85we3xy31lzj\"><em>observe</em> 選項用於指定要回傳的回應內容。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8rhfig2l4dldxgd62su9kxr8k\">`responseType` 選項指定回傳資料的期望格式。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6qxio9pv3o6itn5jadg5n50b5\">要更好地理解 `observe` 和 `responseType` 選項型別，請檢視下面的連結。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ewbie7vv6vw52vehuoye7mfv\">使用 <code>options</code> 物件來設定外發請求的其他方面。例如，在新增標頭訊息時，此服務會使用 <code>headers</code> 選項的屬性來設定預設頭訊息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d0nb21sd39kbmffze9f2gi7gl\">使用 <code>params</code> 屬性來設定帶有 HTTP URL 引數的請求，使用 <code>reportProgress</code> 選項來監聽傳輸大量資料時的進度事件。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2067w6sicuum77gf96p6j5spx\">應用經常會從伺服器請求 JSON 資料。在 <code>ConfigService</code> 例子中，該應用需要伺服器 <code>config.json</code> 上的一個設定檔案來指定資源的 URL。</p>\n<code-example header=\"assets/config.json\" path=\"http/src/assets/config.json\">\n{\n  \"heroesUrl\": \"api/heroes\",\n  \"textfile\": \"assets/textfile.txt\",\n  \"date\": \"2020-01-29\"\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"alnqqiiwkodvdk9xkieoup7ci\">要獲取這種型別的資料，`get()` 呼叫需要以下選項：`{observe: 'body', responseType: 'json'}`。 這些是這些選項的預設值，因此大多數 `get()` 呼叫 - 以及後續的大多數範例 - 不會傳遞選項物件。 後續章節展示了一些其他選項的可能性。</p>\n<p><a id=\"config-service\"></a></p>\n<h3 id=\"handle-data-access-in-a-service-class\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6p3xd5jhc2y81ms0vswj4rx1h\">在服務類別中處理資料訪問<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-request-data-from-server#handle-data-access-in-a-service-class\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"81cffn07hiiyqx5iu519lzwgy\">該範例符合透過將資料訪問功能隔離到可重用的可注入服務中，與元件分離的可維護解決方案的最佳實踐。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8vz03wb2e834oqmfk8do9j445\">`ConfigService` 使用 `HttpClient.get()` 方法獲取 JSON 檔案。</p>\n<code-example header=\"app/config/config.service.ts (getConfig v.1)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_1\">\nconfigUrl = 'assets/config.json';\n\ngetConfig() {\n  return this.http.get&lt;Config&gt;(this.configUrl);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5bvo9zjsrsezvkmlo0btiqhil\">請注意，呼叫了 `get`。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"chgu9pa1to9f4i8w72poahcgm\">沒有傳遞一個選項值，因為伺服器端點回傳 JSON，並且 JSON 是預設資料格式。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6fh9y76cek84x93fs92xd3q1s\">傳遞了一個通用的 `Config`，表示資料回傳型別；你很快將會瞭解原因。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2bol1ak621ar08ga67kp4g6ux\">除了獲取資料，服務還可以對資料進行後處理，新增錯誤處理，並新增重試邏輯。</p>\n<h3 id=\"present-the-data-in-the-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"buo32jv14xx5ibewkhlymkivp\">在元件中展示資料<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-request-data-from-server#present-the-data-in-the-component\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vhsbjan60puc24nknnqkeavp\">`ConfigComponent` 在其建構式函式中注入 `ConfigService` 並提供一個 `showConfig` 方法，該方法呼叫服務的 `getConfig` 方法。</p>\n<code-example header=\"app/config/config.component.ts (showConfig v.1)\" path=\"http/src/app/config/config.component.ts\" region=\"v1\">\nconstructor(private configService: ConfigService) {}\n\nshowConfig() {\n  this.configService.getConfig()\n    .subscribe(data =&gt; this.config = {\n        heroesUrl: data.heroesUrl,\n        textfile:  data.textfile,\n        date: data.date,\n    });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9tt3tn2qnnap7371vvs9ega2s\">因為服務的 `getConfig` 方法回傳一個設定資料的 `Observable`，元件訂閱該方法的回傳值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92ibtcrjzzxyl5844t5uqpwik\">如果你沒有訂閱，服務將不會發出 HTTP 請求，也不會有設定資料顯示。你很快會明白原因。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ezxmmyr9ogp87u4d5pr6foeoa\">這個範例訂閱回呼執行最小的後處理。它將資料欄位複製到元件的 `config` 物件中，該物件在元件範本中綁定數據以進行顯示。</p>\n<p><a id=\"always-subscribe\"></a></p>\n<h2 id=\"starting-the-request\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3f64p9kp72hh8wn0ryf7ak566\">啟動請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-request-data-from-server#starting-the-request\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b47uac0hk9haja3jeiido5p15\">對於所有 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法，在你在方法回傳的 Observable 上呼叫 <code>subscribe()</code> 之前，該方法都不會開始其 HTTP 請求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5oj5wnpyvs8t8bistwkt24h4z\">這適用於 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的<em>所有方法</em>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"45l4t5b3fr6znijo32w6vvi2y\">一般來說，當元件銷燬時，應該取消訂閱可觀察者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6201zklwkec2uo1x0zbhtrc2q\">你不必取消訂閱 `HttpClient` 可觀察者，因為它們在服務器請求回應或超時後會自動取消訂閱。大多數開發人員選擇不取消訂閱。本指南的範例都不會取消訂閱。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ednwuymmw9yo46ppdyae7nm2y\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的所有方法回傳的可觀察物件都設計為<em>冷的</em>。HTTP 請求的執行都是<em>延期執行的</em>，讓你可以用 <code>tap</code> 和 <code>catchError</code> 這樣的運算子來在實際執行 HTTP 請求之前，先對這個可觀察物件進行擴充套件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4kp3rihwbcidc9xx9umflfn7j\">呼叫 <code>subscribe()</code> 會觸發此 Observable 的執行，並導致 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 合成 HTTP 請求並將其傳送到伺服器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"73vgk2ls8b1kjyt2vkd5h4wv1\">可以把這些 Observable 看做實際 HTTP 請求的<em>藍圖</em>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41urw8apt765irjkf3ton8x1\">事實上，每個 <code>subscribe()</code> 都會啟動 observable 的一次單獨的、獨立的執行。訂閱兩次就會導致兩次 HTTP 請求。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst req = http.get&lt;Heroes&gt;('/api/heroes');\n// 0 requests made - .subscribe() not called.\nreq.subscribe();\n// 1 request made.\nreq.subscribe();\n// 2 requests made.\n\n</code-example>\n</div>\n<p><a id=\"typed-response\"></a></p>\n<h2 id=\"requesting-a-typed-response\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7v4lt4mqllm4rrf127nf9oqmw\">請求輸入一個型別的回應<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-request-data-from-server#requesting-a-typed-response\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jit0tmqk6npf3gn2lsmz6tr\">可以構造自己的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 請求來宣告回應物件的型別，以便讓輸出更容易、更明確。所指定的回應型別會在編譯時充當型別斷言。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bovjfqdjczcbalpn05bpymda7\">指定回應型別是為了告訴 TypeScript 應該將回應視為給定型別的宣告。這是一個編譯期檢查，不能保證伺服器的回應一定是這種型別的物件。伺服器有責任確保回傳伺服器 API 所指定的型別。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6xpxbiltv3crm7ms8bybs8ci\">假設你在不指定回傳型別的情況下進行了 `get` 呼叫，如下所示： \n<code-example header=\"Config Service - get without result type (not so good)\" path=\"http/src/app/config/config.service.ts\" region=\"untyped_response\">\n  return this.http.get(this.configUrl); \n</code-example></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jecsz2ptbllbf1h8lhkv6s13\">回傳型別將是 `Object`，要訪問其屬性，你必須明確使用 `as any` 進行轉換，如下所示：</p>\n<code-example header=\"Config Component - without result type (not so good)\" path=\"http/src/app/config/config.component.ts\" region=\"untyped_response\">\nshowConfig() {\n  this.configService.getConfig()\n    .subscribe(data =&gt; this.config = {\n        heroesUrl: (data as any).heroesUrl,\n        textfile:  (data as any).textfile,\n        date: (data as any).date,\n    });\n  }\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d59bpjti8oare2zk315c66s4k\">如果回傳的物件具有所需型別，則更安全、更不臃腫。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4javqoybxnye0imj7h2pdh2o1\">首先，透過定義具有所需屬性的介面開始。 使用介面而不是類別，因為回應是一個普通物件，不能自動轉換為類別的實例。</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"config-interface\">\nexport interface Config {\n  heroesUrl: string;\n  textfile: string;\n  date: any;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1g8jzwf58gtah9iphkuvh45\">現在，在服務中將該介面指定為\n<code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code>呼叫的型別引數。</p>\n<code-example header=\"Config Service - get with result type (better)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_2\">\ngetConfig() {\n  // now returns an Observable of Config\n  return this.http.get&lt;Config&gt;(this.configUrl);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2r1gota3m36wn7i2l3imjgw8z\">修改後的元件方法，其回呼函式中獲取一個帶型別的物件，它易於使用，且消費起來更安全：</p>\n<code-example header=\"Config Component - with typed response\" path=\"http/src/app/config/config.component.ts\" region=\"typed_response\">\nconfig: Config | undefined;\n\nshowConfig() {\n  this.configService.getConfig()\n    .subscribe(data =&gt; this.config = {\n        heroesUrl: data.heroesUrl,\n        textfile:  data.textfile,\n        date: data.date,\n    });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1azsj0whx52zvikgbm95dijnb\">你可以更進一步，使用\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#description\">解構賦值</a>，直接將結果克隆到元件的\n<code>config</code>屬性中。</p>\n<code-example header=\"Config Component - with destructured assignment\" path=\"http/src/app/config/config.component.ts\" region=\"v2\">\nconfig: Config | undefined;\n\nshowConfig() {\n  this.configService.getConfig()\n    // clone the data object, using its known Config shape\n    .subscribe(data =&gt; this.config = { ...data });\n}\n\n</code-example>\n<h2 id=\"reading-the-full-response\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"577uv3zv9fpcd3mn40yo8niz9\">讀取完整的回應體<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-request-data-from-server#reading-the-full-response\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drylrrv7mdfwgzfg7zx8y0mre\">在前面的例子中，對 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 的呼叫沒有指定任何選項。預設情況下，它回傳了回應體中包含的 JSON 資料。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4az0u2t0hoai7xn261lxf0av\">你可能還需要關於這次對話的更多訊息。比如，有時候伺服器會回傳一個特殊的回應頭或狀態碼，來指出某些在應用的工作流程中很重要的條件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1mkkqt2gz2o3crv7nzaltfmur\">可以用 <code>get()</code> 方法的 <code>observe</code> 選項來告訴 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>，你想要完整的回應物件：</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"getConfigResponse\">\ngetConfigResponse(): Observable&lt;<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;&gt; {\n  return this.http.get&lt;Config&gt;(\n    this.configUrl, { observe: 'response' });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8524a89qnh7jax3z28yuoqxgk\">現在，<code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 會回傳一個 <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 型別的 <code>Observable</code>，而不只是 JSON 資料。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efe0aypg6w12eecx77by282oi\">該組件的 <code>showConfigResponse()</code> 方法會像顯示設定資料一樣顯示回應頭：</p>\n<code-example header=\"app/config/config.component.ts (showConfigResponse)\" path=\"http/src/app/config/config.component.ts\" region=\"showConfigResponse\">\nshowConfigResponse() {\n  this.configService.getConfigResponse()\n    // resp is of type `<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;`\n    .subscribe(resp =&gt; {\n      // display its headers\n      const keys = resp.headers.keys();\n      this.headers = keys.map(key =&gt;\n        `${key}: ${resp.headers.get(key)}`);\n\n      // access the body directly, which is typed as `Config`.\n      this.config = { ...resp.body! };\n    });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwtspcanbqzl0h2qirj0q20iz\">如你所見，該回應物件具有一個帶有正確型別的 <code>body</code> 屬性。</p>\n<p><a id=\"string-union-types\"></a></p>\n<h2 id=\"the-observe-and-responsetype-options\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cejnf82dr2l0l8fvi4bxakwor\"><code>observe</code> 和 \n<code>responseType</code> 選項<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-request-data-from-server#the-observe-and-responsetype-options\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"r0fhtezkc8ptzsg94ppwf6er\"><code>observe</code> 和 \n<code>responseType</code> 選項的型別是\n<em>字串聯合</em>，而不是普通字串。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  …\n  observe?: 'body' | 'events' | 'response',\n  …\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  …\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2xbook8zmfdsso24a3x1h70p9\">這可能導致混淆。例如：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n// this works\nclient.get('/foo', {responseType: 'text'})\n\n// but this does NOT work\nconst options = {\n  responseType: 'text',\n};\nclient.get('/foo', options)\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"317l9hcef540n2uo783fkyfav\">在第二種情況中，TypeScript 推斷 <code>options</code> 的型別為 <code>{responseType: string}</code>。這個型別過於寬泛，無法傳給 <code>HttpClient.get</code>，因為後者期望 <code>responseType</code> 的型別是<em>幾個特定的</em>字串之一。<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 被顯式地以這種方式進行了型別化，以便編譯器可以根據你提供的選項報告出正確的回傳型別。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8uy6g1dgux7mqkxtveg8iwk4\">使用 <code>as const</code> 來讓 TypeScript 知道你確實是要使用一個常數字串型別：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst options = {\n  responseType: 'text' as const,\n};\nclient.get('/foo', options);\n\n</code-example>\n</div>\n\n  <div class=\"reviewed\">最後複查時間：Fri Aug 18 2023</div>\n\n\n\n<!-- links to this doc:\n - guide/http-send-data-to-server\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/common/http/HttpHeaders\n - api/common/http/HttpParams\n - api/common/http/HttpResponse\n - guide/glossary#service\n - guide/http-handle-request-errors\n - guide/http-request-data-from-server#always-subscribe\n - guide/http-request-data-from-server#handle-data-access-in-a-service-class\n - guide/http-request-data-from-server#http-request-data-from-a-server\n - guide/http-request-data-from-server#present-the-data-in-the-component\n - guide/http-request-data-from-server#reading-the-full-response\n - guide/http-request-data-from-server#requesting-a-typed-response\n - guide/http-request-data-from-server#starting-the-request\n - guide/http-request-data-from-server#string-union-types\n - guide/http-request-data-from-server#the-observe-and-responsetype-options\n - guide/http-request-data-from-server#typed-response\n - guide/observables-in-angular\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#description\n-->"}