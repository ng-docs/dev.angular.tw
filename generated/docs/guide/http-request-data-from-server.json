{"id":"guide/http-request-data-from-server","title":"HTTP：从服务器请求数据","contents":"<div class=\"content\">\n  <h1 id=\"http-request-data-from-a-server\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8v2ol3mkrsomdd15kuk18lfqc\">HTTP：从服务器请求数据<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-request-data-from-server#http-request-data-from-a-server\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7mxy98pvphbio5quia8ydks5c\">使用\n<a href=\"api/common/http/HttpClient#get\"><code>HttpClient.get()</code></a>方法从服务器获取数据。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2a8ivevcjvln7a2plafzn0wmf\">这个异步方法发送一个HTTP请求，并在接收到响应时返回一个\n<a href=\"guide/observables-in-angular\">Observable</a>，以发出请求的数据。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8thpbgce8nnsmqx5mgwkvfakk\">`get(url, options)` 方法接受两个参数：要获取的字符串端点 URL，以及可选的配置请求的对象。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  headers?: <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a> | {[header: string]: string | string[]},\n  observe?: 'body' | 'events' | 'response',\n  params?: <a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a>|{[param: string]: string | number | boolean | ReadonlyArray&lt;string | number | boolean&gt;},\n  reportProgress?: boolean,\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  withCredentials?: boolean,\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6gnfyfqlgzdzt8qbnoy82r276\">这些重要的选项包括 <em>observe</em> 和 <em>responseType</em> 属性。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3liy686p15pg85we3xy31lzj\"><em>observe</em> 选项用于指定要返回的响应内容。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8rhfig2l4dldxgd62su9kxr8k\">`responseType` 选项指定返回数据的期望格式。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6qxio9pv3o6itn5jadg5n50b5\">要更好地理解 `observe` 和 `responseType` 选项类型，请查看下面的链接。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ewbie7vv6vw52vehuoye7mfv\">使用 <code>options</code> 对象来配置外发请求的其他方面。例如，在添加标头信息时，此服务会使用 <code>headers</code> 选项的属性来设置默认头信息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d0nb21sd39kbmffze9f2gi7gl\">使用 <code>params</code> 属性来配置带有 HTTP URL 参数的请求，使用 <code>reportProgress</code> 选项来监听传输大量数据时的进度事件。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2067w6sicuum77gf96p6j5spx\">应用经常会从服务器请求 JSON 数据。在 <code>ConfigService</code> 例子中，该应用需要服务器 <code>config.json</code> 上的一个配置文件来指定资源的 URL。</p>\n<code-example header=\"assets/config.json\" path=\"http/src/assets/config.json\">\n{\n  \"heroesUrl\": \"api/heroes\",\n  \"textfile\": \"assets/textfile.txt\",\n  \"date\": \"2020-01-29\"\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"alnqqiiwkodvdk9xkieoup7ci\">要获取这种类型的数据，`get()` 调用需要以下选项：`{observe: 'body', responseType: 'json'}`。 这些是这些选项的默认值，因此大多数 `get()` 调用 - 以及后续的大多数示例 - 不会传递选项对象。 后续章节展示了一些其他选项的可能性。</p>\n<p><a id=\"config-service\"></a></p>\n<h3 id=\"handle-data-access-in-a-service-class\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6p3xd5jhc2y81ms0vswj4rx1h\">在服务类中处理数据访问<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-request-data-from-server#handle-data-access-in-a-service-class\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"81cffn07hiiyqx5iu519lzwgy\">该示例符合通过将数据访问功能隔离到可重用的可注入服务中，与组件分离的可维护解决方案的最佳实践。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8vz03wb2e834oqmfk8do9j445\">`ConfigService` 使用 `HttpClient.get()` 方法获取 JSON 文件。</p>\n<code-example header=\"app/config/config.service.ts (getConfig v.1)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_1\">\nconfigUrl = 'assets/config.json';\n\ngetConfig() {\n  return this.http.get&lt;Config&gt;(this.configUrl);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5bvo9zjsrsezvkmlo0btiqhil\">请注意，调用了 `get`。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"chgu9pa1to9f4i8w72poahcgm\">没有传递一个选项值，因为服务器端点返回 JSON，并且 JSON 是默认数据格式。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6fh9y76cek84x93fs92xd3q1s\">传递了一个通用的 `Config`，表示数据返回类型；你很快将会了解原因。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2bol1ak621ar08ga67kp4g6ux\">除了获取数据，服务还可以对数据进行后处理，添加错误处理，并添加重试逻辑。</p>\n<h3 id=\"present-the-data-in-the-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"buo32jv14xx5ibewkhlymkivp\">在组件中展示数据<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-request-data-from-server#present-the-data-in-the-component\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vhsbjan60puc24nknnqkeavp\">`ConfigComponent` 在其构造函数中注入 `ConfigService` 并提供一个 `showConfig` 方法，该方法调用服务的 `getConfig` 方法。</p>\n<code-example header=\"app/config/config.component.ts (showConfig v.1)\" path=\"http/src/app/config/config.component.ts\" region=\"v1\">\nconstructor(private configService: ConfigService) {}\n\nshowConfig() {\n  this.configService.getConfig()\n    .subscribe(data =&gt; this.config = {\n        heroesUrl: data.heroesUrl,\n        textfile:  data.textfile,\n        date: data.date,\n    });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9tt3tn2qnnap7371vvs9ega2s\">因为服务的 `getConfig` 方法返回一个配置数据的 `Observable`，组件订阅该方法的返回值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92ibtcrjzzxyl5844t5uqpwik\">如果你没有订阅，服务将不会发出 HTTP 请求，也不会有配置数据显示。你很快会明白原因。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ezxmmyr9ogp87u4d5pr6foeoa\">这个示例订阅回调执行最小的后处理。它将数据字段复制到组件的 `config` 对象中，该对象在组件模板中绑定数据以进行显示。</p>\n<p><a id=\"always-subscribe\"></a></p>\n<h2 id=\"starting-the-request\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3f64p9kp72hh8wn0ryf7ak566\">启动请求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-request-data-from-server#starting-the-request\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b47uac0hk9haja3jeiido5p15\">对于所有 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法，在你在方法返回的 Observable 上调用 <code>subscribe()</code> 之前，该方法都不会开始其 HTTP 请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5oj5wnpyvs8t8bistwkt24h4z\">这适用于 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的<em>所有方法</em>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"45l4t5b3fr6znijo32w6vvi2y\">一般来说，当组件销毁时，应该取消订阅可观察者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6201zklwkec2uo1x0zbhtrc2q\">你不必取消订阅 `HttpClient` 可观察者，因为它们在服务器请求响应或超时后会自动取消订阅。大多数开发人员选择不取消订阅。本指南的示例都不会取消订阅。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ednwuymmw9yo46ppdyae7nm2y\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的所有方法返回的可观察对象都设计为<em>冷的</em>。HTTP 请求的执行都是<em>延期执行的</em>，让你可以用 <code>tap</code> 和 <code>catchError</code> 这样的操作符来在实际执行 HTTP 请求之前，先对这个可观察对象进行扩展。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4kp3rihwbcidc9xx9umflfn7j\">调用 <code>subscribe()</code> 会触发此 Observable 的执行，并导致 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 合成 HTTP 请求并将其发送到服务器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"73vgk2ls8b1kjyt2vkd5h4wv1\">可以把这些 Observable 看做实际 HTTP 请求的<em>蓝图</em>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41urw8apt765irjkf3ton8x1\">事实上，每个 <code>subscribe()</code> 都会启动 observable 的一次单独的、独立的执行。订阅两次就会导致两次 HTTP 请求。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst req = http.get&lt;Heroes&gt;('/api/heroes');\n// 0 requests made - .subscribe() not called.\nreq.subscribe();\n// 1 request made.\nreq.subscribe();\n// 2 requests made.\n\n</code-example>\n</div>\n<p><a id=\"typed-response\"></a></p>\n<h2 id=\"requesting-a-typed-response\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7v4lt4mqllm4rrf127nf9oqmw\">请求输入一个类型的响应<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-request-data-from-server#requesting-a-typed-response\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jit0tmqk6npf3gn2lsmz6tr\">可以构造自己的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 请求来声明响应对象的类型，以便让输出更容易、更明确。所指定的响应类型会在编译时充当类型断言。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bovjfqdjczcbalpn05bpymda7\">指定响应类型是为了告诉 TypeScript 应该将响应视为给定类型的声明。这是一个编译期检查，不能保证服务器的响应一定是这种类型的对象。服务器有责任确保返回服务器 API 所指定的类型。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6xpxbiltv3crm7ms8bybs8ci\">假设你在不指定返回类型的情况下进行了 `get` 调用，如下所示： \n<code-example header=\"Config Service - get without result type (not so good)\" path=\"http/src/app/config/config.service.ts\" region=\"untyped_response\">\n  return this.http.get(this.configUrl); \n</code-example></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jecsz2ptbllbf1h8lhkv6s13\">返回类型将是 `Object`，要访问其属性，你必须明确使用 `as any` 进行转换，如下所示：</p>\n<code-example header=\"Config Component - without result type (not so good)\" path=\"http/src/app/config/config.component.ts\" region=\"untyped_response\">\nshowConfig() {\n  this.configService.getConfig()\n    .subscribe(data =&gt; this.config = {\n        heroesUrl: (data as any).heroesUrl,\n        textfile:  (data as any).textfile,\n        date: (data as any).date,\n    });\n  }\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d59bpjti8oare2zk315c66s4k\">如果返回的对象具有所需类型，则更安全、更不臃肿。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4javqoybxnye0imj7h2pdh2o1\">首先，通过定义具有所需属性的接口开始。 使用接口而不是类，因为响应是一个普通对象，不能自动转换为类的实例。</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"config-interface\">\nexport interface Config {\n  heroesUrl: string;\n  textfile: string;\n  date: any;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1g8jzwf58gtah9iphkuvh45\">现在，在服务中将该接口指定为\n<code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code>调用的类型参数。</p>\n<code-example header=\"Config Service - get with result type (better)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_2\">\ngetConfig() {\n  // now returns an Observable of Config\n  return this.http.get&lt;Config&gt;(this.configUrl);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2r1gota3m36wn7i2l3imjgw8z\">修改后的组件方法，其回调函数中获取一个带类型的对象，它易于使用，且消费起来更安全：</p>\n<code-example header=\"Config Component - with typed response\" path=\"http/src/app/config/config.component.ts\" region=\"typed_response\">\nconfig: Config | undefined;\n\nshowConfig() {\n  this.configService.getConfig()\n    .subscribe(data =&gt; this.config = {\n        heroesUrl: data.heroesUrl,\n        textfile:  data.textfile,\n        date: data.date,\n    });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1azsj0whx52zvikgbm95dijnb\">你可以更进一步，使用\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#description\">解构赋值</a>，直接将结果克隆到组件的\n<code>config</code>属性中。</p>\n<code-example header=\"Config Component - with destructured assignment\" path=\"http/src/app/config/config.component.ts\" region=\"v2\">\nconfig: Config | undefined;\n\nshowConfig() {\n  this.configService.getConfig()\n    // clone the data object, using its known Config shape\n    .subscribe(data =&gt; this.config = { ...data });\n}\n\n</code-example>\n<h2 id=\"reading-the-full-response\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"577uv3zv9fpcd3mn40yo8niz9\">读取完整的响应体<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-request-data-from-server#reading-the-full-response\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drylrrv7mdfwgzfg7zx8y0mre\">在前面的例子中，对 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 的调用没有指定任何选项。默认情况下，它返回了响应体中包含的 JSON 数据。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4az0u2t0hoai7xn261lxf0av\">你可能还需要关于这次对话的更多信息。比如，有时候服务器会返回一个特殊的响应头或状态码，来指出某些在应用的工作流程中很重要的条件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1mkkqt2gz2o3crv7nzaltfmur\">可以用 <code>get()</code> 方法的 <code>observe</code> 选项来告诉 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>，你想要完整的响应对象：</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"getConfigResponse\">\ngetConfigResponse(): Observable&lt;<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;&gt; {\n  return this.http.get&lt;Config&gt;(\n    this.configUrl, { observe: 'response' });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8524a89qnh7jax3z28yuoqxgk\">现在，<code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 会返回一个 <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 类型的 <code>Observable</code>，而不只是 JSON 数据。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efe0aypg6w12eecx77by282oi\">该组件的 <code>showConfigResponse()</code> 方法会像显示配置数据一样显示响应头：</p>\n<code-example header=\"app/config/config.component.ts (showConfigResponse)\" path=\"http/src/app/config/config.component.ts\" region=\"showConfigResponse\">\nshowConfigResponse() {\n  this.configService.getConfigResponse()\n    // resp is of type `<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;`\n    .subscribe(resp =&gt; {\n      // display its headers\n      const keys = resp.headers.keys();\n      this.headers = keys.map(key =&gt;\n        `${key}: ${resp.headers.get(key)}`);\n\n      // access the body directly, which is typed as `Config`.\n      this.config = { ...resp.body! };\n    });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwtspcanbqzl0h2qirj0q20iz\">如你所见，该响应对象具有一个带有正确类型的 <code>body</code> 属性。</p>\n<p><a id=\"string-union-types\"></a></p>\n<h2 id=\"the-observe-and-responsetype-options\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cejnf82dr2l0l8fvi4bxakwor\"><code>observe</code> 和 \n<code>responseType</code> 选项<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-request-data-from-server#the-observe-and-responsetype-options\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"r0fhtezkc8ptzsg94ppwf6er\"><code>observe</code> 和 \n<code>responseType</code> 选项的类型是\n<em>字符串联合</em>，而不是普通字符串。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  …\n  observe?: 'body' | 'events' | 'response',\n  …\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  …\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2xbook8zmfdsso24a3x1h70p9\">这可能导致混淆。例如：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n// this works\nclient.get('/foo', {responseType: 'text'})\n\n// but this does NOT work\nconst options = {\n  responseType: 'text',\n};\nclient.get('/foo', options)\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"317l9hcef540n2uo783fkyfav\">在第二种情况中，TypeScript 推断 <code>options</code> 的类型为 <code>{responseType: string}</code>。这个类型过于宽泛，无法传给 <code>HttpClient.get</code>，因为后者期望 <code>responseType</code> 的类型是<em>几个特定的</em>字符串之一。<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 被显式地以这种方式进行了类型化，以便编译器可以根据你提供的选项报告出正确的返回类型。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8uy6g1dgux7mqkxtveg8iwk4\">使用 <code>as const</code> 来让 TypeScript 知道你确实是要使用一个常量字符串类型：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst options = {\n  responseType: 'text' as const,\n};\nclient.get('/foo', options);\n\n</code-example>\n</div>\n\n  <div class=\"reviewed\">最后复查时间：Fri Aug 18 2023</div>\n\n\n\n<!-- links to this doc:\n - guide/http-send-data-to-server\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/common/http/HttpHeaders\n - api/common/http/HttpParams\n - api/common/http/HttpResponse\n - guide/glossary#service\n - guide/http-handle-request-errors\n - guide/http-request-data-from-server#always-subscribe\n - guide/http-request-data-from-server#handle-data-access-in-a-service-class\n - guide/http-request-data-from-server#http-request-data-from-a-server\n - guide/http-request-data-from-server#present-the-data-in-the-component\n - guide/http-request-data-from-server#reading-the-full-response\n - guide/http-request-data-from-server#requesting-a-typed-response\n - guide/http-request-data-from-server#starting-the-request\n - guide/http-request-data-from-server#string-union-types\n - guide/http-request-data-from-server#the-observe-and-responsetype-options\n - guide/http-request-data-from-server#typed-response\n - guide/observables-in-angular\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#description\n-->"}