{"id":"guide/dependency-injection-navtree","title":"使用 DI 浏览组件树","contents":"<div class=\"content\">\n  <h1 id=\"navigate-the-component-tree-with-di\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7zzznn4ude6wd6h5evqolnzks\">使用 DI 浏览组件树<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#navigate-the-component-tree-with-di\"><i class=\"material-icons\">link</i></a></h1>\n<div class=\"callout is-critical\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4r7c5x5y77wbuducanio6c3fk\">已标记为归档</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58k4b2kechaaj13ikfgyyx6om\">为确保你拥有最佳的体验，本主题已标记为归档，直到我们确定其清楚地传达了最准确的信息为止。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aozrtn2vasedtzof2srri71ad\">同时，下列主题可能会有所帮助：<a href=\"guide/hierarchical-dependency-injection\">多级注入器</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ck2tsrjevyy0r4iofzx0sxxow\">如果你认为不应将此内容归档，请提交 <a href=\"https://github.com/angular/angular/issues/new?template=3-docs-bug.md\">GitHub 问题</a>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f4fxfrbp7a3hfo37etb9rm4u6\">应用的组件之间经常需要共享信息。你通常要用松耦合的技术来共享信息，比如数据绑定和服务共享。但是有时候让一个组件直接引用另一个组件还是很有意义的。比如，你需要通过另一个组件的直接引用来访问其属性或调用其方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8rhj6qpd5hro9xmiuh0jn1cf7\">在 Angular 中获取组件引用略微有些棘手。Angular 组件本身并没有一棵可以用编程方式检查或浏览的树。其父子关系是通过组件的<a href=\"guide/glossary#view\">视图对象</a>间接建立的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vn2ehfih0qiro3127ly67ie2\">每个组件都有一个<em>宿主视图</em>和一些<em>内嵌视图</em>。组件 A 的内嵌视图可以是组件 B 的宿主视图，而组件 B 还可以有它自己的内嵌视图。这意味着每个组件都有一棵以该组件的宿主视图为根节点的<a href=\"guide/glossary#view-hierarchy\">视图树</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"elnbm95eu7dkomfxo3l7eu22c\">有一些用于在视图树中<em>向下</em>导航的 API。请到 <a href=\"api\">API 参考手册</a>中查看 <code><a href=\"api/core/Query\" class=\"code-anchor\">Query</a></code>、<code><a href=\"api/core/QueryList\" class=\"code-anchor\">QueryList</a></code>、<code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"axa9n5bh3klyv8o13oziocb7f\">不存在用于获取父引用的公共 API。不过，由于每个组件的实例都会添加到注入器的容器中，因此你可以通过 Angular 的依赖注入来访问父组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2plcuym2twbtzul6m1ksrob9\">本节描述的就是关于这种做法的一些技巧。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1hsggpvivtvn69j6ro0qbff08\"><a id=\"find-parent\"></a>\n<a id=\"known-parent\"></a></p>\n<h3 id=\"find-a-parent-component-of-known-type\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d5yyf2i0t3rskncynrh1svqiy\">查找已知类型的父组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-component-of-known-type\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6g26rfzw670t5wj6cxdvykm3b\">你可以使用标准的类注入形式来获取类型已知的父组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tg8h1ol3mz5qzuon06fx2pfh\">在下面的例子中，父组件 <code>AlexComponent</code> 具有一些子组件，包括 <code>CathyComponent</code>：</p>\n<p><a id=\"alex\"></a></p>\n<code-example header=\"parent-finder.component.ts (AlexComponent v.1)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-1\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'alex',\n  template: `\n    &lt;div class=\"a\"&gt;\n      &lt;h3&gt;{{name}}&lt;/h3&gt;\n      &lt;cathy&gt;&lt;/cathy&gt;\n      &lt;craig&gt;&lt;/craig&gt;\n      &lt;carol&gt;&lt;/carol&gt;\n    &lt;/div&gt;`,\n  imports: [CathyComponent, CraigComponent, CarolComponent]\n})\nexport class AlexComponent extends Base\n{\n  override name = 'Alex';\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7n1iv6mq0pkjpdc2pze6niwhg\">在把 <code>AlexComponent</code> 注入到 <code>CathyComponent</code> 的构造函数中之后，<em>Cathy</em> 可以报告她是否能访问 <em>Alex</em>：</p>\n<code-example header=\"parent-finder.component.ts (CathyComponent)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"cathy\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'cathy',\n  template: `\n  &lt;div class=\"c\"&gt;\n    &lt;h3&gt;Cathy&lt;/h3&gt;\n    {{alex ? 'Found' : 'Did not find'}} Alex via the component class.&lt;br&gt;\n  &lt;/div&gt;`\n})\nexport class CathyComponent {\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public alex?: AlexComponent ) { }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d6ejgd6tpgchl5rpnft3xpsyl\">请注意，即使@Optional修饰符出于安全考虑，dependency-injection-in-action中的alex参数仍然设置了。</p>\n<p><a id=\"base-parent\"></a></p>\n<h3 id=\"unable-to-find-a-parent-by-its-base-class\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eag0picd0cpabaiv4g66ax00u\">不能根据父组件的基类访问父组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#unable-to-find-a-parent-by-its-base-class\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dpwdw04kyp8gw9mm60yc4yenu\">如果你<em>不知道</em>具体的父组件类怎么办？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94yr7pof00aydvjzd1r73pl76\">可复用组件可能是多个组件的子组件。想象一个用于渲染相关金融工具的突发新闻的组件。出于商业原因，当市场上的数据流发生变化时，这些新组件会频繁调用其父组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"343zhd2v30slpejpkq0x5fy0t\">该应用可能定义了十几个金融工具组件。理想情况下，它们全都实现了同一个基类，你的 <code>NewsComponent</code> 也能理解其 API。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"arxilctde19j9dx3zmdx2eks1\">如果能查找实现了某个接口的组件当然更好。但那是不可能的。因为 TypeScript 接口在转译后的 JavaScript 中不存在，而 JavaScript 不支持接口。因此，找无可找。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4bzhwid6x24qcc0ha13yw9ren\">这个设计并不怎么好。该例子是为了验证<em>组件是否能通过其父组件的基类来注入父组件</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xkfqepw1xq2u49usyx8r97ov\">这个例子中的 <code>CraigComponent</code> 体现了此问题。<a href=\"guide/dependency-injection-navtree#alex\">往回看</a>，你可以看到 <code>Alex</code> 组件<em>扩展</em>（<em>继承</em>）了基类 <code>Base</code>。</p>\n<code-example header=\"parent-finder.component.ts (Alex class signature)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\">\nexport class AlexComponent extends Base\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99fy1twh7zlscr4y7kh5v6njo\"><code>CraigComponent</code> 试图把 <code>Base</code> 注入到它的构造函数参数 <code>alex</code> 中，并汇报这次注入是否成功了。</p>\n<code-example header=\"parent-finder.component.ts (CraigComponent)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"craig\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'craig',\n  template: `\n  &lt;div class=\"c\"&gt;\n    &lt;h3&gt;Craig&lt;/h3&gt;\n    {{alex ? 'Found' : 'Did not find'}} Alex via the base class.\n  &lt;/div&gt;`\n})\nexport class CraigComponent {\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public alex?: Base ) { }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csub5uai6zbm5sonro3xxgpq0\">不幸的是，这不行！\n<live-example name=\"dependency-injection-in-action\"></live-example> 确认了 <code>alex</code> 参数为空。\n因此，<em>你不能通过父组件的基类注入它</em>。</p>\n<p><a id=\"class-interface-parent\"></a></p>\n<h3 id=\"find-a-parent-by-its-class-interface\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"yutp8bijhh7yqh91d6al9das\">根据父组件的类接口查找它<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-by-its-class-interface\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24bhtzdwahdljhz0pr1n34huf\">你可以通过父组件的<a href=\"guide/dependency-injection-in-action#class-interface\">类接口</a>来查找它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"tn1sg7kojcrb9c3cd52cgzlk\">该父组件必须合作，以类接口令牌为名，为自己定义一个<em>别名提供者</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3lwic0a8gg7w459cqgjsqip0p\">回忆一下，Angular 总是会把组件实例添加到它自己的注入器中，因此<a href=\"guide/dependency-injection-navtree#known-parent\">以前</a>你才能把 <em>Alex</em> 注入到 <em>Cathy</em> 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9uvxkayco06p42k9huewkr26g\">编写一个 <a href=\"guide/dependency-injection-in-action#useexisting\"><em>别名提供者</em></a>（一个 <code>provide</code> 对象字面量，其中有一个 <code>useExisting</code> 定义），创造了另一种方式来注入同一个组件实例，并把那个提供者添加到 <code>AlexComponent</code> <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 元数据的 <code>providers</code> 数组中。</p>\n<p><a id=\"alex-providers\"></a></p>\n<code-example header=\"parent-finder.component.ts (AlexComponent providers)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; AlexComponent) }],\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"845mnbbvt9lef82q48t4ag3w9\"><a href=\"guide/dependency-injection-navtree#parent-token\">Parent</a> 是该提供者的类接口。\n<a href=\"guide/dependency-injection-in-action#forwardref\"><em>forwardRef</em></a> 用于打破循环引用，因为在你刚才这个定义中 <code>AlexComponent</code> 引用了自身。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"680orcreosf4whizbdtmviogw\"><em>Alex</em> 的第三个子组件 <em>Carol</em>，把其父组件注入到了自己的 <code>parent</code> 参数中 —— 和你以前做过的一样。</p>\n<code-example header=\"parent-finder.component.ts (CarolComponent class)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-class\">\nexport class CarolComponent {\n  name = 'Carol';\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"47plie83ewff1xl07byhl8xdr\">下面是 <em>Alex</em> 及其家人的运行效果。</p>\n<div class=\"lightbox\">\n<img alt=\"Alex in action\" src=\"generated/images/guide/dependency-injection-in-action/alex.png\" width=\"302\" height=\"374\">\n</div>\n<p><a id=\"parent-tree\"></a></p>\n<h3 id=\"find-a-parent-in-a-tree-with-skipself\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dxner130vb59iaznku3yqqp44\">使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 在树中查找父级<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-in-a-tree-with-skipself\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6aq7sobiw74p6nnnko9eo05ov\">想象一下组件树的一个分支：<em>Alice</em> -&gt; <em>Barry</em> -&gt; <em>Carol</em>。无论 <em>Alice</em> 还是 <em>Barry</em> 都实现了类接口 <code>Parent</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e8otf3rk9j59f74tq902tuvv2\"><em>Barry</em> 很为难。他需要访问他的母亲 <em>Alice</em>，同时他自己还是 <em>Carol</em> 的父亲。这意味着他必须同时<em>注入</em> <code>Parent</code> 类接口来找到 <em>Alice</em>，同时还要<em>提供</em>一个 <code>Parent</code> 来满足 <em>Carol</em> 的要求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dfo8lw87rh44gj54mqezpkry\"><em>Barry</em> 的代码如下。</p>\n<code-example header=\"parent-finder.component.ts (BarryComponent)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry\">\nconst templateB = `\n  &lt;div class=\"b\"&gt;\n    &lt;div&gt;\n      &lt;h3&gt;{{name}}&lt;/h3&gt;\n      &lt;p&gt;My parent is {{parent?.name}}&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;carol&gt;&lt;/carol&gt;\n    &lt;chris&gt;&lt;/chris&gt;\n  &lt;/div&gt;`;\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector:   'barry',\n  template:   templateB,\n  providers:  [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; BarryComponent) }],\n  imports: [CarolComponent, ChrisComponent]\n})\nexport class BarryComponent implements Parent {\n  name = 'Barry';\n  constructor( @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"epwwz9fxqpaiwk48wn034ozm9\"><em>Barry</em> 的 <code>providers</code> 数组看起来和 <a href=\"guide/dependency-injection-navtree#alex-providers\"><em>Alex</em></a> 的一样。\n如果你准备继续像这样编写<a href=\"guide/dependency-injection-in-action#useexisting\"><em>别名提供者</em></a>，就应该创建一个辅助函数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"98tb0by3x0m3aau8ur0ck6mph\">现在，注意看 <em>Barry</em> 的构造函数。</p>\n<code-tabs>\n    <code-pane header=\"Barry's constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry-ctor\">\nconstructor( @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n\n</code-pane>\n    <code-pane header=\"Carol's constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-ctor\">\nconstructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n\n</code-pane>\n</code-tabs>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0o4i19rvw71i659nebf9s67p\">除增加了 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 装饰器之外，它和 <em>Carol</em> 的构造函数相同。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8lbebf7adf4opx02oywz2lhrj\">使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 有两个重要原因：</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cpty89ygtq3qomxbv4qugwq0c\">它告诉注入器开始从组件树中<em>高于</em>自己的位置（也就是父组件）开始搜索 <code>Parent</code> 依赖。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eifrek8n9464v2p9s22q0m4gd\">如果你省略了 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 装饰器，Angular 就会抛出循环依赖错误。</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nNG0200: Circular dependency in DI detected for BethComponent. Dependency path: BethComponent -&gt; Parent -&gt; BethComponent\n\n</code-example>\n</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2otb67f088hdexb5qrn1hr9h8\">下面是 <em>Alice</em>、<em>Barry</em> 及其家人的运行效果。</p>\n<div class=\"lightbox\">\n<img alt=\"Alice in action\" src=\"generated/images/guide/dependency-injection-in-action/alice.png\" width=\"298\" height=\"631\">\n</div>\n<p><a id=\"parent-token\"></a></p>\n<h3 id=\"parent-class-interface\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"86zvo07pk7v7q2r3vv88ni1h9\">父类接口<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#parent-class-interface\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5thz622zt5lz97rh8z1i72gfi\">你<a href=\"guide/dependency-injection-in-action#class-interface\">已经学过</a>，类接口是一个抽象类，它实际上用做接口而不是基类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1dow83edpt23y54xpdudu2ctf\">下面的例子定义了一个类接口 <code>Parent</code>。</p>\n<code-example header=\"parent-finder.component.ts (Parent class-interface)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"parent\">\nexport abstract class Parent { abstract name: string; }\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gt5k6fteym7ng0w1oamnhq8e\"><code>Parent</code> 类接口定义了一个带类型的 <code>name</code> 属性，但没有实现它。这个 <code>name</code> 属性是父组件中唯一可供子组件调用的成员。这样的窄化接口帮助把子组件从它的父组件中解耦出来。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8hmfktqblqsobn28fdh06l9sp\">一个组件想要作为父组件使用，就<em>应该</em>像 <code>AliceComponent</code> 那样实现这个类接口。</p>\n<code-example header=\"parent-finder.component.ts (AliceComponent class signature)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alice-class-signature\">\nexport class AliceComponent implements Parent\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5sx4vqtph4rte6uhjpk7lp8eb\">这样做可以增加代码的清晰度，但在技术上并不是必要的。虽然 <code>AlexComponent</code> 像 <code>Base</code> 类所要求的一样具有 <code>name</code> 属性，但它的类签名中并没有提及 <code>Parent</code>。</p>\n<code-example header=\"parent-finder.component.ts (AlexComponent class signature)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\">\nexport class AlexComponent extends Base\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"akwj78v9azc8n5l37rvoe284t\"><code>AlexComponent</code> <em>应该</em>实现 <code>Parent</code> 才是一种正确的风格。这个例子中之所以没这样做，<em>只是</em>为了证明即使没有声明接口，代码也可以编译和运行。</p>\n</div>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/TemplateRef\n-->\n<!-- links from this doc:\n - api\n - api/core/Component\n - api/core/ContentChildren\n - api/core/Optional\n - api/core/Query\n - api/core/QueryList\n - api/core/SkipSelf\n - api/core/ViewChildren\n - api/core/forwardRef\n - guide/dependency-injection-in-action#class-interface\n - guide/dependency-injection-in-action#forwardref\n - guide/dependency-injection-in-action#optional\n - guide/dependency-injection-in-action#useexisting\n - guide/dependency-injection-navtree#alex\n - guide/dependency-injection-navtree#alex-providers\n - guide/dependency-injection-navtree#find-a-parent-by-its-class-interface\n - guide/dependency-injection-navtree#find-a-parent-component-of-known-type\n - guide/dependency-injection-navtree#find-a-parent-in-a-tree-with-skipself\n - guide/dependency-injection-navtree#known-parent\n - guide/dependency-injection-navtree#navigate-the-component-tree-with-di\n - guide/dependency-injection-navtree#parent-class-interface\n - guide/dependency-injection-navtree#parent-token\n - guide/dependency-injection-navtree#unable-to-find-a-parent-by-its-base-class\n - guide/glossary#view\n - guide/glossary#view-hierarchy\n - guide/hierarchical-dependency-injection\n - https://github.com/angular/angular/issues/new?template=3-docs-bug.md\n-->"}