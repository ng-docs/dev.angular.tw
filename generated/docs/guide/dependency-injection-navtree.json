{"id":"guide/dependency-injection-navtree","title":"使用 DI 瀏覽元件樹","contents":"<div class=\"content\">\n  <h1 id=\"navigate-the-component-tree-with-di\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7zzznn4ude6wd6h5evqolnzks\">使用 DI 瀏覽元件樹<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#navigate-the-component-tree-with-di\"><i class=\"material-icons\">link</i></a></h1>\n<div class=\"callout is-critical\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4r7c5x5y77wbuducanio6c3fk\">已標記為歸檔</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58k4b2kechaaj13ikfgyyx6om\">為確保你擁有最佳的體驗，本主題已標記為歸檔，直到我們確定其清楚地傳達了最準確的訊息為止。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aozrtn2vasedtzof2srri71ad\">同時，下列主題可能會有所幫助：<a href=\"guide/hierarchical-dependency-injection\">多級注入器</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ck2tsrjevyy0r4iofzx0sxxow\">如果你認為不應將此內容歸檔，請送出 <a href=\"https://github.com/angular/angular/issues/new?template=3-docs-bug.md\">GitHub 問題</a>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f4fxfrbp7a3hfo37etb9rm4u6\">應用的元件之間經常需要共享訊息。你通常要用松耦合的技術來共享訊息，比如資料繫結和服務共享。但是有時候讓一個元件直接引用另一個元件還是很有意義的。比如，你需要透過另一個元件的直接引用來訪問其屬性或呼叫其方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8rhj6qpd5hro9xmiuh0jn1cf7\">在 Angular 中獲取元件引用略微有些棘手。Angular 元件本身並沒有一棵可以用程式設計方式檢查或瀏覽的樹。其父子關係是透過元件的<a href=\"guide/glossary#view\">檢視物件</a>間接建立的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vn2ehfih0qiro3127ly67ie2\">每個元件都有一個<em>宿主檢視</em>和一些<em>內嵌檢視</em>。元件 A 的內嵌檢視可以是元件 B 的宿主檢視，而元件 B 還可以有它自己的內嵌檢視。這意味著每個元件都有一棵以該組件的宿主檢視為根節點的<a href=\"guide/glossary#view-hierarchy\">檢視樹</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"elnbm95eu7dkomfxo3l7eu22c\">有一些用於在檢視樹中<em>向下</em>導向的 API。請到 <a href=\"api\">API 參考手冊</a>中檢視 <code><a href=\"api/core/Query\" class=\"code-anchor\">Query</a></code>、<code><a href=\"api/core/QueryList\" class=\"code-anchor\">QueryList</a></code>、<code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"axa9n5bh3klyv8o13oziocb7f\">不存在用於獲取父引用的公共 API。不過，由於每個元件的實例都會新增到注入器的容器中，因此你可以透過 Angular 的依賴注入來訪問父元件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2plcuym2twbtzul6m1ksrob9\">本節描述的就是關於這種做法的一些技巧。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1hsggpvivtvn69j6ro0qbff08\"><a id=\"find-parent\"></a>\n<a id=\"known-parent\"></a></p>\n<h3 id=\"find-a-parent-component-of-known-type\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d5yyf2i0t3rskncynrh1svqiy\">查詢已知型別的父元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-component-of-known-type\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6g26rfzw670t5wj6cxdvykm3b\">你可以使用標準的類注入形式來獲取型別已知的父元件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tg8h1ol3mz5qzuon06fx2pfh\">在下面的例子中，父元件 <code>AlexComponent</code> 具有一些子元件，包括 <code>CathyComponent</code>：</p>\n<p><a id=\"alex\"></a></p>\n<code-example header=\"parent-finder.component.ts (AlexComponent v.1)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-1\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'alex',\n  template: `\n    &lt;div class=\"a\"&gt;\n      &lt;h3&gt;{{name}}&lt;/h3&gt;\n      &lt;cathy&gt;&lt;/cathy&gt;\n      &lt;craig&gt;&lt;/craig&gt;\n      &lt;carol&gt;&lt;/carol&gt;\n    &lt;/div&gt;`,\n  imports: [CathyComponent, CraigComponent, CarolComponent]\n})\nexport class AlexComponent extends Base\n{\n  override name = 'Alex';\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7n1iv6mq0pkjpdc2pze6niwhg\">在把 <code>AlexComponent</code> 注入到 <code>CathyComponent</code> 的建構式函式中之後，<em>Cathy</em> 可以報告她是否能訪問 <em>Alex</em>：</p>\n<code-example header=\"parent-finder.component.ts (CathyComponent)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"cathy\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'cathy',\n  template: `\n  &lt;div class=\"c\"&gt;\n    &lt;h3&gt;Cathy&lt;/h3&gt;\n    {{alex ? 'Found' : 'Did not find'}} Alex via the component class.&lt;br&gt;\n  &lt;/div&gt;`\n})\nexport class CathyComponent {\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public alex?: AlexComponent ) { }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d6ejgd6tpgchl5rpnft3xpsyl\">請注意，即使@Optional修飾符出於安全考慮，dependency-injection-in-action中的alex引數仍然設定了。</p>\n<p><a id=\"base-parent\"></a></p>\n<h3 id=\"unable-to-find-a-parent-by-its-base-class\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eag0picd0cpabaiv4g66ax00u\">不能根據父元件的基底類別訪問父元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#unable-to-find-a-parent-by-its-base-class\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dpwdw04kyp8gw9mm60yc4yenu\">如果你<em>不知道</em>具體的父元件類別怎麼辦？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94yr7pof00aydvjzd1r73pl76\">可複用元件可能是多個元件的子元件。想象一個用於渲染相關金融工具的突發新聞的元件。出於商業原因，當市場上的資料流發生變化時，這些新元件會頻繁呼叫其父元件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"343zhd2v30slpejpkq0x5fy0t\">該應用可能定義了十幾個金融工具元件。理想情況下，它們全都實現了同一個基底類別，你的 <code>NewsComponent</code> 也能理解其 API。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"arxilctde19j9dx3zmdx2eks1\">如果能查詢實現了某個介面的元件當然更好。但那是不可能的。因為 TypeScript 介面在轉譯後的 JavaScript 中不存在，而 JavaScript 不支援介面。因此，找無可找。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4bzhwid6x24qcc0ha13yw9ren\">這個設計並不怎麼好。該例子是為了驗證<em>元件是否能透過其父元件的基底類別來注入父元件</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xkfqepw1xq2u49usyx8r97ov\">這個例子中的 <code>CraigComponent</code> 體現了此問題。<a href=\"guide/dependency-injection-navtree#alex\">往回看</a>，你可以看到 <code>Alex</code> 元件<em>擴充套件</em>（<em>繼承</em>）了基底類別 <code>Base</code>。</p>\n<code-example header=\"parent-finder.component.ts (Alex class signature)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\">\nexport class AlexComponent extends Base\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99fy1twh7zlscr4y7kh5v6njo\"><code>CraigComponent</code> 試圖把 <code>Base</code> 注入到它的建構式函式引數 <code>alex</code> 中，並彙報這次注入是否成功了。</p>\n<code-example header=\"parent-finder.component.ts (CraigComponent)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"craig\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'craig',\n  template: `\n  &lt;div class=\"c\"&gt;\n    &lt;h3&gt;Craig&lt;/h3&gt;\n    {{alex ? 'Found' : 'Did not find'}} Alex via the base class.\n  &lt;/div&gt;`\n})\nexport class CraigComponent {\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public alex?: Base ) { }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csub5uai6zbm5sonro3xxgpq0\">不幸的是，這不行！\n<live-example name=\"dependency-injection-in-action\"></live-example> 確認了 <code>alex</code> 引數為空。\n因此，<em>你不能透過父元件的基底類別注入它</em>。</p>\n<p><a id=\"class-interface-parent\"></a></p>\n<h3 id=\"find-a-parent-by-its-class-interface\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"yutp8bijhh7yqh91d6al9das\">根據父元件的類介面查詢它<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-by-its-class-interface\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24bhtzdwahdljhz0pr1n34huf\">你可以透過父元件的<a href=\"guide/dependency-injection-in-action#class-interface\">類介面</a>來查詢它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"tn1sg7kojcrb9c3cd52cgzlk\">該父元件必須合作，以類介面令牌為名，為自己定義一個<em>別名提供者</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3lwic0a8gg7w459cqgjsqip0p\">回憶一下，Angular 總是會把元件實例新增到它自己的注入器中，因此<a href=\"guide/dependency-injection-navtree#known-parent\">以前</a>你才能把 <em>Alex</em> 注入到 <em>Cathy</em> 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9uvxkayco06p42k9huewkr26g\">編寫一個 <a href=\"guide/dependency-injection-in-action#useexisting\"><em>別名提供者</em></a>（一個 <code>provide</code> 物件字面量，其中有一個 <code>useExisting</code> 定義），創造了另一種方式來注入同一個元件實例，並把那個提供者新增到 <code>AlexComponent</code> <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 元資料的 <code>providers</code> 陣列中。</p>\n<p><a id=\"alex-providers\"></a></p>\n<code-example header=\"parent-finder.component.ts (AlexComponent providers)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; AlexComponent) }],\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"845mnbbvt9lef82q48t4ag3w9\"><a href=\"guide/dependency-injection-navtree#parent-token\">Parent</a> 是該提供者的類介面。\n<a href=\"guide/dependency-injection-in-action#forwardref\"><em>forwardRef</em></a> 用於打破迴圈引用，因為在你剛才這個定義中 <code>AlexComponent</code> 引用了自身。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"680orcreosf4whizbdtmviogw\"><em>Alex</em> 的第三個子元件 <em>Carol</em>，把其父元件注入到了自己的 <code>parent</code> 引數中 —— 和你以前做過的一樣。</p>\n<code-example header=\"parent-finder.component.ts (CarolComponent class)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-class\">\nexport class CarolComponent {\n  name = 'Carol';\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"47plie83ewff1xl07byhl8xdr\">下面是 <em>Alex</em> 及其家人的執行效果。</p>\n<div class=\"lightbox\">\n<img alt=\"Alex in action\" src=\"generated/images/guide/dependency-injection-in-action/alex.png\" width=\"302\" height=\"374\">\n</div>\n<p><a id=\"parent-tree\"></a></p>\n<h3 id=\"find-a-parent-in-a-tree-with-skipself\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dxner130vb59iaznku3yqqp44\">使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 在樹中查詢父級<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-in-a-tree-with-skipself\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6aq7sobiw74p6nnnko9eo05ov\">想象一下元件樹的一個分支：<em>Alice</em> -&gt; <em>Barry</em> -&gt; <em>Carol</em>。無論 <em>Alice</em> 還是 <em>Barry</em> 都實現了類介面 <code>Parent</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e8otf3rk9j59f74tq902tuvv2\"><em>Barry</em> 很為難。他需要訪問他的母親 <em>Alice</em>，同時他自己還是 <em>Carol</em> 的父親。這意味著他必須同時<em>注入</em> <code>Parent</code> 類介面來找到 <em>Alice</em>，同時還要<em>提供</em>一個 <code>Parent</code> 來滿足 <em>Carol</em> 的要求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dfo8lw87rh44gj54mqezpkry\"><em>Barry</em> 的程式碼如下。</p>\n<code-example header=\"parent-finder.component.ts (BarryComponent)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry\">\nconst templateB = `\n  &lt;div class=\"b\"&gt;\n    &lt;div&gt;\n      &lt;h3&gt;{{name}}&lt;/h3&gt;\n      &lt;p&gt;My parent is {{parent?.name}}&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;carol&gt;&lt;/carol&gt;\n    &lt;chris&gt;&lt;/chris&gt;\n  &lt;/div&gt;`;\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector:   'barry',\n  template:   templateB,\n  providers:  [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; BarryComponent) }],\n  imports: [CarolComponent, ChrisComponent]\n})\nexport class BarryComponent implements Parent {\n  name = 'Barry';\n  constructor( @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"epwwz9fxqpaiwk48wn034ozm9\"><em>Barry</em> 的 <code>providers</code> 陣列看起來和 <a href=\"guide/dependency-injection-navtree#alex-providers\"><em>Alex</em></a> 的一樣。\n如果你準備繼續像這樣編寫<a href=\"guide/dependency-injection-in-action#useexisting\"><em>別名提供者</em></a>，就應該建立一個輔助函式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"98tb0by3x0m3aau8ur0ck6mph\">現在，注意看 <em>Barry</em> 的建構式函式。</p>\n<code-tabs>\n    <code-pane header=\"Barry's constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry-ctor\">\nconstructor( @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n\n</code-pane>\n    <code-pane header=\"Carol's constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-ctor\">\nconstructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n\n</code-pane>\n</code-tabs>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0o4i19rvw71i659nebf9s67p\">除增加了 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 裝飾器之外，它和 <em>Carol</em> 的建構式函式相同。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8lbebf7adf4opx02oywz2lhrj\">使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 有兩個重要原因：</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cpty89ygtq3qomxbv4qugwq0c\">它告訴注入器開始從元件樹中<em>高於</em>自己的位置（也就是父元件）開始搜尋 <code>Parent</code> 依賴。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eifrek8n9464v2p9s22q0m4gd\">如果你省略了 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 裝飾器，Angular 就會丟擲迴圈依賴錯誤。</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nNG0200: Circular dependency in DI detected for BethComponent. Dependency path: BethComponent -&gt; Parent -&gt; BethComponent\n\n</code-example>\n</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2otb67f088hdexb5qrn1hr9h8\">下面是 <em>Alice</em>、<em>Barry</em> 及其家人的執行效果。</p>\n<div class=\"lightbox\">\n<img alt=\"Alice in action\" src=\"generated/images/guide/dependency-injection-in-action/alice.png\" width=\"298\" height=\"631\">\n</div>\n<p><a id=\"parent-token\"></a></p>\n<h3 id=\"parent-class-interface\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"86zvo07pk7v7q2r3vv88ni1h9\">父類別介面<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#parent-class-interface\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5thz622zt5lz97rh8z1i72gfi\">你<a href=\"guide/dependency-injection-in-action#class-interface\">已經學過</a>，類介面是一個抽象類別，它實際上用做介面而不是基底類別。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1dow83edpt23y54xpdudu2ctf\">下面的例子定義了一個類介面 <code>Parent</code>。</p>\n<code-example header=\"parent-finder.component.ts (Parent class-interface)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"parent\">\nexport abstract class Parent { abstract name: string; }\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gt5k6fteym7ng0w1oamnhq8e\"><code>Parent</code> 類介面定義了一個帶型別的 <code>name</code> 屬性，但沒有實現它。這個 <code>name</code> 屬性是父元件中唯一可供子元件呼叫的成員。這樣的窄化介面幫助把子元件從它的父元件中解耦出來。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8hmfktqblqsobn28fdh06l9sp\">一個元件想要作為父元件使用，就<em>應該</em>像 <code>AliceComponent</code> 那樣實現這個類介面。</p>\n<code-example header=\"parent-finder.component.ts (AliceComponent class signature)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alice-class-signature\">\nexport class AliceComponent implements Parent\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5sx4vqtph4rte6uhjpk7lp8eb\">這樣做可以增加程式碼的清晰度，但在技術上並不是必要的。雖然 <code>AlexComponent</code> 像 <code>Base</code> 類所要求的一樣具有 <code>name</code> 屬性，但它的類簽名中並沒有提及 <code>Parent</code>。</p>\n<code-example header=\"parent-finder.component.ts (AlexComponent class signature)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\">\nexport class AlexComponent extends Base\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"akwj78v9azc8n5l37rvoe284t\"><code>AlexComponent</code> <em>應該</em>實現 <code>Parent</code> 才是一種正確的風格。這個例子中之所以沒這樣做，<em>只是</em>為了證明即使沒有宣告介面，程式碼也可以編譯和執行。</p>\n</div>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/TemplateRef\n-->\n<!-- links from this doc:\n - api\n - api/core/Component\n - api/core/ContentChildren\n - api/core/Optional\n - api/core/Query\n - api/core/QueryList\n - api/core/SkipSelf\n - api/core/ViewChildren\n - api/core/forwardRef\n - guide/dependency-injection-in-action#class-interface\n - guide/dependency-injection-in-action#forwardref\n - guide/dependency-injection-in-action#optional\n - guide/dependency-injection-in-action#useexisting\n - guide/dependency-injection-navtree#alex\n - guide/dependency-injection-navtree#alex-providers\n - guide/dependency-injection-navtree#find-a-parent-by-its-class-interface\n - guide/dependency-injection-navtree#find-a-parent-component-of-known-type\n - guide/dependency-injection-navtree#find-a-parent-in-a-tree-with-skipself\n - guide/dependency-injection-navtree#known-parent\n - guide/dependency-injection-navtree#navigate-the-component-tree-with-di\n - guide/dependency-injection-navtree#parent-class-interface\n - guide/dependency-injection-navtree#parent-token\n - guide/dependency-injection-navtree#unable-to-find-a-parent-by-its-base-class\n - guide/glossary#view\n - guide/glossary#view-hierarchy\n - guide/hierarchical-dependency-injection\n - https://github.com/angular/angular/issues/new?template=3-docs-bug.md\n-->"}