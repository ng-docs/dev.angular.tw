{"id":"guide/creating-libraries","title":"创建库","contents":"<div class=\"content\">\n  <h1 id=\"creating-libraries\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"zlzz7c1g9hkwkz1rdjs5em5m\">创建库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#creating-libraries\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brgsk5gzma2asbekb5oarlgga\">对于如何创建和发布新库，以扩展 Angular 的功能，本页面提供了一个概念性的总览</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d4h8gm2oqaey3kcgbu5f7d3s4\">如果你发现自己要在多个应用中解决同样的问题（或者要把你的解决方案分享给其它开发者），你就有了一个潜在的库。简单的例子就是一个用来把用户带到你公司网站上的按钮，该按钮会包含在你公司构建的所有应用中。</p>\n<h2 id=\"getting-started\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c1ec4dv7ru8g390agopg2loxb\">快速上手<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#getting-started\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7keygqbkfp7a542q5398pvl9o\">使用 Angular CLI，用以下命令在新的工作区中生成一个新库的骨架：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng new my-workspace --no-create-application\ncd my-workspace\nng generate library my-lib\n\n</code-example>\n<div class=\"callout is-important\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3rm2nsqx9t5lrtvumk6l4toci\">命名你的库</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dmpij479kqna87yvqtzoxnxpm\">如果你想稍后在公共包注册表（比如 npm）中发布它，则在选择库名称时应该非常小心。参阅<a href=\"guide/creating-libraries#publishing-your-library\">发布你的库</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dl0rbs7g3k5ivhn3x4oqkixf\">避免使用以 <code>ng-</code> 为前缀的名称，比如 <code>ng-library</code>。<code>ng-</code> 前缀是 Angular 框架及其库中使用的保留关键字。首选 <code>ngx-</code> 前缀作为用于表示该库适合与 Angular 一起使用的约定。这也是注册表的使用者区分不同 JavaScript 框架库的优秀指示器。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4tfei1ju96fwcad2lssj284hh\"><code>ng generate</code> 命令会在你的工作区中创建 <code>projects/my-lib</code> 文件夹，其中包含带有一个组件和一个服务的 NgModule。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2dpys0olmqnp34nyygbuu3fzi\">要了解关于库项目的目录结构的详细信息，参阅<a href=\"guide/file-structure\">项目文件结构</a>中的<a href=\"guide/file-structure#library-project-files\">库项目文件</a>部分。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8jl1lqokjz7pin4ndlf76qdbl\">可以使用单一仓库（monorepo）模式将同一个工作区用于多个项目。参阅<a href=\"guide/file-structure#multiple-projects\">建立多项目型工作区</a>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2q546g7l0pk5azhf97a8zwdg\">当你生成一个新库时，该工作区的配置文件 <code>angular.json</code> 中也增加了一个 'library' 类型的项目。</p>\n<code-example format=\"json\">\n\n\"projects\": {\n  …\n  \"my-lib\": {\n    \"root\": \"projects/my-lib\",\n    \"sourceRoot\": \"projects/my-lib/src\",\n    \"projectType\": \"library\",\n    \"prefix\": \"lib\",\n    \"architect\": {\n      \"build\": {\n        \"builder\": \"@angular-devkit/build-angular:ng-packagr\",\n        …\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ed7e9xxb3gx456ja9zhh4eo0f\">可以使用 CLI 命令来构建、测试和 lint 这个项目：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng build my-lib --configuration development\nng test my-lib\nng lint my-lib\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zt4f9akzidt5ghei4axdylqm\">注意，该项目配置的构建器与应用类项目的默认构建器不同。此构建器可以确保库永远使用 <a href=\"guide/aot-compiler\">AoT 编译器</a>构建。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhy4s1q4ia0myi5sgfagm9dnr\">要让库代码可以复用，你必须为它定义一个公共的 API。这个“用户层”定义了库中消费者的可用内容。该库的用户应该可以通过单个的导入路径来访问公共功能（如 NgModules、服务提供者和工具函数）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ei1f0f4jzirbdlm3hbnwvkaoq\">库的公共 API 是在库文件夹下的 <code>public-api.ts</code> 文件中维护的。当你的库被导入应用时，从该文件导出的所有内容都会公开。请使用 NgModule 来暴露这些服务和组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ryyoxar8cjkoe8vl2y9uxy8h\">你的库里应该提供一些文档（通常是 README 文件）来指导别人安装和维护。</p>\n<h2 id=\"refactoring-parts-of-an-application-into-a-library\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"yhhl940weroginw68vbwuq6a\">把应用中的部分内容重构成一个库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#refactoring-parts-of-an-application-into-a-library\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"al5ihssdzcnbc5c71r0mc2s4y\">为了让你的解决方案可供复用，你需要对它进行调整，以免它依赖应用特有的代码。在将应用的功能迁移到库中时，需要注意以下几点。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"em3mt16adfi4sfuofgo9ffe77\">组件和管道之类的可声明对象应该设计成无状态的，这意味着它们不依赖或修改外部变量。如果确实依赖于状态，就需要对每种情况进行评估，以决定它是应用的状态还是库要管理的状态。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7rdao5hzn65qa27323hubsxph\">组件内部订阅的所有可观察对象都应该在这些组件的生命周期内进行清理和释放</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7hnyysjqonu3ucvt7qphoql8x\">组件对外暴露交互方式时，应该通过输入参数来提供上下文，通过输出参数来将事件传给其它组件</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9m7b2elm6etx53ie3u4ga79db\">检查所有内部依赖。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9us480e1xd2wmkyj6uudxhkff\">对于在组件或服务中使用的自定义类或接口，检查它们是否依赖于其它类或接口，它们也需要一起迁移</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"algn2wzgyd7ys09rpo0idaqde\">同样，如果你的库代码依赖于某个服务，则需要迁移该服务</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3g041ziudiiqnxf979j7wvf0t\">如果你的库代码或其模板依赖于其它库（比如 Angular Material），你就必须把它们配置为该库的依赖</li>\n</ul>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5clq0bqzx2yxjb3lecoqozzpr\">考虑如何为客户端应用提供服务。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xfaxmmdlgblqobk1kzzhz68f\">服务应该自己声明提供者（而不是在 NgModule 或组件中声明提供者），以便它们是<em>可摇树优化的</em>。这样，如果服务器从未被注入到导入该库的应用中，编译器就会把该服务从该 bundle 中删除。关于这方面的更多信息，参阅<a href=\"guide/architecture-services#providing-services\">Tree-shakable 提供者</a>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b6wfxmpo8yyoga1rdbf2co900\">如果你在多个 NgModules 注册全局服务提供者或提供者共享，使用<a href=\"guide/singleton-services\"><code>forRoot()</code> 和 <code>forChild()</code> 设计模式</a>由提供<a href=\"api/router/RouterModule\">RouterModule</a></p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"782ph9lqnbqv2yaxlng0ybc7m\">如果你的库中提供的可选服务可能并没有被所有的客户端应用所使用，那么就可以通过<a href=\"guide/lightweight-injection-tokens\">轻量级令牌设计模式</a>为这种情况支持正确的树状<a href=\"guide/lightweight-injection-tokens\">结构了</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<p><a id=\"integrating-with-the-cli\"></a></p>\n<h2 id=\"integrating-with-the-cli-using-code-generation-schematics\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e9y10vkhp2sp8qxctllffgbzp\">使用代码生成原理图与 CLI 集成<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#integrating-with-the-cli-using-code-generation-schematics\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ag0x39e1e62tw58tes6mzvu73\">一个库通常都包含<em>可复用的代码</em>，用于定义组件，服务，以及你刚才导入到项目中的其他 Angular 工件（管道，指令等等）。库被打包成一个 npm 包，用于发布和共享。这个包还可以包含一些<a href=\"guide/glossary#schematic\">原理图</a>，它提供直接在项目中生成或转换代码的指令，就像 CLI 用 <code>ng generate component</code> 创建一个通用的新 <code>ng generate component</code>。比如，用库打包的原理图可以为 Angular CLI 提供生成组件所需的信息，该组件用于配置和使用该库中定义的特定特性或一组特性。这方面的一个例子是 <a href=\"https://material.angular.cn/guide/schematics#navigation-schematic\">Angular Material 的导航原理图</a>，它用来配置 CDK 的 <a href=\"https://material.angular.cn/cdk/layout/overview#breakpointobserver\"><code>BreakpointObserver</code></a> 并把它与 Material 的 <a href=\"https://material.angular.cn/components/sidenav/overview\">MatSideNav</a> 和 <a href=\"https://material.angular.cn/components/toolbar/overview\">MatToolbar</a> 组件一起使用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"fpikdg5hd3ixw6guim89ubyw\">创建并包含以下几种原理图。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2sc7i90hxgq1wlpl7n5smmma3\">包含一个安装原理图，以便 <code>ng add</code> 可以把你的库添加到项目中。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6nyna3yzgbwgayjodumbi5e8y\">在库中包含了生成原理图，以便 <code>ng generate</code> 可以为项目中的已定义工件（组件，服务，测试等）提供支持。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8f2f00zcdwei2rv5xmulo1ev0\">包含一个更新的原理图，以便 <code>ng update</code> 可以更新你的库的依赖，并提供一些迁移来破坏新版本中的更改。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9b8futit3fft50bl82v433l2t\">你的库中所包含的内容取决于你的任务。比如，你可以定义一个原理图来创建一个预先填充了固定数据的下拉列表，以展示如何把它添加到一个应用中。如果你想要一个每次包含不同传入值的下拉列表，那么你的库可以定义一个原理图来用指定的配置创建它。然后，开发人员可以使用 <code>ng generate</code> 为自己的应用配置一个实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3bfxra1ara0dw2eum9sp5vaye\">假设你要读取配置文件，然后根据该配置生成表单。如果该表单需要库的用户进行额外的自定义，它可能最适合用作 schematic。但是，如果这些表单总是一样的，开发人员不需要做太多自定义工作，那么你就可以创建一个动态的组件来获取配置并生成表单。通常，自定义越复杂，schematic 方式就越有用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vj061cztf7fa29uluc2xv7jf\">欲知详情，参阅 <a href=\"guide/schematics\">原理图概览</a> 和 <a href=\"guide/schematics-for-libraries\">供库使用的原理图</a>。</p>\n<h2 id=\"publishing-your-library\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wz5xgr4wsch8fph15vvxikdi\">发布你的库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#publishing-your-library\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f4oxj1ogjpfphqkfugd4vfugq\">使用 Angular CLI 和 npm 包管理器来构建你的库并发布为 npm 包。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3krk3jj5dztmuuett9t4kywsn\">Angular CLI 使用一个名为 <a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/README.md\">ng-packagr</a> 的工具从已编译的代码中创建可以发布到 npm 的软件包。<code>ng-packagr</code> 支持的发行格式的信息以及有关如何为库选择正确格式的指南，参阅<a href=\"guide/creating-libraries#ivy-libraries\">使用 Ivy 构建库</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6jbeb83wzxq6xtwi660bcc3qm\">你应该总是使用 <code>production</code> 配置来构建用于分发的库。这样可以确保所生成的输出对 npm 使用了适当的优化和正确的软件包格式。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng build my-lib\ncd dist/my-lib\nnpm publish\n\n</code-example>\n<p><a id=\"lib-assets\"></a></p>\n<h2 id=\"managing-assets-in-a-library\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ij9bt7c630pne3po3cki9ttp\">管理库中的资产（assets）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#managing-assets-in-a-library\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xe9s0obsx9bvcpal2khs55om\">对于 Angular 库，可分发文件中可包含一些额外的资产，如主题文件、Sass mixins 或文档（如变更日志）。欲知详情，请参见<a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md\">在构建时将资产复制到库中</a>和<a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md\">将资产嵌入到组件样式中</a>。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"813j6xro9iozn5b2ygqeyhrxe\">当包含额外的资产（如 Sass mixins 或预编译的 CSS）时，你需要将这些手动添加到主入口点的 <code>package.json</code> 中的条件化 <a href=\"guide/angular-package-format/#exports\">“exports”</a> 部分。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3po3vafcj969h5u6zz5k2dwe\"><code>ng-packagr</code> 会将手写的 <code>\"exports\"</code> 与自动生成的 <code>\"exports\"</code> 合并，以便让库作者配置额外的导出子路径或自定义条件。</p>\n<code-example language=\"json\">\n\n\"exports\": {\n  \".\": {\n    \"sass\": \"./_index.scss\",\n  },\n  \"./theming\": {\n    \"sass\": \"./_theming.scss\"\n  },\n  \"./prebuilt-themes/indigo-pink.css\": {\n    \"style\": \"./prebuilt-themes/indigo-pink.css\"\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"647802sc88ng8wwfjsb4v12tu\">以上是 <a href=\"https://unpkg.com/browse/@angular/material/package.json\">@angular/material</a> 可分发文件的摘录。</p>\n</div>\n<h2 id=\"peer-dependencies\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"avj3zq5qgopatb0hlcw6f2hee\">同级依赖<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#peer-dependencies\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"79i0txjqv02kw9shhlm1ku7pu\">各种 Angular 库应该把自己依赖的所有 <code>@angular/*</code> 都列为同级依赖。这确保了当各个模块请求 Angular 时，都会得到完全相同的模块。如果某个库在 <code>dependencies</code> 列出 <code>@angular/core</code> 而不是用 <code>peerDependencies</code>，它可能会得到一个不同的 Angular 模块，这会破坏你的应用。</p>\n<h2 id=\"using-your-own-library-in-applications\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ag7zrl4la9hz4dy5g4ttfz0uy\">在应用中使用你自己的库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#using-your-own-library-in-applications\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7gv4xrom9bkqkhs3th59yq4k3\">如果要在同一个工作空间中使用某个库，你不必把它发布到 npm 包管理器，但你还是得先构建它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6560mod8qhj7j92wsu11p3uj0\">要想在应用中使用你自己的库：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ycitnry1hrhtq9hs08tk181e\">构建该库。在构建之前，无法使用库。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng build my-lib\n\n</code-example>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"lspz3ttlhbfbu0jd1vgqb5sf\">在你的应用中，按名字从库中导入：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nimport { myExport } from 'my-lib';\n\n</code-example>\n</li>\n</ul>\n<h3 id=\"building-and-rebuilding-your-library\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"skmftwp7nn8zb9er0qrc6611\">构建和重建你的库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#building-and-rebuilding-your-library\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6awpdn3kdsmn82hybo4h0gju\">如果你没有把库发布为 npm 包，然后把它从 npm 安装到你的应用中，那么构建步骤就是必要的。比如，如果你克隆了 git 仓库并运行了 <code>npm install</code>，编辑器就会把 <code>my-lib</code> 的导入显示为缺失状态（如果你还没有构建过该库）。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"62pm1nful4yie8p1w1pjao9ow\">当你在 Angular 应用中从某个库导入一些东西时，Angular 就会寻找库名和磁盘上某个位置之间的映射关系。当你用 npm 包安装该库时，它就映射到 <code>node_modules</code> 目录下。当你自己构建库时，它就会在 <code>tsconfig</code> 路径中查找这个映射。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1gcl4l25jcvimff4fnw2m48jh\">用 Angular CLI 生成库时，会自动把它的路径添加到 <code>tsconfig</code> 文件中。Angular CLI 使用 <code>tsconfig</code> 路径告诉构建系统在哪里寻找这个库。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ec5eknl3spzzx3ncicvabnc1\">欲知详情，参见<a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\">路径映射概览</a>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e73q0ioc7kixq3671231qy7cj\">如果你发现库中的更改没有反映到应用中，那么你的应用很可能正在使用这个库的旧版本。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ir4v9f6brs8i03o4c0m1zj9r\">每当你对它进行修改时，都可以重建你的库，但这个额外的步骤需要时间。<em>增量构建</em>功能可以改善库的开发体验。每当文件发生变化时，都会执行局部构建，并修补一些文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37n00em1fomk6e7bi0c6hqfu6\">增量构建可以作为开发环境中的后台进程运行。要启用这个特性，可以在构建命令中加入 <code>--watch</code> 标志：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng build my-lib --watch\n\n</code-example>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xno19e4ra1nlldk54htdol9f\">CLI 的 <code>build</code> 命令为库使用与应用不同的构建器，并调用不同的构建工具。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"tzcxkceu3tzaelgepnziklu5\">应用的构建体系（<code>@angular-devkit/build-angular</code>）基于 <code>webpack</code>，并被包含在所有新的 Angular CLI 项目中。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bvsxo84dpu6nks7n9hv9ss5f\">库的构建体系基于 <code>ng-packagr</code>。只有在使用 <code>ng generate library my-lib</code> 添加库时，它才会添加到依赖项中。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6r9elfqazszc4a7unk7w8ox8\">这两种构建体系支持不同的东西，即使它们支持相同的东西，它们的执行方式也不同。这意味着同一套 TypeScript 源码在生成库时生成的 JavaScript 代码可能与生成应用时生成的 JavaScript 代码也不同。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bnq47dfaov3ivrr3qn2sz46ta\">因此，依赖于库的应用应该只使用指向<em>内置库</em>的 TypeScript 路径映射。TypeScript 的路径映射<em>不应该</em>指向库的 <code>.ts</code> 源文件。</p>\n</div>\n<p><a id=\"ivy-libraries\"></a></p>\n<h2 id=\"publishing-libraries\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9jiqaj74dyktjir9mzims4gya\">发布库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#publishing-libraries\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3lnobktb67z5h86aoy2evtr7\">发布库时可以使用两种分发格式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ucy8b8u5sz8a4n9mv6l83ew2\">分发格式</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wgj0ajyj49kc5w373d6t4595\">部分-Ivy（推荐）</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1fubz8o4idg7hypzbmkutkgy6\">包含可被任何从 Angular v12 开始构建的 Ivy 应用程序消费的可移植代码。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9t465lx6s6vcuxkztnyf4691i\">完整-Ivy</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b7imn0pkv29wcj25up8hdzjzu\">包含私有的 Angular Ivy 指令，不保证能够跨不同版本的 Angular 工作。此格式要求库和应用程序必须使用完全相同版本的 Angular 进行构建。该格式适用于所有库和应用程序代码都直接从源代码构建的环境。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qwo94rph4s02ryt4fai8a0fa\">对于发布到 npm 的库，请使用 partial-Ivy 格式，因为它在 Angular 的各个补丁版本之间是稳定的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"75jlq9qjrhywoz32hignxhgfi\">如果要发布到 npm，请避免使用完全 Ivy 的方式编译库，因为生成的 Ivy 指令不属于 Angular 公共 API 的一部分，因此在补丁版本之间可能会有所不同。</p>\n<h2 id=\"ensuring-library-version-compatibility\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2o4jqielq20wi30tul0uzimq0\">确保库版本兼容性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#ensuring-library-version-compatibility\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72k8bb3heyu020bfewvw1uwg7\">用于构建应用的 Angular 版本应始终与用于构建其任何依赖库的 Angular 版本相同或更大。比如，如果你有一个使用 Angular 13 版的库，则依赖于该库的应用应该使用 Angular 13 版或更高版本。Angular 不支持为该应用使用早期版本。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5yxu23zlu6gvxeeu6nbox0xyw\">如果打算将库发布到 npm，请通过在 <code>tsconfig.prod.json</code> 的 <code>\"compilationMode\": \"partial\"</code> 来使用部分 Ivy 代码进行编译。这种部分格式在不同版本的 Angular 之间是稳定的，因此可以安全地发布到 npm。这种格式的代码在应用程序构建期间会使用相同版本的 Angular 编译器进行处理，以确保应用程序及其所有库使用的是同一个版本的 Angular。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"75jlq9qjrhywoz32hignxhgfi\">如果要发布到 npm，请避免使用完全 Ivy 的方式编译库，因为生成的 Ivy 指令不属于 Angular 公共 API 的一部分，因此在补丁版本之间可能会有所不同。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74m6iwfcafae9m7rof8tl9rsa\">如果你以前从未在 npm 中发布过软件包，则必须创建一个用户帐户。在<a href=\"https://docs.npmjs.com/getting-started/publishing-npm-packages\">发布 npm 程序包</a>中了解更多信息。</p>\n<h2 id=\"consuming-partial-ivy-code-outside-the-angular-cli\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ntgb0gaxtvbqltfhe0d02alw\">在 Angular CLI 之外使用部分 Ivy 代码<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#consuming-partial-ivy-code-outside-the-angular-cli\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9bojhjtqotk3gdrilvgiz95sg\">应用将 npm 中的许多 Angular 库安装到其 <code>node_modules</code> 目录中。但是，这些库中的代码不能与已编译的应用直接捆绑在一起，因为它尚未完全编译。要完成编译，可以使用 Angular 链接器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"20evgmt84sn41q6c0j66hlh67\">对于不使用 Angular CLI 的应用程序，此链接器可用作 <a href=\"https://babeljs.io\">Babel</a> 插件。该插件要从 <code>@angular/compiler-cli/linker/babel</code> 导入。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b1mgul1eyw3kv1w8ibtp8aam\">Angular 链接器的 Babel 插件支持构建缓存，这意味着链接器只需一次处理库，而与其他 npm 操作无关。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2nfessm9txlnxt4k91r73rx58\">下面的例子借助 <a href=\"https://webpack.js.org/loaders/babel-loader/#options\">babel-loader</a> 把此链接器注册为 <a href=\"https://babeljs.io\">Babel</a> 插件，从而将此插件集成到自定义 <a href=\"https://webpack.js.org\">Webpack</a> 构建中。</p>\n<code-example header=\"webpack.config.mjs\" path=\"angular-linker-plugin/webpack.config.mjs\" region=\"webpack-config\">\nimport linkerPlugin from '@angular/compiler-cli/linker/babel';\n\nexport default {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.m?js$/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            plugins: [linkerPlugin],\n            compact: false,\n            cacheDirectory: true,\n          }\n        }\n      }\n    ]\n  }\n  // ...\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"exqsrko55t9wcwi3w7obdnxz3\">Angular CLI 自动集成了链接器插件，因此，如果你这个库的使用方也在使用 CLI，则他们可以从 npm 安装 Ivy 原生库，而无需任何其他配置。</p>\n</div>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/angular-package-format\n - guide/cli-builder\n - guide/file-structure\n - guide/glossary\n - guide/libraries\n - guide/npm-packages\n-->\n<!-- links from this doc:\n - api/router/RouterModule\n - guide/angular-package-format/#exports\n - guide/aot-compiler\n - guide/architecture-services#providing-services\n - guide/creating-libraries#building-and-rebuilding-your-library\n - guide/creating-libraries#consuming-partial-ivy-code-outside-the-angular-cli\n - guide/creating-libraries#creating-libraries\n - guide/creating-libraries#ensuring-library-version-compatibility\n - guide/creating-libraries#getting-started\n - guide/creating-libraries#integrating-with-the-cli-using-code-generation-schematics\n - guide/creating-libraries#ivy-libraries\n - guide/creating-libraries#managing-assets-in-a-library\n - guide/creating-libraries#peer-dependencies\n - guide/creating-libraries#publishing-libraries\n - guide/creating-libraries#publishing-your-library\n - guide/creating-libraries#refactoring-parts-of-an-application-into-a-library\n - guide/creating-libraries#using-your-own-library-in-applications\n - guide/file-structure\n - guide/file-structure#library-project-files\n - guide/file-structure#multiple-projects\n - guide/glossary#schematic\n - guide/lightweight-injection-tokens\n - guide/schematics\n - guide/schematics-for-libraries\n - guide/singleton-services\n - https://babeljs.io\n - https://docs.npmjs.com/getting-started/publishing-npm-packages\n - https://github.com/ng-packagr/ng-packagr/blob/master/README.md\n - https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md\n - https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md\n - https://material.angular.io/cdk/layout/overview#breakpointobserver\n - https://material.angular.io/components/sidenav/overview\n - https://material.angular.io/components/toolbar/overview\n - https://material.angular.io/guide/schematics#navigation-schematic\n - https://unpkg.com/browse/@angular/material/package.json\n - https://webpack.js.org\n - https://webpack.js.org/loaders/babel-loader/#options\n - https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\n-->"}