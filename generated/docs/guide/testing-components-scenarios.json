{"id":"guide/testing-components-scenarios","title":"组件测试场景","contents":"<div class=\"content\">\n  <h1 id=\"component-testing-scenarios\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5jpibp6n1zq28ouc6cp4r5kw\">组件测试场景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-testing-scenarios\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ak09en2cgla03f6r1qkq5f1z1\">本指南探讨了一些常见的组件测试用例。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jhe3g7pull8hzqtm08p46wf0\">如果你要试验本指南中所讲的应用，请<live-example name=\"testing\" nodownload=\"\">在浏览器中运行它</live-example>或<live-example name=\"testing\" downloadonly=\"\">下载并在本地运行它</live-example>。</p>\n</div>\n<h2 id=\"component-binding\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f0asb3p38hvlasskxr2g0unas\">组件绑定<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-binding\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"erfedx5mtoy0pzf6al5o407n6\">在范例应用中，<code>BannerComponent</code> 在 HTML 模板中展示了静态的标题文本。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xt4akepqvsnnuh33ekb25imk\">在少许更改之后，<code>BannerComponent</code> 就会通过绑定组件的 <code>title</code> 属性来渲染动态标题。</p>\n<code-example header=\"app/banner/banner.component.ts\" path=\"testing/src/app/banner/banner.component.ts\" region=\"component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-banner',\n  template: '&lt;h1&gt;{{title}}&lt;/h1&gt;',\n  styles: ['h1 { color: green; font-size: 350%}'],\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1iloqyl55ypown3lm3s1skia8\">尽管这很小，但你还是决定要添加一个测试来确认该组件实际显示的是你认为合适的内容。</p>\n<h4 id=\"query-for-the-h1\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44kzpueoxej3fhdoockdsu98r\">查询 <code>&lt;h1&gt;</code> 元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#query-for-the-h1\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9up2flg02aeljodm0j6j4hjyx\">你将编写一系列测试来检查 <code>&lt;h1&gt;</code> 元素中包裹的 <em>title</em> 属性插值绑定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dje2f7dkplza23h52yyethiuy\">你可以修改 <code>beforeEach</code> 以找到带有标准 HTML <code>querySelector</code> 的元素，并把它赋值给 <code>h1</code> 变量。</p>\n<code-example header=\"app/banner/banner.component.spec.ts (setup)\" path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"setup\">\nlet component: BannerComponent;\nlet fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&lt;BannerComponent&gt;;\nlet h1: HTMLElement;\n\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    imports: [BannerComponent],\n  });\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance; // BannerComponent test instance\n  h1 = fixture.nativeElement.querySelector('h1');\n});\n\n</code-example>\n<p><a id=\"detect-changes\"></a></p>\n<h4 id=\"createcomponent-does-not-bind-data\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ja68deaxx19zhbv39r6tvblk\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code> 不绑定数据<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#createcomponent-does-not-bind-data\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2f851s9zxzckdoswjaxpco0sg\">对于你的第一个测试，你希望屏幕上显示默认的 <code>title</code>。你的直觉就是编写一个能立即检查 <code>&lt;h1&gt;</code> 的测试，就像这样：</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"expect-h1-default-v1\">\nit('should display original title', () =&gt; {\n  expect(h1.textContent).toContain(component.title);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2dqpzcuuu30mwevl5n2wbl0nv\"><em>那个测试失败</em>了：</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\nexpected '' to contain 'Test Tour of Heroes'.\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"422huc53i246yaaem1j9lm5br\"><strong>当 Angular 执行变更检测</strong>时就会发生绑定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66bmb3sbnidi9g9c9dwqg8vhu\">在生产环境中，当 Angular 创建一个组件，或者用户输入按键，或者异步活动（比如 AJAX）完成时，就会自动进行变更检测。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"diwe8eojg5qlilq97n6t9m9ua\">该 <code>TestBed.createComponent</code> <em>不会</em>触发变化检测，修改后的测试可以证实这一点：</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"test-w-o-detect-changes\">\nit('no title in the DOM after <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()', () =&gt; {\n  expect(h1.textContent).toEqual('');\n});\n\n</code-example>\n<h4 id=\"detectchanges\"><code>detectChanges()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#detectchanges\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eye1s8wbn4jtej4aj64q58911\">你必须通过调用 <code>fixture.detectChanges()</code> 来告诉 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 执行数据绑定。只有这样，<code>&lt;h1&gt;</code> 才能拥有预期的标题。</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"expect-h1-default\">\nit('should display original title after detectChanges()', () =&gt; {\n  fixture.detectChanges();\n  expect(h1.textContent).toContain(component.title);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51yd4uadsplvmd6c5zmd8jo46\">这里延迟变更检测时机是故意而且有用的。这样才能让测试者在 Angular 启动数据绑定并调用<a href=\"guide/lifecycle-hooks\">生命周期钩子</a>之前，查看并更改组件的状态。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46hf55079ndq85x7vg8elnxrx\">这是另一个测试，它会在调用 <code>fixture.detectChanges()</code> <em>之前</em>改变组件的 <code>title</code> 属性。</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"after-change\">\nit('should display a different test title', () =&gt; {\n  component.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  fixture.detectChanges();\n  expect(h1.textContent).toContain('Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>');\n});\n\n</code-example>\n<p><a id=\"auto-detect-changes\"></a></p>\n<h4 id=\"automatic-change-detection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d9dphvlbvnlcqv7ql0p7bc2zr\">自动变更检测<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#automatic-change-detection\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"67kw3f10c7etrll6slzlv28f6\"><code>BannerComponent</code> 测试会经常调用 <code>detectChanges</code>。一些测试人员更喜欢让 Angular 测试环境自动运行变更检测。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"237ql38jq4nzohmnwtqa5rabc\">可以通过配置带有 <code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code> 提供者的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 来实现这一点。我们首先从测试工具函数库中导入它：</p>\n<code-example header=\"app/banner/banner.component.detect-changes.spec.ts (import)\" path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"import-ComponentFixtureAutoDetect\">\nimport { <a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a> } from '@angular/core/testing';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f3xbom95bbm35awdgyvuopd3u\">然后把它添加到测试模块配置的 <code>providers</code> 中：</p>\n<code-example header=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect)\" path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect\">\nTestBed.configureTestingModule({\n  imports: [BannerComponent],\n  providers: [{ provide: <a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a>, useValue: true }],\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eu7pt1x656xdovf9quymkcrw4\">这里有三个测试来说明自动变更检测是如何工作的。</p>\n<code-example header=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect Tests)\" path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect-tests\">\nit('should display original title', () =&gt; {\n  // Hooray! No `fixture.detectChanges()` needed\n  expect(h1.textContent).toContain(comp.title);\n});\n\nit('should still see original title after comp.title change', () =&gt; {\n  const oldTitle = comp.title;\n  comp.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  // Displayed title is old because Angular didn't hear the change :(\n  expect(h1.textContent).toContain(oldTitle);\n});\n\nit('should display updated title after detectChanges', () =&gt; {\n  comp.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  fixture.detectChanges(); // detect changes explicitly\n  expect(h1.textContent).toContain(comp.title);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"be5qqigl841bsssz3greu05ff\">第一个测试显示了自动变更检测的优点。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eq7f7ghb0fridmv0ouhva9ois\">第二个和第三个测试则揭示了一个重要的限制。该 Angular 测试环境<em>不</em>知道测试改变了组件的 <code>title</code>。<code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code> 服务会响应<em>异步活动，</em>比如 Promise、定时器和 DOM 事件。但却看不见对组件属性的直接同步更新。该测试必须用 <code>fixture.detectChanges()</code> 来触发另一个变更检测周期。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5nsckb6r63dacjwagtvll05u1\">本指南中的范例总是会<em>显式</em>调用 <code>detectChanges()</code>，而不用困惑于测试夹具何时会或不会执行变更检测。更频繁的调用 <code>detectChanges()</code> 毫无危害，没必要只在非常必要时才调用它。</p>\n</div>\n<p><a id=\"dispatch-event\"></a></p>\n<h4 id=\"change-an-input-value-with-dispatchevent\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4fw79hwe97bzhokivsexr5qbf\">使用  <code>dispatchEvent()</code> 改变输入框的值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#change-an-input-value-with-dispatchevent\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2r0rzwasaj3ue69uzd2e9g427\">要模拟用户输入，你可以找到 input 元素并设置它的 <code>value</code> 属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bucusr3q99wcxkxfijsy6zeqr\">你会调用 <code>fixture.detectChanges()</code> 来触发 Angular 的变更检测。但还有一个重要的中间步骤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5i0oozs2salh77nhrccxwq16q\">Angular 并不知道你为 input 设置过 <code>value</code> 属性。在通过调用 <code>dispatchEvent()</code> 分发 <code>input</code> 事件之前，它不会读取该属性。<em>紧接着</em>你就调用了 <code>detectChanges()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"esidsmwffl3td2l6t9h9nisei\">下列例子说明了正确的顺序。</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (pipe test)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"title-case-pipe\">\nit('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () =&gt; {\n  // get the name's input and display elements from the DOM\n  const hostElement: HTMLElement = harness.routeNativeElement!;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input')!;\n  const nameDisplay: HTMLElement = hostElement.querySelector('span')!;\n\n  // simulate user entering a new name into the input box\n  nameInput.value = 'quick BROWN  fOx';\n\n  // Dispatch a DOM event so that Angular learns of input value change.\n  nameInput.dispatchEvent(new <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>('input'));\n\n  // Tell Angular to update the display binding through the title pipe\n  harness.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});\n\n\n</code-example>\n<h2 id=\"component-with-external-files\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tupz2zj58o18z446ljjyvnee\">包含外部文件的组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-external-files\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f13qjaidf8a1519jwx85w25o0\">上面的 <code>BannerComponent</code> 是用<em>内联模板</em>和<em>内联 css</em> 定义的，它们分别是在 <code>@<a href=\"api/core/Component#template\" class=\"code-anchor\">Component.template</a></code> 和 <code>@<a href=\"api/core/Component#styles\" class=\"code-anchor\">Component.styles</a></code> 属性中指定的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ve3m6p37ssko6zzbmvh69igh\">很多组件都会分别用 <code>@<a href=\"api/core/Component#templateUrl\" class=\"code-anchor\">Component.templateUrl</a></code> 和 <code>@<a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">Component.styleUrls</a></code> 属性来指定<em>外部模板</em>和<em>外部 css</em>，就像下面的 <code>BannerComponent</code> 变体一样。</p>\n<code-example header=\"app/banner/banner-external.component.ts (metadata)\" path=\"testing/src/app/banner/banner-external.component.ts\" region=\"metadata\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-banner',\n  templateUrl: './banner-external.component.html',\n  styleUrls: ['./banner-external.component.css'],\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41nllu3k4zs2wf2vsgpkq16f6\">这个语法告诉 Angular 编译器要在组件编译时读取外部文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qgalt4ugkfnt4ugwbc1ppb14\">当运行 <code>ng test</code> 命令时，这不是问题，因为它会<em>在运行测试之前编译应用</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2d7y39kqjwf3vvn15l70rriab\">但是，如果在<strong>非 CLI 环境中</strong>运行这些测试，那么这个组件的测试可能会失败。比如，如果你在一个 web 编程环境（比如 <a href=\"https://plnkr.co\">plunker</a> 中运行 <code>BannerComponent</code> 测试，你会看到如下消息：</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nError: This test module uses the component BannerComponent\nwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26h08hhi9go7cwn71uv517toa\">当运行环境在测试过程中需要编译源代码时，就会得到这条测试失败的消息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2envmwzgjqc9hbgb0w8rggckg\">要解决这个问题，可以像 <a href=\"guide/testing-components-scenarios#compile-components\">调用 <code>compileComponents</code></a> 中讲的那样调用 <code>compileComponents()</code>。</p>\n<p><a id=\"component-with-dependency\"></a></p>\n<h2 id=\"component-with-a-dependency\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gc7b5p3txeu55fqumg6fbmqt\">具有依赖的组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-a-dependency\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"50nquo5snywxvj44c3c0fyazg\">组件通常都有服务依赖。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c4ul77bqmn0vikkz1ohjljmbx\"><code>WelcomeComponent</code> 会向登录用户显示一条欢迎信息。它可以基于注入进来的 <code>UserService</code> 的一个属性了解到用户是谁：</p>\n<code-example header=\"app/welcome/welcome.component.ts\" path=\"testing/src/app/welcome/welcome.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { UserService } from '../<a href=\"api/core/model\" class=\"code-anchor\">model</a>/user.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-welcome',\n  template: '&lt;h3 class=\"welcome\"&gt;&lt;i&gt;{{welcome}}&lt;/i&gt;&lt;/h3&gt;',\n})\nexport class WelcomeComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  welcome = '';\n  constructor(private userService: UserService) {}\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn\n      ? 'Welcome, ' + this.userService.user.name\n      : 'Please log in.';\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5d5igk6x4lvuxmn3q84kys0t1\"><code>WelcomeComponent</code> 拥有与该服务交互的决策逻辑，该逻辑让这个组件值得测试。这是 spec 文件的测试模块配置：</p>\n<code-example header=\"app/welcome/welcome.component.spec.ts\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"config-test-module\">\nTestBed.configureTestingModule({\n  imports: [WelcomeComponent],\n  // providers: [ UserService ],  // NO! Don't provide the real service!\n  // Provide a test-double instead\n  providers: [{ provide: UserService, useValue: userServiceStub }],\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"130pyhgnwn5c40bkg40dnid12\">这次，除了声明<em>被测组件外</em>，该配置还在 <code>providers</code> 列表中加入了 <code>UserService</code> 提供者。但它不是真正的 <code>UserService</code>。</p>\n<p><a id=\"service-test-doubles\"></a></p>\n<h4 id=\"provide-service-test-doubles\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1w4q8bm5nr807s5qarba8g1kj\">为服务提供测试替身<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#provide-service-test-doubles\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6dlaxuh01y0fo41rcjt90lzbq\"><em>待测组件</em>不必注入真正的服务。事实上，如果它们是测试替身，比如 stubs，fakes，spies 或 mocks，通常会更好。该测试规约的目的是测试组件，而不是服务，使用真正的服务可能会遇到麻烦。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"frroue5e7u7cb9s2eyczbpun\">注入真正的 <code>UserService</code> 可能是个噩梦。真正的服务可能要求用户提供登录凭据，并尝试访问认证服务器。这些行为可能难以拦截。为它创建并注册一个测试专用版来代替真正的 <code>UserService</code> 要容易得多，也更安全。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1v9fdptud33pt9541zq0t5hn\">这个特定的测试套件提供了 <code>UserService</code> 的最小化模拟，它满足了 <code>WelcomeComponent</code> 及其测试的需求：</p>\n<code-example header=\"app/welcome/welcome.component.spec.ts\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"user-service-stub\">\nlet userServiceStub: Partial&lt;UserService&gt;;\n\n  userServiceStub = {\n    isLoggedIn: true,\n    user: { name: 'Test User' },\n  };\n\n</code-example>\n<p><a id=\"get-injected-service\"></a></p>\n<h4 id=\"get-injected-services\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"45778uy3p2czps47kn5uge4uw\">取得所注入的服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#get-injected-services\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"m9c4d7trvxi7ktxc5qvtz855\">这些测试需要访问注入到 <code>WelcomeComponent</code> 中的 <code>UserService</code> 桩。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6m40dxfh1l1ky52h73n1y1jk3\">Angular 有一个多级注入系统。它具有多个层级的注入器，从 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 创建的根注入器开始，直到组件树中的各个层级。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5s0h29h0cwhx4n7xrf9p22nxo\">获得注入服务的最安全的方式（<strong>始终有效</strong>），就是<strong><em>从被测组件</em>的注入器中获取它</strong>。组件注入器是测试夹具所提供的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 中的一个属性。</p>\n<code-example header=\"WelcomeComponent's injector\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"injected-service\">\n// UserService actually injected into the component\nuserService = fixture.debugElement.injector.get(UserService);\n\n</code-example>\n<p><a id=\"testbed-inject\"></a></p>\n<h4 id=\"testbedinject\"><code>TestBed.inject()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#testbedinject\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bykps41qltgo5kag1c4xc2gyk\">你<em>可能</em>还可以通过 <code>TestBed.inject()</code> 来从根注入器获得服务。这更容易记忆，也不那么啰嗦。但这只有当 Angular 要把根注入器中的服务实例注入测试组件时才是可行的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dum5381r5qlac7mhucv800jkv\">在下面这个测试套件中，<code>UserService</code><em>唯一的</em>提供者是根测试模块，因此可以安全地调用 <code>TestBed.inject()</code>，如下所示：</p>\n<code-example header=\"TestBed injector\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"inject-from-testbed\">\n// UserService from the root injector\nuserService = TestBed.inject(UserService);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vktz7n1i2esnmw2xjf1mdyff\"><code>TestBed.inject()</code> 不起作用的用例，参阅<a href=\"guide/testing-components-scenarios#component-override\"><em>“覆盖组件提供者”</em></a>部分，它解释了何时以及为什么必须从该组件自身的注入器中获取该服务。</p>\n</div>\n<p><a id=\"welcome-spec-setup\"></a></p>\n<h4 id=\"final-setup-and-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2jcr1xsg9s2nvsca1wo5rjso\">最后的设置与测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#final-setup-and-tests\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"czfxhpvfhc15ugzvuek4r9anu\">这里是完成的 <code>beforeEach()</code>，它使用了 <code>TestBed.inject()</code>：</p>\n<code-example header=\"app/welcome/welcome.component.spec.ts\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"setup\">\nlet userServiceStub: Partial&lt;UserService&gt;;\n\nbeforeEach(() =&gt; {\n  // stub UserService for test purposes\n  userServiceStub = {\n    isLoggedIn: true,\n    user: { name: 'Test User' },\n  };\n\n  TestBed.configureTestingModule({\n    imports: [WelcomeComponent],\n    providers: [{ provide: UserService, useValue: userServiceStub }],\n  });\n\n  fixture = TestBed.createComponent(WelcomeComponent);\n  comp = fixture.componentInstance;\n\n  // UserService from the root injector\n  userService = TestBed.inject(UserService);\n\n  //  get the \"welcome\" element by CSS selector (e.g., by class name)\n  el = fixture.nativeElement.querySelector('.welcome');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlp37v1vnodhqg9bs8toz03x2\">以下是一些测试：</p>\n<code-example header=\"app/welcome/welcome.component.spec.ts\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"tests\">\nit('should welcome the user', () =&gt; {\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).withContext('\"Welcome ...\"').toContain('Welcome');\n  expect(content).withContext('expected name').toContain('Test User');\n});\n\nit('should welcome \"Bubba\"', () =&gt; {\n  userService.user.name = 'Bubba'; // welcome message hasn't been shown yet\n  fixture.detectChanges();\n  expect(el.textContent).toContain('Bubba');\n});\n\nit('should request login if not logged in', () =&gt; {\n  userService.isLoggedIn = false; // welcome message hasn't been shown yet\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).withContext('not welcomed').not.toContain('Welcome');\n  expect(content)\n    .withContext('\"log in\"')\n    .toMatch(/log in/i);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ab103lnr8m8r3s4yhd20qd61i\">首先是一个健全性测试；它确认了桩服务 <code>UserService</code> 被调用过并能正常工作。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dueb1rf00lnlbvxpn9rdq2hna\">Jasmine 匹配器的第二个参数（比如 <code>'expected name'</code>）是一个可选的失败标签。如果此期望失败，Jasmine 就会把这个标签贴到期望失败的消息中。在具有多个期望的测试规约中，它可以帮我们澄清出现了什么问题以及都有哪些期望失败了。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8oztbnowfapmjh4fddh3q6xxh\">当该服务返回不同的值时，其余的测试会确认该组件的逻辑。第二个测试验证了更改用户名的效果。当用户未登录时，第三个测试会检查组件是否显示了正确的消息。</p>\n<p><a id=\"component-with-async-service\"></a></p>\n<h2 id=\"component-with-async-service\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"89pawgl0p7g1f5jqz1hlsyba5\">带异步服务的组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-async-service\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"edm9ff239y53dlmyg0xhu3kh1\">在这个例子中，<code>AboutComponent</code> 模板托管了一个 <code>TwainComponent</code>。<code>TwainComponent</code> 会显示马克·吐温的名言。</p>\n<code-example header=\"app/twain/twain.component.ts (template)\" path=\"testing/src/app/twain/twain.component.ts\" region=\"template\">\ntemplate: ` &lt;p class=\"twain\"&gt;\n    &lt;i&gt;{{ quote | async }}&lt;/i&gt;\n  &lt;/p&gt;\n  &lt;button type=\"button\" (click)=\"getQuote()\"&gt;Next quote&lt;/button&gt;\n  &lt;p class=\"error\" *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"errorMessage\"&gt;{{ errorMessage }}&lt;/p&gt;`,\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9kxi1kdmhqr0kwhssqirw7g19\"><strong>注意</strong>：<br>\n组件的 <code>quote</code> 属性的值通过 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code> 传递。这意味着该属性会返回 <code>Promise</code> 或 <code>Observable</code>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvoy9ncp0swpo3fhe67akgmok\">在这个例子中，<code>TwainComponent.getQuote()</code> 方法告诉你 <code>quote</code> 属性会返回一个 <code>Observable</code>。</p>\n<code-example header=\"app/twain/twain.component.ts (getQuote)\" path=\"testing/src/app/twain/twain.component.ts\" region=\"get-quote\">\ngetQuote() {\n  this.errorMessage = '';\n  this.quote = this.twainService.getQuote().pipe(\n    startWith('...'),\n    catchError((err: any) =&gt; {\n      // Wait a turn because errorMessage already set once this turn\n      setTimeout(() =&gt; (this.errorMessage = err.message || err.toString()));\n      return of('...'); // reset message to placeholder\n    }),\n  );\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2teug54wdj3d09zfbb0x7a8s\">该 <code>TwainComponent</code> 从注入的 <code>TwainService</code> 中获取名言。该在服务能返回第一条名言之前，该服务会先返回一个占位流（<code>'...'</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9063i5m0fs2f5n9xip7kid8rp\"><code>catchError</code> 会拦截服务错误，准备一条错误信息，并在流的成功通道上返回占位值。它必须等一拍（tick）才能设置 <code>errorMessage</code>，以免在同一个变更检测周期内更新此消息两次。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3sjgc24129i86m7ewydreookt\">这些都是你想要测试的特性。</p>\n<h4 id=\"testing-with-a-spy\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dzqjwahmrwy6h4ebjinsilcm\">使用间谍（spy）进行测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#testing-with-a-spy\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c34utfe2vm8zbhez8itios3jh\">在测试组件时，只有该服务的公开 API 才有意义。通常，测试本身不应该调用远程服务器。它们应该模拟这样的调用。这个 <code>app/twain/twain.component.spec.ts</code> 中的环境准备工作展示了一种方法：</p>\n<code-example header=\"app/twain/twain.component.spec.ts (setup)\" path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"setup\">\nbeforeEach(() =&gt; {\n  testQuote = 'Test Quote';\n\n  // Create a fake TwainService object with a `getQuote()` spy\n  const twainService = jasmine.createSpyObj('TwainService', ['getQuote']);\n  // Make the spy return a synchronous Observable with the test data\n  getQuoteSpy = twainService.getQuote.and.returnValue(of(testQuote));\n\n  TestBed.configureTestingModule({\n    imports: [TwainComponent],\n    providers: [{ provide: TwainService, useValue: twainService }],\n  });\n\n  fixture = TestBed.createComponent(TwainComponent);\n  component = fixture.componentInstance;\n  quoteEl = fixture.nativeElement.querySelector('.twain');\n});\n\n</code-example>\n<p><a id=\"service-spy\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cup3iu7q744k00p8r29o1ww04\">仔细看一下这个间谍。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"spy\">\n// Create a fake TwainService object with a `getQuote()` spy\nconst twainService = jasmine.createSpyObj('TwainService', ['getQuote']);\n// Make the spy return a synchronous Observable with the test data\ngetQuoteSpy = twainService.getQuote.and.returnValue(of(testQuote));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7z4dwzy5y9fn5akjyq18wy9pc\">这个间谍的设计目标是让所有对 <code>getQuote</code> 的调用都会收到一个带有测试名言的可观察对象。与真正的 <code>getQuote()</code> 方法不同，这个间谍会绕过服务器，并返回一个立即同步提供可用值的可观察对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5g60gwz61nrhzwgzdf0kxccc4\">虽然这个 <code>Observable</code> 是同步的，但你也可以用这个间谍编写很多有用的测试。</p>\n<p><a id=\"sync-tests\"></a></p>\n<h4 id=\"synchronous-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7xhnk8619g2837p7eu6z4vjwu\">同步测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#synchronous-tests\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7429epq70gbzzgay4gvwkt7i0\">同步 <code>Observable</code> 的一个关键优势是，你通常可以把异步过程转换成同步测试。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"sync-test\">\nit('should show quote after component initialized', () =&gt; {\n  fixture.detectChanges(); // onInit()\n\n  // sync spy result shows testQuote immediately after init\n  expect(quoteEl.textContent).toBe(testQuote);\n  expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cnpxwg1v8igf4a8syzuqjvfo\">当间谍的结果同步返回时，<code>getQuote()</code> 方法会在第一个变更检测周期（Angular 在这里调用 <code>ngOnInit</code>）<em>后</em>立即更新屏幕上的消息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dbb6fqtr6lmlm5t66pmmpi08n\">你在测试错误路径时就没有这么幸运了。虽然服务间谍会同步返回一个错误，但该组件方法会调用 <code>setTimeout()</code>。在值可用之前，测试必须等待 JavaScript 引擎的至少一个周期。因此，该测试必须是<em>异步的</em>。</p>\n<p><a id=\"fake-async\"></a></p>\n<h4 id=\"async-test-with-fakeasync\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51kfmo595l7qkcm0dot8gqfgl\">使用 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 进行异步测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#async-test-with-fakeasync\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ezcd0cri00yd6b8959pktptz\">要使用\n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>功能，必须在测试设置文件中导入\n<code>zone.js/testing</code>。 如果使用Angular CLI创建项目，则已经为您添加了\n<code>zone-testing</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"273rfgrzqzbuurnack4vk6bgw\">当该服务返回 <code>ErrorObservable</code> 时，下列测试会对其预期行为进行确认。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"error-test\">\nit('should display error when TwainService fails', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  // tell spy to return an error observable\n  getQuoteSpy.and.returnValue(throwError(() =&gt; new Error('TwainService test failure')));\n  fixture.detectChanges(); // onInit()\n  // sync spy errors immediately after init\n\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the component's setTimeout()\n\n  fixture.detectChanges(); // update errorMessage within setTimeout()\n\n  expect(errorMessage())\n    .withContext('should display error')\n    .toMatch(/test failure/);\n  expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');\n}));\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jshxd5xnpt2aw70ttdo9hog2\"><strong>注意</strong>：<br>\n<code>it()</code> 函数会接收以下形式的参数。</p>\n</div>\n<code-example format=\"javascript\" language=\"javascript\">\n\n<a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; { /* test body */ })\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c31grd5t1426k8o7101ih55q\">通过在一个特殊的 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> test zone</code>（译注：Zone.js 的一个特例）中运行测试体，<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 函数可以启用线性编码风格。这个测试体看上去是同步的。没有像 <code>Promise.then()</code> 这样的嵌套语法来破坏控制流。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8lmwoq173tcw6lxq99l8lzxon\">限制：如果测试体要进行 <code>XMLHttpRequest</code>（XHR）调用，则 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 函数无效。很少会需要在测试中进行 XHR 调用，但如果你确实要这么做，请参阅 <a href=\"guide/testing-components-scenarios#waitForAsync\"><code>waitForAsync()</code></a> 部分。</p>\n</div>\n<p><a id=\"tick\"></a></p>\n<h4 id=\"the-tick-function\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58b46t8t1sm38zh8crs5upxdr\"><code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>()</code> 函数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-tick-function\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3lo7hr4qd6qjt72sd5qnrauu5\">必须调用\n<a href=\"api/core/testing/tick\">tick()</a>以推进虚拟时钟。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cf10z9mc2ad73aow6e22f7b9\">调用 \n<a href=\"api/core/testing/tick\">tick()</a> 函数模拟时间流逝，直到所有挂起的异步活动完成。在这种情况下，它会等待错误处理器的 \n<code>setTimeout()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8vzm15s9xwmw2v1eujwm4tnkf\"><a href=\"api/core/testing/tick\">tick()</a> 函数接受 \n<code>millis</code> 和 \n<code>tickOptions</code> 作为参数。其中，\n<code>millis</code> 参数指定虚拟时钟前进的时间，默认为 \n<code>0</code>。例如，如果在 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 测试中有一个 \n<code>setTimeout(fn, 100)</code>，你需要使用 \n<code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(100)</code> 来触发 fn 回调。可选的 \n<code>tickOptions</code> 参数具有一个名为 \n<code>processNewMacroTasksSynchronously</code> 的属性，表示在触发时是否调用新生成的宏任务，默认为 \n<code>true</code>。</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick\">\nit('should run timeout callback with delay after call <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> with millis', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  let called = false;\n  setTimeout(() =&gt; {\n    called = true;\n  }, 100);\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(100);\n  expect(called).toBe(true);\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1z172ljkioi48j8omaxsuhssg\"><a href=\"api/core/testing/tick\">tick()</a> 函数是 Angular 测试工具之一，你可以使用 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 导入它。它是 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 的伴侣，只能在 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 函数体内调用。</p>\n<h4 id=\"tickoptions\">tickOptions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#tickoptions\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cb2wz7bxu9no6hdpszbjdkrz2\">在此示例中，你有一个新的宏任务，即嵌套的 <code>setTimeout</code> 函数。默认情况下，当 <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a></code> 为 setTimeout 时，<code>outside</code> 和 <code>nested</code> 都将被触发。</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick-new-macro-task-sync\">\nit('should run new macro task callback with delay after call <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> with millis', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  function nestedTimer(cb: () =&gt; any): void {\n    setTimeout(() =&gt; setTimeout(() =&gt; cb()));\n  }\n  const callback = jasmine.createSpy('callback');\n  nestedTimer(callback);\n  expect(callback).not.toHaveBeenCalled();\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(0);\n  // the nested timeout will also be triggered\n  expect(callback).toHaveBeenCalled();\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"mj2p8pah7be6of7xt5vjbw00\">在某些情况下，你可能不想在滴答时触发新的宏任务。你可以用 <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(millis, {processNewMacroTasksSynchronously: false})</code> 来避免调用新的宏任务。</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick-new-macro-task-async\">\nit('should not run new macro task callback with delay after call <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> with millis', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  function nestedTimer(cb: () =&gt; any): void {\n    setTimeout(() =&gt; setTimeout(() =&gt; cb()));\n  }\n  const callback = jasmine.createSpy('callback');\n  nestedTimer(callback);\n  expect(callback).not.toHaveBeenCalled();\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(0, { processNewMacroTasksSynchronously: false });\n  // the nested timeout will not be triggered\n  expect(callback).not.toHaveBeenCalled();\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(0);\n  expect(callback).toHaveBeenCalled();\n}));\n\n</code-example>\n<h4 id=\"comparing-dates-inside-fakeasync\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"g4kka005dy2nvsa1m151s6ih\">在 fakeAsync() 中比较日期<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#comparing-dates-inside-fakeasync\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bc0vtw03rnvou2uu4ckbelm1q\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 可以模拟时间的流逝，以便让你计算出 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 里面的日期差。</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-date\">\nit('should get Date diff correctly in <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  const start = Date.now();\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(100);\n  const end = Date.now();\n  expect(end - start).toBe(100);\n}));\n\n</code-example>\n<h4 id=\"jasmineclock-with-fakeasync\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5g9x0bmh096pma20bwg37ofsm\">jasmine.clock 与 fakeAsync()<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#jasmineclock-with-fakeasync\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2sbz5rwsojdk776863bo1svef\">Jasmine 还为模拟日期提供了 <code>clock</code> 特性。而 Angular 会在 <code>jasmine.clock().install()</code> 于 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 方法内调用时自动运行这些测试。直到调用了 <code>jasmine.clock().uninstall()</code> 为止。<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 不是必须的，如果嵌套它就抛出错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2bdsyejyk6s39519zmf3zm816\">默认情况下，此功能处于禁用状态。要启用它，请在导入 <code>zone-testing</code> 之前先设置全局标志。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ox5hfhpvb7fr2df65xihu4bm\">如果你使用的是 Angular CLI，请在 <code>src/test.ts</code> 中配置这个标志。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n(window as any)['__zone_symbol__fakeAsyncPatchLock'] = true;\nimport 'zone.js/testing';\n\n</code-example>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-clock\">\ndescribe('use jasmine.clock()', () =&gt; {\n  // need to config __zone_symbol__fakeAsyncPatchLock flag\n  // before loading zone.js/testing\n  beforeEach(() =&gt; {\n    jasmine.clock().install();\n  });\n  afterEach(() =&gt; {\n    jasmine.clock().uninstall();\n  });\n  it('should auto enter <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>', () =&gt; {\n    // is in <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> now, don't need to call <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(testFn)\n    let called = false;\n    setTimeout(() =&gt; {\n      called = true;\n    }, 100);\n    jasmine.clock().tick(100);\n    expect(called).toBe(true);\n  });\n});\n\n</code-example>\n<h4 id=\"using-the-rxjs-scheduler-inside-fakeasync\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bljxy8bpr4niesixrxkrnumxq\">在 fakeAsync() 中使用 RxJS 调度程序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#using-the-rxjs-scheduler-inside-fakeasync\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2mzst8x5awm5s1yx9ju3grjc4\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 使用 RxJS 的调度器，就像使用 <code>setTimeout()</code> 或 <code>setInterval()</code> 一样，但你需要导入 <code>zone.js/plugins/zone-patch-rxjs-fake-async</code> 来给 RxJS 调度器打补丁。</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-rxjs\">\nit('should get Date diff correctly in <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> with rxjs scheduler', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async'\n  // to patch rxjs scheduler\n  let result = '';\n  of('hello')\n    .pipe(delay(1000))\n    .subscribe((v) =&gt; {\n      result = v;\n    });\n  expect(result).toBe('');\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(1000);\n  expect(result).toBe('hello');\n\n  const start = new Date().getTime();\n  let dateDiff = 0;\n  interval(1000)\n    .pipe(take(2))\n    .subscribe(() =&gt; (dateDiff = new Date().getTime() - start));\n\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(1000);\n  expect(dateDiff).toBe(1000);\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(1000);\n  expect(dateDiff).toBe(2000);\n}));\n\n</code-example>\n<h4 id=\"support-more-macrotasks\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6khmypguz3a7ivj0dq5xcw6u\">支持更多的 macroTasks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#support-more-macrotasks\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"epi3rp6vj2nkuzb41xq250nh6\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 默认支持以下宏任务。</p>\n<ul>\n<li><code>setTimeout</code></li>\n<li><code>setInterval</code></li>\n<li><code>requestAnimationFrame</code></li>\n<li><code>webkitRequestAnimationFrame</code></li>\n<li><code>mozRequestAnimationFrame</code></li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5dvicvj9y6i0o4mui72kvz6az\">如果你运行其他宏任务，比如 <code>HTMLCanvasElement.toBlob()</code>，就会抛出 <em>\"Unknown macroTask scheduled in fake async test\"</em> 错误。</p>\n<code-tabs>\n    <code-pane header=\"src/app/shared/canvas.component.spec.ts (failing)\" path=\"testing/src/app/shared/canvas.component.spec.ts\" region=\"without-toBlob-macrotask\">\nimport { <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> } from '@angular/core/testing';\n\nimport { CanvasComponent } from './canvas.component';\n\ndescribe('CanvasComponent', () =&gt; {\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    await TestBed.configureTestingModule({\n      imports: [CanvasComponent],\n    }).compileComponents();\n  });\n\n  it('should be able to generate blob data from canvas', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n    const fixture = TestBed.createComponent(CanvasComponent);\n    const canvasComp = fixture.componentInstance;\n\n    fixture.detectChanges();\n    expect(canvasComp.blobSize).toBe(0);\n\n    <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();\n    expect(canvasComp.blobSize).toBeGreaterThan(0);\n  }));\n});\n\n</code-pane>\n    <code-pane header=\"src/app/shared/canvas.component.ts\" path=\"testing/src/app/shared/canvas.component.ts\" region=\"main\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>, <a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'sample-canvas',\n  template: '&lt;canvas #sampleCanvas width=\"200\" height=\"200\"&gt;&lt;/canvas&gt;',\n})\nexport class CanvasComponent implements <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a> {\n  blobSize = 0;\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('sampleCanvas') sampleCanvas!: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n  ngAfterViewInit() {\n    const canvas: HTMLCanvasElement = this.sampleCanvas.nativeElement;\n    const context = canvas.getContext('2d')!;\n\n    context.clearRect(0, 0, 200, 200);\n    context.fillStyle = '#FF1122';\n    context.fillRect(0, 0, 200, 200);\n\n    canvas.toBlob((blob) =&gt; {\n      this.blobSize = blob?.size ?? 0;\n    });\n  }\n}\n\n</code-pane>\n</code-tabs>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ulqjpkhw7tlpcqa6m2884qnz\">如果你想支持这种情况，就要在 <code>beforeEach()</code> 定义你要支持的宏任务。比如：</p>\n<code-example header=\"src/app/shared/canvas.component.spec.ts (excerpt)\" path=\"testing/src/app/shared/canvas.component.spec.ts\" region=\"enable-toBlob-macrotask\">\nbeforeEach(() =&gt; {\n  (window as any).__zone_symbol__FakeAsyncTestMacroTask = [\n    {\n      source: 'HTMLCanvasElement.toBlob',\n      callbackArgs: [{ size: 200 }],\n    },\n  ];\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eadl771eykn1j9pozis1z3k8d\"><strong>注意</strong>：<br>\n要在依赖 Zone.js 的应用中使用 <code>&lt;canvas&gt;</code> 元素，你需要导入 <code>zone-patch-canvas</code> 补丁（或者在 <code>polyfills.ts</code> 中，或者在用到 <code>&lt;canvas&gt;</code> 的那个文件中）：</p>\n</div>\n<code-example header=\"src/polyfills.ts or src/app/shared/canvas.component.ts\" path=\"testing/src/app/shared/canvas.component.ts\" region=\"import-canvas-patch\">\n// Import patch to make <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> `HTMLCanvasElement` methods (such as `.toBlob()`) Zone.js-aware.\n// Either import in `polyfills.ts` (if used in more than one places in the app) or in the component\n// file using `HTMLCanvasElement` (if it is only used in a single file).\nimport 'zone.js/plugins/zone-patch-canvas';\n\n</code-example>\n<h4 id=\"async-observables\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a2syrkvav0rjr6ltkb6y9qp8x\">异步可观察对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#async-observables\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6bp7zynw5cwjcqzvzy13yp4gw\">你可能已经对前面这些测试的测试覆盖率感到满意。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ajz0d0yxcxxbv6tu0t4p3gc1\">但是，你可能也会为另一个事实感到不安：真实的服务并不是这样工作的。真实的服务会向远程服务器发送请求。服务器需要一定的时间才能做出响应，并且其响应体肯定不会像前面两个测试中一样是立即可用的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29r8tnt11rzgv6s8ytr54foob\">如果能像下面这样从 <code>getQuote()</code> 间谍中返回一个<em>异步的</em>可观察对象，你的测试就会更真实地反映现实世界。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"async-setup\">\n// Simulate delayed observable values with the `asyncData()` helper\ngetQuoteSpy.and.returnValue(asyncData(testQuote));\n\n</code-example>\n<h4 id=\"async-observable-helpers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"13lyh42xwxbspib1hohkfirxk\">异步可观察对象测试助手<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#async-observable-helpers\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zrpte3sxg68xsj39az8bwvc6\">异步可观察对象可以由测试助手 <code>asyncData</code> 生成。测试助手 <code>asyncData</code> 是一个你必须自行编写的工具函数，当然也可以从下面的范例代码中复制它。</p>\n<code-example header=\"testing/async-observable-helpers.ts\" path=\"testing/src/testing/async-observable-helpers.ts\" region=\"async-data\">\n/**\n * Create <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> observable that emits-once and completes\n * after a JS engine turn\n */\nexport function asyncData&lt;T&gt;(data: T) {\n  return defer(() =&gt; Promise.resolve(data));\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c5luofchbkwheg6cfi8r19tbj\">这个助手返回的可观察对象会在 JavaScript 引擎的下一个周期中发送 <code>data</code> 值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cfnky4locqzypktyk0fiejit\"><a href=\"http://reactivex.io/documentation/operators/defer.html\">RxJS 的 <code>defer()</code> 操作符</a>返回一个可观察对象。它的参数是一个返回 Promise 或可观察对象的工厂函数。当某个订阅者订阅 <em>defer</em> 生成的可观察对象时，defer 就会调用此工厂函数生成新的可观察对象，并让该订阅者订阅这个新对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"38uyp6zi7rskge9bx8cgsirpw\"><code>defer()</code> 操作符会把 <code>Promise.resolve()</code> 转换成一个新的可观察对象，它和 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 一样只会发送一次然后立即结束（complete）。这样，当订阅者收到数据后就会自动取消订阅。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3kkjegr84wd0vb2uq6r9qtfg6\">还有一个类似的用来生成异步错误的测试助手。</p>\n<code-example path=\"testing/src/testing/async-observable-helpers.ts\" region=\"async-error\">\n/**\n * Create <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> observable error that errors\n * after a JS engine turn\n */\nexport function asyncError&lt;T&gt;(errorObject: any) {\n  return defer(() =&gt; Promise.reject(errorObject));\n}\n\n</code-example>\n<h4 id=\"more-async-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e3pu8whi5ta5n9eelcvb0sajf\">更多异步测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#more-async-tests\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4khdyf4pknb628ht42x55hbii\">现在，<code>getQuote()</code> 间谍正在返回异步可观察对象，你的大多数测试都必须是异步的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2hm7fd2u1ddg8hqmo49hrc5lf\">下面是一个 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 测试，用于演示你在真实世界中所期望的数据流。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"fake-async-test\">\nit('should show quote after getQuote (<a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>)', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');\n\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observable to get the quote\n  fixture.detectChanges(); // update view\n\n  expect(quoteEl.textContent).withContext('should show quote').toBe(testQuote);\n  expect(errorMessage()).withContext('should not show error').toBeNull();\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4fy3pycuvzczlf72cayhiphcg\">注意，quote 元素会在 <code>ngOnInit()</code> 之后显示占位符 <code>'...'</code>。因为第一句名言尚未到来。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvgdxiu38d2cco0dpiq95d8p4\">要刷新可观察对象中的第一个引号，你需要调用 \n<a href=\"api/core/testing/tick\">tick()</a>。然后调用 \n<code>detectChanges()</code> 来告诉 Angular 更新屏幕。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xutq7f545hf4fff66b9zql41\">然后，你可以断言 quote 元素是否显示了预期的文本。</p>\n<p><a id=\"waitForAsync\"></a></p>\n<h4 id=\"async-test-with-waitforasync\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ytehlx8arvsgyn0dzlv4o7kk\">用 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 进行异步测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#async-test-with-waitforasync\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3tjwxfwf3s976dpfdyzanilho\">要使用 \n<code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 功能，你必须在测试设置文件中导入 \n<code>zone.js/testing</code>。如果你使用 Angular CLI 创建项目，\n<code>zone-testing</code> 已经为你添加了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"l8x3xmlq18gx0rnidv6a4ouu\">这是之前的 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 测试，用 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 工具函数重写的版本。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"waitForAsync-test\">\nit('should show quote after getQuote (<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>)', <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');\n\n  fixture.whenStable().then(() =&gt; {\n    // wait for <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> getQuote\n    fixture.detectChanges(); // update view with quote\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).withContext('should not show error').toBeNull();\n  });\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eqfioagm7ehx759b3z4srpt34\"><code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 工具函数通过把测试代码安排到在特殊的<em>异步测试区（async test zone）</em>下运行来隐藏某些用来处理异步的样板代码。你不需要把 Jasmine 的 <code>done()</code> 传给测试并让测试调用 <code>done()</code>，因为它在 Promise 或者可观察对象的回调函数中是 <code>undefined</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4putogow5fkddnw9fdvdt7uj4\">但是，可以通过调用 <code>fixture.whenStable()</code> 函数来揭示本测试的异步性，因为该函数打破了线性的控制流。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"319k7i1w64v5zvt6d9um19rmb\">在 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 中使用 <code>intervalTimer()</code>（比如 <code>setInterval()</code>）时，别忘了在测试后通过 <code>clearInterval()</code> 取消这个定时器，否则 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 永远不会结束。</p>\n<p><a id=\"when-stable\"></a></p>\n<h4 id=\"whenstable\"><code>whenStable</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#whenstable\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ml23jlhym4az0fx7go6etsru\">测试必须等待 \n<code>getQuote()</code> 可观察对象发出下一个引号。而不是调用 \n<a href=\"api/core/testing/tick\">tick()</a>，它调用 \n<code>fixture.whenStable()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9k05fc0yjlmrkv7bxgqufv1q7\"><code>fixture.whenStable()</code> 返回一个 Promise，它会在 JavaScript 引擎的任务队列变空时解析。在这个例子中，当可观察对象发出第一句名言时，任务队列就会变为空。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1np0agztt9j7o8casmbh6o7ff\">测试会在该 Promise 的回调中继续进行，它会调用 <code>detectChanges()</code> 来用期望的文本更新 quote 元素。</p>\n<p><a id=\"jasmine-done\"></a></p>\n<h4 id=\"jasmine-done\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"64v4s799jt45nzfmvgswaxsas\">Jasmine \n<code>done()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#jasmine-done\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azzdv9btrfmko6k0fwebuumlb\">虽然 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 和 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 函数可以大大简化 Angular 的异步测试，但你仍然可以回退到传统技术，并给 <code>it</code> 传一个以 <a href=\"https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support\"><code>done</code> 回调</a>为参数的函数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5f0m6jg1oea36jzwgsttwtrxn\">但你不能在 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 或 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 函数中调用 <code>done()</code>，因为那里的 <code>done</code> 参数是 <code>undefined</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"blmq3nau4h5odsdrg6t41id2t\">现在，你要自己负责串联各种 Promise、处理错误，并在适当的时机调用 <code>done()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amqwrdb1g660735y6sd2n7jv6\">编写带有 <code>done()</code> 的测试函数要比用 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 和 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 的形式笨重。但是当代码涉及到像 <code>setInterval</code> 这样的 <code>intervalTimer()</code> 时，它往往是必要的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"auovp3e6hnbdtavitqqgudds9\">这里是上一个测试的另外两种版本，用 <code>done()</code> 编写。第一个订阅了通过组件的 <code>quote</code> 属性暴露给模板的 <code>Observable</code>。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"quote-done-test\">\nit('should show last quote (quote done)', (done: DoneFn) =&gt; {\n  fixture.detectChanges();\n\n  component.quote.pipe(last()).subscribe(() =&gt; {\n    fixture.detectChanges(); // update view with quote\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).withContext('should not show error').toBeNull();\n    done();\n  });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6i0cqhvq0u5hg79e8obxyievj\">RxJS 的 <code>last()</code> 操作符会在完成之前发出可观察对象的最后一个值，它同样是测试名言。<code>subscribe</code> 回调会调用 <code>detectChanges()</code> 来使用测试名言刷新的 quote 元素，方法与之前的测试一样。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ico8eene3fg5twehgzndk0q8\">在某些测试中，你可能更关心注入的服务方法是如何被调的以及它返回了什么值，而不是屏幕显示的内容。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ax2e5koho8inrmsrqpffb0ica\">服务间谍，比如伪 <code>TwainService</code> 上的 <code>qetQuote()</code> 间谍，可以给你那些信息，并对视图的状态做出断言。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"spy-done-test\">\nit('should show quote after getQuote (spy done)', (done: DoneFn) =&gt; {\n  fixture.detectChanges();\n\n  // the spy's most recent call returns the observable with the test quote\n  getQuoteSpy.calls.mostRecent().returnValue.subscribe(() =&gt; {\n    fixture.detectChanges(); // update view with quote\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).withContext('should not show error').toBeNull();\n    done();\n  });\n});\n\n</code-example>\n<p><a id=\"marble-testing\"></a></p>\n<h2 id=\"component-marble-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2flqz2rbktkr322r731gly6ne\">组件的弹珠测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-marble-tests\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"egvxaj2v8u2gudffcs7082u33\">前面的 <code>TwainComponent</code> 测试通过 <code>asyncData</code> 和 <code>asyncError</code> 工具函数模拟了一个来自 <code>TwainService</code> 的异步响应体可观察对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5pcfofecuusi0itmoasnbcwzf\">你可以自己编写这些简短易用的函数。不幸的是，对于很多常见的场景来说，它们太简单了。可观察对象经常会发送很多次，可能是在经过一段显著的延迟之后。组件可以用重叠的值序列和错误序列来协调多个可观察对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72ofdwsy8yaq3za341h0hooyr\"><strong>RxJS 弹珠测试</strong>是一种测试可观察场景的好方法，它既简单又复杂。你很可能已经看过用于说明可观察对象是如何工作<a href=\"https://rxmarbles.com\">弹珠图</a>。弹珠测试使用类似的弹珠语言来指定测试中的可观察流和期望值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35pcad5gldcesffko6f1lxjky\">下面的例子用弹珠测试再次实现了 <code>TwainComponent</code> 中的两个测试。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f02hgkdt38eeoal5awvc0ez2i\">首先安装 npm 包 <code>jasmine-marbles</code>。然后导入你需要的符号。</p>\n<code-example header=\"app/twain/twain.component.marbles.spec.ts (import marbles)\" path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"import-marbles\">\nimport { cold, getTestScheduler } from 'jasmine-marbles';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ahzb4teblmwe85f8qx216j1pt\">获取名言的完整测试方法如下：</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"get-quote-test\">\nit('should show quote after getQuote (marbles)', () =&gt; {\n  // observable test quote value and complete(), after delay\n  const q$ = cold('---x|', { x: testQuote });\n  getQuoteSpy.and.returnValue(q$);\n\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');\n\n  getTestScheduler().flush(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observables\n\n  fixture.detectChanges(); // update view\n\n  expect(quoteEl.textContent).withContext('should show quote').toBe(testQuote);\n  expect(errorMessage()).withContext('should not show error').toBeNull();\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"edb8ukca66x5ou1mto5vk4rff\">注意，这个 Jasmine 测试是同步的。没有 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>。弹珠测试使用测试调度程序（scheduler）来模拟同步测试中的时间流逝。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b0uhtvjoqkcc59tbhqv7nzyiy\">弹珠测试的美妙之处在于对可观察对象流的视觉定义。这个测试定义了一个<a href=\"guide/testing-components-scenarios#cold-observable\"><em>冷</em>可观察对象</a>，它等待三<a href=\"guide/testing-components-scenarios#marble-frame\">帧</a>（<code>---</code>），发出一个值（<code>x</code>），并完成（<code>|</code>）。在第二个参数中，你把值标记（<code>x</code>）映射到了发出的值（<code>testQuote</code>）。</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"test-quote-marbles\">\nconst q$ = cold('---x|', { x: testQuote });\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2yo7gngw3es3p52ovd7cye0h0\">这个弹珠库会构造出相应的可观察对象，测试程序把它用作 <code>getQuote</code> 间谍的返回值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gqye8hvke21h1y4wfji72rbn\">当你准备好激活弹珠的可观察对象时，就告诉 <code>TestScheduler</code> 把它准备好的任务队列<em>刷新</em>一下。</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"test-scheduler-flush\">\ngetTestScheduler().flush(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observables\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cente6gdrjw98uce7uwhkg1sv\">这一步与之前 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 和 \n<code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 示例中的 \n<a href=\"api/core/testing/tick\">tick()</a> 和 \n<code>whenStable()</code> 类似。测试的其他部分与这些示例相同。</p>\n<h4 id=\"marble-error-testing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7n6xe9d8jwwgicoxiy7xqu6fi\">弹珠错误测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#marble-error-testing\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72isgvfkcedhgs20qqvuuysln\">下面是 <code>getQuote()</code> 错误测试的弹珠测试版。</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"error-test\">\nit('should display error when TwainService fails', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  // observable error after delay\n  const q$ = cold('---#|', null, new Error('TwainService test failure'));\n  getQuoteSpy.and.returnValue(q$);\n\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');\n\n  getTestScheduler().flush(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observables\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // component shows error after a setTimeout()\n  fixture.detectChanges(); // update error message\n\n  expect(errorMessage())\n    .withContext('should display error')\n    .toMatch(/test failure/);\n  expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zmt30wnr2uhirgd8s7tir1rr\">它仍然是异步测试，调用 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 和 <a href=\"api/core/testing/tick\">tick()</a>，因为该组件在处理错误时会调用 <code>setTimeout()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"m5udc7cf180y73roer1vkcy3\">看看这个弹珠的可观察定义。</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"error-marbles\">\nconst q$ = cold('---#|', null, new Error('TwainService test failure'));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43tib88dxe9sdqiefn1vmahk8\">这是一个<em>冷</em>可观察对象，等待三帧，然后发出一个错误，井号（<code>#</code>）标出了在第三个参数中指定错误的发生时间。第二个参数为 null，因为该可观察对象永远不会发出值。</p>\n<h4 id=\"learn-about-marble-testing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2a2c7dfw6lfhfjd7o4n5zwdw7\">了解弹珠测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#learn-about-marble-testing\"><i class=\"material-icons\">link</i></a></h4>\n<p><a id=\"marble-frame\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1hlvvnvmqzp3f7z0pqefdgodj\"><em>弹珠帧</em>是测试时间线上的虚拟单位。每个符号（<code>-</code>，<code>x</code>，<code>|</code>，<code>#</code>）都表示经过了一帧。</p>\n<p><a id=\"cold-observable\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7jf1fue4uk61q4feug142lk17\">冷可观察对象在订阅前不会产生值。大多数应用程序可观察对象都是冷的。所有 \n<a href=\"guide/understanding-communicating-with-http\"><em>HttpClient</em></a> 方法返回冷可观察对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a1ev4vn8d9py8w9rlbytdczbx\">而<em>热的</em>可观察对象在订阅它<em>之前</em>就已经在生成了这些值。用来报告路由器活动的 <a href=\"api/router/Router#events\"><code>Router.events</code></a> 可观察对象就是一种<em>热</em>可观察对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8se9zu65zyo5hx2n9uymdaizg\">RxJS 弹珠测试这个主题非常丰富，超出了本指南的范围。你可以在网上了解它，先从其<a href=\"https://rxjs.dev/guide/testing/marble-testing\">官方文档</a>开始。</p>\n<p><a id=\"component-with-input-output\"></a></p>\n<h2 id=\"component-with-inputs-and-outputs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6akltf74dkxr2nmj7g3zripof\">具有输入和输出属性的组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-inputs-and-outputs\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aahkeczgvqe66xi2moaexymy2\">具有输入和输出属性的组件通常会出现在宿主组件的视图模板中。宿主使用属性绑定来设置输入属性，并使用事件绑定来监听输出属性引发的事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1hx0jgd2ywi97x99pqc5lpysx\">本测试的目标是验证这些绑定是否如预期般工作。这些测试应该设置输入值并监听输出事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"acfwvlxhw8304giw7perl0adx\"><code>DashboardHeroComponent</code> 是这类组件的一个小例子。它会显示由 <code>DashboardComponent</code> 提供的一个英雄。点击这个英雄就会告诉 <code>DashboardComponent</code>，用户已经选择了此英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a31limhqwwj3hsibg7nkghqb7\"><code>DashboardHeroComponent</code> 会像这样内嵌在 <code>DashboardComponent</code> 模板中的：</p>\n<code-example header=\"app/dashboard/dashboard.component.html (excerpt)\" path=\"testing/src/app/dashboard/dashboard.component.html\" region=\"dashboard-hero\">\n&lt;dashboard-hero\n  *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"\n  class=\"col-1-4\"\n  [hero]=\"hero\"\n  (selected)=\"gotoDetail($event)\"\n&gt;\n&lt;/dashboard-hero&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c62nix4n89aziikt2xjhts5h9\"><code>DashboardHeroComponent</code> 出现在 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 复写器中，把它的输入属性 <code>hero</code> 设置为当前的循环变量，并监听该组件的 <code>selected</code> 事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8iuphrpgspoxeic7iudpmq98e\">这里是组件的完整定义：</p>\n<p><a id=\"dashboard-hero-component\"></a></p>\n<code-example header=\"app/dashboard/dashboard-hero.component.ts (component)\" path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'dashboard-hero',\n  template: `\n    &lt;button type=\"button\" (click)=\"click()\" class=\"hero\"&gt;\n      {{ hero.name | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a> }}\n    &lt;/button&gt;\n  `,\n  styleUrls: ['./dashboard-hero.component.css'],\n  imports: [<a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">UpperCasePipe</a>],\n})\nexport class DashboardHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() selected = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;Hero&gt;();\n  click() {\n    this.selected.emit(this.hero);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"da1qy45zna391vdzo5g6hz6l3\">在测试一个组件时，像这样简单的场景没什么内在价值，但值得了解它。你可以继续尝试这些方法：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zw4mcquoy3dninubu80dy65u\">用 <code>DashboardComponent</code> 来测试它。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwjqc304k7lr4a0gsp8yf7mmt\">把它作为一个独立的组件进行测试。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9z0danrblvrqr555ocpc92fd4\">用 <code>DashboardComponent</code> 的一个替代品来测试它。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2daf0y5s8yvr6zeeaxlxwa0p1\">快速看一眼 <code>DashboardComponent</code> 构造函数就知道不建议采用第一种方法：</p>\n<code-example header=\"app/dashboard/dashboard.component.ts (constructor)\" path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\">\nconstructor(\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  private heroService: HeroService,\n) {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51q1biw4uj1cpmtsnva1hu85o\"><code>DashboardComponent</code> 依赖于 Angular 的路由器和 <code>HeroService</code>。你可能不得不用测试替身来代替它们，这有很多工作。路由器看上去特别有挑战性。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cl9ltcozvtiqui7172ayksvu\"><a href=\"guide/testing-components-scenarios#routing-component\">下面的讨论</a>涵盖了如何测试那些需要用到路由器的组件。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cbz43fd7iiytv6ekhzz5kht9i\">当前的目标是测试 <code>DashboardHeroComponent</code>，而不是 <code>DashboardComponent</code>，所以试试第二个和第三个选项。</p>\n<p><a id=\"dashboard-standalone\"></a></p>\n<h4 id=\"test-dashboardherocomponent-stand-alone\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wq1b88co1sl5tho6ypzo59wg\">单独测试 <code>DashboardHeroComponent</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#test-dashboardherocomponent-stand-alone\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d9ucpbe0i5au54cvoq2ujv1f0\">这里是 spec 文件中环境设置部分的内容。</p>\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (setup)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"setup\">\nTestBed.configureTestingModule({\n  providers: appProviders,\n  imports: [DashboardHeroComponent],\n})\nfixture = TestBed.createComponent(DashboardHeroComponent);\ncomp = fixture.componentInstance;\n\n// find the hero's <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> and element\nheroDe = fixture.debugElement.query(By.css('.hero'));\nheroEl = heroDe.nativeElement;\n\n// mock the hero supplied by the parent component\nexpectedHero = { id: 42, name: 'Test Name' };\n\n// simulate the parent setting the input property with that hero\ncomp.hero = expectedHero;\n\n// <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> initial data binding\nfixture.detectChanges();\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1tlnik787nvutnvi5rihaj2x1\">注意这些设置代码如何把一个测试英雄（<code>expectedHero</code>）赋值给组件的 <code>hero</code> 属性的，它模仿了 <code>DashboardComponent</code> 在其复写器中通过属性绑定来设置它的方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhbxawydf079bm3cuvpsix68p\">下面的测试验证了英雄名是通过绑定传播到模板的。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"name-test\">\nit('should display hero name in uppercase', () =&gt; {\n  const expectedPipedName = expectedHero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71l9xp0xjxenkqqhn2k01i9nm\">因为<a href=\"guide/testing-components-scenarios#dashboard-hero-component\">模板</a>把英雄的名字传给了 <code><a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">UpperCasePipe</a></code>，所以测试必须要让元素值与其大写形式的名字一致。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cyd2ey00pqvvz1ifn9fqblik4\">这个小测试演示了 Angular 测试会如何验证一个组件的可视化表示形式 - 这是<a href=\"guide/testing-components-basics#component-class-testing\">组件类测试</a>所无法实现的 - 成本相对较低，无需进行更慢、更复杂的端到端测试。</p>\n</div>\n<h4 id=\"clicking\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xzyzhgy3ao0qjsswmxwjfnz0\">点击<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#clicking\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8niqxzg9qg6k46cg8lrx7xu9k\">单击该英雄应该会让一个宿主组件（可能是 <code>DashboardComponent</code>）监听到 <code>selected</code> 事件。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test\">\nit('should raise selected event when clicked (triggerEventHandler)', () =&gt; {\n  let selectedHero: Hero | undefined;\n  comp.selected.pipe(first()).subscribe((hero: Hero) =&gt; (selectedHero = hero));\n\n  heroDe.triggerEventHandler('click');\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f4kv4j6ud92xugi07u88n1vz1\">该组件的 <code>selected</code> 属性给消费者返回了一个 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>，它看起来像是 RxJS 的同步 <code>Observable</code>。该测试只有在宿主组件<em>隐式</em>触发时才需要<em>显式</em>订阅它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4qz5na1mf0jj7gmtzeolaca6r\">当组件的行为符合预期时，单击此英雄的元素就会告诉组件的 <code>selected</code> 属性发出了一个 <code>hero</code> 对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6mrm2xwtjftqy75bkk26dfmt\">该测试通过对 <code>selected</code> 的订阅来检测该事件。</p>\n<p><a id=\"trigger-event-handler\"></a></p>\n<h4 id=\"triggereventhandler\"><code>triggerEventHandler</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#triggereventhandler\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2txv3kkkokn0vbe7jd0kaphnn\">前面测试中的 <code>heroDe</code> 是一个指向英雄条目 <code>&lt;div&gt;</code> 的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dhr74g9pzokzkyddaunuflmpg\">它有一些用于抽象与原生元素交互的 Angular 属性和方法。这个测试会使用事件名称 <code>click</code> 来调用 <code>DebugElement.triggerEventHandler</code>。<code>click</code> 的事件绑定到了 <code>DashboardHeroComponent.click()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlppoouihcpcbszrlyioskd6d\">Angular 的 <code>DebugElement.triggerEventHandler</code> 可以用<strong>事件的名字</strong>触发<strong>任何数据绑定事件</strong>。第二个参数是传给事件处理器的事件对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cmfn670w9psrj9cixjnxwuidd\">该测试触发了一个 “click” 事件。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"trigger-event-handler\">\nheroDe.triggerEventHandler('click');\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68s6klqmouuxwkk5x2bgsm38i\">在这里，测试程序假设运行时间的事件处理器（组件的 <code>click()</code> 方法）不关心事件对象。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vrlkaeaz8fbokb3qvitemfpy\">其它处理器的要求比较严格。比如，<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令期望一个带有 <code>button</code> 属性的对象，该属性用于指出点击时按下的是哪个鼠标按钮（如果有）。如果不给出这个事件对象，<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令就会抛出一个错误。</p>\n</div>\n<h4 id=\"click-the-element\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7y6e4w4w8rkf5d29p98b3gn0r\">点击该元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#click-the-element\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dz63du0423sp1zvau7uob0adu\">下面这个测试改为调用原生元素自己的 <code>click()</code> 方法，它对于<em>这个组件</em>来说相当完美。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-2\">\nit('should raise selected event when clicked (element.click)', () =&gt; {\n  let selectedHero: Hero | undefined;\n  comp.selected.pipe(first()).subscribe((hero: Hero) =&gt; (selectedHero = hero));\n\n  heroEl.click();\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<p><a id=\"click-helper\"></a></p>\n<h4 id=\"click-helper\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aif2jhvpda4oimvqlgcdhr5z4\"><code>click()</code> 帮助器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#click-helper\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4aqbfipdljftyc329w5k5y05b\">点击按钮、链接或者任意 HTML 元素是很常见的测试任务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68iq7o40h99t7dlmta93jqyhe\">把<em>点击事件</em>的处理过程包装到如下的 <code>click()</code> 辅助函数中，可以让这项任务更一致、更简单：</p>\n<code-example header=\"testing/index.ts (click helper)\" path=\"testing/src/testing/index.ts\" region=\"click-event\">\n/** Button events to pass to `DebugElement.triggerEventHandler` for <a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a> event handler */\nexport const ButtonClickEvents = {\n  left: { button: 0 },\n  right: { button: 2 },\n};\n\n/** Simulate element click. Defaults to mouse left-button click event. */\nexport function click(\n  el: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> | HTMLElement,\n  eventObj: any = ButtonClickEvents.left,\n): void {\n  if (el instanceof HTMLElement) {\n    el.click();\n  } else {\n    el.triggerEventHandler('click', eventObj);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5penf8u6a4465908n3rp5nt7p\">第一个参数是<strong>用来点击的元素</strong>。如果你愿意，可以将自定义的事件对象传给第二个参数。默认的是（局部的）<a href=\"https://developer.mozilla.org/docs/Web/API/MouseEvent/button\">鼠标左键事件对象</a>，它被许多事件处理器接受，包括 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26eis6yj7ij5dxvven5bk2zm6\"><code>click()</code> 辅助函数<strong>不是</strong>Angular 测试工具之一。它是在<strong>本章的例子代码</strong>中定义的函数方法，被所有测试例子所用。如果你喜欢它，将它添加到你自己的辅助函数集。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dj3pfjwvn51x7so63un6fl749\">下面是把前面的测试用 <code>click</code> 辅助函数重写后的版本。</p>\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (test with click helper)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-3\">\nit('should raise selected event when clicked (click helper with <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>)', () =&gt; {\n  let selectedHero: Hero | undefined;\n  comp.selected.pipe(first()).subscribe((hero: Hero) =&gt; (selectedHero = hero));\n\n  click(heroDe); // click helper with <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>\n\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<p><a id=\"component-inside-test-host\"></a></p>\n<h2 id=\"component-inside-a-test-host\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d5o8ljbojifmr4s6e99zljc9e\">位于测试宿主中的组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-inside-a-test-host\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cv7i0kkpmseyl6t7x3qnhpz22\">前面的这些测试都是自己扮演宿主元素 <code>DashboardComponent</code> 的角色。但是当 <code>DashboardHeroComponent</code> 真的绑定到某个宿主元素时还能正常工作吗？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aprkwxjx7upqj6uzou625dagv\">固然，你也可以测试真实的 <code>DashboardComponent</code>。但要想这么做需要做很多准备工作，特别是它的模板中使用了某些特性，如 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>、 其它组件、布局 HTML、附加绑定、注入了多个服务的构造函数、如何用正确的方式与那些服务交互等。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cfxhty0gg3eri0rnfywmhmjxm\">想出这么多需要努力排除的干扰，只是为了证明一点 —— 可以造出这样一个令人满意的<em>测试宿主</em>：</p>\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (test host)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  imports: [DashboardHeroComponent],\n  template: ` &lt;dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"&gt; &lt;/dashboard-hero&gt;`,\n})\nclass TestHostComponent {\n  hero: Hero = { id: 42, name: 'Test Name' };\n  selectedHero: Hero | undefined;\n  onSelected(hero: Hero) {\n    this.selectedHero = hero;\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"17aybcmy96iv5ycte2esh48s9\">这个测试宿主像 <code>DashboardComponent</code> 那样绑定了 <code>DashboardHeroComponent</code>，但是没有 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>、 没有 <code>HeroService</code>，也没有 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5supqa8fgis1d4p97t5nrbyeo\">这个测试宿主使用其测试用的英雄设置了组件的输入属性 <code>hero</code>。它使用 <code>onSelected</code> 事件处理器绑定了组件的 <code>selected</code> 事件，其中把事件中发出的英雄记录到了 <code>selectedHero</code> 属性中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"erja8a5shvuxp3c8tpkeacdpi\">稍后，这个测试就可以轻松检查 <code>selectedHero</code> 以验证 <code>DashboardHeroComponent.selected</code> 事件确实发出了所期望的英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"351dk5uiyfvr7jbv9hhhfzjhv\">这个<em>测试宿主</em>中的准备代码和独立测试中的准备过程类似：</p>\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (test host setup)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-setup\">\nTestBed.configureTestingModule({\n  providers: appProviders,\n  imports: [DashboardHeroComponent, TestHostComponent],\n})\n// create TestHostComponent instead of DashboardHeroComponent\nfixture = TestBed.createComponent(TestHostComponent);\ntestHost = fixture.componentInstance;\nheroEl = fixture.nativeElement.querySelector('.hero');\nfixture.detectChanges(); // <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> initial data binding\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jfbtwpmyvq9rt3ckck3jt0mr\">这个测试模块的配置信息有三个重要的不同点：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5rae7zv6g9qtme1wonzo7cjzl\">它同时<strong>声明</strong>了 <code>DashboardHeroComponent</code> 和 <code>TestHostComponent</code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63riq2qpe5fg1azmmrs48crps\">它<strong>创建</strong>了 <code>TestHostComponent</code>，而非 <code>DashboardHeroComponent</code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ecimwegy6rhzj0bh9z3j70inz\"><code>TestHostComponent</code> 通过绑定机制设置了 <code>DashboardHeroComponent.hero</code>。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8t6ic5ucnwj8n1ljsgo4p5pf\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code> 返回的 <code>fixture</code> 里有 <code>TestHostComponent</code> 实例，而非 <code>DashboardHeroComponent</code> 组件实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3qw0dewurmhn36gf1oqy4g567\">当然，创建 <code>TestHostComponent</code> 有创建 <code>DashboardHeroComponent</code> 的副作用，因为后者出现在前者的模板中。英雄元素（<code>heroEl</code>）的查询语句仍然可以在测试 DOM 中找到它，尽管元素树比以前更深。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7zxbrdygjmsirjboyh9sh9103\">这些测试本身和它们的孤立版本几乎相同：</p>\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (test-host)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-tests\">\nit('should display hero name', () =&gt; {\n  const expectedPipedName = testHost.hero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\nit('should raise selected event when clicked', () =&gt; {\n  click(heroEl);\n  // selected hero should be the same data bound hero\n  expect(testHost.selectedHero).toBe(testHost.hero);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2cxz6e9kheiq6yshgc27mty8b\">只有 selected 事件的测试不一样。它确保被选择的 <code>DashboardHeroComponent</code> 英雄确实通过事件绑定被传递到宿主组件。</p>\n<p><a id=\"routing-component\"></a></p>\n<h2 id=\"routing-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9u7mq4pbjyv40jwu8gjh18zum\">路由组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#routing-component\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9kta34sephuj4ctyukhngrg7q\">所谓<em>路由组件</em>就是指会要求 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 导航到其它组件的组件。<code>DashboardComponent</code> 就是一个<em>路由组件</em>，因为用户可以通过点击仪表盘中的某个<em>英雄按钮</em>来导航到 <code>HeroDetailComponent</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e4wmlb91dnhmzguc50xrs4wjw\">路由确实很复杂。测试 <code>DashboardComponent</code> 看上去有点令人生畏，因为它牵扯到和 <code>HeroService</code> 一起注入进来的 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>。</p>\n<code-example header=\"app/dashboard/dashboard.component.ts (constructor)\" path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\">\nconstructor(\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  private heroService: HeroService,\n) {}\n\n</code-example>\n<code-example header=\"app/dashboard/dashboard.component.ts (goToDetail)\" path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"goto-detail\">\ngotoDetail(hero: Hero) {\n  const url = `/heroes/${hero.id}`;\n  this.router.navigateByUrl(url);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"apjl2mfdfkproi9zoeztrptqp\">Angular 提供了一些测试助手来减少样板代码并更有效地测试依赖于 Router 和 HttpClient 的代码。</p>\n<code-example header=\"app/dashboard/dashboard.component.spec.ts\" path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"router-harness\">\nTestBed.configureTestingModule(\n  Object.assign({}, appConfig, {\n    imports: [DashboardComponent],\n    providers: [\n      <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{ path: '**', component: DashboardComponent }]),\n      <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n      <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n      HeroService,\n    ],\n  }),\n)\n  .compileComponents()\n  .then(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    harness = await RouterTestingHarness.create();\n    comp = await harness.navigateByUrl('/', DashboardComponent);\n    TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>).expectOne('api/heroes').flush(getTestHeroes());\n  });\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aayupyjnkwj7ghgzy56yba92p\">下面这个测试会点击正在显示的英雄，并确认我们正在导航到所期望的 URL。</p>\n<code-example header=\"app/dashboard/dashboard.component.spec.ts (navigate test)\" path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"navigate-test\">\nit('should tell navigate when hero clicked', <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await heroClick(); // <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> click on first inner &lt;div class=\"hero\"&gt;\n\n  // expecting to navigate to id of the component's first hero\n  const id = comp.heroes[0].id;\n  expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url)\n    .withContext('should nav to HeroDetail for first hero')\n    .toEqual(`/heroes/${id}`);\n});\n\n</code-example>\n<p><a id=\"routed-component-w-param\"></a></p>\n<h2 id=\"routed-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ca0qb793u28asb2pr12abrcat\">路由目标组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#routed-components\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2cgyfr4ypowtxuc3qbbozwknd\"><em>路由目标组件</em>是指 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 导航到的目标。它测试起来可能很复杂，特别是当路由到的这个组件<em>包含参数</em>的时候。<code>HeroDetailComponent</code> 就是一个<em>路由目标组件</em>，它是某个路由定义指向的目标。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3zu6fvnyoqa2qemvfw1v8br04\">当用户点击<em>仪表盘</em>中的英雄时，<code>DashboardComponent</code> 会要求 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 导航到 <code>heroes/:id</code>。<code>:id</code> 是一个路由参数，它的值就是所要编辑的英雄的 <code>id</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4hmme4stz91wn12scw4tacayk\">该 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 会根据那个 URL 匹配到一个指向 <code>HeroDetailComponent</code> 的路由。它会创建一个带有路由信息的 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 对象，并把它注入到一个 <code>HeroDetailComponent</code> 的新实例中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b9lk3m1abbsp03d1o8dnz0gab\">下面是 <code>HeroDetailComponent</code> 的构造函数：</p>\n<code-example header=\"app/hero/hero-detail.component.ts (constructor)\" path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ctor\">\nconstructor(\n  private heroDetailService: HeroDetailService,\n  private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n) {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44utcugltpmq0800aq9rhq6bh\"><code>HeroDetailComponent</code> 组件需要一个 <code>id</code> 参数，以便通过 <code>HeroDetailService</code> 获取相应的英雄。该组件只能从 <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 属性中获取这个 <code>id</code>，这个属性是一个 <code>Observable</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2f2b6ilfxcloxa5cyexcj6axs\">它不能仅仅引用 <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 的 <code>id</code> 属性。该组件不得不<em>订阅</em> <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 这个可观察对象，要做好它在生命周期中随时会发生变化的准备。</p>\n<code-example header=\"app/hero/hero-detail.component.ts (ngOnInit)\" path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ng-on-init\">\nngOnInit(): void {\n  // get hero when `id` param changes\n  this.route.paramMap.subscribe((pmap) =&gt; this.getHero(pmap.get('id')));\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8jfqapiio248t8f18tk0j8j5l\"><a href=\"guide/router-tutorial-toh\">路由教程：英雄之旅</a>一章的 <a href=\"guide/router-tutorial-toh#activated-route-in-action\">ActivatedRoute 实战</a>部分详细讲解了 <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"34a9aq4xsq8s5mq1crriyg3jz\">通过导航到不同的路由，测试可以探查 <code>HeroDetailComponent</code> 是如何对不同的 <code>id</code> 参数值做出响应的。</p>\n<h4 id=\"testing-with-the-routertestingharness\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6hj5gd4607xjxf6aqj3gshu0s\">使用 <code>ActivatedRouteStub</code> 进行测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#testing-with-the-routertestingharness\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2374t2d9s5zfixbfdxu1lrspv\">下面的测试程序是演示组件在被观察的 <code>id</code> 指向现有英雄时的行为：</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (existing id)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-good-id\">\ndescribe('when navigate to existing hero', () =&gt; {\n  let expectedHero: Hero;\n\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    expectedHero = firstHero;\n    await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(expectedHero.id);\n  });\n  it(\"should display that hero's name\", () =&gt; {\n    expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n  });\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"egsvfwrw9kj7xplplhymq9lvi\">稍后会对 <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code> 方法和 <code>page</code> 对象进行讨论。不过目前，你只要凭直觉来理解就行了。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35s151lkbccxpzrhi65adxj2u\">当找不到 <code>id</code> 的时候，组件应该重新路由到 <code>HeroListComponent</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6fgdve13s7yy4dyutd50t2acg\">测试套件的准备代码提供了一个和<a href=\"guide/testing-components-scenarios#routing-component\">前面</a>一样的路由器间谍，它会充当路由器的角色，而不用发起实际的导航。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ctw509cw2ylaocv2gryy70nh1\">这个测试中会期待该组件尝试导航到 <code>HeroListComponent</code>。</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (bad id)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-bad-id\">\ndescribe('when navigate to non-existent hero id', () =&gt; {\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(999);\n  });\n\n  it('should try to navigate back to hero list', () =&gt; {\n    expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes');\n  });\n});\n\n</code-example>\n<h2 id=\"nested-component-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b867kv4bibqcsucw7n6kky6hj\">对嵌套组件的测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#nested-component-tests\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80ejtb5xykj7ol81bc5jtwlt3\">组件的模板中通常还会有嵌套组件，嵌套组件的模板还可能包含更多组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d7qf3lcdpauhem95ozbcael1r\">这棵组件树可能非常深，并且大多数时候在测试这棵树顶部的组件时，这些嵌套的组件都无关紧要。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dcejotvqjvx3sjgcl5hnizzkn\">比如，<code>AppComponent</code> 会显示一个带有链接及其 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令的导航条。</p>\n<code-example header=\"app/app.component.html\" path=\"testing/src/app/app.component.html\">\n&lt;app-banner&gt;&lt;/app-banner&gt;\n&lt;app-welcome&gt;&lt;/app-welcome&gt;\n&lt;nav&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/dashboard\"&gt;Dashboard&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\"&gt;Heroes&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/about\"&gt;About&lt;/a&gt;\n&lt;/nav&gt;\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cgrfrqak7dztdznvovrvccuqf\">要想验证这些链接，你不必用 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 进行导航，也不必使用 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 来指出 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 应该把<em>路由目标组件</em>插入到什么地方。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b0trxeu42mq5umejpr2mfn1p0\">而 <code>BannerComponent</code> 和 <code>WelcomeComponent</code>（写作 <code>&lt;app-banner&gt;</code> 和 <code>&lt;app-welcome&gt;</code>）也同样风马牛不相及。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5o8kosjrwuuypvcitvfe0g8zd\">然而，任何测试，只要能在 DOM 中创建 <code>AppComponent</code>，也就同样能创建这三个组件的实例。如果要创建它们，你就要配置 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3zjkhnnjpfzfahohhc59bgw1t\">如果你忘了声明它们，Angular 编译器就无法在 <code>AppComponent</code> 模板中识别出 <code>&lt;app-banner&gt;</code>、<code>&lt;app-welcome&gt;</code> 和 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 标记，并抛出一个错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bee1eoienzsxfjz7fcv9dg1om\">如果你声明的这些都是真实的组件，那么也同样要声明<em>它们</em>的嵌套组件，并要为这棵组件树中的<em>任何</em>组件提供要注入的<em>所有</em>服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59aebrdhcs5i9hayt01xly9jq\">如果只是想回答关于链接的一些简单问题，做这些显然就太多了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bq6c8rjnospe6a114xflty2aw\">本节会讲减少此类准备工作的两项技术。单独使用或组合使用它们，可以让这些测试聚焦于要测试的主要组件上。</p>\n<p><a id=\"stub-component\"></a></p>\n<h5 id=\"stubbing-unneeded-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xf0j58xy8pd7945d3owxi2ei\">对不需要的组件提供桩（stub）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#stubbing-unneeded-components\"><i class=\"material-icons\">link</i></a></h5>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8p7ostyzclgvuoiz384s3kpy\">这项技术中，你要为那些在测试中无关紧要的组件或指令创建和声明一些测试桩。</p>\n<code-example header=\"app/app.component.spec.ts (stub declaration)\" path=\"testing/src/app/app.component.spec.ts\" region=\"component-stubs\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ standalone: true, selector: 'app-banner', template: '' })\nclass BannerStubComponent {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ standalone: true, selector: '<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>', template: '' })\nclass RouterOutletStubComponent {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ standalone: true, selector: 'app-welcome', template: '' })\nclass WelcomeStubComponent {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"zz9fqdgy67aho07tc4wekkda\">这些测试桩的选择器要和其对应的真实组件一致，但其模板和类是空的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wfmz4wgvubciyheu3b57cz81\">然后在 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的配置中那些真正有用的组件、指令、管道之后声明它们。</p>\n<code-example header=\"app/app.component.spec.ts (TestBed stubs)\" path=\"testing/src/app/app.component.spec.ts\" region=\"testbed-stubs\">\nTestBed.configureTestingModule(\n  Object.assign({}, appConfig, {\n    imports: [\n      AppComponent,\n      BannerStubComponent,\n      <a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>,\n      RouterOutletStubComponent,\n      WelcomeStubComponent,\n    ],\n    providers: [<a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([]), UserService],\n  }),\n)\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3hm7s5x7prju490spg5jb2yd9\"><code>AppComponent</code> 是该测试的主角，因此当然要用它的真实版本。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1oia9ptwsrcykit8zsdn1373m\">其它都是测试桩。</p>\n<p><a id=\"no-errors-schema\"></a></p>\n<h4 id=\"no_errors_schema\"><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#no_errors_schema\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4yar357kciry6hjcafsnymloe\">第二种办法就是把 <code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 添加到 <code>TestBed.schemas</code> 的元数据中。</p>\n<code-example header=\"app/app.component.spec.ts (NO_ERRORS_SCHEMA)\" path=\"testing/src/app/app.component.spec.ts\" region=\"no-errors-schema\">\nTestBed.configureTestingModule(\n  Object.assign({}, appConfig, {\n    imports: [\n      AppComponent,\n      <a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>,\n    ],\n    providers: [<a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([]), UserService],\n    schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>],\n  }),\n)\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cr5a083qzo65xg8mm9oyxkhm\"><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 会要求 Angular 编译器忽略不认识的那些元素和属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"88ffuxxshvhpzlkdzgbyn3q49\">编译器将会识别出 <code>&lt;app-root&gt;</code> 元素和 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 属性，因为你在 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的配置中声明了相应的 <code>AppComponent</code> 和 <code>RouterLinkDirectiveStub</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bmqcaj0vtv9cq2fuyie39ft58\">但编译器在遇到 <code>&lt;app-banner&gt;</code>、<code>&lt;app-welcome&gt;</code> 或 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 时不会报错。它只会把它们渲染成空白标签，而浏览器会忽略这些标签。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92rv6shqwij8w6w9rwlaw3lmt\">你不用再提供桩组件了。</p>\n<h4 id=\"use-both-techniques-together\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26luscwauyhxs3fsg5ps6hgx2\">同时使用这两项技术<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#use-both-techniques-together\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eao68ejtfk32rgtovoyovku0y\">这些是进行<em>浅层</em>测试要用到的技术，之所以叫浅层测试是因为只包含本测试所关心的这个组件模板中的元素。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2oncy3o1dmr7ya9ucza3i3mv\"><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 方法在这两者中比较简单，但也不要过度使用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e88ldsrilrgg6d4wp900o3d7i\"><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 还会阻止编译器告诉你因为的疏忽或拼写错误而缺失的组件和属性。你如果人工找出这些 bug 可能要浪费几个小时，但编译器可以立即捕获它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5doxb0pn8rtlgjz6x8nz517ys\"><em>桩组件</em>方式还有其它优点。虽然<em>这个</em>例子中的桩是空的，但你如果想要和它们用某种形式互动，也可以给它们一些裁剪过的模板和类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"avciyrauanr9iwma6awupxhwc\">在实践中，你可以在准备代码中组合使用这两种技术，例子如下。</p>\n<code-example header=\"app/app.component.spec.ts (mixed setup)\" path=\"testing/src/app/app.component.spec.ts\" region=\"mixed-setup\">\nTestBed.configureTestingModule(\n  Object.assign({}, appConfig, {\n    imports: [\n      AppComponent,\n      BannerStubComponent,\n      <a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>,\n    ],\n    providers: [<a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([]), UserService],\n    schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>],\n  }),\n)\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7hhb0qap6g2eg9ichvgv7zvnv\">Angular 编译器会为 <code>&lt;app-banner&gt;</code> 元素创建 <code>BannerStubComponent</code>，并把 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 应用到带有 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 属性的链接上，不过它会忽略 <code>&lt;app-welcome&gt;</code> 和 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 标签。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bpri5l03klwoxjt2sbi5na9l8\"><a id=\"by-directive\"></a>\n<a id=\"inject-directive\"></a></p>\n<h4 id=\"bydirective-and-injected-directives\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4dnqomcs6sfetld7m3znwer1z\"><code>By.directive</code> 与注入的指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#bydirective-and-injected-directives\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gpft9ec9qy1w4wrgwoc2f8m\">再一步配置触发了数据绑定的初始化，获取导航链接的引用：</p>\n<code-example header=\"app/app.component.spec.ts (test setup)\" path=\"testing/src/app/app.component.spec.ts\" region=\"test-setup\">\nbeforeEach(() =&gt; {\n  fixture.detectChanges(); // <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> initial data binding\n\n  // find DebugElements with an attached RouterLinkStubDirective\n  linkDes = fixture.debugElement.queryAll(By.directive(<a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>));\n\n  // get attached link directive instances\n  // using each <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>'s injector\n  routerLinks = linkDes.map((de) =&gt; de.injector.get(<a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>));\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3u9fdsznbwxcnxjxy6ncfdjsc\">有三点特别重要：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"36vn7ez0zlzzu1qdmzu8m1b07\">你可以使用 <code>By.directive</code> 来定位一个带附属指令的链接元素。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d1ferlr0swuybvi74i0vffoxf\">该查询返回包含了匹配元素的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 包装器。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3pmqbiv96c1hsbzcqgvmspmwy\">每个 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 都会导出该元素中的一个依赖注入器，其中带有指定的指令实例。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6adft3lczl7lmru73jdcq4z40\"><code>AppComponent</code> 中要验证的链接如下：</p>\n<code-example header=\"app/app.component.html (navigation links)\" path=\"testing/src/app/app.component.html\" region=\"links\">\n&lt;nav&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/dashboard\"&gt;Dashboard&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\"&gt;Heroes&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/about\"&gt;About&lt;/a&gt;\n&lt;/nav&gt;\n\n</code-example>\n<p><a id=\"app-component-tests\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cj73obu7i7zhp9y07a1qjpry9\">下面这些测试用来确认那些链接是否如预期般连接到了 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令中：</p>\n<code-example header=\"app/app.component.spec.ts (selected tests)\" path=\"testing/src/app/app.component.spec.ts\" region=\"tests\">\nit('can get RouterLinks from template', () =&gt; {\n  expect(routerLinks.length).withContext('should have 3 routerLinks').toBe(3);\n  expect(routerLinks[0].href).toBe('/dashboard');\n  expect(routerLinks[1].href).toBe('/heroes');\n  expect(routerLinks[2].href).toBe('/about');\n});\n\nit('can click Heroes link in template', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  const heroesLinkDe = linkDes[1]; // heroes link <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>\n\n  TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).resetConfig([{ path: '**', children: [] }]);\n  heroesLinkDe.triggerEventHandler('click', { button: 0 });\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();\n  fixture.detectChanges();\n\n  expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toBe('/heroes');\n}));\n\n</code-example>\n<p><a id=\"page-object\"></a></p>\n<h2 id=\"use-a-page-object\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d9qje71zra5eyw9hom3ehkiki\">使用 <code>page</code> 对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#use-a-page-object\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8c4x7ggqu8w6ltj4fmea6is95\"><code>HeroDetailComponent</code> 是带有标题、两个英雄字段和两个按钮的简单视图。</p>\n<div class=\"lightbox\">\n<img alt=\"HeroDetailComponent in action\" src=\"generated/images/guide/testing/hero-detail.component.png\" width=\"269\" height=\"170\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4rge93bafozg97ktx4m3w76q\">但即使是这么简单的表单，其模板中也涉及到不少复杂性。</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.html\" header=\"app/hero/hero-detail.component.html\">\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\"&gt;\n  &lt;h2&gt;\n    &lt;span&gt;{{ hero.name | <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">titlecase</a> }}&lt;/span&gt; Details\n  &lt;/h2&gt;\n  &lt;div&gt;&lt;span&gt;id: &lt;/span&gt;{{ hero.id }}&lt;/div&gt;\n  &lt;div&gt;\n    &lt;label for=\"name\"&gt;name: &lt;/label&gt;\n    &lt;input id=\"name\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" placeholder=\"name\" /&gt;\n  &lt;/div&gt;\n  &lt;button type=\"button\" (click)=\"save()\"&gt;Save&lt;/button&gt;\n  &lt;button type=\"button\" (click)=\"cancel()\"&gt;Cancel&lt;/button&gt;\n&lt;/div&gt;\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cg10ynzbf8uf2rxb3o9lph6p1\">这些供练习用的组件需要 ……</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eq1tj4793dhnlbpsa1wbsw5kz\">等获取到英雄之后才能让元素出现在 DOM 中</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5cu598a72n1z7fsn2tn8jit1l\">一个对标题文本的引用</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bd2zgtj8zktg78ituhv1p2rft\">一个对 name 输入框的引用，以便对它进行探查和修改</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uy3kwhnrvtt1fg1dqjsyeo2v\">引用两个按钮，以便点击它们</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bp3iz6dv31ps5x30zu471f1dc\">为组件和路由器的方法安插间谍</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bdv1cg0mw1m9xwdiukwh5wpfo\">即使是像这样一个很小的表单，也能产生令人疯狂的错综复杂的条件设置和 CSS 元素选择。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"am5sj0d79q0n6r9agf082vr6k\">可以使用 <code>Page</code> 类来征服这种复杂性。<code>Page</code> 类可以处理对组件属性的访问，并对设置这些属性的逻辑进行封装。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"67uuvaycjhu2omwzp1ew8ps1q\">下面是一个供 <code>hero-detail.component.spec.ts</code> 使用的 <code>Page</code> 类</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (Page)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"page\">\nclass Page {\n  // getter properties wait to <a href=\"api/animations/query\" class=\"code-anchor\">query</a> the DOM until called.\n  get buttons() {\n    return this.queryAll&lt;HTMLButtonElement&gt;('button');\n  }\n  get saveBtn() {\n    return this.buttons[0];\n  }\n  get cancelBtn() {\n    return this.buttons[1];\n  }\n  get nameDisplay() {\n    return this.query&lt;HTMLElement&gt;('span');\n  }\n  get nameInput() {\n    return this.query&lt;HTMLInputElement&gt;('input');\n  }\n\n  //// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> helpers ////\n  private <a href=\"api/animations/query\" class=\"code-anchor\">query</a>&lt;T&gt;(selector: string): T {\n    return harness.routeNativeElement!.querySelector(selector)! as T;\n  }\n\n  private queryAll&lt;T&gt;(selector: string): T[] {\n    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"36jp2xbsoqvhvygu6k3mx1u2\">现在，用来操作和检查组件的重要钩子都被井然有序的组织起来了，可以通过 <code>page</code> 实例来使用它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9qs68nfup4npf147co9eecu5t\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code> 方法会创建一个 <code>page</code> 对象，并在 <code>hero</code> 到来时自动填补空白。</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (createComponent)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"create-component\">\n<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> function <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(id: number) {\n  harness = await RouterTestingHarness.create();\n  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);\n  page = new Page();\n\n  const request = TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>).expectOne(`api/heroes/?id=${id}`);\n  const hero = getTestHeroes().find((h) =&gt; h.id === Number(id));\n  request.flush(hero ? [hero] : []);\n  harness.detectChanges();\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"akwr9l1qosfrfbwuaphrwh27b\">还有更多的 <code>HeroDetailComponent</code> 测试可以证明这一点。</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (selected tests)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"selected-tests\">\nit(\"should display that hero's name\", () =&gt; {\n  expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n});\n\nit('should navigate when click cancel', () =&gt; {\n  click(page.cancelBtn);\n  expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual(`/heroes/${expectedHero.id}`);\n});\n\nit('should save when click save but not navigate immediately', () =&gt; {\n  click(page.saveBtn);\n  expect(TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>).expectOne({ method: 'PUT', url: 'api/heroes' }));\n  expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes/41');\n});\n\nit('should navigate when click save and save resolves', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  click(page.saveBtn);\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // wait for <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> save to complete\n  expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes/41');\n}));\n\nit('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () =&gt; {\n  // get the name's input and display elements from the DOM\n  const hostElement: HTMLElement = harness.routeNativeElement!;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input')!;\n  const nameDisplay: HTMLElement = hostElement.querySelector('span')!;\n\n  // simulate user entering a new name into the input box\n  nameInput.value = 'quick BROWN  fOx';\n\n  // Dispatch a DOM event so that Angular learns of input value change.\n  nameInput.dispatchEvent(new <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>('input'));\n\n  // Tell Angular to update the display binding through the title pipe\n  harness.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});\n\n</code-example>\n<p><a id=\"compile-components\"></a></p>\n<h2 id=\"calling-compilecomponents\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56oq240vlwrcjj867ol39albx\">调用 <code>compileComponents()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#calling-compilecomponents\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d05l4xuic1110awa1kkrz80tu\">如果你<em>只想</em>使用 CLI 的 <code>ng test</code> 命令来运行测试，那么可以忽略这一节。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4spks1aa259148n67m7nne9k2\">如果你在<strong>非 CLI 环境</strong>中运行测试，这些测试可能会报错，错误信息如下：</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nError: This test module uses the component BannerComponent\nwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aus0eq4ywpi2a5jmepvg9gysg\">问题的根源在于这个测试中至少有一个组件引用了外部模板或外部 CSS 文件，就像下面这个版本的 <code>BannerComponent</code> 所示。</p>\n<code-example header=\"app/banner/banner-external.component.ts (external template &amp; css)\" path=\"testing/src/app/banner/banner-external.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-banner',\n  templateUrl: './banner-external.component.html',\n  styleUrls: ['./banner-external.component.css'],\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ayu3s6yieh4yi04tv9ts8ka6\">当 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 视图创建组件时，这个测试失败了。</p>\n<code-example avoid=\"\" header=\"app/banner/banner-external.component.spec.ts (setup that fails)\" path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"setup-may-fail\">\nbeforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await TestBed.configureTestingModule({\n    imports: [BannerComponent],\n  }); // missing call to compileComponents()\n  fixture = TestBed.createComponent(BannerComponent);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7fny46hsuupawp17vismv9izw\">回想一下，这个应用从未编译过。所以当你调用 <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code> 的时候，<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 就会进行隐式编译。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4kwy38s3zrwla8s5sx3t4sp8r\">当它的源码都在内存中的时候，这样做没问题。不过 <code>BannerComponent</code> 需要一些外部文件，编译时必须从文件系统中读取它，而这是一个天生的<em>异步</em>操作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7enqyqyn936p8qeiwiiiz23gd\">如果 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 继续执行，这些测试就会继续运行，并在编译器完成这些异步工作之前导致莫名其妙的失败。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56ght0bl8zvthwq8ybbauz7te\">这些错误信息告诉你要使用 <code>compileComponents()</code> 进行显式的编译。</p>\n<h4 id=\"compilecomponents-is-async\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dk7nawia0rg8fjkg3oh09chm\"><code>compileComponents()</code> 是异步的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#compilecomponents-is-async\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5gtaw6a789flsrbfamqxy3718\">你必须在异步测试函数中调用 <code>compileComponents()</code>。</p>\n<div class=\"alert is-critical\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41nab5wzs9l66rb66zll42n0z\">如果你忘了把测试函数标为异步的（比如忘了像稍后的代码中那样使用 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code>），就会看到下列错误。</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nError: ViewDestroyedError: Attempt to use a destroyed view\n\n</code-example>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ogf1axrgmc4dftw8mb1q70sf\">典型的做法是把准备逻辑拆成两个独立的 <code>beforeEach()</code> 函数：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dt2uvbdl3r7k4tmkiulzt8lb8\">函数</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"du2k0ot8dd85yee4gr9zf42g4\">异步 \n<code>beforeEach()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c56u2iatdmxbl3gg1o92k37x5\">编译组件</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5g2ncw2j80y78up5ntt2dcgnn\">同步 \n<code>beforeEach()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3f2tdtttkscvy1a04iwgphg4w\">执行剩余的设置</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"the-async-beforeeach\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"njhruait1bzaikt45w14e25n\">异步的 <code>beforeEach</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-async-beforeeach\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6yipia3l0nnx2k5u5qld7sfo8\">像下面这样编写第一个异步的 <code>beforeEach</code>。</p>\n<code-example header=\"app/banner/banner-external.component.spec.ts (async beforeEach)\" path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"async-before-each\">\nbeforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await TestBed.configureTestingModule({\n    imports: [BannerComponent],\n  }).compileComponents(); // compile template and css\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cje3k9y437gr60nioyrjlextj\"><code>TestBed.configureTestingModule()</code> 方法返回 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 类，所以你可以链式调用其它 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 中的静态方法，比如 <code>compileComponents()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74nyj1vf24c9jg62m1qdywmn4\">在这个例子中，<code>BannerComponent</code> 是仅有的待编译组件。其它例子中可能会使用多个组件来配置测试模块，并且可能引入某些具有其它组件的应用模块。它们中的任何一个都可能需要外部文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6h6g2w983h6bhw2jsuwwzdahm\"><code>TestBed.compileComponents</code> 方法会异步编译测试模块中配置过的所有组件。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2q9ie0mzerpzo25oe3z2uaxq6\">在调用了 <code>compileComponents()</code> 之后就不能再重新配置 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 了。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9d0sisv3pfviy5x9sdoitgvvj\">调用 <code>compileComponents()</code> 会关闭当前的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 实例，不再允许进行配置。你不能再调用任何 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 中的配置方法，既不能调 <code>configureTestingModule()</code>，也不能调用任何 <code>override...</code> 方法。如果你试图这么做，<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 就会抛出错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2ufugfuig078c4y2uihee773\">确保 <code>compileComponents()</code> 是调用 <code>TestBed.createComponent()</code> 之前的最后一步。</p>\n<h4 id=\"the-synchronous-beforeeach\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ckphykf0z3x2wguklmyepdlfj\">同步的 <code>beforeEach</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-synchronous-beforeeach\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ezsui7sbtsnoohc2x86089roz\">第二个同步 <code>beforeEach()</code> 的例子包含剩下的准备步骤，包括创建组件和查询那些要检查的元素。</p>\n<code-example header=\"app/banner/banner-external.component.spec.ts (synchronous beforeEach)\" path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"sync-before-each\">\nbeforeEach(() =&gt; {\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance; // BannerComponent test instance\n  h1 = fixture.nativeElement.querySelector('h1');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqlokmnx11k26sjpjw6hchxej\">测试运行器（runner）会先等待第一个异步 <code>beforeEach</code> 函数执行完再调用第二个。</p>\n<h4 id=\"consolidated-setup\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"275hecw5dasswv084vnlw1hda\">整理过的准备代码<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#consolidated-setup\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9l2iqffa5xlkod1ni7d8ytfo1\">你可以把这两个 <code>beforeEach()</code> 函数重整成一个异步的 <code>beforeEach()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qvqxdxofpna2cl2aw95yhsi1\"><code>compileComponents()</code> 方法返回一个 Promise，所以你可以通过把同步代码移到 <code>await</code> 关键字后面，在那里，这个 Promise 已经解析了。</p>\n<code-example header=\"app/banner/banner-external.component.spec.ts (one beforeEach)\" path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"one-before-each\">\nbeforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await TestBed.configureTestingModule({\n    imports: [BannerComponent],\n  }).compileComponents();\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance;\n  h1 = fixture.nativeElement.querySelector('h1');\n});\n\n</code-example>\n<h4 id=\"compilecomponents-is-harmless\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bq4x2wbiz3ms5wkidedg8n35r\"><code>compileComponents()</code> 是无害的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#compilecomponents-is-harmless\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9yiqkrnkkughrrs238uebn4e3\">在不需要 <code>compileComponents()</code> 的时候调用它也不会有害处。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1x6raz9ssnfk0j3sxcoq55xzt\">虽然在运行 <code>ng test</code> 时永远都不需要调用 <code>compileComponents()</code>，但 CLI 生成的组件测试文件还是会调用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9vrcabz52diuth4ewlrsby7em\">但这篇指南中的这些测试只会在必要时才调用 <code>compileComponents</code>。</p>\n<p><a id=\"import-module\"></a></p>\n<h2 id=\"setup-with-module-imports\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3sb9tbb1jmqxi0sbrd1nwelbh\">准备模块的 <code>imports</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#setup-with-module-imports\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5yj4pig6c3iql2s9krf4glahr\">此前的组件测试程序使用了一些 <code>declarations</code> 来配置模块，就像这样：</p>\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (configure TestBed)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"config-testbed\">\nTestBed.configureTestingModule({\n  providers: appProviders,\n  imports: [DashboardHeroComponent],\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2peumleole4tzo3pimpkjfm9\"><code>DashboardComponent</code> 非常简单。它不需要帮助。但是更加复杂的组件通常依赖其它组件、指令、管道和提供者，所以这些必须也被添加到测试模块中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"au4oa6nkcv0t6cmfzqmkp6tz0\">幸运的是，<code>TestBed.configureTestingModule</code> 参数与传入 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 装饰器的元数据一样，也就是所你也可以指定 <code>providers</code> 和 <code>imports</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"32kkg3jy7q71yy3ajzii4m1lq\">虽然 <code>HeroDetailComponent</code> 很小，结构也很简单，但是它需要很多帮助。除了从默认测试模块 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> 中获得的支持，它还需要：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5rsrsj1mu0jicfulmh00eiu6k\"><code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 里的 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 和其它，来进行双向数据绑定</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xa8ay7ox2nrw2i55asn6s9cu\"><code>shared</code> 目录里的 <code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"epcqqmd4fps64lqzarr97tmed\">路由器服务</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41hpllyksn3iof9rf1wi0wdd9\">英雄数据访问这些服务</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3rv6lwu7j7bkdaeckgqcmmx5g\">一种方法是从各个部分配置测试模块，就像这样：</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (FormsModule setup)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-forms-module\">\nbeforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await TestBed.configureTestingModule(\n    Object.assign({}, appConfig, {\n      imports: [<a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>, HeroDetailComponent, <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a>],\n      providers: [\n        <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n        <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n        <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{ path: 'heroes/:id', component: HeroDetailComponent }]),\n      ],\n    }),\n  ).compileComponents();\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58sjvoajd9f0vccrt0gp02cxw\">注意，<code>beforeEach()</code> 是异步的，它调用 <code>TestBed.compileComponents</code> 是因为 <code>HeroDetailComponent</code> 有外部模板和 CSS 文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uyvqrdpddpyhhn7k1x020ab4\">如<a href=\"guide/testing-components-scenarios#compile-components\">调用 <code>compileComponents()</code></a> 中所解释的那样，这些测试可以运行在非 CLI 环境下，那里 Angular 并不会在浏览器中编译它们。</p>\n</div>\n<h4 id=\"import-a-shared-module\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8j08sii3rhb6e3o6km7yvmgv6\">导入共享模块<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#import-a-shared-module\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8jthfri2fjtlor8zepoqkwg09\">因为很多应用组件都需要 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 和 <code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code>，所以开发者创建了 <code>SharedModule</code> 来把它们及其它常用的部分组合在一起。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2rpmit6om983te8fqk7gcx8bb\">这些测试配置也可以使用 <code>SharedModule</code>，如下所示：</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (SharedModule setup)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-shared-module\">\nbeforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await TestBed.configureTestingModule(\n    Object.assign({}, appConfig, {\n      imports: [HeroDetailComponent, sharedImports],\n      providers: [\n        <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{ path: 'heroes/:id', component: HeroDetailComponent }]),\n        <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n        <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n      ],\n    }),\n  ).compileComponents();\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2bdmvq9zfnmqrl5ei9na1hidz\">它的导入声明少一些，稍微干净一些，小一些，这个例子中未展示它。</p>\n<p><a id=\"feature-module-import\"></a></p>\n<h4 id=\"import-a-feature-module\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crgh806lzqxhf9p75u9dp6u8s\">导入特性模块<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#import-a-feature-module\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6neu34qn49l94i6hbkutfzo62\"><code>HeroDetailComponent</code> 是 <code>HeroModule</code> 这个<a href=\"guide/feature-modules\">特性模块</a>的一部分，它聚合了更多相互依赖的片段，包括 <code>SharedModule</code>。试试下面这个导入了 <code>HeroModule</code> 的测试配置：</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (HeroModule setup)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-hero-module\">\nbeforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await TestBed.configureTestingModule(\n    Object.assign({}, appConfig, {\n      imports: [HeroDetailComponent, HeroListComponent],\n      providers: [\n        <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([\n          { path: 'heroes/:id', component: HeroDetailComponent },\n          { path: 'heroes', component: HeroListComponent },\n        ]),\n        <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n        <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n      ],\n    }),\n  ).compileComponents();\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f4imy8wqug3756anrcjy6w347\">这样特别清爽。只有 <code>providers</code> 里面的测试替身被保留。连 <code>HeroDetailComponent</code> 声明都消失了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a11g5c8tuco32h8tssibqawem\">事实上，如果你试图声明它，Angular 就会抛出一个错误，因为 <code>HeroDetailComponent</code> 同时声明在了 <code>HeroModule</code> 和 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 创建的 <code>DynamicTestModule</code> 中。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aw9sq9k4w09bec5thdckl86d5\">如果模块中有很多共同依赖，并且该模块很小（这也是特性模块的应有形态），那么直接导入组件的特性模块可以成为配置这些测试的最佳方式。</p>\n</div>\n<p><a id=\"component-override\"></a></p>\n<h2 id=\"override-component-providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78zumly5k3ex6me9sk4ig5504\">改写组件的服务提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#override-component-providers\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4b4rnelrl6pexirajky2zxe4a\"><code>HeroDetailComponent</code> 提供自己的 <code>HeroDetailService</code> 服务。</p>\n<code-example header=\"app/hero/hero-detail.component.ts (prototype)\" path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"prototype\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-hero-detail',\n  templateUrl: './hero-detail.component.html',\n  styleUrls: ['./hero-detail.component.css'],\n  providers: [HeroDetailService],\n  imports: [sharedImports, <a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>],\n})\nexport class HeroDetailComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(\n    private heroDetailService: HeroDetailService,\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  ) {}\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eemr8nehlchf38p6rfzeve6an\">在 <code>TestBed.configureTestingModule</code> 的 <code>providers</code> 中 stub 伪造组件的 <code>HeroDetailService</code> 是不可行的。这些是<strong>测试模块</strong>的提供者，而非组件的。组件级别的提供者应该在<strong>fixture 级别</strong>的依赖注入器中进行准备。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ncr8lidy99tnie3p379jwr06\">Angular 会使用自己的注入器来创建这些组件，这个注入器是夹具的注入器的子注入器。它使用这个子注入器注册了该组件服务提供者（这里是 <code>HeroDetailService</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dmgnhcvhe1h6iwd6mqghrnm8v\">测试没办法从测试夹具的注入器中获取子注入器中的服务，而 <code>TestBed.configureTestingModule</code> 也没法配置它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"21gy9bv0pdz1l0o7sr7qfpo63\">Angular 始终都在创建真实 <code>HeroDetailService</code> 的实例。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8y7gqga1tezs9wye1k1hqot55\">如果 <code>HeroDetailService</code> 向远程服务器发出自己的 XHR 请求，这些测试可能会失败或者超时。这个远程服务器可能根本不存在。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71cj16a6q02kpbfq42aaug12b\">幸运的是，<code>HeroDetailService</code> 将远程数据访问的责任交给了注入进来的 <code>HeroService</code>。</p>\n<code-example header=\"app/hero/hero-detail.service.ts (prototype)\" path=\"testing/src/app/hero/hero-detail.service.ts\" region=\"prototype\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({ providedIn: 'root' })\nexport class HeroDetailService {\n  constructor(private heroService: HeroService) {}\n  /* . . . */\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3blzbfu1de43g1th50f7rxopq\"><a href=\"guide/testing-components-scenarios#feature-module-import\">前面的测试配置</a>使用 <code>TestHeroService</code> 替换了真实的 <code>HeroService</code>，它拦截了发往服务器的请求，并伪造了服务器的响应。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ujlesnkhih21kzujt3906llq\">如果你没有这么幸运怎么办？如果伪造 <code>HeroService</code> 很难怎么办？如果 <code>HeroDetailService</code> 自己发出服务器请求怎么办？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4gt02cye7uvpifgwh3w7b3or7\"><code>TestBed.overrideComponent</code> 方法可以将组件的 <code>providers</code> 替换为容易管理的<strong>测试替身</strong>，参阅下面的变体准备代码：</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (Override setup)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-override\">\nbeforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await TestBed.configureTestingModule(\n    Object.assign({}, appConfig, {\n      imports: [HeroDetailComponent, HeroListComponent],\n      providers: [\n        <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([\n          { path: 'heroes', component: HeroListComponent },\n          { path: 'heroes/:id', component: HeroDetailComponent },\n        ]),\n        <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>,\n        <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>,\n        // HeroDetailService at this level is IRRELEVANT!\n        { provide: HeroDetailService, useValue: {} },\n      ],\n    }),\n  )\n    .overrideComponent(HeroDetailComponent, {\n      set: { providers: [{ provide: HeroDetailService, useClass: HeroDetailServiceSpy }] },\n    })\n    .compileComponents();\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1icm3efa4z3qzdpzytncej7r2\">注意，<code>TestBed.configureTestingModule</code> 不再提供伪造的 <code>HeroService</code>，因为<a href=\"guide/testing-components-scenarios#spy-stub\">并不需要</a>。</p>\n<p><a id=\"override-component-method\"></a></p>\n<h4 id=\"the-overridecomponent-method\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"135z7jbukbsge8kx78q6zeoap\"><code>overrideComponent</code> 方法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-overridecomponent-method\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"et5wd2qgx00ss4hvkklh1gdsm\">注意这个 <code>overrideComponent</code> 方法。</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (overrideComponent)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-component-method\">\n.overrideComponent(HeroDetailComponent, {\n  set: { providers: [{ provide: HeroDetailService, useClass: HeroDetailServiceSpy }] },\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92q7a7ozdbgkfon29vu2k0vu3\">它接受两个参数：要改写的组件类型（<code>HeroDetailComponent</code>），以及用于改写的元数据对象。<a href=\"guide/testing-utility-apis#metadata-override-object\">用于改写的元数据对象</a>是一个泛型，其定义如下：</p>\n<code-example language=\"javascript\">\n\ntype <a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&lt;T&gt; = {\n  add?: Partial&lt;T&gt;;\n  remove?: Partial&lt;T&gt;;\n  set?: Partial&lt;T&gt;;\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c1lh2e2kbgkh1fhsws08xvi60\">元数据重载对象可以添加和删除元数据属性的项目，也可以彻底重设这些属性。这个例子重新设置了组件的 <code>providers</code> 元数据。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"57n2rpaw1cxgh8ch3qwetjyhy\">这个类型参数 <code>T</code> 就是你传给 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 装饰器的元数据：</p>\n<code-example language=\"javascript\">\n\nselector?: string;\ntemplate?: string;\ntemplateUrl?: string;\nproviders?: any[];\n…\n\n</code-example>\n<p><a id=\"spy-stub\"></a></p>\n<h4 id=\"provide-a-spy-stub-herodetailservicespy\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"649ip5u8lygkqxsd5bpfr523h\">提供 <em>间谍桩</em>（<code>HeroDetailServiceSpy</code>）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#provide-a-spy-stub-herodetailservicespy\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"207r7ony5uvimd8yc5sm44ohp\">这个例子把组件的 <code>providers</code> 数组完全替换成了一个包含 <code>HeroDetailServiceSpy</code> 的新数组。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7rpbnoly7jvfddt2hioz38g4p\"><code>HeroDetailServiceSpy</code> 是实际 <code>HeroDetailService</code> 服务的桩版本，它伪造了该服务的所有必要特性。但它既不需要注入也不会委托给低层的 <code>HeroService</code> 服务，因此不用为 <code>HeroService</code> 提供测试替身。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"de4tk14jnxgfkfy8c19l901jw\">通过对该服务的方法进行刺探，<code>HeroDetailComponent</code> 的关联测试将会对 <code>HeroDetailService</code> 是否被调用过进行断言。因此，这个桩类会把它的方法实现为刺探方法：</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (HeroDetailServiceSpy)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"hds-spy\">\nclass HeroDetailServiceSpy {\n  testHero: Hero = { ...testHero };\n\n  /* emit cloned test hero */\n  getHero = jasmine\n    .createSpy('getHero')\n    .and.callFake(() =&gt; asyncData(Object.assign({}, this.testHero)));\n\n  /* emit clone of test hero, with changes merged in */\n  saveHero = jasmine\n    .createSpy('saveHero')\n    .and.callFake((hero: Hero) =&gt; asyncData(Object.assign(this.testHero, hero)));\n}\n\n\n</code-example>\n<p><a id=\"override-tests\"></a></p>\n<h4 id=\"the-override-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ffh9bs7hgbf7j9rxeup6cj2e\">改写测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-override-tests\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e4l6c1scuxaozonp9wbjk4r5h\">现在，测试程序可以通过操控这个 spy-stub 的 <code>testHero</code>，直接控制组件的英雄，并确认那个服务方法被调用过。</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (override tests)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-tests\">\n  let hdsSpy: HeroDetailServiceSpy;\n\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    harness = await RouterTestingHarness.create();\n    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);\n    page = new Page();\n    // get the component's injected HeroDetailServiceSpy\n    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;\n\n    harness.detectChanges();\n  });\n\n  it('should have called `getHero`', () =&gt; {\n    expect(hdsSpy.getHero.calls.count())\n      .withContext('getHero called once')\n      .toBe(1, 'getHero called once');\n  });\n\n  it(\"should display stub hero's name\", () =&gt; {\n    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);\n  });\n\n  it('should save stub hero change', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n    const origName = hdsSpy.testHero.name;\n    const newName = 'New Name';\n\n    page.nameInput.value = newName;\n\n    page.nameInput.dispatchEvent(new <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>('input')); // tell Angular\n\n    expect(component.hero.name).withContext('component hero has new name').toBe(newName);\n    expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName);\n\n    click(page.saveBtn);\n    expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);\n\n    <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // wait for <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> save to complete\n    expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName);\n    expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes');\n  }));\n}\n\n////////////////////\nimport { getTestHeroes } from '../<a href=\"api/core/model\" class=\"code-anchor\">model</a>/testing/test-hero.service';\n\nconst firstHero = getTestHeroes()[0];\n\nfunction heroModuleSetup() {\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    await TestBed.configureTestingModule(\n      Object.assign({}, appConfig, {\n        imports: [HeroDetailComponent, HeroListComponent],\n        providers: [\n          <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([\n            { path: 'heroes/:id', component: HeroDetailComponent },\n            { path: 'heroes', component: HeroListComponent },\n          ]),\n          <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n          <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n        ],\n      }),\n    ).compileComponents();\n  });\n\n  describe('when navigate to existing hero', () =&gt; {\n    let expectedHero: Hero;\n\n    beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n      expectedHero = firstHero;\n      await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(expectedHero.id);\n    });\n    it(\"should display that hero's name\", () =&gt; {\n      expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n    });\n\n    it('should navigate when click cancel', () =&gt; {\n      click(page.cancelBtn);\n      expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual(`/heroes/${expectedHero.id}`);\n    });\n\n    it('should save when click save but not navigate immediately', () =&gt; {\n      click(page.saveBtn);\n      expect(TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>).expectOne({ method: 'PUT', url: 'api/heroes' }));\n      expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes/41');\n    });\n\n    it('should navigate when click save and save resolves', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n      click(page.saveBtn);\n      <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // wait for <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> save to complete\n      expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes/41');\n    }));\n\n    it('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () =&gt; {\n      // get the name's input and display elements from the DOM\n      const hostElement: HTMLElement = harness.routeNativeElement!;\n      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;\n      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;\n\n      // simulate user entering a new name into the input box\n      nameInput.value = 'quick BROWN  fOx';\n\n      // Dispatch a DOM event so that Angular learns of input value change.\n      nameInput.dispatchEvent(new <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>('input'));\n\n      // Tell Angular to update the display binding through the title pipe\n      harness.detectChanges();\n\n      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n    });\n\n  });\n\n  describe('when navigate to non-existent hero id', () =&gt; {\n    beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n      await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(999);\n    });\n\n    it('should try to navigate back to hero list', () =&gt; {\n      expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes');\n    });\n  });\n}\n\n/////////////////////\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a> } from '../shared/title-case.pipe';\nimport { appConfig } from '../app.config';\n\nfunction formsModuleSetup() {\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    await TestBed.configureTestingModule(\n      Object.assign({}, appConfig, {\n        imports: [<a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>, HeroDetailComponent, <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a>],\n        providers: [\n          <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n          <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n          <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{ path: 'heroes/:id', component: HeroDetailComponent }]),\n        ],\n      }),\n    ).compileComponents();\n  });\n\n  it(\"should display 1st hero's name\", <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    const expectedHero = firstHero;\n    await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(expectedHero.id).then(() =&gt; {\n      expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n    });\n  });\n}\n\n///////////////////////\n\nfunction sharedModuleSetup() {\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    await TestBed.configureTestingModule(\n      Object.assign({}, appConfig, {\n        imports: [HeroDetailComponent, sharedImports],\n        providers: [\n          <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{ path: 'heroes/:id', component: HeroDetailComponent }]),\n          <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n          <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n        ],\n      }),\n    ).compileComponents();\n  });\n\n  it(\"should display 1st hero's name\", <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    const expectedHero = firstHero;\n    await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(expectedHero.id).then(() =&gt; {\n      expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n    });\n  });\n}\n\n/////////// Helpers /////\n\n/** Create the HeroDetailComponent, initialize it, set test variables  */\n<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> function <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(id: number) {\n  harness = await RouterTestingHarness.create();\n  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);\n  page = new Page();\n\n  const request = TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>).expectOne(`api/heroes/?id=${id}`);\n  const hero = getTestHeroes().find((h) =&gt; h.id === Number(id));\n  request.flush(hero ? [hero] : []);\n  harness.detectChanges();\n}\n\nclass Page {\n  // getter properties wait to <a href=\"api/animations/query\" class=\"code-anchor\">query</a> the DOM until called.\n  get buttons() {\n    return this.queryAll&lt;HTMLButtonElement&gt;('button');\n  }\n  get saveBtn() {\n    return this.buttons[0];\n  }\n  get cancelBtn() {\n    return this.buttons[1];\n  }\n  get nameDisplay() {\n    return this.query&lt;HTMLElement&gt;('span');\n  }\n  get nameInput() {\n    return this.query&lt;HTMLInputElement&gt;('input');\n  }\n\n  //// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> helpers ////\n  private <a href=\"api/animations/query\" class=\"code-anchor\">query</a>&lt;T&gt;(selector: string): T {\n    return harness.routeNativeElement!.querySelector(selector)! as T;\n  }\n\n  private queryAll&lt;T&gt;(selector: string): T[] {\n    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];\n  }\n}\n\n\n</code-example>\n<p><a id=\"more-overrides\"></a></p>\n<h4 id=\"more-overrides\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9mjbrzoai8owzny0n4irwd9ej\">更多的改写<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#more-overrides\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6uvwtqn5x3p6sip0h1t2tv9od\"><code>TestBed.overrideComponent</code> 方法可以在相同或不同的组件中被反复调用。<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 还提供了类似的 <code>overrideDirective</code>、<code>overrideModule</code> 和 <code>overridePipe</code> 方法，用来深入并重载这些其它类的部件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cioq7okr6hzk3x17w9z7zhkax\">自己探索这些选项和组合。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Thu Sep 07 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/DebugElement\n - guide/testing\n - guide/testing-attribute-directives\n - guide/testing-components-basics\n - guide/testing-utility-apis\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/animations/trigger\n - api/common/AsyncPipe\n - api/common/CommonModule\n - api/common/NgFor\n - api/common/NgIf\n - api/common/TitleCasePipe\n - api/common/UpperCasePipe\n - api/common/http/HttpClient\n - api/common/http/HttpHandler\n - api/common/http/provideHttpClient\n - api/common/http/testing/HttpTestingController\n - api/common/http/testing/provideHttpClientTesting\n - api/core/AfterViewInit\n - api/core/Component\n - api/core/Component#styleUrls\n - api/core/Component#styles\n - api/core/Component#template\n - api/core/Component#templateUrl\n - api/core/DebugElement\n - api/core/ElementRef\n - api/core/EventEmitter\n - api/core/Injectable\n - api/core/Input\n - api/core/NO_ERRORS_SCHEMA\n - api/core/NgModule\n - api/core/OnInit\n - api/core/Output\n - api/core/ViewChild\n - api/core/createComponent\n - api/core/model\n - api/core/testing/ComponentFixture\n - api/core/testing/ComponentFixtureAutoDetect\n - api/core/testing/MetadataOverride\n - api/core/testing/TestBed\n - api/core/testing/fakeAsync\n - api/core/testing/flush\n - api/core/testing/tick\n - api/core/testing/waitForAsync\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/Title\n - api/platform-browser/animations/async\n - api/router/ActivatedRoute\n - api/router/ActivatedRoute#paramMap\n - api/router/Event\n - api/router/Router\n - api/router/Router#events\n - api/router/RouterLink\n - api/router/RouterOutlet\n - api/router/provideRouter\n - api/router/testing/RouterTestingHarness\n - guide/feature-modules\n - guide/lifecycle-hooks\n - guide/router-tutorial-toh\n - guide/router-tutorial-toh#activated-route-in-action\n - guide/testing-components-basics#component-class-testing\n - guide/testing-components-scenarios#async-observable-helpers\n - guide/testing-components-scenarios#async-observables\n - guide/testing-components-scenarios#async-test-with-fakeasync\n - guide/testing-components-scenarios#async-test-with-waitforasync\n - guide/testing-components-scenarios#automatic-change-detection\n - guide/testing-components-scenarios#bydirective-and-injected-directives\n - guide/testing-components-scenarios#calling-compilecomponents\n - guide/testing-components-scenarios#change-an-input-value-with-dispatchevent\n - guide/testing-components-scenarios#click-helper\n - guide/testing-components-scenarios#click-the-element\n - guide/testing-components-scenarios#clicking\n - guide/testing-components-scenarios#cold-observable\n - guide/testing-components-scenarios#comparing-dates-inside-fakeasync\n - guide/testing-components-scenarios#compile-components\n - guide/testing-components-scenarios#compilecomponents-is-async\n - guide/testing-components-scenarios#compilecomponents-is-harmless\n - guide/testing-components-scenarios#component-binding\n - guide/testing-components-scenarios#component-inside-a-test-host\n - guide/testing-components-scenarios#component-marble-tests\n - guide/testing-components-scenarios#component-override\n - guide/testing-components-scenarios#component-testing-scenarios\n - guide/testing-components-scenarios#component-with-a-dependency\n - guide/testing-components-scenarios#component-with-async-service\n - guide/testing-components-scenarios#component-with-external-files\n - guide/testing-components-scenarios#component-with-inputs-and-outputs\n - guide/testing-components-scenarios#consolidated-setup\n - guide/testing-components-scenarios#createcomponent-does-not-bind-data\n - guide/testing-components-scenarios#dashboard-hero-component\n - guide/testing-components-scenarios#detectchanges\n - guide/testing-components-scenarios#feature-module-import\n - guide/testing-components-scenarios#final-setup-and-tests\n - guide/testing-components-scenarios#get-injected-services\n - guide/testing-components-scenarios#import-a-feature-module\n - guide/testing-components-scenarios#import-a-shared-module\n - guide/testing-components-scenarios#jasmine-done\n - guide/testing-components-scenarios#jasmineclock-with-fakeasync\n - guide/testing-components-scenarios#learn-about-marble-testing\n - guide/testing-components-scenarios#marble-error-testing\n - guide/testing-components-scenarios#marble-frame\n - guide/testing-components-scenarios#more-async-tests\n - guide/testing-components-scenarios#more-overrides\n - guide/testing-components-scenarios#nested-component-tests\n - guide/testing-components-scenarios#no_errors_schema\n - guide/testing-components-scenarios#override-component-providers\n - guide/testing-components-scenarios#provide-a-spy-stub-herodetailservicespy\n - guide/testing-components-scenarios#provide-service-test-doubles\n - guide/testing-components-scenarios#query-for-the-h1\n - guide/testing-components-scenarios#routed-components\n - guide/testing-components-scenarios#routing-component\n - guide/testing-components-scenarios#setup-with-module-imports\n - guide/testing-components-scenarios#spy-stub\n - guide/testing-components-scenarios#stubbing-unneeded-components\n - guide/testing-components-scenarios#support-more-macrotasks\n - guide/testing-components-scenarios#synchronous-tests\n - guide/testing-components-scenarios#test-dashboardherocomponent-stand-alone\n - guide/testing-components-scenarios#testbedinject\n - guide/testing-components-scenarios#testing-with-a-spy\n - guide/testing-components-scenarios#testing-with-the-routertestingharness\n - guide/testing-components-scenarios#the-async-beforeeach\n - guide/testing-components-scenarios#the-override-tests\n - guide/testing-components-scenarios#the-overridecomponent-method\n - guide/testing-components-scenarios#the-synchronous-beforeeach\n - guide/testing-components-scenarios#the-tick-function\n - guide/testing-components-scenarios#tickoptions\n - guide/testing-components-scenarios#triggereventhandler\n - guide/testing-components-scenarios#use-a-page-object\n - guide/testing-components-scenarios#use-both-techniques-together\n - guide/testing-components-scenarios#using-the-rxjs-scheduler-inside-fakeasync\n - guide/testing-components-scenarios#waitForAsync\n - guide/testing-components-scenarios#whenstable\n - guide/testing-utility-apis#metadata-override-object\n - guide/understanding-communicating-with-http\n - http://reactivex.io/documentation/operators/defer.html\n - https://developer.mozilla.org/docs/Web/API/MouseEvent/button\n - https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support\n - https://plnkr.co\n - https://rxjs.dev/guide/testing/marble-testing\n - https://rxmarbles.com\n-->"}