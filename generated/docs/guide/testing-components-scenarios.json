{"id":"guide/testing-components-scenarios","title":"元件測試場景","contents":"<div class=\"content\">\n  <h1 id=\"component-testing-scenarios\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5jpibp6n1zq28ouc6cp4r5kw\">元件測試場景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-testing-scenarios\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ak09en2cgla03f6r1qkq5f1z1\">本指南探討了一些常見的元件測試用例。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jhe3g7pull8hzqtm08p46wf0\">如果你要試驗本指南中所講的應用，請<live-example name=\"testing\" nodownload=\"\">在瀏覽器中執行它</live-example>或<live-example name=\"testing\" downloadonly=\"\">下載並在本地執行它</live-example>。</p>\n</div>\n<h2 id=\"component-binding\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f0asb3p38hvlasskxr2g0unas\">元件繫結<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-binding\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"erfedx5mtoy0pzf6al5o407n6\">在範例應用中，<code>BannerComponent</code> 在 HTML 樣板中展示了靜態的標題文字。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xt4akepqvsnnuh33ekb25imk\">在少許更改之後，<code>BannerComponent</code> 就會透過繫結元件的 <code>title</code> 屬性來渲染動態標題。</p>\n<code-example header=\"app/banner/banner.component.ts\" path=\"testing/src/app/banner/banner.component.ts\" region=\"component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-banner',\n  template: '&lt;h1&gt;{{title}}&lt;/h1&gt;',\n  styles: ['h1 { color: green; font-size: 350%}'],\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1iloqyl55ypown3lm3s1skia8\">儘管這很小，但你還是決定要新增一個測試來確認該組件實際顯示的是你認為合適的內容。</p>\n<h4 id=\"query-for-the-h1\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44kzpueoxej3fhdoockdsu98r\">查詢 <code>&lt;h1&gt;</code> 元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#query-for-the-h1\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9up2flg02aeljodm0j6j4hjyx\">你將編寫一系列測試來檢查 <code>&lt;h1&gt;</code> 元素中包裹的 <em>title</em> 屬性內嵌繫結。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dje2f7dkplza23h52yyethiuy\">你可以修改 <code>beforeEach</code> 以找到帶有標準 HTML <code>querySelector</code> 的元素，並把它賦值給 <code>h1</code> 變數。</p>\n<code-example header=\"app/banner/banner.component.spec.ts (setup)\" path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"setup\">\nlet component: BannerComponent;\nlet fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&lt;BannerComponent&gt;;\nlet h1: HTMLElement;\n\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    imports: [BannerComponent],\n  });\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance; // BannerComponent test instance\n  h1 = fixture.nativeElement.querySelector('h1');\n});\n\n</code-example>\n<p><a id=\"detect-changes\"></a></p>\n<h4 id=\"createcomponent-does-not-bind-data\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ja68deaxx19zhbv39r6tvblk\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code> 不綁定數據<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#createcomponent-does-not-bind-data\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2f851s9zxzckdoswjaxpco0sg\">對於你的第一個測試，你希望螢幕上顯示預設的 <code>title</code>。你的直覺就是編寫一個能立即檢查 <code>&lt;h1&gt;</code> 的測試，就像這樣：</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"expect-h1-default-v1\">\nit('should display original title', () =&gt; {\n  expect(h1.textContent).toContain(component.title);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2dqpzcuuu30mwevl5n2wbl0nv\"><em>那個測試失敗</em>了：</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\nexpected '' to contain 'Test Tour of Heroes'.\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"422huc53i246yaaem1j9lm5br\"><strong>當 Angular 執行變更檢測</strong>時就會發生繫結。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66bmb3sbnidi9g9c9dwqg8vhu\">在生產環境中，當 Angular 建立一個元件，或者使用者輸入按鍵，或者非同步活動（比如 AJAX）完成時，就會自動進行變更檢測。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"diwe8eojg5qlilq97n6t9m9ua\">該 <code>TestBed.createComponent</code> <em>不會</em>觸發變化檢測，修改後的測試可以證實這一點：</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"test-w-o-detect-changes\">\nit('no title in the DOM after <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()', () =&gt; {\n  expect(h1.textContent).toEqual('');\n});\n\n</code-example>\n<h4 id=\"detectchanges\"><code>detectChanges()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#detectchanges\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eye1s8wbn4jtej4aj64q58911\">你必須透過呼叫 <code>fixture.detectChanges()</code> 來告訴 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 執行資料繫結。只有這樣，<code>&lt;h1&gt;</code> 才能擁有預期的標題。</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"expect-h1-default\">\nit('should display original title after detectChanges()', () =&gt; {\n  fixture.detectChanges();\n  expect(h1.textContent).toContain(component.title);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51yd4uadsplvmd6c5zmd8jo46\">這裡延遲變更檢測時機是故意而且有用的。這樣才能讓測試者在 Angular 啟動資料繫結並呼叫<a href=\"guide/lifecycle-hooks\">生命週期鉤子</a>之前，檢視並更改元件的狀態。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46hf55079ndq85x7vg8elnxrx\">這是另一個測試，它會在呼叫 <code>fixture.detectChanges()</code> <em>之前</em>改變元件的 <code>title</code> 屬性。</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"after-change\">\nit('should display a different test title', () =&gt; {\n  component.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  fixture.detectChanges();\n  expect(h1.textContent).toContain('Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>');\n});\n\n</code-example>\n<p><a id=\"auto-detect-changes\"></a></p>\n<h4 id=\"automatic-change-detection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d9dphvlbvnlcqv7ql0p7bc2zr\">自動變更檢測<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#automatic-change-detection\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"67kw3f10c7etrll6slzlv28f6\"><code>BannerComponent</code> 測試會經常呼叫 <code>detectChanges</code>。一些測試人員更喜歡讓 Angular 測試環境自動執行變更檢測。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"237ql38jq4nzohmnwtqa5rabc\">可以透過設定帶有 <code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code> 提供者的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 來實現這一點。我們首先從測試工具函式庫中匯入它：</p>\n<code-example header=\"app/banner/banner.component.detect-changes.spec.ts (import)\" path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"import-ComponentFixtureAutoDetect\">\nimport { <a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a> } from '@angular/core/testing';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f3xbom95bbm35awdgyvuopd3u\">然後把它新增到測試模組設定的 <code>providers</code> 中：</p>\n<code-example header=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect)\" path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect\">\nTestBed.configureTestingModule({\n  imports: [BannerComponent],\n  providers: [{ provide: <a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a>, useValue: true }],\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eu7pt1x656xdovf9quymkcrw4\">這裡有三個測試來說明自動變更檢測是如何工作的。</p>\n<code-example header=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect Tests)\" path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect-tests\">\nit('should display original title', () =&gt; {\n  // Hooray! No `fixture.detectChanges()` needed\n  expect(h1.textContent).toContain(comp.title);\n});\n\nit('should still see original title after comp.title change', () =&gt; {\n  const oldTitle = comp.title;\n  comp.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  // Displayed title is old because Angular didn't hear the change :(\n  expect(h1.textContent).toContain(oldTitle);\n});\n\nit('should display updated title after detectChanges', () =&gt; {\n  comp.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  fixture.detectChanges(); // detect changes explicitly\n  expect(h1.textContent).toContain(comp.title);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"be5qqigl841bsssz3greu05ff\">第一個測試顯示了自動變更檢測的優點。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eq7f7ghb0fridmv0ouhva9ois\">第二個和第三個測試則揭示了一個重要的限制。該 Angular 測試環境<em>不</em>知道測試改變了元件的 <code>title</code>。<code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code> 服務會回應<em>非同步活動，</em>比如 Promise、定時器和 DOM 事件。但卻看不見對元件屬性的直接同步更新。該測試必須用 <code>fixture.detectChanges()</code> 來觸發另一個變更檢測週期。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5nsckb6r63dacjwagtvll05u1\">本指南中的範例總是會<em>顯式</em>呼叫 <code>detectChanges()</code>，而不用困惑於測試夾具何時會或不會執行變更檢測。更頻繁的呼叫 <code>detectChanges()</code> 毫無危害，沒必要只在非常必要時才調用它。</p>\n</div>\n<p><a id=\"dispatch-event\"></a></p>\n<h4 id=\"change-an-input-value-with-dispatchevent\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4fw79hwe97bzhokivsexr5qbf\">使用  <code>dispatchEvent()</code> 改變輸入框的值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#change-an-input-value-with-dispatchevent\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2r0rzwasaj3ue69uzd2e9g427\">要模擬使用者輸入，你可以找到 input 元素並設定它的 <code>value</code> 屬性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bucusr3q99wcxkxfijsy6zeqr\">你會呼叫 <code>fixture.detectChanges()</code> 來觸發 Angular 的變更檢測。但還有一個重要的中間步驟。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5i0oozs2salh77nhrccxwq16q\">Angular 並不知道你為 input 設定過 <code>value</code> 屬性。在透過呼叫 <code>dispatchEvent()</code> 分發 <code>input</code> 事件之前，它不會讀取該屬性。<em>緊接著</em>你就呼叫了 <code>detectChanges()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"esidsmwffl3td2l6t9h9nisei\">下列例子說明了正確的順序。</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (pipe test)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"title-case-pipe\">\nit('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () =&gt; {\n  // get the name's input and display elements from the DOM\n  const hostElement: HTMLElement = harness.routeNativeElement!;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input')!;\n  const nameDisplay: HTMLElement = hostElement.querySelector('span')!;\n\n  // simulate user entering a new name into the input box\n  nameInput.value = 'quick BROWN  fOx';\n\n  // Dispatch a DOM event so that Angular learns of input value change.\n  nameInput.dispatchEvent(new <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>('input'));\n\n  // Tell Angular to update the display binding through the title pipe\n  harness.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});\n\n\n</code-example>\n<h2 id=\"component-with-external-files\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tupz2zj58o18z446ljjyvnee\">包含外部檔案的元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-external-files\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f13qjaidf8a1519jwx85w25o0\">上面的 <code>BannerComponent</code> 是用<em>行內樣板</em>和<em>行內 css</em> 定義的，它們分別是在 <code>@<a href=\"api/core/Component#template\" class=\"code-anchor\">Component.template</a></code> 和 <code>@<a href=\"api/core/Component#styles\" class=\"code-anchor\">Component.styles</a></code> 屬性中指定的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ve3m6p37ssko6zzbmvh69igh\">很多元件都會分別用 <code>@<a href=\"api/core/Component#templateUrl\" class=\"code-anchor\">Component.templateUrl</a></code> 和 <code>@<a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">Component.styleUrls</a></code> 屬性來指定<em>外部樣板</em>和<em>外部 css</em>，就像下面的 <code>BannerComponent</code> 變體一樣。</p>\n<code-example header=\"app/banner/banner-external.component.ts (metadata)\" path=\"testing/src/app/banner/banner-external.component.ts\" region=\"metadata\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-banner',\n  templateUrl: './banner-external.component.html',\n  styleUrls: ['./banner-external.component.css'],\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41nllu3k4zs2wf2vsgpkq16f6\">這個語法告訴 Angular 編譯器要在元件編譯時讀取外部檔案。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qgalt4ugkfnt4ugwbc1ppb14\">當執行 <code>ng test</code> 指令時，這不是問題，因為它會<em>在執行測試之前編譯應用</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2d7y39kqjwf3vvn15l70rriab\">但是，如果在<strong>非 CLI 環境中</strong>執行這些測試，那麼這個元件的測試可能會失敗。比如，如果你在一個 web 程式設計環境（比如 <a href=\"https://plnkr.co\">plunker</a> 中執行 <code>BannerComponent</code> 測試，你會看到如下訊息：</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nError: This test module uses the component BannerComponent\nwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26h08hhi9go7cwn71uv517toa\">當執行環境在測試過程中需要編譯原始碼時，就會得到這條測試失敗的訊息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2envmwzgjqc9hbgb0w8rggckg\">要解決這個問題，可以像 <a href=\"guide/testing-components-scenarios#compile-components\">呼叫 <code>compileComponents</code></a> 中講的那樣呼叫 <code>compileComponents()</code>。</p>\n<p><a id=\"component-with-dependency\"></a></p>\n<h2 id=\"component-with-a-dependency\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gc7b5p3txeu55fqumg6fbmqt\">具有依賴的元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-a-dependency\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"50nquo5snywxvj44c3c0fyazg\">元件通常都有服務依賴。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c4ul77bqmn0vikkz1ohjljmbx\"><code>WelcomeComponent</code> 會向登入使用者顯示一條歡迎訊息。它可以基於注入進來的 <code>UserService</code> 的一個屬性瞭解到使用者是誰：</p>\n<code-example header=\"app/welcome/welcome.component.ts\" path=\"testing/src/app/welcome/welcome.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { UserService } from '../<a href=\"api/core/model\" class=\"code-anchor\">model</a>/user.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-welcome',\n  template: '&lt;h3 class=\"welcome\"&gt;&lt;i&gt;{{welcome}}&lt;/i&gt;&lt;/h3&gt;',\n})\nexport class WelcomeComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  welcome = '';\n  constructor(private userService: UserService) {}\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn\n      ? 'Welcome, ' + this.userService.user.name\n      : 'Please log in.';\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5d5igk6x4lvuxmn3q84kys0t1\"><code>WelcomeComponent</code> 擁有與該服務互動的決策邏輯，該邏輯讓這個元件值得測試。這是 spec 檔案的測試模組設定：</p>\n<code-example header=\"app/welcome/welcome.component.spec.ts\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"config-test-module\">\nTestBed.configureTestingModule({\n  imports: [WelcomeComponent],\n  // providers: [ UserService ],  // NO! Don't provide the real service!\n  // Provide a test-double instead\n  providers: [{ provide: UserService, useValue: userServiceStub }],\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"130pyhgnwn5c40bkg40dnid12\">這次，除了宣告<em>被測元件外</em>，該設定還在 <code>providers</code> 清單中加入了 <code>UserService</code> 提供者。但它不是真正的 <code>UserService</code>。</p>\n<p><a id=\"service-test-doubles\"></a></p>\n<h4 id=\"provide-service-test-doubles\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1w4q8bm5nr807s5qarba8g1kj\">為服務提供測試替身<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#provide-service-test-doubles\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6dlaxuh01y0fo41rcjt90lzbq\"><em>待測元件</em>不必注入真正的服務。事實上，如果它們是測試替身，比如 stubs，fakes，spies 或 mocks，通常會更好。該測試規約的目的是測試元件，而不是服務，使用真正的服務可能會遇到麻煩。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"frroue5e7u7cb9s2eyczbpun\">注入真正的 <code>UserService</code> 可能是個噩夢。真正的服務可能要求使用者提供登入憑據，並嘗試訪問認證伺服器。這些行為可能難以攔截。為它建立並註冊一個測試專用版來代替真正的 <code>UserService</code> 要容易得多，也更安全。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1v9fdptud33pt9541zq0t5hn\">這個特定的測試套件提供了 <code>UserService</code> 的最小化模擬，它滿足了 <code>WelcomeComponent</code> 及其測試的需求：</p>\n<code-example header=\"app/welcome/welcome.component.spec.ts\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"user-service-stub\">\nlet userServiceStub: Partial&lt;UserService&gt;;\n\n  userServiceStub = {\n    isLoggedIn: true,\n    user: { name: 'Test User' },\n  };\n\n</code-example>\n<p><a id=\"get-injected-service\"></a></p>\n<h4 id=\"get-injected-services\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"45778uy3p2czps47kn5uge4uw\">取得所注入的服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#get-injected-services\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"m9c4d7trvxi7ktxc5qvtz855\">這些測試需要訪問注入到 <code>WelcomeComponent</code> 中的 <code>UserService</code> 樁。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6m40dxfh1l1ky52h73n1y1jk3\">Angular 有一個多級注入系統。它具有多個層級的注入器，從 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 建立的根注入器開始，直到元件樹中的各個層級。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5s0h29h0cwhx4n7xrf9p22nxo\">獲得注入服務的最安全的方式（<strong>始終有效</strong>），就是<strong><em>從被測元件</em>的注入器中獲取它</strong>。元件注入器是測試夾具所提供的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 中的一個屬性。</p>\n<code-example header=\"WelcomeComponent's injector\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"injected-service\">\n// UserService actually injected into the component\nuserService = fixture.debugElement.injector.get(UserService);\n\n</code-example>\n<p><a id=\"testbed-inject\"></a></p>\n<h4 id=\"testbedinject\"><code>TestBed.inject()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#testbedinject\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bykps41qltgo5kag1c4xc2gyk\">你<em>可能</em>還可以透過 <code>TestBed.inject()</code> 來從根注入器獲得服務。這更容易記憶，也不那麼囉嗦。但這隻有當 Angular 要把根注入器中的服務實例注入測試元件時才是可行的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dum5381r5qlac7mhucv800jkv\">在下面這個測試套件中，<code>UserService</code><em>唯一的</em>提供者是根測試模組，因此可以安全地呼叫 <code>TestBed.inject()</code>，如下所示：</p>\n<code-example header=\"TestBed injector\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"inject-from-testbed\">\n// UserService from the root injector\nuserService = TestBed.inject(UserService);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vktz7n1i2esnmw2xjf1mdyff\"><code>TestBed.inject()</code> 不起作用的用例，參閱<a href=\"guide/testing-components-scenarios#component-override\"><em>『覆蓋元件提供者』</em></a>部分，它解釋了何時以及為什麼必須從該組件自身的注入器中獲取該服務。</p>\n</div>\n<p><a id=\"welcome-spec-setup\"></a></p>\n<h4 id=\"final-setup-and-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2jcr1xsg9s2nvsca1wo5rjso\">最後的設定與測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#final-setup-and-tests\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"czfxhpvfhc15ugzvuek4r9anu\">這裡是完成的 <code>beforeEach()</code>，它使用了 <code>TestBed.inject()</code>：</p>\n<code-example header=\"app/welcome/welcome.component.spec.ts\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"setup\">\nlet userServiceStub: Partial&lt;UserService&gt;;\n\nbeforeEach(() =&gt; {\n  // stub UserService for test purposes\n  userServiceStub = {\n    isLoggedIn: true,\n    user: { name: 'Test User' },\n  };\n\n  TestBed.configureTestingModule({\n    imports: [WelcomeComponent],\n    providers: [{ provide: UserService, useValue: userServiceStub }],\n  });\n\n  fixture = TestBed.createComponent(WelcomeComponent);\n  comp = fixture.componentInstance;\n\n  // UserService from the root injector\n  userService = TestBed.inject(UserService);\n\n  //  get the \"welcome\" element by CSS selector (e.g., by class name)\n  el = fixture.nativeElement.querySelector('.welcome');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlp37v1vnodhqg9bs8toz03x2\">以下是一些測試：</p>\n<code-example header=\"app/welcome/welcome.component.spec.ts\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"tests\">\nit('should welcome the user', () =&gt; {\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).withContext('\"Welcome ...\"').toContain('Welcome');\n  expect(content).withContext('expected name').toContain('Test User');\n});\n\nit('should welcome \"Bubba\"', () =&gt; {\n  userService.user.name = 'Bubba'; // welcome message hasn't been shown yet\n  fixture.detectChanges();\n  expect(el.textContent).toContain('Bubba');\n});\n\nit('should request login if not logged in', () =&gt; {\n  userService.isLoggedIn = false; // welcome message hasn't been shown yet\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).withContext('not welcomed').not.toContain('Welcome');\n  expect(content)\n    .withContext('\"log in\"')\n    .toMatch(/log in/i);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ab103lnr8m8r3s4yhd20qd61i\">首先是一個健全性測試；它確認了樁服務 <code>UserService</code> 被呼叫過並能正常工作。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dueb1rf00lnlbvxpn9rdq2hna\">Jasmine 對應器的第二個引數（比如 <code>'expected name'</code>）是一個可選的失敗標籤。如果此期望失敗，Jasmine 就會把這個標籤貼到期望失敗的訊息中。在具有多個期望的測試規約中，它可以幫我們澄清出現了什麼問題以及都有哪些期望失敗了。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8oztbnowfapmjh4fddh3q6xxh\">當該服務回傳不同的值時，其餘的測試會確認該組件的邏輯。第二個測試驗證了更改使用者名的效果。當用戶未登入時，第三個測試會檢查元件是否顯示了正確的訊息。</p>\n<p><a id=\"component-with-async-service\"></a></p>\n<h2 id=\"component-with-async-service\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"89pawgl0p7g1f5jqz1hlsyba5\">帶非同步服務的元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-async-service\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"edm9ff239y53dlmyg0xhu3kh1\">在這個例子中，<code>AboutComponent</code> 樣板託管了一個 <code>TwainComponent</code>。<code>TwainComponent</code> 會顯示馬克·吐溫的名言。</p>\n<code-example header=\"app/twain/twain.component.ts (template)\" path=\"testing/src/app/twain/twain.component.ts\" region=\"template\">\ntemplate: ` &lt;p class=\"twain\"&gt;\n    &lt;i&gt;{{ quote | async }}&lt;/i&gt;\n  &lt;/p&gt;\n  &lt;button type=\"button\" (click)=\"getQuote()\"&gt;Next quote&lt;/button&gt;\n  &lt;p class=\"error\" *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"errorMessage\"&gt;{{ errorMessage }}&lt;/p&gt;`,\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9kxi1kdmhqr0kwhssqirw7g19\"><strong>注意</strong>：<br>\n元件的 <code>quote</code> 屬性的值透過 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code> 傳遞。這意味著該屬性會回傳 <code>Promise</code> 或 <code>Observable</code>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvoy9ncp0swpo3fhe67akgmok\">在這個例子中，<code>TwainComponent.getQuote()</code> 方法告訴你 <code>quote</code> 屬性會回傳一個 <code>Observable</code>。</p>\n<code-example header=\"app/twain/twain.component.ts (getQuote)\" path=\"testing/src/app/twain/twain.component.ts\" region=\"get-quote\">\ngetQuote() {\n  this.errorMessage = '';\n  this.quote = this.twainService.getQuote().pipe(\n    startWith('...'),\n    catchError((err: any) =&gt; {\n      // Wait a turn because errorMessage already set once this turn\n      setTimeout(() =&gt; (this.errorMessage = err.message || err.toString()));\n      return of('...'); // reset message to placeholder\n    }),\n  );\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2teug54wdj3d09zfbb0x7a8s\">該 <code>TwainComponent</code> 從注入的 <code>TwainService</code> 中獲取名言。該在服務能回傳第一條名言之前，該服務會先回傳一個佔位流（<code>'...'</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9063i5m0fs2f5n9xip7kid8rp\"><code>catchError</code> 會攔截服務錯誤，準備一條錯誤訊息，並在流的成功通道上回傳佔位值。它必須等一拍（tick）才能設定 <code>errorMessage</code>，以免在同一個變更檢測週期內更新此訊息兩次。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3sjgc24129i86m7ewydreookt\">這些都是你想要測試的屬性。</p>\n<h4 id=\"testing-with-a-spy\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dzqjwahmrwy6h4ebjinsilcm\">使用間諜（spy）進行測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#testing-with-a-spy\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c34utfe2vm8zbhez8itios3jh\">在測試元件時，只有該服務的公開 API 才有意義。通常，測試本身不應該呼叫遠端伺服器。它們應該模擬這樣的呼叫。這個 <code>app/twain/twain.component.spec.ts</code> 中的環境準備工作展示了一種方法：</p>\n<code-example header=\"app/twain/twain.component.spec.ts (setup)\" path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"setup\">\nbeforeEach(() =&gt; {\n  testQuote = 'Test Quote';\n\n  // Create a fake TwainService object with a `getQuote()` spy\n  const twainService = jasmine.createSpyObj('TwainService', ['getQuote']);\n  // Make the spy return a synchronous Observable with the test data\n  getQuoteSpy = twainService.getQuote.and.returnValue(of(testQuote));\n\n  TestBed.configureTestingModule({\n    imports: [TwainComponent],\n    providers: [{ provide: TwainService, useValue: twainService }],\n  });\n\n  fixture = TestBed.createComponent(TwainComponent);\n  component = fixture.componentInstance;\n  quoteEl = fixture.nativeElement.querySelector('.twain');\n});\n\n</code-example>\n<p><a id=\"service-spy\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cup3iu7q744k00p8r29o1ww04\">仔細看一下這個間諜。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"spy\">\n// Create a fake TwainService object with a `getQuote()` spy\nconst twainService = jasmine.createSpyObj('TwainService', ['getQuote']);\n// Make the spy return a synchronous Observable with the test data\ngetQuoteSpy = twainService.getQuote.and.returnValue(of(testQuote));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7z4dwzy5y9fn5akjyq18wy9pc\">這個間諜的設計目標是讓所有對 <code>getQuote</code> 的呼叫都會收到一個帶有測試名言的可觀察物件。與真正的 <code>getQuote()</code> 方法不同，這個間諜會繞過伺服器，並回傳一個立即同步提供可用值的可觀察物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5g60gwz61nrhzwgzdf0kxccc4\">雖然這個 <code>Observable</code> 是同步的，但你也可以用這個間諜編寫很多有用的測試。</p>\n<p><a id=\"sync-tests\"></a></p>\n<h4 id=\"synchronous-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7xhnk8619g2837p7eu6z4vjwu\">同步測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#synchronous-tests\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7429epq70gbzzgay4gvwkt7i0\">同步 <code>Observable</code> 的一個關鍵優勢是，你通常可以把非同步過程轉換成同步測試。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"sync-test\">\nit('should show quote after component initialized', () =&gt; {\n  fixture.detectChanges(); // onInit()\n\n  // sync spy result shows testQuote immediately after init\n  expect(quoteEl.textContent).toBe(testQuote);\n  expect(getQuoteSpy.calls.any()).withContext('getQuote called').toBe(true);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cnpxwg1v8igf4a8syzuqjvfo\">當間諜的結果同步回傳時，<code>getQuote()</code> 方法會在第一個變更檢測週期（Angular 在這裡呼叫 <code>ngOnInit</code>）<em>後</em>立即更新螢幕上的訊息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dbb6fqtr6lmlm5t66pmmpi08n\">你在測試錯誤路徑時就沒有這麼幸運了。雖然服務間諜會同步回傳一個錯誤，但該組件方法會呼叫 <code>setTimeout()</code>。在值可用之前，測試必須等待 JavaScript 引擎的至少一個週期。因此，該測試必須是<em>非同步的</em>。</p>\n<p><a id=\"fake-async\"></a></p>\n<h4 id=\"async-test-with-fakeasync\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51kfmo595l7qkcm0dot8gqfgl\">使用 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 進行非同步測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#async-test-with-fakeasync\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ezcd0cri00yd6b8959pktptz\">要使用\n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>功能，必須在測試設定檔案中匯入\n<code>zone.js/testing</code>。 如果使用Angular CLI建立專案，則已經為您新增了\n<code>zone-testing</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"273rfgrzqzbuurnack4vk6bgw\">當該服務回傳 <code>ErrorObservable</code> 時，下列測試會對其預期行為進行確認。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"error-test\">\nit('should display error when TwainService fails', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  // tell spy to return an error observable\n  getQuoteSpy.and.returnValue(throwError(() =&gt; new Error('TwainService test failure')));\n  fixture.detectChanges(); // onInit()\n  // sync spy errors immediately after init\n\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the component's setTimeout()\n\n  fixture.detectChanges(); // update errorMessage within setTimeout()\n\n  expect(errorMessage())\n    .withContext('should display error')\n    .toMatch(/test failure/);\n  expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');\n}));\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jshxd5xnpt2aw70ttdo9hog2\"><strong>注意</strong>：<br>\n<code>it()</code> 函式會接收以下形式的引數。</p>\n</div>\n<code-example format=\"javascript\" language=\"javascript\">\n\n<a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; { /* test body */ })\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c31grd5t1426k8o7101ih55q\">透過在一個特殊的 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> test zone</code>（譯註：Zone.js 的一個特例）中執行測試體，<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 函式可以啟用線性編碼風格。這個測試體看上去是同步的。沒有像 <code>Promise.then()</code> 這樣的巢狀語法來破壞控制流。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8lmwoq173tcw6lxq99l8lzxon\">限制：如果測試體要進行 <code>XMLHttpRequest</code>（XHR）呼叫，則 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 函式無效。很少會需要在測試中進行 XHR 呼叫，但如果你確實要這麼做，請參閱 <a href=\"guide/testing-components-scenarios#waitForAsync\"><code>waitForAsync()</code></a> 部分。</p>\n</div>\n<p><a id=\"tick\"></a></p>\n<h4 id=\"the-tick-function\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58b46t8t1sm38zh8crs5upxdr\"><code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>()</code> 函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-tick-function\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3lo7hr4qd6qjt72sd5qnrauu5\">必須呼叫\n<a href=\"api/core/testing/tick\">tick()</a>以推進虛擬時鐘。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cf10z9mc2ad73aow6e22f7b9\">呼叫 \n<a href=\"api/core/testing/tick\">tick()</a> 函式模擬時間流逝，直到所有掛起的非同步活動完成。在這種情況下，它會等待錯誤處理器的 \n<code>setTimeout()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8vzm15s9xwmw2v1eujwm4tnkf\"><a href=\"api/core/testing/tick\">tick()</a> 函式接受 \n<code>millis</code> 和 \n<code>tickOptions</code> 作為引數。其中，\n<code>millis</code> 引數指定虛擬時鐘前進的時間，預設為 \n<code>0</code>。例如，如果在 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 測試中有一個 \n<code>setTimeout(fn, 100)</code>，你需要使用 \n<code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(100)</code> 來觸發 fn 回呼。可選的 \n<code>tickOptions</code> 引數具有一個名為 \n<code>processNewMacroTasksSynchronously</code> 的屬性，表示在觸發時是否呼叫新生成的巨集任務，預設為 \n<code>true</code>。</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick\">\nit('should run timeout callback with delay after call <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> with millis', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  let called = false;\n  setTimeout(() =&gt; {\n    called = true;\n  }, 100);\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(100);\n  expect(called).toBe(true);\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1z172ljkioi48j8omaxsuhssg\"><a href=\"api/core/testing/tick\">tick()</a> 函式是 Angular 測試工具之一，你可以使用 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 匯入它。它是 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 的伴侶，只能在 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 函式體內呼叫。</p>\n<h4 id=\"tickoptions\">tickOptions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#tickoptions\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cb2wz7bxu9no6hdpszbjdkrz2\">在此範例中，你有一個新的巨集任務，即巢狀的 <code>setTimeout</code> 函式。預設情況下，當 <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a></code> 為 setTimeout 時，<code>outside</code> 和 <code>nested</code> 都將被觸發。</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick-new-macro-task-sync\">\nit('should run new macro task callback with delay after call <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> with millis', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  function nestedTimer(cb: () =&gt; any): void {\n    setTimeout(() =&gt; setTimeout(() =&gt; cb()));\n  }\n  const callback = jasmine.createSpy('callback');\n  nestedTimer(callback);\n  expect(callback).not.toHaveBeenCalled();\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(0);\n  // the nested timeout will also be triggered\n  expect(callback).toHaveBeenCalled();\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"mj2p8pah7be6of7xt5vjbw00\">在某些情況下，你可能不想在滴答時觸發新的巨集任務。你可以用 <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(millis, {processNewMacroTasksSynchronously: false})</code> 來避免呼叫新的巨集任務。</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick-new-macro-task-async\">\nit('should not run new macro task callback with delay after call <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> with millis', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  function nestedTimer(cb: () =&gt; any): void {\n    setTimeout(() =&gt; setTimeout(() =&gt; cb()));\n  }\n  const callback = jasmine.createSpy('callback');\n  nestedTimer(callback);\n  expect(callback).not.toHaveBeenCalled();\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(0, { processNewMacroTasksSynchronously: false });\n  // the nested timeout will not be triggered\n  expect(callback).not.toHaveBeenCalled();\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(0);\n  expect(callback).toHaveBeenCalled();\n}));\n\n</code-example>\n<h4 id=\"comparing-dates-inside-fakeasync\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"g4kka005dy2nvsa1m151s6ih\">在 fakeAsync() 中比較日期<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#comparing-dates-inside-fakeasync\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bc0vtw03rnvou2uu4ckbelm1q\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 可以模擬時間的流逝，以便讓你計算出 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 裡面的日期差。</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-date\">\nit('should get Date diff correctly in <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  const start = Date.now();\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(100);\n  const end = Date.now();\n  expect(end - start).toBe(100);\n}));\n\n</code-example>\n<h4 id=\"jasmineclock-with-fakeasync\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5g9x0bmh096pma20bwg37ofsm\">jasmine.clock 與 fakeAsync()<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#jasmineclock-with-fakeasync\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2sbz5rwsojdk776863bo1svef\">Jasmine 還為模擬日期提供了 <code>clock</code> 屬性。而 Angular 會在 <code>jasmine.clock().install()</code> 於 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 方法內呼叫時自動執行這些測試。直到呼叫了 <code>jasmine.clock().uninstall()</code> 為止。<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 不是必須的，如果巢狀它就丟擲錯誤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2bdsyejyk6s39519zmf3zm816\">預設情況下，此功能處於停用狀態。要啟用它，請在匯入 <code>zone-testing</code> 之前先設定全域標誌。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ox5hfhpvb7fr2df65xihu4bm\">如果你使用的是 Angular CLI，請在 <code>src/test.ts</code> 中設定這個標誌。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n(window as any)['__zone_symbol__fakeAsyncPatchLock'] = true;\nimport 'zone.js/testing';\n\n</code-example>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-clock\">\ndescribe('use jasmine.clock()', () =&gt; {\n  // need to config __zone_symbol__fakeAsyncPatchLock flag\n  // before loading zone.js/testing\n  beforeEach(() =&gt; {\n    jasmine.clock().install();\n  });\n  afterEach(() =&gt; {\n    jasmine.clock().uninstall();\n  });\n  it('should auto enter <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>', () =&gt; {\n    // is in <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> now, don't need to call <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(testFn)\n    let called = false;\n    setTimeout(() =&gt; {\n      called = true;\n    }, 100);\n    jasmine.clock().tick(100);\n    expect(called).toBe(true);\n  });\n});\n\n</code-example>\n<h4 id=\"using-the-rxjs-scheduler-inside-fakeasync\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bljxy8bpr4niesixrxkrnumxq\">在 fakeAsync() 中使用 RxJS 排程程式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#using-the-rxjs-scheduler-inside-fakeasync\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2mzst8x5awm5s1yx9ju3grjc4\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 使用 RxJS 的排程器，就像使用 <code>setTimeout()</code> 或 <code>setInterval()</code> 一樣，但你需要匯入 <code>zone.js/plugins/zone-patch-rxjs-fake-async</code> 來給 RxJS 排程器打補丁。</p>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-rxjs\">\nit('should get Date diff correctly in <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> with rxjs scheduler', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async'\n  // to patch rxjs scheduler\n  let result = '';\n  of('hello')\n    .pipe(delay(1000))\n    .subscribe((v) =&gt; {\n      result = v;\n    });\n  expect(result).toBe('');\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(1000);\n  expect(result).toBe('hello');\n\n  const start = new Date().getTime();\n  let dateDiff = 0;\n  interval(1000)\n    .pipe(take(2))\n    .subscribe(() =&gt; (dateDiff = new Date().getTime() - start));\n\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(1000);\n  expect(dateDiff).toBe(1000);\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(1000);\n  expect(dateDiff).toBe(2000);\n}));\n\n</code-example>\n<h4 id=\"support-more-macrotasks\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6khmypguz3a7ivj0dq5xcw6u\">支援更多的 macroTasks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#support-more-macrotasks\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"epi3rp6vj2nkuzb41xq250nh6\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 預設支援以下巨集任務。</p>\n<ul>\n<li><code>setTimeout</code></li>\n<li><code>setInterval</code></li>\n<li><code>requestAnimationFrame</code></li>\n<li><code>webkitRequestAnimationFrame</code></li>\n<li><code>mozRequestAnimationFrame</code></li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5dvicvj9y6i0o4mui72kvz6az\">如果你執行其他巨集任務，比如 <code>HTMLCanvasElement.toBlob()</code>，就會丟擲 <em>\"Unknown macroTask scheduled in fake async test\"</em> 錯誤。</p>\n<code-tabs>\n    <code-pane header=\"src/app/shared/canvas.component.spec.ts (failing)\" path=\"testing/src/app/shared/canvas.component.spec.ts\" region=\"without-toBlob-macrotask\">\nimport { <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> } from '@angular/core/testing';\n\nimport { CanvasComponent } from './canvas.component';\n\ndescribe('CanvasComponent', () =&gt; {\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    await TestBed.configureTestingModule({\n      imports: [CanvasComponent],\n    }).compileComponents();\n  });\n\n  it('should be able to generate blob data from canvas', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n    const fixture = TestBed.createComponent(CanvasComponent);\n    const canvasComp = fixture.componentInstance;\n\n    fixture.detectChanges();\n    expect(canvasComp.blobSize).toBe(0);\n\n    <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();\n    expect(canvasComp.blobSize).toBeGreaterThan(0);\n  }));\n});\n\n</code-pane>\n    <code-pane header=\"src/app/shared/canvas.component.ts\" path=\"testing/src/app/shared/canvas.component.ts\" region=\"main\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>, <a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'sample-canvas',\n  template: '&lt;canvas #sampleCanvas width=\"200\" height=\"200\"&gt;&lt;/canvas&gt;',\n})\nexport class CanvasComponent implements <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a> {\n  blobSize = 0;\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('sampleCanvas') sampleCanvas!: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n  ngAfterViewInit() {\n    const canvas: HTMLCanvasElement = this.sampleCanvas.nativeElement;\n    const context = canvas.getContext('2d')!;\n\n    context.clearRect(0, 0, 200, 200);\n    context.fillStyle = '#FF1122';\n    context.fillRect(0, 0, 200, 200);\n\n    canvas.toBlob((blob) =&gt; {\n      this.blobSize = blob?.size ?? 0;\n    });\n  }\n}\n\n</code-pane>\n</code-tabs>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ulqjpkhw7tlpcqa6m2884qnz\">如果你想支援這種情況，就要在 <code>beforeEach()</code> 定義你要支援的巨集任務。比如：</p>\n<code-example header=\"src/app/shared/canvas.component.spec.ts (excerpt)\" path=\"testing/src/app/shared/canvas.component.spec.ts\" region=\"enable-toBlob-macrotask\">\nbeforeEach(() =&gt; {\n  (window as any).__zone_symbol__FakeAsyncTestMacroTask = [\n    {\n      source: 'HTMLCanvasElement.toBlob',\n      callbackArgs: [{ size: 200 }],\n    },\n  ];\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eadl771eykn1j9pozis1z3k8d\"><strong>注意</strong>：<br>\n要在依賴 Zone.js 的應用中使用 <code>&lt;canvas&gt;</code> 元素，你需要匯入 <code>zone-patch-canvas</code> 補丁（或者在 <code>polyfills.ts</code> 中，或者在用到 <code>&lt;canvas&gt;</code> 的那個檔案中）：</p>\n</div>\n<code-example header=\"src/polyfills.ts or src/app/shared/canvas.component.ts\" path=\"testing/src/app/shared/canvas.component.ts\" region=\"import-canvas-patch\">\n// Import patch to make <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> `HTMLCanvasElement` methods (such as `.toBlob()`) Zone.js-aware.\n// Either import in `polyfills.ts` (if used in more than one places in the app) or in the component\n// file using `HTMLCanvasElement` (if it is only used in a single file).\nimport 'zone.js/plugins/zone-patch-canvas';\n\n</code-example>\n<h4 id=\"async-observables\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a2syrkvav0rjr6ltkb6y9qp8x\">非同步可觀察物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#async-observables\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6bp7zynw5cwjcqzvzy13yp4gw\">你可能已經對前面這些測試的測試覆蓋率感到滿意。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ajz0d0yxcxxbv6tu0t4p3gc1\">但是，你可能也會為另一個事實感到不安：真實的服務並不是這樣工作的。真實的服務會向遠端伺服器傳送請求。伺服器需要一定的時間才能做出回應，並且其回應體肯定不會像前面兩個測試中一樣是立即可用的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29r8tnt11rzgv6s8ytr54foob\">如果能像下面這樣從 <code>getQuote()</code> 間諜中回傳一個<em>非同步的</em>可觀察物件，你的測試就會更真實地反映現實世界。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"async-setup\">\n// Simulate delayed observable values with the `asyncData()` helper\ngetQuoteSpy.and.returnValue(asyncData(testQuote));\n\n</code-example>\n<h4 id=\"async-observable-helpers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"13lyh42xwxbspib1hohkfirxk\">非同步可觀察物件測試助手<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#async-observable-helpers\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zrpte3sxg68xsj39az8bwvc6\">非同步可觀察物件可以由測試助手 <code>asyncData</code> 生成。測試助手 <code>asyncData</code> 是一個你必須自行編寫的工具函式，當然也可以從下面的範例程式碼中複製它。</p>\n<code-example header=\"testing/async-observable-helpers.ts\" path=\"testing/src/testing/async-observable-helpers.ts\" region=\"async-data\">\n/**\n * Create <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> observable that emits-once and completes\n * after a JS engine turn\n */\nexport function asyncData&lt;T&gt;(data: T) {\n  return defer(() =&gt; Promise.resolve(data));\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c5luofchbkwheg6cfi8r19tbj\">這個助手回傳的可觀察物件會在 JavaScript 引擎的下一個週期中傳送 <code>data</code> 值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cfnky4locqzypktyk0fiejit\"><a href=\"http://reactivex.io/documentation/operators/defer.html\">RxJS 的 <code>defer()</code> 運算子</a>回傳一個可觀察物件。它的引數是一個回傳 Promise 或可觀察物件的工廠函式。當某個訂閱者訂閱 <em>defer</em> 生成的可觀察物件時，defer 就會呼叫此工廠函式生成新的可觀察物件，並讓該訂閱者訂閱這個新物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"38uyp6zi7rskge9bx8cgsirpw\"><code>defer()</code> 運算子會把 <code>Promise.resolve()</code> 轉換成一個新的可觀察物件，它和 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 一樣只會傳送一次然後立即結束（complete）。這樣，當訂閱者收到資料後就會自動取消訂閱。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3kkjegr84wd0vb2uq6r9qtfg6\">還有一個類似的用來生成非同步錯誤的測試助手。</p>\n<code-example path=\"testing/src/testing/async-observable-helpers.ts\" region=\"async-error\">\n/**\n * Create <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> observable error that errors\n * after a JS engine turn\n */\nexport function asyncError&lt;T&gt;(errorObject: any) {\n  return defer(() =&gt; Promise.reject(errorObject));\n}\n\n</code-example>\n<h4 id=\"more-async-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e3pu8whi5ta5n9eelcvb0sajf\">更多非同步測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#more-async-tests\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4khdyf4pknb628ht42x55hbii\">現在，<code>getQuote()</code> 間諜正在回傳非同步可觀察物件，你的大多數測試都必須是非同步的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2hm7fd2u1ddg8hqmo49hrc5lf\">下面是一個 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 測試，用於示範你在真實世界中所期望的資料流。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"fake-async-test\">\nit('should show quote after getQuote (<a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>)', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');\n\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observable to get the quote\n  fixture.detectChanges(); // update view\n\n  expect(quoteEl.textContent).withContext('should show quote').toBe(testQuote);\n  expect(errorMessage()).withContext('should not show error').toBeNull();\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4fy3pycuvzczlf72cayhiphcg\">注意，quote 元素會在 <code>ngOnInit()</code> 之後顯示佔位符 <code>'...'</code>。因為第一句名言尚未到來。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvgdxiu38d2cco0dpiq95d8p4\">要重新整理可觀察物件中的第一個引號，你需要呼叫 \n<a href=\"api/core/testing/tick\">tick()</a>。然後呼叫 \n<code>detectChanges()</code> 來告訴 Angular 更新螢幕。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xutq7f545hf4fff66b9zql41\">然後，你可以斷言 quote 元素是否顯示了預期的文字。</p>\n<p><a id=\"waitForAsync\"></a></p>\n<h4 id=\"async-test-with-waitforasync\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ytehlx8arvsgyn0dzlv4o7kk\">用 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 進行非同步測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#async-test-with-waitforasync\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3tjwxfwf3s976dpfdyzanilho\">要使用 \n<code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 功能，你必須在測試設定檔案中匯入 \n<code>zone.js/testing</code>。如果你使用 Angular CLI 建立專案，\n<code>zone-testing</code> 已經為你新增了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"l8x3xmlq18gx0rnidv6a4ouu\">這是之前的 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 測試，用 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 工具函式重寫的版本。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"waitForAsync-test\">\nit('should show quote after getQuote (<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>)', <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');\n\n  fixture.whenStable().then(() =&gt; {\n    // wait for <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> getQuote\n    fixture.detectChanges(); // update view with quote\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).withContext('should not show error').toBeNull();\n  });\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eqfioagm7ehx759b3z4srpt34\"><code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 工具函式透過把測試程式碼安排到在特殊的<em>非同步測試區（async test zone）</em>下執行來隱藏某些用來處理非同步的樣板程式碼。你不需要把 Jasmine 的 <code>done()</code> 傳給測試並讓測試呼叫 <code>done()</code>，因為它在 Promise 或者可觀察物件的回呼函式中是 <code>undefined</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4putogow5fkddnw9fdvdt7uj4\">但是，可以透過呼叫 <code>fixture.whenStable()</code> 函式來揭示本測試的非同步性，因為該函式打破了線性的控制流。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"319k7i1w64v5zvt6d9um19rmb\">在 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 中使用 <code>intervalTimer()</code>（比如 <code>setInterval()</code>）時，別忘了在測試後透過 <code>clearInterval()</code> 取消這個定時器，否則 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 永遠不會結束。</p>\n<p><a id=\"when-stable\"></a></p>\n<h4 id=\"whenstable\"><code>whenStable</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#whenstable\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ml23jlhym4az0fx7go6etsru\">測試必須等待 \n<code>getQuote()</code> 可觀察物件發出下一個引號。而不是呼叫 \n<a href=\"api/core/testing/tick\">tick()</a>，它呼叫 \n<code>fixture.whenStable()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9k05fc0yjlmrkv7bxgqufv1q7\"><code>fixture.whenStable()</code> 回傳一個 Promise，它會在 JavaScript 引擎的任務佇列變空時解析。在這個例子中，當可觀察物件發出第一句名言時，任務佇列就會變為空。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1np0agztt9j7o8casmbh6o7ff\">測試會在該 Promise 的回呼中繼續進行，它會呼叫 <code>detectChanges()</code> 來用期望的文字更新 quote 元素。</p>\n<p><a id=\"jasmine-done\"></a></p>\n<h4 id=\"jasmine-done\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"64v4s799jt45nzfmvgswaxsas\">Jasmine \n<code>done()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#jasmine-done\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azzdv9btrfmko6k0fwebuumlb\">雖然 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 和 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 函式可以大大簡化 Angular 的非同步測試，但你仍然可以回退到傳統技術，並給 <code>it</code> 傳一個以 <a href=\"https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support\"><code>done</code> 回呼</a>為引數的函式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5f0m6jg1oea36jzwgsttwtrxn\">但你不能在 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 或 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 函式中呼叫 <code>done()</code>，因為那裡的 <code>done</code> 引數是 <code>undefined</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"blmq3nau4h5odsdrg6t41id2t\">現在，你要自己負責串聯各種 Promise、處理錯誤，並在適當的時機呼叫 <code>done()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amqwrdb1g660735y6sd2n7jv6\">編寫帶有 <code>done()</code> 的測試函式要比用 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 和 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 的形式笨重。但是當代碼涉及到像 <code>setInterval</code> 這樣的 <code>intervalTimer()</code> 時，它往往是必要的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"auovp3e6hnbdtavitqqgudds9\">這裡是上一個測試的另外兩種版本，用 <code>done()</code> 編寫。第一個訂閱了透過元件的 <code>quote</code> 屬性暴露給樣板的 <code>Observable</code>。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"quote-done-test\">\nit('should show last quote (quote done)', (done: DoneFn) =&gt; {\n  fixture.detectChanges();\n\n  component.quote.pipe(last()).subscribe(() =&gt; {\n    fixture.detectChanges(); // update view with quote\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).withContext('should not show error').toBeNull();\n    done();\n  });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6i0cqhvq0u5hg79e8obxyievj\">RxJS 的 <code>last()</code> 運算子會在完成之前發出可觀察物件的最後一個值，它同樣是測試名言。<code>subscribe</code> 回呼會呼叫 <code>detectChanges()</code> 來使用測試名言重新整理的 quote 元素，方法與之前的測試一樣。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ico8eene3fg5twehgzndk0q8\">在某些測試中，你可能更關心注入的服務方法是如何被調的以及它回傳了什麼值，而不是螢幕顯示的內容。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ax2e5koho8inrmsrqpffb0ica\">服務間諜，比如偽 <code>TwainService</code> 上的 <code>qetQuote()</code> 間諜，可以給你那些訊息，並對視圖的狀態做出斷言。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"spy-done-test\">\nit('should show quote after getQuote (spy done)', (done: DoneFn) =&gt; {\n  fixture.detectChanges();\n\n  // the spy's most recent call returns the observable with the test quote\n  getQuoteSpy.calls.mostRecent().returnValue.subscribe(() =&gt; {\n    fixture.detectChanges(); // update view with quote\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).withContext('should not show error').toBeNull();\n    done();\n  });\n});\n\n</code-example>\n<p><a id=\"marble-testing\"></a></p>\n<h2 id=\"component-marble-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2flqz2rbktkr322r731gly6ne\">元件的彈珠測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-marble-tests\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"egvxaj2v8u2gudffcs7082u33\">前面的 <code>TwainComponent</code> 測試透過 <code>asyncData</code> 和 <code>asyncError</code> 工具函式模擬了一個來自 <code>TwainService</code> 的非同步回應體可觀察物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5pcfofecuusi0itmoasnbcwzf\">你可以自己編寫這些簡短易用的函式。不幸的是，對於很多常見的場景來說，它們太簡單了。可觀察物件經常會發送很多次，可能是在經過一段顯著的延遲之後。元件可以用重疊的值序列和錯誤序列來協調多個可觀察物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72ofdwsy8yaq3za341h0hooyr\"><strong>RxJS 彈珠測試</strong>是一種測試可觀察場景的好方法，它既簡單又複雜。你很可能已經看過用於說明可觀察物件是如何工作<a href=\"https://rxmarbles.com\">彈珠圖</a>。彈珠測試使用類似的彈珠語言來指定測試中的可觀察流和期望值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35pcad5gldcesffko6f1lxjky\">下面的例子用彈珠測試再次實現了 <code>TwainComponent</code> 中的兩個測試。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f02hgkdt38eeoal5awvc0ez2i\">首先安裝 npm 套件 <code>jasmine-marbles</code>。然後匯入你需要的符號。</p>\n<code-example header=\"app/twain/twain.component.marbles.spec.ts (import marbles)\" path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"import-marbles\">\nimport { cold, getTestScheduler } from 'jasmine-marbles';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ahzb4teblmwe85f8qx216j1pt\">獲取名言的完整測試方法如下：</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"get-quote-test\">\nit('should show quote after getQuote (marbles)', () =&gt; {\n  // observable test quote value and complete(), after delay\n  const q$ = cold('---x|', { x: testQuote });\n  getQuoteSpy.and.returnValue(q$);\n\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');\n\n  getTestScheduler().flush(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observables\n\n  fixture.detectChanges(); // update view\n\n  expect(quoteEl.textContent).withContext('should show quote').toBe(testQuote);\n  expect(errorMessage()).withContext('should not show error').toBeNull();\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"edb8ukca66x5ou1mto5vk4rff\">注意，這個 Jasmine 測試是同步的。沒有 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>。彈珠測試使用測試排程程式（scheduler）來模擬同步測試中的時間流逝。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b0uhtvjoqkcc59tbhqv7nzyiy\">彈珠測試的美妙之處在於對可觀察物件流的視覺定義。這個測試定義了一個<a href=\"guide/testing-components-scenarios#cold-observable\"><em>冷</em>可觀察物件</a>，它等待三<a href=\"guide/testing-components-scenarios#marble-frame\">幀</a>（<code>---</code>），發出一個值（<code>x</code>），並完成（<code>|</code>）。在第二個引數中，你把值標記（<code>x</code>）對映到了發出的值（<code>testQuote</code>）。</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"test-quote-marbles\">\nconst q$ = cold('---x|', { x: testQuote });\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2yo7gngw3es3p52ovd7cye0h0\">這個彈珠函式庫會構造出相應的可觀察物件，測試程式把它用作 <code>getQuote</code> 間諜的回傳值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gqye8hvke21h1y4wfji72rbn\">當你準備好啟用彈珠的可觀察物件時，就告訴 <code>TestScheduler</code> 把它準備好的任務佇列<em>重新整理</em>一下。</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"test-scheduler-flush\">\ngetTestScheduler().flush(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observables\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cente6gdrjw98uce7uwhkg1sv\">這一步與之前 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 和 \n<code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 範例中的 \n<a href=\"api/core/testing/tick\">tick()</a> 和 \n<code>whenStable()</code> 類似。測試的其他部分與這些範例相同。</p>\n<h4 id=\"marble-error-testing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7n6xe9d8jwwgicoxiy7xqu6fi\">彈珠錯誤測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#marble-error-testing\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72isgvfkcedhgs20qqvuuysln\">下面是 <code>getQuote()</code> 錯誤測試的彈珠測試版。</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"error-test\">\nit('should display error when TwainService fails', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  // observable error after delay\n  const q$ = cold('---#|', null, new Error('TwainService test failure'));\n  getQuoteSpy.and.returnValue(q$);\n\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');\n\n  getTestScheduler().flush(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observables\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // component shows error after a setTimeout()\n  fixture.detectChanges(); // update error message\n\n  expect(errorMessage())\n    .withContext('should display error')\n    .toMatch(/test failure/);\n  expect(quoteEl.textContent).withContext('should show placeholder').toBe('...');\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zmt30wnr2uhirgd8s7tir1rr\">它仍然是非同步測試，呼叫 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 和 <a href=\"api/core/testing/tick\">tick()</a>，因為該組件在處理錯誤時會呼叫 <code>setTimeout()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"m5udc7cf180y73roer1vkcy3\">看看這個彈珠的可觀察定義。</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"error-marbles\">\nconst q$ = cold('---#|', null, new Error('TwainService test failure'));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43tib88dxe9sdqiefn1vmahk8\">這是一個<em>冷</em>可觀察物件，等待三幀，然後發出一個錯誤，井號（<code>#</code>）標出了在第三個引數中指定錯誤的發生時間。第二個引數為 null，因為該可觀察物件永遠不會發出值。</p>\n<h4 id=\"learn-about-marble-testing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2a2c7dfw6lfhfjd7o4n5zwdw7\">瞭解彈珠測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#learn-about-marble-testing\"><i class=\"material-icons\">link</i></a></h4>\n<p><a id=\"marble-frame\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1hlvvnvmqzp3f7z0pqefdgodj\"><em>彈珠幀</em>是測試時間線上的虛擬單位。每個符號（<code>-</code>，<code>x</code>，<code>|</code>，<code>#</code>）都表示經過了一幀。</p>\n<p><a id=\"cold-observable\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7jf1fue4uk61q4feug142lk17\">冷可觀察物件在訂閱前不會產生值。大多數應用程式可觀察物件都是冷的。所有 \n<a href=\"guide/understanding-communicating-with-http\"><em>HttpClient</em></a> 方法回傳冷可觀察物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a1ev4vn8d9py8w9rlbytdczbx\">而<em>熱的</em>可觀察物件在訂閱它<em>之前</em>就已經在生成了這些值。用來報告路由器活動的 <a href=\"api/router/Router#events\"><code>Router.events</code></a> 可觀察物件就是一種<em>熱</em>可觀察物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8se9zu65zyo5hx2n9uymdaizg\">RxJS 彈珠測試這個主題非常豐富，超出了本指南的範圍。你可以在網上瞭解它，先從其<a href=\"https://rxjs.dev/guide/testing/marble-testing\">官方文件</a>開始。</p>\n<p><a id=\"component-with-input-output\"></a></p>\n<h2 id=\"component-with-inputs-and-outputs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6akltf74dkxr2nmj7g3zripof\">具有輸入和輸出屬性的元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-inputs-and-outputs\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aahkeczgvqe66xi2moaexymy2\">具有輸入和輸出屬性的元件通常會出現在宿主元件的檢視樣板中。宿主使用屬性繫結來設定輸入屬性，並使用事件繫結來監聽輸出屬性引發的事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1hx0jgd2ywi97x99pqc5lpysx\">本測試的目標是驗證這些繫結是否如預期般工作。這些測試應該設定輸入值並監聽輸出事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"acfwvlxhw8304giw7perl0adx\"><code>DashboardHeroComponent</code> 是這類元件的一個小例子。它會顯示由 <code>DashboardComponent</code> 提供的一個英雄。點選這個英雄就會告訴 <code>DashboardComponent</code>，使用者已經選擇了此英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a31limhqwwj3hsibg7nkghqb7\"><code>DashboardHeroComponent</code> 會像這樣內嵌在 <code>DashboardComponent</code> 樣板中的：</p>\n<code-example header=\"app/dashboard/dashboard.component.html (excerpt)\" path=\"testing/src/app/dashboard/dashboard.component.html\" region=\"dashboard-hero\">\n&lt;dashboard-hero\n  *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"\n  class=\"col-1-4\"\n  [hero]=\"hero\"\n  (selected)=\"gotoDetail($event)\"\n&gt;\n&lt;/dashboard-hero&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c62nix4n89aziikt2xjhts5h9\"><code>DashboardHeroComponent</code> 出現在 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 複寫器中，把它的輸入屬性 <code>hero</code> 設定為當前的迴圈變數，並監聽該組件的 <code>selected</code> 事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8iuphrpgspoxeic7iudpmq98e\">這裡是元件的完整定義：</p>\n<p><a id=\"dashboard-hero-component\"></a></p>\n<code-example header=\"app/dashboard/dashboard-hero.component.ts (component)\" path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'dashboard-hero',\n  template: `\n    &lt;button type=\"button\" (click)=\"click()\" class=\"hero\"&gt;\n      {{ hero.name | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a> }}\n    &lt;/button&gt;\n  `,\n  styleUrls: ['./dashboard-hero.component.css'],\n  imports: [<a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">UpperCasePipe</a>],\n})\nexport class DashboardHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() selected = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;Hero&gt;();\n  click() {\n    this.selected.emit(this.hero);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"da1qy45zna391vdzo5g6hz6l3\">在測試一個元件時，像這樣簡單的場景沒什麼內在價值，但值得瞭解它。你可以繼續嘗試這些方法：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zw4mcquoy3dninubu80dy65u\">用 <code>DashboardComponent</code> 來測試它。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwjqc304k7lr4a0gsp8yf7mmt\">把它作為一個獨立的元件進行測試。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9z0danrblvrqr555ocpc92fd4\">用 <code>DashboardComponent</code> 的一個替代品來測試它。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2daf0y5s8yvr6zeeaxlxwa0p1\">快速看一眼 <code>DashboardComponent</code> 建構式函式就知道不建議採用第一種方法：</p>\n<code-example header=\"app/dashboard/dashboard.component.ts (constructor)\" path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\">\nconstructor(\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  private heroService: HeroService,\n) {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51q1biw4uj1cpmtsnva1hu85o\"><code>DashboardComponent</code> 依賴於 Angular 的路由器和 <code>HeroService</code>。你可能不得不用測試替身來代替它們，這有很多工作。路由器看上去特別有挑戰性。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cl9ltcozvtiqui7172ayksvu\"><a href=\"guide/testing-components-scenarios#routing-component\">下面的討論</a>涵蓋瞭如何測試那些需要用到路由器的元件。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cbz43fd7iiytv6ekhzz5kht9i\">當前的目標是測試 <code>DashboardHeroComponent</code>，而不是 <code>DashboardComponent</code>，所以試試第二個和第三個選項。</p>\n<p><a id=\"dashboard-standalone\"></a></p>\n<h4 id=\"test-dashboardherocomponent-stand-alone\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wq1b88co1sl5tho6ypzo59wg\">單獨測試 <code>DashboardHeroComponent</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#test-dashboardherocomponent-stand-alone\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d9ucpbe0i5au54cvoq2ujv1f0\">這裡是 spec 檔案中環境設定部分的內容。</p>\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (setup)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"setup\">\nTestBed.configureTestingModule({\n  providers: appProviders,\n  imports: [DashboardHeroComponent],\n})\nfixture = TestBed.createComponent(DashboardHeroComponent);\ncomp = fixture.componentInstance;\n\n// find the hero's <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> and element\nheroDe = fixture.debugElement.query(By.css('.hero'));\nheroEl = heroDe.nativeElement;\n\n// mock the hero supplied by the parent component\nexpectedHero = { id: 42, name: 'Test Name' };\n\n// simulate the parent setting the input property with that hero\ncomp.hero = expectedHero;\n\n// <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> initial data binding\nfixture.detectChanges();\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1tlnik787nvutnvi5rihaj2x1\">注意這些設定程式碼如何把一個測試英雄（<code>expectedHero</code>）賦值給元件的 <code>hero</code> 屬性的，它模仿了 <code>DashboardComponent</code> 在其複寫器中透過屬性繫結來設定它的方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhbxawydf079bm3cuvpsix68p\">下面的測試驗證了英雄名是透過繫結傳播到樣板的。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"name-test\">\nit('should display hero name in uppercase', () =&gt; {\n  const expectedPipedName = expectedHero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71l9xp0xjxenkqqhn2k01i9nm\">因為<a href=\"guide/testing-components-scenarios#dashboard-hero-component\">樣板</a>把英雄的名字傳給了 <code><a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">UpperCasePipe</a></code>，所以測試必須要讓元素值與其大寫形式的名字一致。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cyd2ey00pqvvz1ifn9fqblik4\">這個小測試示範了 Angular 測試會如何驗證一個元件的視覺化表示形式 - 這是<a href=\"guide/testing-components-basics#component-class-testing\">元件類別測試</a>所無法實現的 - 成本相對較低，無需進行更慢、更復雜的端到端測試。</p>\n</div>\n<h4 id=\"clicking\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xzyzhgy3ao0qjsswmxwjfnz0\">點選<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#clicking\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8niqxzg9qg6k46cg8lrx7xu9k\">單擊該英雄應該會讓一個宿主元件（可能是 <code>DashboardComponent</code>）監聽到 <code>selected</code> 事件。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test\">\nit('should raise selected event when clicked (triggerEventHandler)', () =&gt; {\n  let selectedHero: Hero | undefined;\n  comp.selected.pipe(first()).subscribe((hero: Hero) =&gt; (selectedHero = hero));\n\n  heroDe.triggerEventHandler('click');\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f4kv4j6ud92xugi07u88n1vz1\">該組件的 <code>selected</code> 屬性給消費者回傳了一個 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>，它看起來像是 RxJS 的同步 <code>Observable</code>。該測試只有在宿主元件<em>隱式</em>觸發時才需要<em>顯式</em>訂閱它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4qz5na1mf0jj7gmtzeolaca6r\">當元件的行為符合預期時，單擊此英雄的元素就會告訴元件的 <code>selected</code> 屬性發出了一個 <code>hero</code> 物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6mrm2xwtjftqy75bkk26dfmt\">該測試透過對 <code>selected</code> 的訂閱來檢測該事件。</p>\n<p><a id=\"trigger-event-handler\"></a></p>\n<h4 id=\"triggereventhandler\"><code>triggerEventHandler</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#triggereventhandler\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2txv3kkkokn0vbe7jd0kaphnn\">前面測試中的 <code>heroDe</code> 是一個指向英雄條目 <code>&lt;div&gt;</code> 的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dhr74g9pzokzkyddaunuflmpg\">它有一些用於抽象與原生元素互動的 Angular 屬性和方法。這個測試會使用事件名稱 <code>click</code> 來呼叫 <code>DebugElement.triggerEventHandler</code>。<code>click</code> 的事件繫結到了 <code>DashboardHeroComponent.click()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlppoouihcpcbszrlyioskd6d\">Angular 的 <code>DebugElement.triggerEventHandler</code> 可以用<strong>事件的名字</strong>觸發<strong>任何資料繫結事件</strong>。第二個引數是傳給事件處理器的事件物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cmfn670w9psrj9cixjnxwuidd\">該測試觸發了一個 『click』 事件。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"trigger-event-handler\">\nheroDe.triggerEventHandler('click');\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68s6klqmouuxwkk5x2bgsm38i\">在這裡，測試程式假設執行時間的事件處理器（元件的 <code>click()</code> 方法）不關心事件物件。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vrlkaeaz8fbokb3qvitemfpy\">其它處理器的要求比較嚴格。比如，<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令期望一個帶有 <code>button</code> 屬性的物件，該屬性用於指出點選時按下的是哪個滑鼠按鈕（如果有）。如果不給出這個事件物件，<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令就會丟擲一個錯誤。</p>\n</div>\n<h4 id=\"click-the-element\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7y6e4w4w8rkf5d29p98b3gn0r\">點選該元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#click-the-element\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dz63du0423sp1zvau7uob0adu\">下面這個測試改為呼叫原生元素自己的 <code>click()</code> 方法，它對於<em>這個元件</em>來說相當完美。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-2\">\nit('should raise selected event when clicked (element.click)', () =&gt; {\n  let selectedHero: Hero | undefined;\n  comp.selected.pipe(first()).subscribe((hero: Hero) =&gt; (selectedHero = hero));\n\n  heroEl.click();\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<p><a id=\"click-helper\"></a></p>\n<h4 id=\"click-helper\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aif2jhvpda4oimvqlgcdhr5z4\"><code>click()</code> 幫助器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#click-helper\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4aqbfipdljftyc329w5k5y05b\">點選按鈕、連結或者任意 HTML 元素是很常見的測試任務。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68iq7o40h99t7dlmta93jqyhe\">把<em>點選事件</em>的處理過程包裝到如下的 <code>click()</code> 輔助函式中，可以讓這項任務更一致、更簡單：</p>\n<code-example header=\"testing/index.ts (click helper)\" path=\"testing/src/testing/index.ts\" region=\"click-event\">\n/** Button events to pass to `DebugElement.triggerEventHandler` for <a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a> event handler */\nexport const ButtonClickEvents = {\n  left: { button: 0 },\n  right: { button: 2 },\n};\n\n/** Simulate element click. Defaults to mouse left-button click event. */\nexport function click(\n  el: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> | HTMLElement,\n  eventObj: any = ButtonClickEvents.left,\n): void {\n  if (el instanceof HTMLElement) {\n    el.click();\n  } else {\n    el.triggerEventHandler('click', eventObj);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5penf8u6a4465908n3rp5nt7p\">第一個引數是<strong>用來點選的元素</strong>。如果你願意，可以將自定義的事件物件傳給第二個引數。預設的是（區域性的）<a href=\"https://developer.mozilla.org/docs/Web/API/MouseEvent/button\">滑鼠左鍵事件物件</a>，它被許多事件處理器接受，包括 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26eis6yj7ij5dxvven5bk2zm6\"><code>click()</code> 輔助函式<strong>不是</strong>Angular 測試工具之一。它是在<strong>本章的例子程式碼</strong>中定義的函式方法，被所有測試例子所用。如果你喜歡它，將它新增到你自己的輔助函式集。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dj3pfjwvn51x7so63un6fl749\">下面是把前面的測試用 <code>click</code> 輔助函式重寫後的版本。</p>\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (test with click helper)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-3\">\nit('should raise selected event when clicked (click helper with <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>)', () =&gt; {\n  let selectedHero: Hero | undefined;\n  comp.selected.pipe(first()).subscribe((hero: Hero) =&gt; (selectedHero = hero));\n\n  click(heroDe); // click helper with <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>\n\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<p><a id=\"component-inside-test-host\"></a></p>\n<h2 id=\"component-inside-a-test-host\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d5o8ljbojifmr4s6e99zljc9e\">位於測試宿主中的元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-inside-a-test-host\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cv7i0kkpmseyl6t7x3qnhpz22\">前面的這些測試都是自己扮演宿主元素 <code>DashboardComponent</code> 的角色。但是當 <code>DashboardHeroComponent</code> 真的繫結到某個宿主元素時還能正常工作嗎？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aprkwxjx7upqj6uzou625dagv\">固然，你也可以測試真實的 <code>DashboardComponent</code>。但要想這麼做需要做很多準備工作，特別是它的樣板中使用了某些屬性，如 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>、 其它元件、佈局 HTML、附加繫結、注入了多個服務的建構式函式、如何用正確的方式與那些服務互動等。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cfxhty0gg3eri0rnfywmhmjxm\">想出這麼多需要努力排除的干擾，只是為了證明一點 —— 可以造出這樣一個令人滿意的<em>測試宿主</em>：</p>\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (test host)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  imports: [DashboardHeroComponent],\n  template: ` &lt;dashboard-hero [hero]=\"hero\" (selected)=\"onSelected($event)\"&gt; &lt;/dashboard-hero&gt;`,\n})\nclass TestHostComponent {\n  hero: Hero = { id: 42, name: 'Test Name' };\n  selectedHero: Hero | undefined;\n  onSelected(hero: Hero) {\n    this.selectedHero = hero;\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"17aybcmy96iv5ycte2esh48s9\">這個測試宿主像 <code>DashboardComponent</code> 那樣繫結了 <code>DashboardHeroComponent</code>，但是沒有 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>、 沒有 <code>HeroService</code>，也沒有 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5supqa8fgis1d4p97t5nrbyeo\">這個測試宿主使用其測試用的英雄設定了元件的輸入屬性 <code>hero</code>。它使用 <code>onSelected</code> 事件處理器繫結了元件的 <code>selected</code> 事件，其中把事件中發出的英雄記錄到了 <code>selectedHero</code> 屬性中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"erja8a5shvuxp3c8tpkeacdpi\">稍後，這個測試就可以輕鬆檢查 <code>selectedHero</code> 以驗證 <code>DashboardHeroComponent.selected</code> 事件確實發出了所期望的英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"351dk5uiyfvr7jbv9hhhfzjhv\">這個<em>測試宿主</em>中的準備程式碼和獨立測試中的準備過程類似：</p>\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (test host setup)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-setup\">\nTestBed.configureTestingModule({\n  providers: appProviders,\n  imports: [DashboardHeroComponent, TestHostComponent],\n})\n// create TestHostComponent instead of DashboardHeroComponent\nfixture = TestBed.createComponent(TestHostComponent);\ntestHost = fixture.componentInstance;\nheroEl = fixture.nativeElement.querySelector('.hero');\nfixture.detectChanges(); // <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> initial data binding\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jfbtwpmyvq9rt3ckck3jt0mr\">這個測試模組的設定訊息有三個重要的不同點：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5rae7zv6g9qtme1wonzo7cjzl\">它同時<strong>宣告</strong>了 <code>DashboardHeroComponent</code> 和 <code>TestHostComponent</code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63riq2qpe5fg1azmmrs48crps\">它<strong>建立</strong>了 <code>TestHostComponent</code>，而非 <code>DashboardHeroComponent</code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ecimwegy6rhzj0bh9z3j70inz\"><code>TestHostComponent</code> 透過繫結機制設定了 <code>DashboardHeroComponent.hero</code>。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8t6ic5ucnwj8n1ljsgo4p5pf\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code> 回傳的 <code>fixture</code> 裡有 <code>TestHostComponent</code> 實例，而非 <code>DashboardHeroComponent</code> 元件實例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3qw0dewurmhn36gf1oqy4g567\">當然，建立 <code>TestHostComponent</code> 有建立 <code>DashboardHeroComponent</code> 的副作用，因為後者出現在前者的樣板中。英雄元素（<code>heroEl</code>）的查詢語句仍然可以在測試 DOM 中找到它，儘管元素樹比以前更深。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7zxbrdygjmsirjboyh9sh9103\">這些測試本身和它們的孤立版本幾乎相同：</p>\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (test-host)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-tests\">\nit('should display hero name', () =&gt; {\n  const expectedPipedName = testHost.hero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\nit('should raise selected event when clicked', () =&gt; {\n  click(heroEl);\n  // selected hero should be the same data bound hero\n  expect(testHost.selectedHero).toBe(testHost.hero);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2cxz6e9kheiq6yshgc27mty8b\">只有 selected 事件的測試不一樣。它確保被選擇的 <code>DashboardHeroComponent</code> 英雄確實透過事件繫結被傳遞到宿主元件。</p>\n<p><a id=\"routing-component\"></a></p>\n<h2 id=\"routing-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9u7mq4pbjyv40jwu8gjh18zum\">路由元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#routing-component\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9kta34sephuj4ctyukhngrg7q\">所謂<em>路由元件</em>就是指會要求 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 導向到其它元件的元件。<code>DashboardComponent</code> 就是一個<em>路由元件</em>，因為使用者可以透過點選儀表盤中的某個<em>英雄按鈕</em>來導向到 <code>HeroDetailComponent</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e4wmlb91dnhmzguc50xrs4wjw\">路由確實很複雜。測試 <code>DashboardComponent</code> 看上去有點令人生畏，因為它牽扯到和 <code>HeroService</code> 一起注入進來的 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>。</p>\n<code-example header=\"app/dashboard/dashboard.component.ts (constructor)\" path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\">\nconstructor(\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  private heroService: HeroService,\n) {}\n\n</code-example>\n<code-example header=\"app/dashboard/dashboard.component.ts (goToDetail)\" path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"goto-detail\">\ngotoDetail(hero: Hero) {\n  const url = `/heroes/${hero.id}`;\n  this.router.navigateByUrl(url);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"apjl2mfdfkproi9zoeztrptqp\">Angular 提供了一些測試助手來減少樣板程式碼並更有效地測試依賴於 Router 和 HttpClient 的程式碼。</p>\n<code-example header=\"app/dashboard/dashboard.component.spec.ts\" path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"router-harness\">\nTestBed.configureTestingModule(\n  Object.assign({}, appConfig, {\n    imports: [DashboardComponent],\n    providers: [\n      <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{ path: '**', component: DashboardComponent }]),\n      <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n      <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n      HeroService,\n    ],\n  }),\n)\n  .compileComponents()\n  .then(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    harness = await RouterTestingHarness.create();\n    comp = await harness.navigateByUrl('/', DashboardComponent);\n    TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>).expectOne('api/heroes').flush(getTestHeroes());\n  });\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aayupyjnkwj7ghgzy56yba92p\">下面這個測試會點選正在顯示的英雄，並確認我們正在導向到所期望的 URL。</p>\n<code-example header=\"app/dashboard/dashboard.component.spec.ts (navigate test)\" path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"navigate-test\">\nit('should tell navigate when hero clicked', <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await heroClick(); // <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> click on first inner &lt;div class=\"hero\"&gt;\n\n  // expecting to navigate to id of the component's first hero\n  const id = comp.heroes[0].id;\n  expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url)\n    .withContext('should nav to HeroDetail for first hero')\n    .toEqual(`/heroes/${id}`);\n});\n\n</code-example>\n<p><a id=\"routed-component-w-param\"></a></p>\n<h2 id=\"routed-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ca0qb793u28asb2pr12abrcat\">路由目標元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#routed-components\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2cgyfr4ypowtxuc3qbbozwknd\"><em>路由目標元件</em>是指 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 導向到的目標。它測試起來可能很複雜，特別是當路由到的這個元件<em>包含引數</em>的時候。<code>HeroDetailComponent</code> 就是一個<em>路由目標元件</em>，它是某個路由定義指向的目標。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3zu6fvnyoqa2qemvfw1v8br04\">當用戶點選<em>儀表盤</em>中的英雄時，<code>DashboardComponent</code> 會要求 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 導向到 <code>heroes/:id</code>。<code>:id</code> 是一個路由引數，它的值就是所要編輯的英雄的 <code>id</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4hmme4stz91wn12scw4tacayk\">該 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 會根據那個 URL 對應到一個指向 <code>HeroDetailComponent</code> 的路由。它會建立一個帶有路由訊息的 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 物件，並把它注入到一個 <code>HeroDetailComponent</code> 的新實例中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b9lk3m1abbsp03d1o8dnz0gab\">下面是 <code>HeroDetailComponent</code> 的建構式函式：</p>\n<code-example header=\"app/hero/hero-detail.component.ts (constructor)\" path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ctor\">\nconstructor(\n  private heroDetailService: HeroDetailService,\n  private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n) {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44utcugltpmq0800aq9rhq6bh\"><code>HeroDetailComponent</code> 元件需要一個 <code>id</code> 引數，以便透過 <code>HeroDetailService</code> 獲取相應的英雄。該組件只能從 <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 屬性中獲取這個 <code>id</code>，這個屬性是一個 <code>Observable</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2f2b6ilfxcloxa5cyexcj6axs\">它不能僅僅引用 <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 的 <code>id</code> 屬性。該組件不得不<em>訂閱</em> <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 這個可觀察物件，要做好它在生命週期中隨時會發生變化的準備。</p>\n<code-example header=\"app/hero/hero-detail.component.ts (ngOnInit)\" path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ng-on-init\">\nngOnInit(): void {\n  // get hero when `id` param changes\n  this.route.paramMap.subscribe((pmap) =&gt; this.getHero(pmap.get('id')));\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8jfqapiio248t8f18tk0j8j5l\"><a href=\"guide/router-tutorial-toh\">路由教程：英雄之旅</a>一章的 <a href=\"guide/router-tutorial-toh#activated-route-in-action\">ActivatedRoute 實戰</a>部分詳細講解了 <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"34a9aq4xsq8s5mq1crriyg3jz\">透過導向到不同的路由，測試可以探查 <code>HeroDetailComponent</code> 是如何對不同的 <code>id</code> 引數值做出回應的。</p>\n<h4 id=\"testing-with-the-routertestingharness\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6hj5gd4607xjxf6aqj3gshu0s\">使用 <code>ActivatedRouteStub</code> 進行測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#testing-with-the-routertestingharness\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2374t2d9s5zfixbfdxu1lrspv\">下面的測試程式是示範元件在被觀察的 <code>id</code> 指向現有英雄時的行為：</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (existing id)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-good-id\">\ndescribe('when navigate to existing hero', () =&gt; {\n  let expectedHero: Hero;\n\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    expectedHero = firstHero;\n    await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(expectedHero.id);\n  });\n  it(\"should display that hero's name\", () =&gt; {\n    expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n  });\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"egsvfwrw9kj7xplplhymq9lvi\">稍後會對 <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code> 方法和 <code>page</code> 物件進行討論。不過目前，你只要憑直覺來理解就行了。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35s151lkbccxpzrhi65adxj2u\">當找不到 <code>id</code> 的時候，元件應該重新路由到 <code>HeroListComponent</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6fgdve13s7yy4dyutd50t2acg\">測試套件的準備程式碼提供了一個和<a href=\"guide/testing-components-scenarios#routing-component\">前面</a>一樣的路由器間諜，它會充當路由器的角色，而不用發起實際的導向。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ctw509cw2ylaocv2gryy70nh1\">這個測試中會期待該組件嘗試導向到 <code>HeroListComponent</code>。</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (bad id)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-bad-id\">\ndescribe('when navigate to non-existent hero id', () =&gt; {\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(999);\n  });\n\n  it('should try to navigate back to hero list', () =&gt; {\n    expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes');\n  });\n});\n\n</code-example>\n<h2 id=\"nested-component-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b867kv4bibqcsucw7n6kky6hj\">對巢狀元件的測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#nested-component-tests\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80ejtb5xykj7ol81bc5jtwlt3\">元件的樣板中通常還會有巢狀元件，巢狀元件的樣板還可能包含更多元件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d7qf3lcdpauhem95ozbcael1r\">這棵元件樹可能非常深，並且大多數時候在測試這棵樹頂部的元件時，這些巢狀的元件都無關緊要。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dcejotvqjvx3sjgcl5hnizzkn\">比如，<code>AppComponent</code> 會顯示一個帶有連結及其 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令的導向條。</p>\n<code-example header=\"app/app.component.html\" path=\"testing/src/app/app.component.html\">\n&lt;app-banner&gt;&lt;/app-banner&gt;\n&lt;app-welcome&gt;&lt;/app-welcome&gt;\n&lt;nav&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/dashboard\"&gt;Dashboard&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\"&gt;Heroes&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/about\"&gt;About&lt;/a&gt;\n&lt;/nav&gt;\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cgrfrqak7dztdznvovrvccuqf\">要想驗證這些連結，你不必用 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 進行導向，也不必使用 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 來指出 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 應該把<em>路由目標元件</em>插入到什麼地方。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b0trxeu42mq5umejpr2mfn1p0\">而 <code>BannerComponent</code> 和 <code>WelcomeComponent</code>（寫作 <code>&lt;app-banner&gt;</code> 和 <code>&lt;app-welcome&gt;</code>）也同樣風馬牛不相及。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5o8kosjrwuuypvcitvfe0g8zd\">然而，任何測試，只要能在 DOM 中建立 <code>AppComponent</code>，也就同樣能建立這三個元件的實例。如果要建立它們，你就要設定 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3zjkhnnjpfzfahohhc59bgw1t\">如果你忘了宣告它們，Angular 編譯器就無法在 <code>AppComponent</code> 樣板中識別出 <code>&lt;app-banner&gt;</code>、<code>&lt;app-welcome&gt;</code> 和 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 標記，並丟擲一個錯誤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bee1eoienzsxfjz7fcv9dg1om\">如果你宣告的這些都是真實的元件，那麼也同樣要宣告<em>它們</em>的巢狀元件，並要為這棵元件樹中的<em>任何</em>元件提供要注入的<em>所有</em>服務。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59aebrdhcs5i9hayt01xly9jq\">如果只是想回答關於連結的一些簡單問題，做這些顯然就太多了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bq6c8rjnospe6a114xflty2aw\">本節會講減少此類準備工作的兩項技術。單獨使用或組合使用它們，可以讓這些測試聚焦於要測試的主要元件上。</p>\n<p><a id=\"stub-component\"></a></p>\n<h5 id=\"stubbing-unneeded-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xf0j58xy8pd7945d3owxi2ei\">對不需要的元件提供樁（stub）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#stubbing-unneeded-components\"><i class=\"material-icons\">link</i></a></h5>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8p7ostyzclgvuoiz384s3kpy\">這項技術中，你要為那些在測試中無關緊要的元件或指令建立和聲明一些測試樁。</p>\n<code-example header=\"app/app.component.spec.ts (stub declaration)\" path=\"testing/src/app/app.component.spec.ts\" region=\"component-stubs\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ standalone: true, selector: 'app-banner', template: '' })\nclass BannerStubComponent {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ standalone: true, selector: '<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>', template: '' })\nclass RouterOutletStubComponent {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ standalone: true, selector: 'app-welcome', template: '' })\nclass WelcomeStubComponent {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"zz9fqdgy67aho07tc4wekkda\">這些測試樁的選擇器要和其對應的真實元件一致，但其樣板和類是空的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wfmz4wgvubciyheu3b57cz81\">然後在 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的設定中那些真正有用的元件、指令、通道之後宣告它們。</p>\n<code-example header=\"app/app.component.spec.ts (TestBed stubs)\" path=\"testing/src/app/app.component.spec.ts\" region=\"testbed-stubs\">\nTestBed.configureTestingModule(\n  Object.assign({}, appConfig, {\n    imports: [\n      AppComponent,\n      BannerStubComponent,\n      <a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>,\n      RouterOutletStubComponent,\n      WelcomeStubComponent,\n    ],\n    providers: [<a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([]), UserService],\n  }),\n)\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3hm7s5x7prju490spg5jb2yd9\"><code>AppComponent</code> 是該測試的主角，因此當然要用它的真實版本。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1oia9ptwsrcykit8zsdn1373m\">其它都是測試樁。</p>\n<p><a id=\"no-errors-schema\"></a></p>\n<h4 id=\"no_errors_schema\"><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#no_errors_schema\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4yar357kciry6hjcafsnymloe\">第二種辦法就是把 <code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 新增到 <code>TestBed.schemas</code> 的元資料中。</p>\n<code-example header=\"app/app.component.spec.ts (NO_ERRORS_SCHEMA)\" path=\"testing/src/app/app.component.spec.ts\" region=\"no-errors-schema\">\nTestBed.configureTestingModule(\n  Object.assign({}, appConfig, {\n    imports: [\n      AppComponent,\n      <a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>,\n    ],\n    providers: [<a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([]), UserService],\n    schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>],\n  }),\n)\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cr5a083qzo65xg8mm9oyxkhm\"><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 會要求 Angular 編譯器忽略不認識的那些元素和屬性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"88ffuxxshvhpzlkdzgbyn3q49\">編譯器將會識別出 <code>&lt;app-root&gt;</code> 元素和 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 屬性，因為你在 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的設定中宣告了相應的 <code>AppComponent</code> 和 <code>RouterLinkDirectiveStub</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bmqcaj0vtv9cq2fuyie39ft58\">但編譯器在遇到 <code>&lt;app-banner&gt;</code>、<code>&lt;app-welcome&gt;</code> 或 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 時不會報錯。它只會把它們渲染成空白標籤，而瀏覽器會忽略這些標籤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92rv6shqwij8w6w9rwlaw3lmt\">你不用再提供樁元件了。</p>\n<h4 id=\"use-both-techniques-together\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26luscwauyhxs3fsg5ps6hgx2\">同時使用這兩項技術<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#use-both-techniques-together\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eao68ejtfk32rgtovoyovku0y\">這些是進行<em>淺層</em>測試要用到的技術，之所以叫淺層測試是因為只包含本測試所關心的這個元件樣板中的元素。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2oncy3o1dmr7ya9ucza3i3mv\"><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 方法在這兩者中比較簡單，但也不要過度使用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e88ldsrilrgg6d4wp900o3d7i\"><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 還會阻止編譯器告訴你因為的疏忽或拼寫錯誤而缺失的元件和屬性。你如果人工找出這些 bug 可能要浪費幾個小時，但編譯器可以立即捕獲它們。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5doxb0pn8rtlgjz6x8nz517ys\"><em>樁元件</em>方式還有其它優點。雖然<em>這個</em>例子中的樁是空的，但你如果想要和它們用某種形式互動，也可以給它們一些裁剪過的樣板和類。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"avciyrauanr9iwma6awupxhwc\">在實踐中，你可以在準備程式碼中組合使用這兩種技術，例子如下。</p>\n<code-example header=\"app/app.component.spec.ts (mixed setup)\" path=\"testing/src/app/app.component.spec.ts\" region=\"mixed-setup\">\nTestBed.configureTestingModule(\n  Object.assign({}, appConfig, {\n    imports: [\n      AppComponent,\n      BannerStubComponent,\n      <a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>,\n    ],\n    providers: [<a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([]), UserService],\n    schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>],\n  }),\n)\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7hhb0qap6g2eg9ichvgv7zvnv\">Angular 編譯器會為 <code>&lt;app-banner&gt;</code> 元素建立 <code>BannerStubComponent</code>，並把 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 應用到帶有 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 屬性的連結上，不過它會忽略 <code>&lt;app-welcome&gt;</code> 和 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 標籤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bpri5l03klwoxjt2sbi5na9l8\"><a id=\"by-directive\"></a>\n<a id=\"inject-directive\"></a></p>\n<h4 id=\"bydirective-and-injected-directives\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4dnqomcs6sfetld7m3znwer1z\"><code>By.directive</code> 與注入的指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#bydirective-and-injected-directives\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gpft9ec9qy1w4wrgwoc2f8m\">再一步設定觸發了資料繫結的初始化，獲取導向連結的引用：</p>\n<code-example header=\"app/app.component.spec.ts (test setup)\" path=\"testing/src/app/app.component.spec.ts\" region=\"test-setup\">\nbeforeEach(() =&gt; {\n  fixture.detectChanges(); // <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> initial data binding\n\n  // find DebugElements with an attached RouterLinkStubDirective\n  linkDes = fixture.debugElement.queryAll(By.directive(<a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>));\n\n  // get attached link directive instances\n  // using each <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>'s injector\n  routerLinks = linkDes.map((de) =&gt; de.injector.get(<a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>));\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3u9fdsznbwxcnxjxy6ncfdjsc\">有三點特別重要：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"36vn7ez0zlzzu1qdmzu8m1b07\">你可以使用 <code>By.directive</code> 來定位一個帶附屬指令的連結元素。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d1ferlr0swuybvi74i0vffoxf\">該查詢回傳包含了對應元素的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 套件裝器。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3pmqbiv96c1hsbzcqgvmspmwy\">每個 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 都會匯出該元素中的一個依賴注入器，其中帶有指定的指令實例。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6adft3lczl7lmru73jdcq4z40\"><code>AppComponent</code> 中要驗證的連結如下：</p>\n<code-example header=\"app/app.component.html (navigation links)\" path=\"testing/src/app/app.component.html\" region=\"links\">\n&lt;nav&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/dashboard\"&gt;Dashboard&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\"&gt;Heroes&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/about\"&gt;About&lt;/a&gt;\n&lt;/nav&gt;\n\n</code-example>\n<p><a id=\"app-component-tests\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cj73obu7i7zhp9y07a1qjpry9\">下面這些測試用來確認那些連結是否如預期般連線到了 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令中：</p>\n<code-example header=\"app/app.component.spec.ts (selected tests)\" path=\"testing/src/app/app.component.spec.ts\" region=\"tests\">\nit('can get RouterLinks from template', () =&gt; {\n  expect(routerLinks.length).withContext('should have 3 routerLinks').toBe(3);\n  expect(routerLinks[0].href).toBe('/dashboard');\n  expect(routerLinks[1].href).toBe('/heroes');\n  expect(routerLinks[2].href).toBe('/about');\n});\n\nit('can click Heroes link in template', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  const heroesLinkDe = linkDes[1]; // heroes link <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>\n\n  TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).resetConfig([{ path: '**', children: [] }]);\n  heroesLinkDe.triggerEventHandler('click', { button: 0 });\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();\n  fixture.detectChanges();\n\n  expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toBe('/heroes');\n}));\n\n</code-example>\n<p><a id=\"page-object\"></a></p>\n<h2 id=\"use-a-page-object\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d9qje71zra5eyw9hom3ehkiki\">使用 <code>page</code> 物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#use-a-page-object\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8c4x7ggqu8w6ltj4fmea6is95\"><code>HeroDetailComponent</code> 是帶有標題、兩個英雄欄位和兩個按鈕的簡單檢視。</p>\n<div class=\"lightbox\">\n<img alt=\"HeroDetailComponent in action\" src=\"generated/images/guide/testing/hero-detail.component.png\" width=\"269\" height=\"170\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4rge93bafozg97ktx4m3w76q\">但即使是這麼簡單的表單，其樣板中也涉及到不少複雜性。</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.html\" header=\"app/hero/hero-detail.component.html\">\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\"&gt;\n  &lt;h2&gt;\n    &lt;span&gt;{{ hero.name | <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">titlecase</a> }}&lt;/span&gt; Details\n  &lt;/h2&gt;\n  &lt;div&gt;&lt;span&gt;id: &lt;/span&gt;{{ hero.id }}&lt;/div&gt;\n  &lt;div&gt;\n    &lt;label for=\"name\"&gt;name: &lt;/label&gt;\n    &lt;input id=\"name\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" placeholder=\"name\" /&gt;\n  &lt;/div&gt;\n  &lt;button type=\"button\" (click)=\"save()\"&gt;Save&lt;/button&gt;\n  &lt;button type=\"button\" (click)=\"cancel()\"&gt;Cancel&lt;/button&gt;\n&lt;/div&gt;\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cg10ynzbf8uf2rxb3o9lph6p1\">這些供練習用的元件需要 ……</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eq1tj4793dhnlbpsa1wbsw5kz\">等獲取到英雄之後才能讓元素出現在 DOM 中</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5cu598a72n1z7fsn2tn8jit1l\">一個對標題文字的引用</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bd2zgtj8zktg78ituhv1p2rft\">一個對 name 輸入框的引用，以便對它進行探查和修改</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uy3kwhnrvtt1fg1dqjsyeo2v\">引用兩個按鈕，以便點選它們</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bp3iz6dv31ps5x30zu471f1dc\">為元件和路由器的方法安插間諜</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bdv1cg0mw1m9xwdiukwh5wpfo\">即使是像這樣一個很小的表單，也能產生令人瘋狂的錯綜複雜的條件設定和 CSS 元素選擇。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"am5sj0d79q0n6r9agf082vr6k\">可以使用 <code>Page</code> 類來征服這種複雜性。<code>Page</code> 類可以處理對元件屬性的訪問，並對設定這些屬性的邏輯進行封裝。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"67uuvaycjhu2omwzp1ew8ps1q\">下面是一個供 <code>hero-detail.component.spec.ts</code> 使用的 <code>Page</code> 類</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (Page)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"page\">\nclass Page {\n  // getter properties wait to <a href=\"api/animations/query\" class=\"code-anchor\">query</a> the DOM until called.\n  get buttons() {\n    return this.queryAll&lt;HTMLButtonElement&gt;('button');\n  }\n  get saveBtn() {\n    return this.buttons[0];\n  }\n  get cancelBtn() {\n    return this.buttons[1];\n  }\n  get nameDisplay() {\n    return this.query&lt;HTMLElement&gt;('span');\n  }\n  get nameInput() {\n    return this.query&lt;HTMLInputElement&gt;('input');\n  }\n\n  //// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> helpers ////\n  private <a href=\"api/animations/query\" class=\"code-anchor\">query</a>&lt;T&gt;(selector: string): T {\n    return harness.routeNativeElement!.querySelector(selector)! as T;\n  }\n\n  private queryAll&lt;T&gt;(selector: string): T[] {\n    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"36jp2xbsoqvhvygu6k3mx1u2\">現在，用來操作和檢查元件的重要鉤子都被井然有序的組織起來了，可以透過 <code>page</code> 實例來使用它們。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9qs68nfup4npf147co9eecu5t\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code> 方法會建立一個 <code>page</code> 物件，並在 <code>hero</code> 到來時自動填補空白。</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (createComponent)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"create-component\">\n<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> function <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(id: number) {\n  harness = await RouterTestingHarness.create();\n  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);\n  page = new Page();\n\n  const request = TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>).expectOne(`api/heroes/?id=${id}`);\n  const hero = getTestHeroes().find((h) =&gt; h.id === Number(id));\n  request.flush(hero ? [hero] : []);\n  harness.detectChanges();\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"akwr9l1qosfrfbwuaphrwh27b\">還有更多的 <code>HeroDetailComponent</code> 測試可以證明這一點。</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (selected tests)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"selected-tests\">\nit(\"should display that hero's name\", () =&gt; {\n  expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n});\n\nit('should navigate when click cancel', () =&gt; {\n  click(page.cancelBtn);\n  expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual(`/heroes/${expectedHero.id}`);\n});\n\nit('should save when click save but not navigate immediately', () =&gt; {\n  click(page.saveBtn);\n  expect(TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>).expectOne({ method: 'PUT', url: 'api/heroes' }));\n  expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes/41');\n});\n\nit('should navigate when click save and save resolves', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  click(page.saveBtn);\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // wait for <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> save to complete\n  expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes/41');\n}));\n\nit('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () =&gt; {\n  // get the name's input and display elements from the DOM\n  const hostElement: HTMLElement = harness.routeNativeElement!;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input')!;\n  const nameDisplay: HTMLElement = hostElement.querySelector('span')!;\n\n  // simulate user entering a new name into the input box\n  nameInput.value = 'quick BROWN  fOx';\n\n  // Dispatch a DOM event so that Angular learns of input value change.\n  nameInput.dispatchEvent(new <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>('input'));\n\n  // Tell Angular to update the display binding through the title pipe\n  harness.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});\n\n</code-example>\n<p><a id=\"compile-components\"></a></p>\n<h2 id=\"calling-compilecomponents\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56oq240vlwrcjj867ol39albx\">呼叫 <code>compileComponents()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#calling-compilecomponents\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d05l4xuic1110awa1kkrz80tu\">如果你<em>只想</em>使用 CLI 的 <code>ng test</code> 指令來執行測試，那麼可以忽略這一節。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4spks1aa259148n67m7nne9k2\">如果你在<strong>非 CLI 環境</strong>中執行測試，這些測試可能會報錯，錯誤訊息如下：</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nError: This test module uses the component BannerComponent\nwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aus0eq4ywpi2a5jmepvg9gysg\">問題的根源在於這個測試中至少有一個元件引用了外部樣板或外部 CSS 檔案，就像下面這個版本的 <code>BannerComponent</code> 所示。</p>\n<code-example header=\"app/banner/banner-external.component.ts (external template &amp; css)\" path=\"testing/src/app/banner/banner-external.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-banner',\n  templateUrl: './banner-external.component.html',\n  styleUrls: ['./banner-external.component.css'],\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ayu3s6yieh4yi04tv9ts8ka6\">當 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 檢視建立元件時，這個測試失敗了。</p>\n<code-example avoid=\"\" header=\"app/banner/banner-external.component.spec.ts (setup that fails)\" path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"setup-may-fail\">\nbeforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await TestBed.configureTestingModule({\n    imports: [BannerComponent],\n  }); // missing call to compileComponents()\n  fixture = TestBed.createComponent(BannerComponent);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7fny46hsuupawp17vismv9izw\">回想一下，這個應用從未編譯過。所以當你呼叫 <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code> 的時候，<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 就會進行隱式編譯。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4kwy38s3zrwla8s5sx3t4sp8r\">當它的原始碼都在記憶體中的時候，這樣做沒問題。不過 <code>BannerComponent</code> 需要一些外部檔案，編譯時必須從檔案系統中讀取它，而這是一個天生的<em>非同步</em>操作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7enqyqyn936p8qeiwiiiz23gd\">如果 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 繼續執行，這些測試就會繼續執行，並在編譯器完成這些非同步工作之前導致莫名其妙的失敗。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56ght0bl8zvthwq8ybbauz7te\">這些錯誤訊息告訴你要使用 <code>compileComponents()</code> 進行顯式的編譯。</p>\n<h4 id=\"compilecomponents-is-async\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dk7nawia0rg8fjkg3oh09chm\"><code>compileComponents()</code> 是非同步的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#compilecomponents-is-async\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5gtaw6a789flsrbfamqxy3718\">你必須在非同步測試函式中呼叫 <code>compileComponents()</code>。</p>\n<div class=\"alert is-critical\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41nab5wzs9l66rb66zll42n0z\">如果你忘了把測試函式標為非同步的（比如忘了像稍後的程式碼中那樣使用 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code>），就會看到下列錯誤。</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nError: ViewDestroyedError: Attempt to use a destroyed view\n\n</code-example>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ogf1axrgmc4dftw8mb1q70sf\">典型的做法是把準備邏輯拆成兩個獨立的 <code>beforeEach()</code> 函式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dt2uvbdl3r7k4tmkiulzt8lb8\">函式</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"du2k0ot8dd85yee4gr9zf42g4\">非同步 \n<code>beforeEach()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c56u2iatdmxbl3gg1o92k37x5\">編譯元件</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5g2ncw2j80y78up5ntt2dcgnn\">同步 \n<code>beforeEach()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3f2tdtttkscvy1a04iwgphg4w\">執行剩餘的設定</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"the-async-beforeeach\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"njhruait1bzaikt45w14e25n\">非同步的 <code>beforeEach</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-async-beforeeach\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6yipia3l0nnx2k5u5qld7sfo8\">像下面這樣編寫第一個非同步的 <code>beforeEach</code>。</p>\n<code-example header=\"app/banner/banner-external.component.spec.ts (async beforeEach)\" path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"async-before-each\">\nbeforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await TestBed.configureTestingModule({\n    imports: [BannerComponent],\n  }).compileComponents(); // compile template and css\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cje3k9y437gr60nioyrjlextj\"><code>TestBed.configureTestingModule()</code> 方法回傳 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 類，所以你可以鏈式呼叫其它 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 中的靜態方法，比如 <code>compileComponents()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74nyj1vf24c9jg62m1qdywmn4\">在這個例子中，<code>BannerComponent</code> 是僅有的待編譯元件。其它例子中可能會使用多個元件來設定測試模組，並且可能引入某些具有其它元件的應用模組。它們中的任何一個都可能需要外部檔案。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6h6g2w983h6bhw2jsuwwzdahm\"><code>TestBed.compileComponents</code> 方法會非同步編譯測試模組中設定過的所有元件。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2q9ie0mzerpzo25oe3z2uaxq6\">在呼叫了 <code>compileComponents()</code> 之後就不能再重新設定 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 了。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9d0sisv3pfviy5x9sdoitgvvj\">呼叫 <code>compileComponents()</code> 會關閉當前的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 實例，不再允許進行設定。你不能再呼叫任何 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 中的設定方法，既不能調 <code>configureTestingModule()</code>，也不能呼叫任何 <code>override...</code> 方法。如果你試圖這麼做，<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 就會丟擲錯誤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2ufugfuig078c4y2uihee773\">確保 <code>compileComponents()</code> 是呼叫 <code>TestBed.createComponent()</code> 之前的最後一步。</p>\n<h4 id=\"the-synchronous-beforeeach\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ckphykf0z3x2wguklmyepdlfj\">同步的 <code>beforeEach</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-synchronous-beforeeach\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ezsui7sbtsnoohc2x86089roz\">第二個同步 <code>beforeEach()</code> 的例子包含剩下的準備步驟，包括建立元件和查詢那些要檢查的元素。</p>\n<code-example header=\"app/banner/banner-external.component.spec.ts (synchronous beforeEach)\" path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"sync-before-each\">\nbeforeEach(() =&gt; {\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance; // BannerComponent test instance\n  h1 = fixture.nativeElement.querySelector('h1');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqlokmnx11k26sjpjw6hchxej\">測試執行器（runner）會先等待第一個非同步 <code>beforeEach</code> 函式執行完再呼叫第二個。</p>\n<h4 id=\"consolidated-setup\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"275hecw5dasswv084vnlw1hda\">整理過的準備程式碼<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#consolidated-setup\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9l2iqffa5xlkod1ni7d8ytfo1\">你可以把這兩個 <code>beforeEach()</code> 函式重整成一個非同步的 <code>beforeEach()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qvqxdxofpna2cl2aw95yhsi1\"><code>compileComponents()</code> 方法回傳一個 Promise，所以你可以透過把同步程式碼移到 <code>await</code> 關鍵字後面，在那裡，這個 Promise 已經解析了。</p>\n<code-example header=\"app/banner/banner-external.component.spec.ts (one beforeEach)\" path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"one-before-each\">\nbeforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await TestBed.configureTestingModule({\n    imports: [BannerComponent],\n  }).compileComponents();\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance;\n  h1 = fixture.nativeElement.querySelector('h1');\n});\n\n</code-example>\n<h4 id=\"compilecomponents-is-harmless\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bq4x2wbiz3ms5wkidedg8n35r\"><code>compileComponents()</code> 是無害的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#compilecomponents-is-harmless\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9yiqkrnkkughrrs238uebn4e3\">在不需要 <code>compileComponents()</code> 的時候呼叫它也不會有害處。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1x6raz9ssnfk0j3sxcoq55xzt\">雖然在執行 <code>ng test</code> 時永遠都不需要呼叫 <code>compileComponents()</code>，但 CLI 生成的元件測試檔案還是會呼叫它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9vrcabz52diuth4ewlrsby7em\">但這篇指南中的這些測試只會在必要時才調用 <code>compileComponents</code>。</p>\n<p><a id=\"import-module\"></a></p>\n<h2 id=\"setup-with-module-imports\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3sb9tbb1jmqxi0sbrd1nwelbh\">準備模組的 <code>imports</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#setup-with-module-imports\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5yj4pig6c3iql2s9krf4glahr\">此前的元件測試程式使用了一些 <code>declarations</code> 來設定模組，就像這樣：</p>\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (configure TestBed)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"config-testbed\">\nTestBed.configureTestingModule({\n  providers: appProviders,\n  imports: [DashboardHeroComponent],\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2peumleole4tzo3pimpkjfm9\"><code>DashboardComponent</code> 非常簡單。它不需要幫助。但是更加複雜的元件通常依賴其它元件、指令、通道和提供者，所以這些必須也被新增到測試模組中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"au4oa6nkcv0t6cmfzqmkp6tz0\">幸運的是，<code>TestBed.configureTestingModule</code> 引數與傳入 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 裝飾器的元資料一樣，也就是所你也可以指定 <code>providers</code> 和 <code>imports</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"32kkg3jy7q71yy3ajzii4m1lq\">雖然 <code>HeroDetailComponent</code> 很小，結構也很簡單，但是它需要很多幫助。除了從預設測試模組 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> 中獲得的支援，它還需要：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5rsrsj1mu0jicfulmh00eiu6k\"><code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 裡的 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 和其它，來進行雙向資料繫結</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xa8ay7ox2nrw2i55asn6s9cu\"><code>shared</code> 目錄裡的 <code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"epcqqmd4fps64lqzarr97tmed\">路由器服務</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41hpllyksn3iof9rf1wi0wdd9\">英雄資料訪問這些服務</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3rv6lwu7j7bkdaeckgqcmmx5g\">一種方法是從各個部分設定測試模組，就像這樣：</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (FormsModule setup)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-forms-module\">\nbeforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await TestBed.configureTestingModule(\n    Object.assign({}, appConfig, {\n      imports: [<a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>, HeroDetailComponent, <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a>],\n      providers: [\n        <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n        <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n        <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{ path: 'heroes/:id', component: HeroDetailComponent }]),\n      ],\n    }),\n  ).compileComponents();\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58sjvoajd9f0vccrt0gp02cxw\">注意，<code>beforeEach()</code> 是非同步的，它呼叫 <code>TestBed.compileComponents</code> 是因為 <code>HeroDetailComponent</code> 有外部樣板和 CSS 檔案。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uyvqrdpddpyhhn7k1x020ab4\">如<a href=\"guide/testing-components-scenarios#compile-components\">呼叫 <code>compileComponents()</code></a> 中所解釋的那樣，這些測試可以執行在非 CLI 環境下，那裡 Angular 並不會在瀏覽器中編譯它們。</p>\n</div>\n<h4 id=\"import-a-shared-module\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8j08sii3rhb6e3o6km7yvmgv6\">匯入共享模組<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#import-a-shared-module\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8jthfri2fjtlor8zepoqkwg09\">因為很多應用元件都需要 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 和 <code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code>，所以開發者建立了 <code>SharedModule</code> 來把它們及其它常用的部分組合在一起。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2rpmit6om983te8fqk7gcx8bb\">這些測試設定也可以使用 <code>SharedModule</code>，如下所示：</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (SharedModule setup)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-shared-module\">\nbeforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await TestBed.configureTestingModule(\n    Object.assign({}, appConfig, {\n      imports: [HeroDetailComponent, sharedImports],\n      providers: [\n        <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{ path: 'heroes/:id', component: HeroDetailComponent }]),\n        <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n        <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n      ],\n    }),\n  ).compileComponents();\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2bdmvq9zfnmqrl5ei9na1hidz\">它的匯入宣告少一些，稍微乾淨一些，小一些，這個例子中未展示它。</p>\n<p><a id=\"feature-module-import\"></a></p>\n<h4 id=\"import-a-feature-module\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crgh806lzqxhf9p75u9dp6u8s\">匯入屬性模組<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#import-a-feature-module\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6neu34qn49l94i6hbkutfzo62\"><code>HeroDetailComponent</code> 是 <code>HeroModule</code> 這個<a href=\"guide/feature-modules\">屬性模組</a>的一部分，它聚合了更多相互依賴的片段，包括 <code>SharedModule</code>。試試下面這個匯入了 <code>HeroModule</code> 的測試設定：</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (HeroModule setup)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-hero-module\">\nbeforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await TestBed.configureTestingModule(\n    Object.assign({}, appConfig, {\n      imports: [HeroDetailComponent, HeroListComponent],\n      providers: [\n        <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([\n          { path: 'heroes/:id', component: HeroDetailComponent },\n          { path: 'heroes', component: HeroListComponent },\n        ]),\n        <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n        <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n      ],\n    }),\n  ).compileComponents();\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f4imy8wqug3756anrcjy6w347\">這樣特別清爽。只有 <code>providers</code> 裡面的測試替身被保留。連 <code>HeroDetailComponent</code> 宣告都消失了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a11g5c8tuco32h8tssibqawem\">事實上，如果你試圖宣告它，Angular 就會丟擲一個錯誤，因為 <code>HeroDetailComponent</code> 同時宣告在了 <code>HeroModule</code> 和 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 建立的 <code>DynamicTestModule</code> 中。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aw9sq9k4w09bec5thdckl86d5\">如果模組中有很多共同依賴，並且該模組很小（這也是屬性模組的應有形態），那麼直接匯入元件的屬性模組可以成為設定這些測試的最佳方式。</p>\n</div>\n<p><a id=\"component-override\"></a></p>\n<h2 id=\"override-component-providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78zumly5k3ex6me9sk4ig5504\">改寫元件的服務提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#override-component-providers\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4b4rnelrl6pexirajky2zxe4a\"><code>HeroDetailComponent</code> 提供自己的 <code>HeroDetailService</code> 服務。</p>\n<code-example header=\"app/hero/hero-detail.component.ts (prototype)\" path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"prototype\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-hero-detail',\n  templateUrl: './hero-detail.component.html',\n  styleUrls: ['./hero-detail.component.css'],\n  providers: [HeroDetailService],\n  imports: [sharedImports, <a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>],\n})\nexport class HeroDetailComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(\n    private heroDetailService: HeroDetailService,\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  ) {}\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eemr8nehlchf38p6rfzeve6an\">在 <code>TestBed.configureTestingModule</code> 的 <code>providers</code> 中 stub 偽造元件的 <code>HeroDetailService</code> 是不可行的。這些是<strong>測試模組</strong>的提供者，而非元件的。元件級別的提供者應該在<strong>fixture 級別</strong>的依賴注入器中進行準備。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ncr8lidy99tnie3p379jwr06\">Angular 會使用自己的注入器來建立這些元件，這個注入器是夾具的注入器的子注入器。它使用這個子注入器註冊了該組件服務提供者（這裡是 <code>HeroDetailService</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dmgnhcvhe1h6iwd6mqghrnm8v\">測試沒辦法從測試夾具的注入器中獲取子注入器中的服務，而 <code>TestBed.configureTestingModule</code> 也沒法設定它們。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"21gy9bv0pdz1l0o7sr7qfpo63\">Angular 始終都在建立真實 <code>HeroDetailService</code> 的實例。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8y7gqga1tezs9wye1k1hqot55\">如果 <code>HeroDetailService</code> 向遠端伺服器發出自己的 XHR 請求，這些測試可能會失敗或者超時。這個遠端伺服器可能根本不存在。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71cj16a6q02kpbfq42aaug12b\">幸運的是，<code>HeroDetailService</code> 將遠端資料訪問的責任交給了注入進來的 <code>HeroService</code>。</p>\n<code-example header=\"app/hero/hero-detail.service.ts (prototype)\" path=\"testing/src/app/hero/hero-detail.service.ts\" region=\"prototype\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({ providedIn: 'root' })\nexport class HeroDetailService {\n  constructor(private heroService: HeroService) {}\n  /* . . . */\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3blzbfu1de43g1th50f7rxopq\"><a href=\"guide/testing-components-scenarios#feature-module-import\">前面的測試設定</a>使用 <code>TestHeroService</code> 替換了真實的 <code>HeroService</code>，它攔截了發往伺服器的請求，並偽造了伺服器的回應。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ujlesnkhih21kzujt3906llq\">如果你沒有這麼幸運怎麼辦？如果偽造 <code>HeroService</code> 很難怎麼辦？如果 <code>HeroDetailService</code> 自己發出伺服器請求怎麼辦？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4gt02cye7uvpifgwh3w7b3or7\"><code>TestBed.overrideComponent</code> 方法可以將元件的 <code>providers</code> 替換為容易管理的<strong>測試替身</strong>，參閱下面的變體準備程式碼：</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (Override setup)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-override\">\nbeforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await TestBed.configureTestingModule(\n    Object.assign({}, appConfig, {\n      imports: [HeroDetailComponent, HeroListComponent],\n      providers: [\n        <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([\n          { path: 'heroes', component: HeroListComponent },\n          { path: 'heroes/:id', component: HeroDetailComponent },\n        ]),\n        <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>,\n        <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>,\n        // HeroDetailService at this level is IRRELEVANT!\n        { provide: HeroDetailService, useValue: {} },\n      ],\n    }),\n  )\n    .overrideComponent(HeroDetailComponent, {\n      set: { providers: [{ provide: HeroDetailService, useClass: HeroDetailServiceSpy }] },\n    })\n    .compileComponents();\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1icm3efa4z3qzdpzytncej7r2\">注意，<code>TestBed.configureTestingModule</code> 不再提供偽造的 <code>HeroService</code>，因為<a href=\"guide/testing-components-scenarios#spy-stub\">並不需要</a>。</p>\n<p><a id=\"override-component-method\"></a></p>\n<h4 id=\"the-overridecomponent-method\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"135z7jbukbsge8kx78q6zeoap\"><code>overrideComponent</code> 方法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-overridecomponent-method\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"et5wd2qgx00ss4hvkklh1gdsm\">注意這個 <code>overrideComponent</code> 方法。</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (overrideComponent)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-component-method\">\n.overrideComponent(HeroDetailComponent, {\n  set: { providers: [{ provide: HeroDetailService, useClass: HeroDetailServiceSpy }] },\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92q7a7ozdbgkfon29vu2k0vu3\">它接受兩個引數：要改寫的元件類別型（<code>HeroDetailComponent</code>），以及用於改寫的元資料物件。<a href=\"guide/testing-utility-apis#metadata-override-object\">用於改寫的元資料物件</a>是一個泛型，其定義如下：</p>\n<code-example language=\"javascript\">\n\ntype <a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&lt;T&gt; = {\n  add?: Partial&lt;T&gt;;\n  remove?: Partial&lt;T&gt;;\n  set?: Partial&lt;T&gt;;\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c1lh2e2kbgkh1fhsws08xvi60\">元資料過載物件可以新增和刪除元資料屬性的專案，也可以徹底重設這些屬性。這個例子重新設定了元件的 <code>providers</code> 元資料。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"57n2rpaw1cxgh8ch3qwetjyhy\">這個型別引數 <code>T</code> 就是你傳給 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 裝飾器的元資料：</p>\n<code-example language=\"javascript\">\n\nselector?: string;\ntemplate?: string;\ntemplateUrl?: string;\nproviders?: any[];\n…\n\n</code-example>\n<p><a id=\"spy-stub\"></a></p>\n<h4 id=\"provide-a-spy-stub-herodetailservicespy\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"649ip5u8lygkqxsd5bpfr523h\">提供 <em>間諜樁</em>（<code>HeroDetailServiceSpy</code>）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#provide-a-spy-stub-herodetailservicespy\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"207r7ony5uvimd8yc5sm44ohp\">這個例子把元件的 <code>providers</code> 陣列完全替換成了一個包含 <code>HeroDetailServiceSpy</code> 的新陣列。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7rpbnoly7jvfddt2hioz38g4p\"><code>HeroDetailServiceSpy</code> 是實際 <code>HeroDetailService</code> 服務的樁版本，它偽造了該服務的所有必要屬性。但它既不需要注入也不會委託給低層的 <code>HeroService</code> 服務，因此不用為 <code>HeroService</code> 提供測試替身。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"de4tk14jnxgfkfy8c19l901jw\">透過對該服務的方法進行刺探，<code>HeroDetailComponent</code> 的關聯測試將會對 <code>HeroDetailService</code> 是否被呼叫過進行斷言。因此，這個樁類會把它的方法實現為刺探方法：</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (HeroDetailServiceSpy)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"hds-spy\">\nclass HeroDetailServiceSpy {\n  testHero: Hero = { ...testHero };\n\n  /* emit cloned test hero */\n  getHero = jasmine\n    .createSpy('getHero')\n    .and.callFake(() =&gt; asyncData(Object.assign({}, this.testHero)));\n\n  /* emit clone of test hero, with changes merged in */\n  saveHero = jasmine\n    .createSpy('saveHero')\n    .and.callFake((hero: Hero) =&gt; asyncData(Object.assign(this.testHero, hero)));\n}\n\n\n</code-example>\n<p><a id=\"override-tests\"></a></p>\n<h4 id=\"the-override-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ffh9bs7hgbf7j9rxeup6cj2e\">改寫測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-override-tests\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e4l6c1scuxaozonp9wbjk4r5h\">現在，測試程式可以透過操控這個 spy-stub 的 <code>testHero</code>，直接控制組件的英雄，並確認那個服務方法被呼叫過。</p>\n<code-example header=\"app/hero/hero-detail.component.spec.ts (override tests)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-tests\">\n  let hdsSpy: HeroDetailServiceSpy;\n\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    harness = await RouterTestingHarness.create();\n    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);\n    page = new Page();\n    // get the component's injected HeroDetailServiceSpy\n    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;\n\n    harness.detectChanges();\n  });\n\n  it('should have called `getHero`', () =&gt; {\n    expect(hdsSpy.getHero.calls.count())\n      .withContext('getHero called once')\n      .toBe(1, 'getHero called once');\n  });\n\n  it(\"should display stub hero's name\", () =&gt; {\n    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);\n  });\n\n  it('should save stub hero change', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n    const origName = hdsSpy.testHero.name;\n    const newName = 'New Name';\n\n    page.nameInput.value = newName;\n\n    page.nameInput.dispatchEvent(new <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>('input')); // tell Angular\n\n    expect(component.hero.name).withContext('component hero has new name').toBe(newName);\n    expect(hdsSpy.testHero.name).withContext('service hero unchanged before save').toBe(origName);\n\n    click(page.saveBtn);\n    expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);\n\n    <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // wait for <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> save to complete\n    expect(hdsSpy.testHero.name).withContext('service hero has new name after save').toBe(newName);\n    expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes');\n  }));\n}\n\n////////////////////\nimport { getTestHeroes } from '../<a href=\"api/core/model\" class=\"code-anchor\">model</a>/testing/test-hero.service';\n\nconst firstHero = getTestHeroes()[0];\n\nfunction heroModuleSetup() {\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    await TestBed.configureTestingModule(\n      Object.assign({}, appConfig, {\n        imports: [HeroDetailComponent, HeroListComponent],\n        providers: [\n          <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([\n            { path: 'heroes/:id', component: HeroDetailComponent },\n            { path: 'heroes', component: HeroListComponent },\n          ]),\n          <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n          <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n        ],\n      }),\n    ).compileComponents();\n  });\n\n  describe('when navigate to existing hero', () =&gt; {\n    let expectedHero: Hero;\n\n    beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n      expectedHero = firstHero;\n      await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(expectedHero.id);\n    });\n    it(\"should display that hero's name\", () =&gt; {\n      expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n    });\n\n    it('should navigate when click cancel', () =&gt; {\n      click(page.cancelBtn);\n      expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual(`/heroes/${expectedHero.id}`);\n    });\n\n    it('should save when click save but not navigate immediately', () =&gt; {\n      click(page.saveBtn);\n      expect(TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>).expectOne({ method: 'PUT', url: 'api/heroes' }));\n      expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes/41');\n    });\n\n    it('should navigate when click save and save resolves', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n      click(page.saveBtn);\n      <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // wait for <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> save to complete\n      expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes/41');\n    }));\n\n    it('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () =&gt; {\n      // get the name's input and display elements from the DOM\n      const hostElement: HTMLElement = harness.routeNativeElement!;\n      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;\n      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;\n\n      // simulate user entering a new name into the input box\n      nameInput.value = 'quick BROWN  fOx';\n\n      // Dispatch a DOM event so that Angular learns of input value change.\n      nameInput.dispatchEvent(new <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>('input'));\n\n      // Tell Angular to update the display binding through the title pipe\n      harness.detectChanges();\n\n      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n    });\n\n  });\n\n  describe('when navigate to non-existent hero id', () =&gt; {\n    beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n      await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(999);\n    });\n\n    it('should try to navigate back to hero list', () =&gt; {\n      expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes');\n    });\n  });\n}\n\n/////////////////////\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a> } from '../shared/title-case.pipe';\nimport { appConfig } from '../app.config';\n\nfunction formsModuleSetup() {\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    await TestBed.configureTestingModule(\n      Object.assign({}, appConfig, {\n        imports: [<a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>, HeroDetailComponent, <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a>],\n        providers: [\n          <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n          <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n          <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{ path: 'heroes/:id', component: HeroDetailComponent }]),\n        ],\n      }),\n    ).compileComponents();\n  });\n\n  it(\"should display 1st hero's name\", <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    const expectedHero = firstHero;\n    await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(expectedHero.id).then(() =&gt; {\n      expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n    });\n  });\n}\n\n///////////////////////\n\nfunction sharedModuleSetup() {\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    await TestBed.configureTestingModule(\n      Object.assign({}, appConfig, {\n        imports: [HeroDetailComponent, sharedImports],\n        providers: [\n          <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{ path: 'heroes/:id', component: HeroDetailComponent }]),\n          <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n          <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n        ],\n      }),\n    ).compileComponents();\n  });\n\n  it(\"should display 1st hero's name\", <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    const expectedHero = firstHero;\n    await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(expectedHero.id).then(() =&gt; {\n      expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n    });\n  });\n}\n\n/////////// Helpers /////\n\n/** Create the HeroDetailComponent, initialize it, set test variables  */\n<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> function <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(id: number) {\n  harness = await RouterTestingHarness.create();\n  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);\n  page = new Page();\n\n  const request = TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>).expectOne(`api/heroes/?id=${id}`);\n  const hero = getTestHeroes().find((h) =&gt; h.id === Number(id));\n  request.flush(hero ? [hero] : []);\n  harness.detectChanges();\n}\n\nclass Page {\n  // getter properties wait to <a href=\"api/animations/query\" class=\"code-anchor\">query</a> the DOM until called.\n  get buttons() {\n    return this.queryAll&lt;HTMLButtonElement&gt;('button');\n  }\n  get saveBtn() {\n    return this.buttons[0];\n  }\n  get cancelBtn() {\n    return this.buttons[1];\n  }\n  get nameDisplay() {\n    return this.query&lt;HTMLElement&gt;('span');\n  }\n  get nameInput() {\n    return this.query&lt;HTMLInputElement&gt;('input');\n  }\n\n  //// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> helpers ////\n  private <a href=\"api/animations/query\" class=\"code-anchor\">query</a>&lt;T&gt;(selector: string): T {\n    return harness.routeNativeElement!.querySelector(selector)! as T;\n  }\n\n  private queryAll&lt;T&gt;(selector: string): T[] {\n    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];\n  }\n}\n\n\n</code-example>\n<p><a id=\"more-overrides\"></a></p>\n<h4 id=\"more-overrides\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9mjbrzoai8owzny0n4irwd9ej\">更多的改寫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#more-overrides\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6uvwtqn5x3p6sip0h1t2tv9od\"><code>TestBed.overrideComponent</code> 方法可以在相同或不同的元件中被反覆呼叫。<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 還提供了類似的 <code>overrideDirective</code>、<code>overrideModule</code> 和 <code>overridePipe</code> 方法，用來深入並重載這些其它類別的部件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cioq7okr6hzk3x17w9z7zhkax\">自己探索這些選項和組合。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Thu Sep 07 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/DebugElement\n - guide/testing\n - guide/testing-attribute-directives\n - guide/testing-components-basics\n - guide/testing-utility-apis\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/animations/trigger\n - api/common/AsyncPipe\n - api/common/CommonModule\n - api/common/NgFor\n - api/common/NgIf\n - api/common/TitleCasePipe\n - api/common/UpperCasePipe\n - api/common/http/HttpClient\n - api/common/http/HttpHandler\n - api/common/http/provideHttpClient\n - api/common/http/testing/HttpTestingController\n - api/common/http/testing/provideHttpClientTesting\n - api/core/AfterViewInit\n - api/core/Component\n - api/core/Component#styleUrls\n - api/core/Component#styles\n - api/core/Component#template\n - api/core/Component#templateUrl\n - api/core/DebugElement\n - api/core/ElementRef\n - api/core/EventEmitter\n - api/core/Injectable\n - api/core/Input\n - api/core/NO_ERRORS_SCHEMA\n - api/core/NgModule\n - api/core/OnInit\n - api/core/Output\n - api/core/ViewChild\n - api/core/createComponent\n - api/core/model\n - api/core/testing/ComponentFixture\n - api/core/testing/ComponentFixtureAutoDetect\n - api/core/testing/MetadataOverride\n - api/core/testing/TestBed\n - api/core/testing/fakeAsync\n - api/core/testing/flush\n - api/core/testing/tick\n - api/core/testing/waitForAsync\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/Title\n - api/platform-browser/animations/async\n - api/router/ActivatedRoute\n - api/router/ActivatedRoute#paramMap\n - api/router/Event\n - api/router/Router\n - api/router/Router#events\n - api/router/RouterLink\n - api/router/RouterOutlet\n - api/router/provideRouter\n - api/router/testing/RouterTestingHarness\n - guide/feature-modules\n - guide/lifecycle-hooks\n - guide/router-tutorial-toh\n - guide/router-tutorial-toh#activated-route-in-action\n - guide/testing-components-basics#component-class-testing\n - guide/testing-components-scenarios#async-observable-helpers\n - guide/testing-components-scenarios#async-observables\n - guide/testing-components-scenarios#async-test-with-fakeasync\n - guide/testing-components-scenarios#async-test-with-waitforasync\n - guide/testing-components-scenarios#automatic-change-detection\n - guide/testing-components-scenarios#bydirective-and-injected-directives\n - guide/testing-components-scenarios#calling-compilecomponents\n - guide/testing-components-scenarios#change-an-input-value-with-dispatchevent\n - guide/testing-components-scenarios#click-helper\n - guide/testing-components-scenarios#click-the-element\n - guide/testing-components-scenarios#clicking\n - guide/testing-components-scenarios#cold-observable\n - guide/testing-components-scenarios#comparing-dates-inside-fakeasync\n - guide/testing-components-scenarios#compile-components\n - guide/testing-components-scenarios#compilecomponents-is-async\n - guide/testing-components-scenarios#compilecomponents-is-harmless\n - guide/testing-components-scenarios#component-binding\n - guide/testing-components-scenarios#component-inside-a-test-host\n - guide/testing-components-scenarios#component-marble-tests\n - guide/testing-components-scenarios#component-override\n - guide/testing-components-scenarios#component-testing-scenarios\n - guide/testing-components-scenarios#component-with-a-dependency\n - guide/testing-components-scenarios#component-with-async-service\n - guide/testing-components-scenarios#component-with-external-files\n - guide/testing-components-scenarios#component-with-inputs-and-outputs\n - guide/testing-components-scenarios#consolidated-setup\n - guide/testing-components-scenarios#createcomponent-does-not-bind-data\n - guide/testing-components-scenarios#dashboard-hero-component\n - guide/testing-components-scenarios#detectchanges\n - guide/testing-components-scenarios#feature-module-import\n - guide/testing-components-scenarios#final-setup-and-tests\n - guide/testing-components-scenarios#get-injected-services\n - guide/testing-components-scenarios#import-a-feature-module\n - guide/testing-components-scenarios#import-a-shared-module\n - guide/testing-components-scenarios#jasmine-done\n - guide/testing-components-scenarios#jasmineclock-with-fakeasync\n - guide/testing-components-scenarios#learn-about-marble-testing\n - guide/testing-components-scenarios#marble-error-testing\n - guide/testing-components-scenarios#marble-frame\n - guide/testing-components-scenarios#more-async-tests\n - guide/testing-components-scenarios#more-overrides\n - guide/testing-components-scenarios#nested-component-tests\n - guide/testing-components-scenarios#no_errors_schema\n - guide/testing-components-scenarios#override-component-providers\n - guide/testing-components-scenarios#provide-a-spy-stub-herodetailservicespy\n - guide/testing-components-scenarios#provide-service-test-doubles\n - guide/testing-components-scenarios#query-for-the-h1\n - guide/testing-components-scenarios#routed-components\n - guide/testing-components-scenarios#routing-component\n - guide/testing-components-scenarios#setup-with-module-imports\n - guide/testing-components-scenarios#spy-stub\n - guide/testing-components-scenarios#stubbing-unneeded-components\n - guide/testing-components-scenarios#support-more-macrotasks\n - guide/testing-components-scenarios#synchronous-tests\n - guide/testing-components-scenarios#test-dashboardherocomponent-stand-alone\n - guide/testing-components-scenarios#testbedinject\n - guide/testing-components-scenarios#testing-with-a-spy\n - guide/testing-components-scenarios#testing-with-the-routertestingharness\n - guide/testing-components-scenarios#the-async-beforeeach\n - guide/testing-components-scenarios#the-override-tests\n - guide/testing-components-scenarios#the-overridecomponent-method\n - guide/testing-components-scenarios#the-synchronous-beforeeach\n - guide/testing-components-scenarios#the-tick-function\n - guide/testing-components-scenarios#tickoptions\n - guide/testing-components-scenarios#triggereventhandler\n - guide/testing-components-scenarios#use-a-page-object\n - guide/testing-components-scenarios#use-both-techniques-together\n - guide/testing-components-scenarios#using-the-rxjs-scheduler-inside-fakeasync\n - guide/testing-components-scenarios#waitForAsync\n - guide/testing-components-scenarios#whenstable\n - guide/testing-utility-apis#metadata-override-object\n - guide/understanding-communicating-with-http\n - http://reactivex.io/documentation/operators/defer.html\n - https://developer.mozilla.org/docs/Web/API/MouseEvent/button\n - https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support\n - https://plnkr.co\n - https://rxjs.dev/guide/testing/marble-testing\n - https://rxmarbles.com\n-->"}