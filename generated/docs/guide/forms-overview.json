{"id":"guide/forms-overview","title":"Angular 表單簡介","contents":"<div class=\"content\">\n  <h1 id=\"introduction-to-forms-in-angular\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7o5evbt8m8a5chz2mdh39m3bz\">Angular 表單簡介<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#introduction-to-forms-in-angular\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"acbzlf69r51ppxbqncxvosfsn\">用表單處理使用者輸入是許多常見應用的基礎功能。\n應用透過表單來讓使用者登入、修改個人檔案、輸入敏感訊息以及執行各種資料輸入任務。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eurm3ascqk2h4ig5e1hnizhcx\">Angular 提供了兩種不同的方法來透過表單處理使用者輸入：回應式表單和樣板驅動表單。\n兩者都從檢視中捕獲使用者輸入事件、驗證使用者輸入、建立表單模型、修改資料模型，並提供跟蹤這些更改的途徑。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aq3bag4d3y8rnpeyrwdgl9b0a\">本指南提供的訊息可以幫你確定哪種方式最適合你的情況。它介紹了這兩種方法所用的公共構造塊，還總結了兩種方式之間的關鍵區別，並在建立、資料流和測試等不同的情境下展示了這些差異。</p>\n<h2 id=\"prerequisites\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e44b21uig1fakj5vcfuvz1bdu\">前提條件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#prerequisites\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7tpo3lrdg4mco0t530rclr53p\">本指南假設你對以下內容有基本的瞭解。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"hvl8rjzxrmac41qpao60jlv6\"><a href=\"https://www.typescriptlang.org/\" title=\"TypeScript 語言\">TypeScript</a>和 HTML5 程式設計</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"655p6dhauz2ot3psa4gysttev\">Angular 的應用設計基礎，就像<a href=\"guide/architecture\" title=\"Angular 概念簡介。\">Angular Concepts 中</a>描述的那樣</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9npb20i9qclwsqwgxx2gfw9np\"><a href=\"guide/architecture-components#template-syntax\" title=\"樣板語法簡介\">Angular 樣板語法</a>的基礎知識</li>\n</ul>\n<h2 id=\"choosing-an-approach\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e5w7rl07hdukdij8b3as3qbid\">選擇一種方法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#choosing-an-approach\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4y96qhbczq5jloc5csxzejc70\">回應式表單和樣板驅動表單以不同的方式處理和管理表單資料。每種方法都有各自的優點。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xsni8fgg13z9qwldwylke25i\">表單</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2xwzrnb2ye7twpwf3t9i2eiv\">回應式表單</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43t6m1vi6b1vr0x93iyi169ve\">提供對底層表單物件模型的直接、明確訪問。與樣板驅動表單相比，它們更加健壯：它們更具可擴充套件性、可重用性和可測試性。如果表單是你應用的關鍵部分，或者你已經在應用中使用回應式模式建立應用，那就使用回應式表單。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ikuesboztjr8out2q3bj6j8i\">樣板驅動表單</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayvotbxmvji1hsei11mp1beht\">依賴於樣板中的指令來建立和操縱底層物件模型。它們對於在應用中新增一個簡單的表單很有用，比如電子郵件清單登錄檔單。它們很容易新增到應用中，但不像回應式表單那樣具有良好的擴充套件性。如果你的表單需求非常基本，邏輯可以完全在樣板中管理，那麼樣板驅動表單可能是一個很好的選擇。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"key-differences\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"17mblkyyiy67qhoqo19d4yyf1\">關鍵差異<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#key-differences\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3us5tmzgqsru1eiu3ijm0sgaw\">下表總結了回應式表單和樣板驅動表單之間的一些關鍵差異。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"beymamclbildi1j6u2luvobnb\">回應式</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a2fvyexkjup80ihgwwa7zlgj1\">樣板驅動</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9z3uxnf3ax9pceugnecec61x3\"><a href=\"guide/forms-overview#setup\">設定表單模型</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3po6hh34gd0qfhasfmiiik77b\">顯式，在元件類別中建立</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"416g1ayukcukzkrmkvdjj53ev\">隱式，由指令建立</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dfbadqbauugtwlr03ec00xb5a\"><a href=\"guide/forms-overview#mutability-of-the-data-model\">資料模型</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3b1dazfmeruw52vpp6quu4m56\">結構化和不可變</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"61harkjo062k26dyun9c6jfa3\">非結構化和可變</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebopzhygfldd8ts9n4bxrlhdv\"><a href=\"guide/forms-overview#data-flow-in-forms\">資料流</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2u2hy2y6ad0o9jvjm516n2pzv\">同步</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2eem8gjjq9t3zly57owr6sbb8\">非同步</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a9oic9413thtwy7tpgjt77f4t\"><a href=\"guide/forms-overview#validation\">表單驗證</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dt2uvbdl3r7k4tmkiulzt8lb8\">函式</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9uaad125h3hufxqa64leub0r9\">指令</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"scalability\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2o6opt1nvbl33tg3476xzzuv5\">可伸縮性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#scalability\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c56wnd2xa1ni0oj5vgkji1bds\">如果表單是應用程式的核心部分，那麼可伸縮性就非常重要。能夠跨元件複用表單模型是至關重要的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ec844a3xmlq1mw3rmfw8r3c9\">回應式表單比樣板驅動表單更有可伸縮性。它們提供對底層表單 API 的直接訪問，並且在檢視和數據模型之間使用<a href=\"guide/forms-overview#data-flow-in-reactive-forms\">同步資料流</a>，從而可以更輕鬆地建立大型表單。回應式表單需要較少的測試設定，測試時不需要深入理解變更檢測，就能正確測試表單更新和驗證。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"992e2vrvtaj48iq1qzir847rh\">樣板驅動表單專注於簡單的場景，可複用性沒那麼高。它們抽象出了底層表單 API，並且在檢視和數據模型之間使用<a href=\"guide/forms-overview#data-flow-in-template-driven-forms\">非同步資料流</a>。對樣板驅動表單的這種抽象也會影響測試。測試程式非常依賴於手動觸發變更檢測才能正常執行，並且需要進行更多設定工作。</p>\n<p><a id=\"setup\"></a></p>\n<h2 id=\"setting-up-the-form-model\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"vd8uvn18s2003cdareku8py\">建立表單模型<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#setting-up-the-form-model\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rpj0msitef6f5olivusd74ma\">回應式表單和樣板驅動型表單都會跟蹤使用者與之互動的表單輸入元素和元件模型中的表單資料之間的值變更。這兩種方法共享同一套底層建立塊，只在如何建立和管理常用表單控制元件實例方面有所不同。</p>\n<h3 id=\"common-form-foundation-classes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"85cbpj2qfnlzfk9fk9vzh0g5i\">常用表單基礎類<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#common-form-foundation-classes\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1lzo0ijuvgfhi4n44df86i957\">回應式表單和樣板驅動表單都建立在下列基礎類之上。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a19nalj6m5o4n2pxfxkv4iyj7\">基礎類</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"30uooirslsrx1kpin16rmo7h3\">跟蹤獨立表單控制元件的值和驗證狀態。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7fe38mjuep8vp55zwp60czljp\">跟蹤一組表單控制元件的相同值和狀態。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/forms/FormArray\" class=\"code-anchor\">FormArray</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ek1excyungbnoe1v66yipxrpw\">跟蹤一組表單控制元件的相同值和狀態。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/forms/ControlValueAccessor\" class=\"code-anchor\">ControlValueAccessor</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"34zuqlyr6a9zg23wwe52x7nh2\">在 Angular \n<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例和內建 DOM 元素之間建立橋樑。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"setup-the-form-model\"></a></p>\n<h3 id=\"setup-in-reactive-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4as3zzpl7lybj6rc97y4p87zw\">建立回應式表單<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#setup-in-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dzdxd2yoivx2wg17z031ggwp0\">對於回應式表單，你可以直接在元件類別中定義表單模型。<code>[formControl]</code> 指令會通過內部值訪問器來把顯式建立的 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例與檢視中的特定表單元素聯絡起來。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7lz6diuj6xvgfzpb1wzher99v\">下面的元件使用回應式表單為單個控制元件實現了一個輸入欄位。在這個例子中，表單模型是 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例。</p>\n<code-example path=\"forms-overview/src/app/reactive/favorite-color/favorite-color.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>, <a href=\"api/forms/ReactiveFormsModule\" class=\"code-anchor\">ReactiveFormsModule</a> } from '@angular/forms';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-reactive-favorite-color',\n  template: `\n    Favorite Color: &lt;input type=\"text\" [formControl]=\"favoriteColorControl\" /&gt;\n  `,\n  imports: [<a href=\"api/forms/ReactiveFormsModule\" class=\"code-anchor\">ReactiveFormsModule</a>],\n})\nexport class FavoriteColorComponent {\n  favoriteColorControl = new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('');\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qivnzbsj3clhjysd7qlu893g\">圖 1 展示了在回應式表單中，表單模型是如何成為事實之源（source of truth）的。它透過輸入元素上的 <code>[formControl]</code> 指令，在任何給定的時間點提供表單元素的值和狀態。</p>\n<!--todo: make consistent with other topics -->\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8n81m82bb3du082baqwju56fj\"><strong>圖 1.</strong> <em>在回應式表單中直接訪問表單模型</em></p>\n<div class=\"lightbox\">\n<img alt=\"Reactive forms key differences\" src=\"generated/images/guide/forms-overview/key-diff-reactive-forms.png\" width=\"635\" height=\"335\">\n</div>\n<h3 id=\"setup-in-template-driven-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4t6lp7vgwfq56zqidtkuw4hdi\">建立樣板驅動表單<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#setup-in-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b7qe7qy1lxo03bdjlva7clp6q\">在樣板驅動表單中，表單模型是隱式的，而不是顯式的。指令 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 為指定的表單元素建立並管理一個 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4i2vifvwsamzoyd686kpn1daf\">下面的元件使用樣板驅動表單為單個控制元件實現了同樣的輸入欄位。</p>\n<code-example path=\"forms-overview/src/app/template/favorite-color/favorite-color.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-template-favorite-color',\n  template: `\n    Favorite Color: &lt;input type=\"text\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"favoriteColor\" /&gt;\n  `,\n  imports: [<a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>],\n})\nexport class FavoriteColorComponent {\n  favoriteColor = '';\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29viilcx20tao7mc6j8hcmbh3\">在樣板驅動表單中，其事實之源就是樣板。你沒有對 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例的直接程式設計訪問，如圖 2 所示。</p>\n<!--todo: make consistent with other topics -->\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1krbzow9tcfe4odv92uxxvgjw\"><strong>圖 2.</strong> <em>樣板驅動表單中對錶單模型的間接訪問。</em></p>\n<div class=\"lightbox\">\n<img alt=\"Template-driven forms key differences\" src=\"generated/images/guide/forms-overview/key-diff-td-forms.png\" width=\"607\" height=\"387\">\n</div>\n<p><a id=\"data-flow-in-forms\"></a></p>\n<h2 id=\"data-flow-in-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99472ufe9n7iw9tr7jch0a71l\">表單中的資料流<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#data-flow-in-forms\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37177mxdfgce4kl3j3e9kup0i\">當應用包含一個表單時，Angular 必須讓該檢視與元件模型保持同步，並讓元件模型與檢視保持同步。當用戶透過檢視更改值並進行選擇時，新值必須反映在資料模型中。同樣，當程式邏輯改變資料模型中的值時，這些值也必須反映到檢視中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"25j7t0crxtrki2e3ya7m1v3mx\">回應式表單和樣板驅動表單在處理來自使用者或程式化變更時的資料處理方式上有所不同。下面的這些原理圖會以上面定義的 <code>favorite-color</code> 輸入欄位為例，分別說明兩種表單各自的資料流。</p>\n<p><a id=\"data-flow-in-reactive-forms\"></a></p>\n<h3 id=\"data-flow-in-reactive-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b3rm4rqtg5mku3liqu4ho2t27\">回應式表單中的資料流<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#data-flow-in-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cg4u34ceeej67pjo7909zy4cp\">在回應式表單中，檢視中的每個表單元素都直接連結到一個表單模型（<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例）。\n從檢視到模型的修改以及從模型到檢視的修改都是同步的，而且不依賴於 UI 的渲染方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9hl4tb1veopxo66cwpfs3ibnf\">這個檢視到模型的圖表展示了當輸入欄位的值發生變化時，資料流是如何從檢視開始經過下列步驟進行流動的。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"czg1ped18o7gaoo0drhzx3rm8\">最終使用者在輸入框元素中鍵入了一個值，這裡是 \"Blue\"。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a20cxksvyo2jbk0kyvo8q6fza\">這個輸入框元素會發出一個帶有最新值的 \"input\" 事件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"caysotaohxkfswfwrlryc72fb\">這個控制元件值訪問器 <code><a href=\"api/forms/ControlValueAccessor\" class=\"code-anchor\">ControlValueAccessor</a></code> 會監聽表單輸入框元素上的事件，並立即把新值傳給 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6r4tmnsnmyux0tem1413exiqf\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例會通過 <code>valueChanges</code> 這個可觀察物件發出這個新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6o84h5lh1a0whj8cudceg9lwj\"><code>valueChanges</code> 的任何一個訂閱者都會收到這個新值。</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"Reactive forms data flow - view to model\" src=\"generated/images/guide/forms-overview/dataflow-reactive-forms-vtm.png\" width=\"600\" height=\"592\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9313120ylistdipv0uf6ne38l\">這個模型到檢視的原理圖體現了程式中對模型的修改是如何透過下列步驟傳播到檢視中的。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bd32f151d7cfk4qt2c6yaqem4\"><code>favoriteColorControl.setValue()</code> 方法被呼叫，它會更新這個 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 的值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6r4tmnsnmyux0tem1413exiqf\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例會通過 <code>valueChanges</code> 這個可觀察物件發出這個新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6o84h5lh1a0whj8cudceg9lwj\"><code>valueChanges</code> 的任何一個訂閱者都會收到這個新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5n09qcw4tez2634hdbkbqvwno\">該表單輸入框元素上的控制元件值訪問器會把控制元件更新為這個新值。</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"Reactive forms data flow - model to view\" src=\"generated/images/guide/forms-overview/dataflow-reactive-forms-mtv.png\" width=\"600\" height=\"611\">\n</div>\n<p><a id=\"data-flow-in-template-driven-forms\"></a></p>\n<h3 id=\"data-flow-in-template-driven-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aikd7yu9ohck7b7pwaor509nv\">樣板驅動表單中的資料流<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#data-flow-in-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c220zh08db1gij1mgzr8i21vt\">在樣板驅動表單中，每一個表單元素都是和一個負責管理內部表單模型的指令關聯起來的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9hl4tb1veopxo66cwpfs3ibnf\">這個檢視到模型的圖表展示了當輸入欄位的值發生變化時，資料流是如何從檢視開始經過下列步驟進行流動的。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6mazhtn6xgr4vigolblu2g3vx\">最終使用者在輸入框元素中敲 \"Blue\"。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f1qcwuv0oaqs1lzxjkxucwrcj\">該輸入框元素會發出一個 \"input\" 事件，帶著值 \"Blue\"。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ytx9ui10vegn178z08ynvw2w\">附著在該輸入框上的控制元件值訪問器會觸發 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例上的 <code>setValue()</code> 方法。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6r4tmnsnmyux0tem1413exiqf\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例會通過 <code>valueChanges</code> 這個可觀察物件發出這個新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6o84h5lh1a0whj8cudceg9lwj\"><code>valueChanges</code> 的任何一個訂閱者都會收到這個新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"75etgywiwq0z7e97qu4xe6t4\">控制元件值訪問器 <code>ControlValueAccessory</code> 還會呼叫 <code><a href=\"api/forms/NgModel#viewToModelUpdate\" class=\"code-anchor\">NgModel.viewToModelUpdate()</a></code> 方法，它會發出一個 <code>ngModelChange</code> 事件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jc4ifrfg7ffszguinwxqr8uo\">由於該組件樣板雙向資料繫結到了 <code>favoriteColor</code>，元件中的 <code>favoriteColor</code> 屬性就會修改為 <code>ngModelChange</code> 事件所發出的值（\"Blue\"）。</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"Template-driven forms data flow - view to model\" width=\"100%\" src=\"generated/images/guide/forms-overview/dataflow-td-forms-vtm.png\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"asrqpsxmzdbl7fykquqye0srs\">這個模型到檢視的原理圖展示了當 <code>favoriteColor</code> 從<em>藍</em>變到<em>紅</em>時，資料是如何經過如下步驟從模型流動到檢視的。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dzc0fknrkb4kmn7isurjhobwd\">元件中修改了 <code>favoriteColor</code> 的值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"jm63uz2hoby47dlz6eq6bn6t\">變更檢測開始。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhpjdykg0nx0gtj0q4rsoumax\">在變更檢測期間，由於這些輸入框之一的值發生了變化，Angular 就會呼叫 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 指令上的 <code>ngOnChanges</code> 生命週期鉤子。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7epodembq9p1eoze69o52cwsd\"><code>ngOnChanges()</code> 方法會把一個非同步任務排入佇列，以設定內部 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例的值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bnnzbtxjnzwnw0zofzdv48ies\">變更檢測完成。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1l2jisw88l3tvqkvepeflrz2d\">在下一個檢測週期，用來為 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例賦值的任務就會執行。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8yhv452gqkc6qrz1qw5vexag\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例透過可觀察物件 <code>valueChanges</code> 發出最新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6o84h5lh1a0whj8cudceg9lwj\"><code>valueChanges</code> 的任何一個訂閱者都會收到這個新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ebaq8uyoturm5maps8uep0ne\">控制元件值訪問器 <code><a href=\"api/forms/ControlValueAccessor\" class=\"code-anchor\">ControlValueAccessor</a></code> 會使用 <code>favoriteColor</code> 的最新值來修改表單的輸入框元素。</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"Template-driven forms data flow - model to view\" width=\"100%\" src=\"generated/images/guide/forms-overview/dataflow-td-forms-mtv.png\">\n</div>\n<p><a id=\"mutability-of-the-data-model\"></a></p>\n<h3 id=\"mutability-of-the-data-model\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8a7ok15vnroy0m8n4p6otx0az\">資料模型的可變性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#mutability-of-the-data-model\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zi1eho7dwuwefiogjdd1d9e6\">變更追蹤的方法對應用的效率有著重要影響。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xsni8fgg13z9qwldwylke25i\">表單</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2xwzrnb2ye7twpwf3t9i2eiv\">回應式表單</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ak3g1olkqlgbya4zd1ag8egqa\">透過將其作為不可變資料結構提供，保持資料模型的純淨。每次在資料模型上觸發更改時，\n<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例回傳一個新的資料模型，而不是更新現有的資料模型。這使您能夠透過控制元件的可觀察物件跟蹤唯一的更改。因為資料更新遵循回應式模式，您可以與可觀察物件運算子整合以轉換資料，從而使變更檢測更有效率，因為它只需在唯一變更時更新。因為資料更新遵循回應式模式，您可以與可觀察物件運算子整合以轉換資料。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ikuesboztjr8out2q3bj6j8i\">樣板驅動表單</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cy4370jn6qowd2ixfbl5s33o\">依賴於可變性和雙向資料繫結，以在樣板中進行更改時更新元件中的資料模型。使用雙向資料繫結時，資料模型沒有唯一的更改需要跟蹤，因此變更檢測在確定何時需要更新時效率較低。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qgaf2xpzojcu8a3l6yc21xa8\">前面那些使用 <code>favorite-color</code> 輸入元素的例子就示範了這種差異。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7towdvbio5ncbh8oroqcac42g\">對於回應式表單，當控制元件值更新時，<strong><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 的實例</strong>總會回傳一個新值</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bpkre46o2dq3abgp6v2uzty9i\">對於樣板驅動表單，<strong><code>favorite-color</code> 屬性</strong>總會被修改為新值</li>\n</ul>\n<p><a id=\"validation\"></a></p>\n<h2 id=\"form-validation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9oba10w29tdu00d0zldlhdruv\">表單驗證<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#form-validation\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3t1nt8bdgh0mliep8pm6n8sk2\">驗證是管理任何表單時必備的一部分。無論你是要檢查必填項，還是查詢外部 API 來檢查使用者名是否已存在，Angular 都會提供一組內建的驗證器，以及建立自定義驗證器所需的能力。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xsni8fgg13z9qwldwylke25i\">表單</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2xwzrnb2ye7twpwf3t9i2eiv\">回應式表單</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2y00vqb0tk3adhn2r1161wcq\">定義自定義驗證器為接收一個控制元件進行驗證的\n<strong>函式</strong></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ikuesboztjr8out2q3bj6j8i\">樣板驅動表單</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ouv0aq8zu2yqkvpuo29eodww\">與樣板\n<strong>指令</strong>相關聯，必須提供包裝驗證函式的自定義驗證器指令</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1oi1oh5xdbutd3ouwrbufn5nb\">要了解驗證器的更多知識，參閱<a href=\"guide/form-validation\">表單驗證</a>。</p>\n<h2 id=\"testing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"etpgj6p39fywtmcrsphy8qrcg\">測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#testing\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6mg4fpm5e37dii1hnj6gi5ki\">測試在複雜的應用程式中也起著重要的作用。當驗證你的表單功能是否正確時，更簡單的測試策略往往也更有用。測試回應式表單和樣板驅動表單的差別之一在於它們是否需要渲染 UI 才能基於表單控制元件和表單欄位變化來執行斷言。下面的例子示範了使用回應式表單和樣板驅動表單時表單的測試過程。</p>\n<h3 id=\"testing-reactive-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bjv843oafc1y9eq181dg6at7g\">測試回應式表單<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#testing-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ab6icdnvhrj3gspumg1ct1yo6\">回應式表單提供了相對簡單的測試策略，因為它們能提供對錶單和數據模型的同步訪問，而且不必渲染 UI 就能測試它們。在這些測試中，控制元件和數據是透過控制元件進行查詢和操縱的，不需要和變更檢測週期打交道。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a9aticl2y3aiinnqlz6pe7e0x\">下面的測試利用前面例子中的 \"喜歡的顏色\" 元件來驗證回應式表單中的 \"從檢視到模型\" 和 \"從模型到檢視\" 資料流。</p>\n<!--todo: make consistent with other topics -->\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ojv4oqnma19dxq7oduaxr8r7\"><strong>驗證『從檢視到模型』的資料流</strong></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"19j8ftquallal10mlo4qvpcg7\">第一個例子執行了下列步驟來驗證『從檢視到模型』資料流。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78w38u5puerwpid0jmfrjskjz\">查詢表單輸入框元素的檢視，併為測試建立自定義的 \"input\" 事件</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7j4u42i7juseeku7f5i0u2me5\">把輸入的新值設定為 <em>Red</em>，並在表單輸入元素上排程 \"input\" 事件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"55o0qn06f36gsse897rrk1omr\">斷言該組件的 <code>favoriteColorControl</code> 的值與來自輸入框的值是對應的。</li>\n</ol>\n<code-example header=\"Favorite color test - view to model\" path=\"forms-overview/src/app/reactive/favorite-color/favorite-color.component.spec.ts\" region=\"view-to-model\">\nit('should update the value of the input field', () =&gt; {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3of9j8pabf14gymudav6rtxx9\">下一個例子執行了下列步驟來驗證『從模型到檢視』資料流。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8vosm0t595oge9s9tqv98ya6u\">使用 <code>favoriteColorControl</code> 這個 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例來設定新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"mgbnxo67xpvb1lb1ifkv4zde\">查詢表單中輸入框的檢視。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8jlag8hiaqk98imgeokgjbfmb\">斷言控制元件上設定的新值與輸入中的值是對應的。</li>\n</ol>\n<code-example header=\"Favorite color test - model to view\" path=\"forms-overview/src/app/reactive/favorite-color/favorite-color.component.spec.ts\" region=\"model-to-view\">\nit('should update the value in the control', () =&gt; {\n  component.favoriteColorControl.setValue('Blue');\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n});\n\n</code-example>\n<h3 id=\"testing-template-driven-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dodjm2pzlmrtzauhvrg5jzdka\">測試樣板驅動表單<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#testing-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ocyyyxiy5xb326snk6sjuv6l\">使用樣板驅動表單編寫測試就需要詳細瞭解變更檢測過程，以及指令在每個變更檢測週期中如何執行，以確保在正確的時間查詢、測試或更改元素。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e9rjywcsiagr3asat0qvrwcvr\">下面的測試使用了以前的 \"喜歡的顏色\" 元件，來驗證樣板驅動表單的 \"從檢視到模型\" 和 \"從模型到檢視\" 資料流。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"chku795zj036mb9gwhn094g10\">下面的測試驗證了 \"從檢視到模型\" 資料流：</p>\n<code-example header=\"Favorite color test - view to model\" path=\"forms-overview/src/app/template/favorite-color/favorite-color.component.spec.ts\" region=\"view-to-model\">\nit('should update the favorite color in the component', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  fixture.detectChanges();\n\n  expect(component.favoriteColor).toEqual('Red');\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crsiuuufn1jd57emeq250aifq\">這個 \"檢視到模型\" 測試的執行步驟如下：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78w38u5puerwpid0jmfrjskjz\">查詢表單輸入框元素的檢視，併為測試建立自定義的 \"input\" 事件</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7j4u42i7juseeku7f5i0u2me5\">把輸入的新值設定為 <em>Red</em>，並在表單輸入元素上排程 \"input\" 事件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bm25ip6x2uyryu38qfk2iownq\">透過測試夾具（Fixture）來執行變更檢測。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dznmfq0mwoknim2gt5zxkbc5r\">斷言該組件 <code>favoriteColor</code> 屬性的值與來自輸入框的值是對應的。</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"85wm9u8c4ftd0kdddou9buowb\">下面的測試驗證了 \"從模型到檢視\" 的資料流：</p>\n<code-example header=\"Favorite color test - model to view\" path=\"forms-overview/src/app/template/favorite-color/favorite-color.component.spec.ts\" region=\"model-to-view\">\nit('should update the favorite color on the input field', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  component.favoriteColor = 'Blue';\n\n  fixture.detectChanges();\n\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"96sz3xae4hctlw3c8lr135gu8\">這個 \"模型到檢視\" 測試的執行步驟如下：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1jazn4yg4fc8tjgduh0dewut1\">使用元件實例來設定 <code>favoriteColor</code> 的值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bm25ip6x2uyryu38qfk2iownq\">透過測試夾具（Fixture）來執行變更檢測。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c0a1r0bu9901v5iq1y5d9nlsc\">在 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 任務中使用 <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>()</code> 方法來模擬時間的流逝。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"mgbnxo67xpvb1lb1ifkv4zde\">查詢表單中輸入框的檢視。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b9uxx9lggcy89zr63cw81lbow\">斷言輸入框的值與該組件實例的 <code>favoriteColor</code> 屬性值是對應的。</li>\n</ol>\n<h2 id=\"next-steps\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c4pkljueu68ifjoi5994e9l8o\">下一步<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#next-steps\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f12x3s8sgeivlj1ki3ee6uv4n\">要進一步瞭解回應式表單，參閱下列章節：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6eb6f99oqlsb6x0n77wdfb7t\"><a href=\"guide/reactive-forms\">回應式表單</a></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9sz26lkvn9m7ykf69q69cwz1v\"><a href=\"guide/form-validation#reactive-form-validation\">表單驗證</a></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5pmfl3i3ug0zdj3rjfydf7bi\"><a href=\"guide/dynamic-form\">動態表單</a></li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"20iahnjug73qams2e9h6znh4d\">要進一步瞭解樣板驅動表單，參閱下列章節：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5n836lphbfoybjnf08hma68i\"><a href=\"guide/forms\">建立樣板驅動表單</a>教程</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bcz4qt742vjnjywp70aq9dobw\"><a href=\"guide/form-validation#template-driven-validation\">表單驗證</a></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5m7in0dyrov163os1t0nql89t\"><code><a href=\"api/forms/NgForm\" class=\"code-anchor\">NgForm</a></code> 指令 API 參考手冊</li>\n</ul>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Thu Sep 07 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/forms\n - api/forms/ReactiveFormsModule\n - features\n - guide/architecture-next-steps\n - guide/developer-guide-overview\n - guide/docs-style-guide\n - guide/example-apps-list\n - guide/form-validation\n - guide/forms\n - guide/glossary\n - guide/npm-packages\n - guide/reactive-forms\n - guide/user-input\n - guide/what-is-angular\n - scaling\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/testing/fakeAsync\n - api/core/testing/tick\n - api/forms/ControlValueAccessor\n - api/forms/FormArray\n - api/forms/FormControl\n - api/forms/FormGroup\n - api/forms/FormsModule\n - api/forms/NgForm\n - api/forms/NgModel\n - api/forms/NgModel#viewToModelUpdate\n - api/forms/ReactiveFormsModule\n - guide/architecture\n - guide/architecture-components#template-syntax\n - guide/dynamic-form\n - guide/form-validation\n - guide/form-validation#reactive-form-validation\n - guide/form-validation#template-driven-validation\n - guide/forms\n - guide/forms-overview#choosing-an-approach\n - guide/forms-overview#common-form-foundation-classes\n - guide/forms-overview#data-flow-in-forms\n - guide/forms-overview#data-flow-in-reactive-forms\n - guide/forms-overview#data-flow-in-template-driven-forms\n - guide/forms-overview#form-validation\n - guide/forms-overview#introduction-to-forms-in-angular\n - guide/forms-overview#key-differences\n - guide/forms-overview#mutability-of-the-data-model\n - guide/forms-overview#next-steps\n - guide/forms-overview#prerequisites\n - guide/forms-overview#scalability\n - guide/forms-overview#setting-up-the-form-model\n - guide/forms-overview#setup\n - guide/forms-overview#setup-in-reactive-forms\n - guide/forms-overview#setup-in-template-driven-forms\n - guide/forms-overview#testing\n - guide/forms-overview#testing-reactive-forms\n - guide/forms-overview#testing-template-driven-forms\n - guide/forms-overview#validation\n - guide/reactive-forms\n - https://www.typescriptlang.org/\n-->"}