{"id":"guide/forms-overview","title":"Angular 表单简介","contents":"<div class=\"content\">\n  <h1 id=\"introduction-to-forms-in-angular\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7o5evbt8m8a5chz2mdh39m3bz\">Angular 表单简介<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#introduction-to-forms-in-angular\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"acbzlf69r51ppxbqncxvosfsn\">用表单处理用户输入是许多常见应用的基础功能。\n应用通过表单来让用户登录、修改个人档案、输入敏感信息以及执行各种数据输入任务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eurm3ascqk2h4ig5e1hnizhcx\">Angular 提供了两种不同的方法来通过表单处理用户输入：响应式表单和模板驱动表单。\n两者都从视图中捕获用户输入事件、验证用户输入、创建表单模型、修改数据模型，并提供跟踪这些更改的途径。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aq3bag4d3y8rnpeyrwdgl9b0a\">本指南提供的信息可以帮你确定哪种方式最适合你的情况。它介绍了这两种方法所用的公共构造块，还总结了两种方式之间的关键区别，并在建立、数据流和测试等不同的情境下展示了这些差异。</p>\n<h2 id=\"prerequisites\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e44b21uig1fakj5vcfuvz1bdu\">前提条件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#prerequisites\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7tpo3lrdg4mco0t530rclr53p\">本指南假设你对以下内容有基本的了解。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"hvl8rjzxrmac41qpao60jlv6\"><a href=\"https://www.typescriptlang.org/\" title=\"TypeScript 语言\">TypeScript</a>和 HTML5 编程</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"655p6dhauz2ot3psa4gysttev\">Angular 的应用设计基础，就像<a href=\"guide/architecture\" title=\"Angular 概念简介。\">Angular Concepts 中</a>描述的那样</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9npb20i9qclwsqwgxx2gfw9np\"><a href=\"guide/architecture-components#template-syntax\" title=\"模板语法简介\">Angular 模板语法</a>的基础知识</li>\n</ul>\n<h2 id=\"choosing-an-approach\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e5w7rl07hdukdij8b3as3qbid\">选择一种方法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#choosing-an-approach\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4y96qhbczq5jloc5csxzejc70\">响应式表单和模板驱动表单以不同的方式处理和管理表单数据。每种方法都有各自的优点。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xsni8fgg13z9qwldwylke25i\">表单</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2xwzrnb2ye7twpwf3t9i2eiv\">响应式表单</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43t6m1vi6b1vr0x93iyi169ve\">提供对底层表单对象模型的直接、明确访问。与模板驱动表单相比，它们更加健壮：它们更具可扩展性、可重用性和可测试性。如果表单是你应用的关键部分，或者你已经在应用中使用响应式模式构建应用，那就使用响应式表单。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ikuesboztjr8out2q3bj6j8i\">模板驱动表单</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayvotbxmvji1hsei11mp1beht\">依赖于模板中的指令来创建和操纵底层对象模型。它们对于在应用中添加一个简单的表单很有用，比如电子邮件列表注册表单。它们很容易添加到应用中，但不像响应式表单那样具有良好的扩展性。如果你的表单需求非常基本，逻辑可以完全在模板中管理，那么模板驱动表单可能是一个很好的选择。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"key-differences\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"17mblkyyiy67qhoqo19d4yyf1\">关键差异<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#key-differences\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3us5tmzgqsru1eiu3ijm0sgaw\">下表总结了响应式表单和模板驱动表单之间的一些关键差异。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"beymamclbildi1j6u2luvobnb\">响应式</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a2fvyexkjup80ihgwwa7zlgj1\">模板驱动</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9z3uxnf3ax9pceugnecec61x3\"><a href=\"guide/forms-overview#setup\">设置表单模型</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3po6hh34gd0qfhasfmiiik77b\">显式，在组件类中创建</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"416g1ayukcukzkrmkvdjj53ev\">隐式，由指令创建</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dfbadqbauugtwlr03ec00xb5a\"><a href=\"guide/forms-overview#mutability-of-the-data-model\">数据模型</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3b1dazfmeruw52vpp6quu4m56\">结构化和不可变</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"61harkjo062k26dyun9c6jfa3\">非结构化和可变</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebopzhygfldd8ts9n4bxrlhdv\"><a href=\"guide/forms-overview#data-flow-in-forms\">数据流</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2u2hy2y6ad0o9jvjm516n2pzv\">同步</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2eem8gjjq9t3zly57owr6sbb8\">异步</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a9oic9413thtwy7tpgjt77f4t\"><a href=\"guide/forms-overview#validation\">表单验证</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dt2uvbdl3r7k4tmkiulzt8lb8\">函数</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9uaad125h3hufxqa64leub0r9\">指令</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"scalability\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2o6opt1nvbl33tg3476xzzuv5\">可伸缩性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#scalability\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c56wnd2xa1ni0oj5vgkji1bds\">如果表单是应用程序的核心部分，那么可伸缩性就非常重要。能够跨组件复用表单模型是至关重要的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ec844a3xmlq1mw3rmfw8r3c9\">响应式表单比模板驱动表单更有可伸缩性。它们提供对底层表单 API 的直接访问，并且在视图和数据模型之间使用<a href=\"guide/forms-overview#data-flow-in-reactive-forms\">同步数据流</a>，从而可以更轻松地创建大型表单。响应式表单需要较少的测试设置，测试时不需要深入理解变更检测，就能正确测试表单更新和验证。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"992e2vrvtaj48iq1qzir847rh\">模板驱动表单专注于简单的场景，可复用性没那么高。它们抽象出了底层表单 API，并且在视图和数据模型之间使用<a href=\"guide/forms-overview#data-flow-in-template-driven-forms\">异步数据流</a>。对模板驱动表单的这种抽象也会影响测试。测试程序非常依赖于手动触发变更检测才能正常运行，并且需要进行更多设置工作。</p>\n<p><a id=\"setup\"></a></p>\n<h2 id=\"setting-up-the-form-model\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"vd8uvn18s2003cdareku8py\">建立表单模型<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#setting-up-the-form-model\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rpj0msitef6f5olivusd74ma\">响应式表单和模板驱动型表单都会跟踪用户与之交互的表单输入元素和组件模型中的表单数据之间的值变更。这两种方法共享同一套底层构建块，只在如何创建和管理常用表单控件实例方面有所不同。</p>\n<h3 id=\"common-form-foundation-classes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"85cbpj2qfnlzfk9fk9vzh0g5i\">常用表单基础类<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#common-form-foundation-classes\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1lzo0ijuvgfhi4n44df86i957\">响应式表单和模板驱动表单都建立在下列基础类之上。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a19nalj6m5o4n2pxfxkv4iyj7\">基础类</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"30uooirslsrx1kpin16rmo7h3\">跟踪独立表单控件的值和验证状态。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7fe38mjuep8vp55zwp60czljp\">跟踪一组表单控件的相同值和状态。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/forms/FormArray\" class=\"code-anchor\">FormArray</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ek1excyungbnoe1v66yipxrpw\">跟踪一组表单控件的相同值和状态。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/forms/ControlValueAccessor\" class=\"code-anchor\">ControlValueAccessor</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"34zuqlyr6a9zg23wwe52x7nh2\">在 Angular \n<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例和内置 DOM 元素之间创建桥梁。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"setup-the-form-model\"></a></p>\n<h3 id=\"setup-in-reactive-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4as3zzpl7lybj6rc97y4p87zw\">建立响应式表单<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#setup-in-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dzdxd2yoivx2wg17z031ggwp0\">对于响应式表单，你可以直接在组件类中定义表单模型。<code>[formControl]</code> 指令会通过内部值访问器来把显式创建的 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例与视图中的特定表单元素联系起来。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7lz6diuj6xvgfzpb1wzher99v\">下面的组件使用响应式表单为单个控件实现了一个输入字段。在这个例子中，表单模型是 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例。</p>\n<code-example path=\"forms-overview/src/app/reactive/favorite-color/favorite-color.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>, <a href=\"api/forms/ReactiveFormsModule\" class=\"code-anchor\">ReactiveFormsModule</a> } from '@angular/forms';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-reactive-favorite-color',\n  template: `\n    Favorite Color: &lt;input type=\"text\" [formControl]=\"favoriteColorControl\" /&gt;\n  `,\n  imports: [<a href=\"api/forms/ReactiveFormsModule\" class=\"code-anchor\">ReactiveFormsModule</a>],\n})\nexport class FavoriteColorComponent {\n  favoriteColorControl = new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('');\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qivnzbsj3clhjysd7qlu893g\">图 1 展示了在响应式表单中，表单模型是如何成为事实之源（source of truth）的。它通过输入元素上的 <code>[formControl]</code> 指令，在任何给定的时间点提供表单元素的值和状态。</p>\n<!--todo: make consistent with other topics -->\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8n81m82bb3du082baqwju56fj\"><strong>图 1.</strong> <em>在响应式表单中直接访问表单模型</em></p>\n<div class=\"lightbox\">\n<img alt=\"Reactive forms key differences\" src=\"generated/images/guide/forms-overview/key-diff-reactive-forms.png\" width=\"635\" height=\"335\">\n</div>\n<h3 id=\"setup-in-template-driven-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4t6lp7vgwfq56zqidtkuw4hdi\">建立模板驱动表单<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#setup-in-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b7qe7qy1lxo03bdjlva7clp6q\">在模板驱动表单中，表单模型是隐式的，而不是显式的。指令 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 为指定的表单元素创建并管理一个 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4i2vifvwsamzoyd686kpn1daf\">下面的组件使用模板驱动表单为单个控件实现了同样的输入字段。</p>\n<code-example path=\"forms-overview/src/app/template/favorite-color/favorite-color.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-template-favorite-color',\n  template: `\n    Favorite Color: &lt;input type=\"text\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"favoriteColor\" /&gt;\n  `,\n  imports: [<a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>],\n})\nexport class FavoriteColorComponent {\n  favoriteColor = '';\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29viilcx20tao7mc6j8hcmbh3\">在模板驱动表单中，其事实之源就是模板。你没有对 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例的直接编程访问，如图 2 所示。</p>\n<!--todo: make consistent with other topics -->\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1krbzow9tcfe4odv92uxxvgjw\"><strong>图 2.</strong> <em>模板驱动表单中对表单模型的间接访问。</em></p>\n<div class=\"lightbox\">\n<img alt=\"Template-driven forms key differences\" src=\"generated/images/guide/forms-overview/key-diff-td-forms.png\" width=\"607\" height=\"387\">\n</div>\n<p><a id=\"data-flow-in-forms\"></a></p>\n<h2 id=\"data-flow-in-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99472ufe9n7iw9tr7jch0a71l\">表单中的数据流<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#data-flow-in-forms\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37177mxdfgce4kl3j3e9kup0i\">当应用包含一个表单时，Angular 必须让该视图与组件模型保持同步，并让组件模型与视图保持同步。当用户通过视图更改值并进行选择时，新值必须反映在数据模型中。同样，当程序逻辑改变数据模型中的值时，这些值也必须反映到视图中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"25j7t0crxtrki2e3ya7m1v3mx\">响应式表单和模板驱动表单在处理来自用户或程序化变更时的数据处理方式上有所不同。下面的这些原理图会以上面定义的 <code>favorite-color</code> 输入字段为例，分别说明两种表单各自的数据流。</p>\n<p><a id=\"data-flow-in-reactive-forms\"></a></p>\n<h3 id=\"data-flow-in-reactive-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b3rm4rqtg5mku3liqu4ho2t27\">响应式表单中的数据流<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#data-flow-in-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cg4u34ceeej67pjo7909zy4cp\">在响应式表单中，视图中的每个表单元素都直接链接到一个表单模型（<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例）。\n从视图到模型的修改以及从模型到视图的修改都是同步的，而且不依赖于 UI 的渲染方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9hl4tb1veopxo66cwpfs3ibnf\">这个视图到模型的图表展示了当输入字段的值发生变化时，数据流是如何从视图开始经过下列步骤进行流动的。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"czg1ped18o7gaoo0drhzx3rm8\">最终用户在输入框元素中键入了一个值，这里是 \"Blue\"。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a20cxksvyo2jbk0kyvo8q6fza\">这个输入框元素会发出一个带有最新值的 \"input\" 事件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"caysotaohxkfswfwrlryc72fb\">这个控件值访问器 <code><a href=\"api/forms/ControlValueAccessor\" class=\"code-anchor\">ControlValueAccessor</a></code> 会监听表单输入框元素上的事件，并立即把新值传给 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6r4tmnsnmyux0tem1413exiqf\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例会通过 <code>valueChanges</code> 这个可观察对象发出这个新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6o84h5lh1a0whj8cudceg9lwj\"><code>valueChanges</code> 的任何一个订阅者都会收到这个新值。</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"Reactive forms data flow - view to model\" src=\"generated/images/guide/forms-overview/dataflow-reactive-forms-vtm.png\" width=\"600\" height=\"592\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9313120ylistdipv0uf6ne38l\">这个模型到视图的原理图体现了程序中对模型的修改是如何通过下列步骤传播到视图中的。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bd32f151d7cfk4qt2c6yaqem4\"><code>favoriteColorControl.setValue()</code> 方法被调用，它会更新这个 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 的值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6r4tmnsnmyux0tem1413exiqf\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例会通过 <code>valueChanges</code> 这个可观察对象发出这个新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6o84h5lh1a0whj8cudceg9lwj\"><code>valueChanges</code> 的任何一个订阅者都会收到这个新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5n09qcw4tez2634hdbkbqvwno\">该表单输入框元素上的控件值访问器会把控件更新为这个新值。</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"Reactive forms data flow - model to view\" src=\"generated/images/guide/forms-overview/dataflow-reactive-forms-mtv.png\" width=\"600\" height=\"611\">\n</div>\n<p><a id=\"data-flow-in-template-driven-forms\"></a></p>\n<h3 id=\"data-flow-in-template-driven-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aikd7yu9ohck7b7pwaor509nv\">模板驱动表单中的数据流<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#data-flow-in-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c220zh08db1gij1mgzr8i21vt\">在模板驱动表单中，每一个表单元素都是和一个负责管理内部表单模型的指令关联起来的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9hl4tb1veopxo66cwpfs3ibnf\">这个视图到模型的图表展示了当输入字段的值发生变化时，数据流是如何从视图开始经过下列步骤进行流动的。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6mazhtn6xgr4vigolblu2g3vx\">最终用户在输入框元素中敲 \"Blue\"。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f1qcwuv0oaqs1lzxjkxucwrcj\">该输入框元素会发出一个 \"input\" 事件，带着值 \"Blue\"。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ytx9ui10vegn178z08ynvw2w\">附着在该输入框上的控件值访问器会触发 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例上的 <code>setValue()</code> 方法。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6r4tmnsnmyux0tem1413exiqf\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例会通过 <code>valueChanges</code> 这个可观察对象发出这个新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6o84h5lh1a0whj8cudceg9lwj\"><code>valueChanges</code> 的任何一个订阅者都会收到这个新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"75etgywiwq0z7e97qu4xe6t4\">控件值访问器 <code>ControlValueAccessory</code> 还会调用 <code><a href=\"api/forms/NgModel#viewToModelUpdate\" class=\"code-anchor\">NgModel.viewToModelUpdate()</a></code> 方法，它会发出一个 <code>ngModelChange</code> 事件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jc4ifrfg7ffszguinwxqr8uo\">由于该组件模板双向数据绑定到了 <code>favoriteColor</code>，组件中的 <code>favoriteColor</code> 属性就会修改为 <code>ngModelChange</code> 事件所发出的值（\"Blue\"）。</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"Template-driven forms data flow - view to model\" width=\"100%\" src=\"generated/images/guide/forms-overview/dataflow-td-forms-vtm.png\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"asrqpsxmzdbl7fykquqye0srs\">这个模型到视图的原理图展示了当 <code>favoriteColor</code> 从<em>蓝</em>变到<em>红</em>时，数据是如何经过如下步骤从模型流动到视图的。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dzc0fknrkb4kmn7isurjhobwd\">组件中修改了 <code>favoriteColor</code> 的值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"jm63uz2hoby47dlz6eq6bn6t\">变更检测开始。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhpjdykg0nx0gtj0q4rsoumax\">在变更检测期间，由于这些输入框之一的值发生了变化，Angular 就会调用 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 指令上的 <code>ngOnChanges</code> 生命周期钩子。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7epodembq9p1eoze69o52cwsd\"><code>ngOnChanges()</code> 方法会把一个异步任务排入队列，以设置内部 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例的值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bnnzbtxjnzwnw0zofzdv48ies\">变更检测完成。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1l2jisw88l3tvqkvepeflrz2d\">在下一个检测周期，用来为 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例赋值的任务就会执行。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8yhv452gqkc6qrz1qw5vexag\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例通过可观察对象 <code>valueChanges</code> 发出最新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6o84h5lh1a0whj8cudceg9lwj\"><code>valueChanges</code> 的任何一个订阅者都会收到这个新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ebaq8uyoturm5maps8uep0ne\">控件值访问器 <code><a href=\"api/forms/ControlValueAccessor\" class=\"code-anchor\">ControlValueAccessor</a></code> 会使用 <code>favoriteColor</code> 的最新值来修改表单的输入框元素。</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"Template-driven forms data flow - model to view\" width=\"100%\" src=\"generated/images/guide/forms-overview/dataflow-td-forms-mtv.png\">\n</div>\n<p><a id=\"mutability-of-the-data-model\"></a></p>\n<h3 id=\"mutability-of-the-data-model\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8a7ok15vnroy0m8n4p6otx0az\">数据模型的可变性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#mutability-of-the-data-model\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zi1eho7dwuwefiogjdd1d9e6\">变更追踪的方法对应用的效率有着重要影响。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xsni8fgg13z9qwldwylke25i\">表单</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2xwzrnb2ye7twpwf3t9i2eiv\">响应式表单</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ak3g1olkqlgbya4zd1ag8egqa\">通过将其作为不可变数据结构提供，保持数据模型的纯净。每次在数据模型上触发更改时，\n<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例返回一个新的数据模型，而不是更新现有的数据模型。这使您能够通过控件的可观察对象跟踪唯一的更改。因为数据更新遵循响应式模式，您可以与可观察对象操作符集成以转换数据，从而使变更检测更有效率，因为它只需在唯一变更时更新。因为数据更新遵循响应式模式，您可以与可观察对象操作符集成以转换数据。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ikuesboztjr8out2q3bj6j8i\">模板驱动表单</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cy4370jn6qowd2ixfbl5s33o\">依赖于可变性和双向数据绑定，以在模板中进行更改时更新组件中的数据模型。使用双向数据绑定时，数据模型没有唯一的更改需要跟踪，因此变更检测在确定何时需要更新时效率较低。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qgaf2xpzojcu8a3l6yc21xa8\">前面那些使用 <code>favorite-color</code> 输入元素的例子就演示了这种差异。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7towdvbio5ncbh8oroqcac42g\">对于响应式表单，当控件值更新时，<strong><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 的实例</strong>总会返回一个新值</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bpkre46o2dq3abgp6v2uzty9i\">对于模板驱动表单，<strong><code>favorite-color</code> 属性</strong>总会被修改为新值</li>\n</ul>\n<p><a id=\"validation\"></a></p>\n<h2 id=\"form-validation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9oba10w29tdu00d0zldlhdruv\">表单验证<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#form-validation\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3t1nt8bdgh0mliep8pm6n8sk2\">验证是管理任何表单时必备的一部分。无论你是要检查必填项，还是查询外部 API 来检查用户名是否已存在，Angular 都会提供一组内置的验证器，以及创建自定义验证器所需的能力。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xsni8fgg13z9qwldwylke25i\">表单</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2xwzrnb2ye7twpwf3t9i2eiv\">响应式表单</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2y00vqb0tk3adhn2r1161wcq\">定义自定义验证器为接收一个控件进行验证的\n<strong>函数</strong></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ikuesboztjr8out2q3bj6j8i\">模板驱动表单</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ouv0aq8zu2yqkvpuo29eodww\">与模板\n<strong>指令</strong>相关联，必须提供包装验证函数的自定义验证器指令</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1oi1oh5xdbutd3ouwrbufn5nb\">要了解验证器的更多知识，参阅<a href=\"guide/form-validation\">表单验证</a>。</p>\n<h2 id=\"testing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"etpgj6p39fywtmcrsphy8qrcg\">测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#testing\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6mg4fpm5e37dii1hnj6gi5ki\">测试在复杂的应用程序中也起着重要的作用。当验证你的表单功能是否正确时，更简单的测试策略往往也更有用。测试响应式表单和模板驱动表单的差别之一在于它们是否需要渲染 UI 才能基于表单控件和表单字段变化来执行断言。下面的例子演示了使用响应式表单和模板驱动表单时表单的测试过程。</p>\n<h3 id=\"testing-reactive-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bjv843oafc1y9eq181dg6at7g\">测试响应式表单<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#testing-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ab6icdnvhrj3gspumg1ct1yo6\">响应式表单提供了相对简单的测试策略，因为它们能提供对表单和数据模型的同步访问，而且不必渲染 UI 就能测试它们。在这些测试中，控件和数据是通过控件进行查询和操纵的，不需要和变更检测周期打交道。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a9aticl2y3aiinnqlz6pe7e0x\">下面的测试利用前面例子中的 \"喜欢的颜色\" 组件来验证响应式表单中的 \"从视图到模型\" 和 \"从模型到视图\" 数据流。</p>\n<!--todo: make consistent with other topics -->\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ojv4oqnma19dxq7oduaxr8r7\"><strong>验证“从视图到模型”的数据流</strong></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"19j8ftquallal10mlo4qvpcg7\">第一个例子执行了下列步骤来验证“从视图到模型”数据流。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78w38u5puerwpid0jmfrjskjz\">查询表单输入框元素的视图，并为测试创建自定义的 \"input\" 事件</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7j4u42i7juseeku7f5i0u2me5\">把输入的新值设置为 <em>Red</em>，并在表单输入元素上调度 \"input\" 事件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"55o0qn06f36gsse897rrk1omr\">断言该组件的 <code>favoriteColorControl</code> 的值与来自输入框的值是匹配的。</li>\n</ol>\n<code-example header=\"Favorite color test - view to model\" path=\"forms-overview/src/app/reactive/favorite-color/favorite-color.component.spec.ts\" region=\"view-to-model\">\nit('should update the value of the input field', () =&gt; {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3of9j8pabf14gymudav6rtxx9\">下一个例子执行了下列步骤来验证“从模型到视图”数据流。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8vosm0t595oge9s9tqv98ya6u\">使用 <code>favoriteColorControl</code> 这个 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例来设置新值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"mgbnxo67xpvb1lb1ifkv4zde\">查询表单中输入框的视图。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8jlag8hiaqk98imgeokgjbfmb\">断言控件上设置的新值与输入中的值是匹配的。</li>\n</ol>\n<code-example header=\"Favorite color test - model to view\" path=\"forms-overview/src/app/reactive/favorite-color/favorite-color.component.spec.ts\" region=\"model-to-view\">\nit('should update the value in the control', () =&gt; {\n  component.favoriteColorControl.setValue('Blue');\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n});\n\n</code-example>\n<h3 id=\"testing-template-driven-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dodjm2pzlmrtzauhvrg5jzdka\">测试模板驱动表单<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#testing-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ocyyyxiy5xb326snk6sjuv6l\">使用模板驱动表单编写测试就需要详细了解变更检测过程，以及指令在每个变更检测周期中如何运行，以确保在正确的时间查询、测试或更改元素。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e9rjywcsiagr3asat0qvrwcvr\">下面的测试使用了以前的 \"喜欢的颜色\" 组件，来验证模板驱动表单的 \"从视图到模型\" 和 \"从模型到视图\" 数据流。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"chku795zj036mb9gwhn094g10\">下面的测试验证了 \"从视图到模型\" 数据流：</p>\n<code-example header=\"Favorite color test - view to model\" path=\"forms-overview/src/app/template/favorite-color/favorite-color.component.spec.ts\" region=\"view-to-model\">\nit('should update the favorite color in the component', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  fixture.detectChanges();\n\n  expect(component.favoriteColor).toEqual('Red');\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crsiuuufn1jd57emeq250aifq\">这个 \"视图到模型\" 测试的执行步骤如下：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78w38u5puerwpid0jmfrjskjz\">查询表单输入框元素的视图，并为测试创建自定义的 \"input\" 事件</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7j4u42i7juseeku7f5i0u2me5\">把输入的新值设置为 <em>Red</em>，并在表单输入元素上调度 \"input\" 事件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bm25ip6x2uyryu38qfk2iownq\">通过测试夹具（Fixture）来运行变更检测。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dznmfq0mwoknim2gt5zxkbc5r\">断言该组件 <code>favoriteColor</code> 属性的值与来自输入框的值是匹配的。</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"85wm9u8c4ftd0kdddou9buowb\">下面的测试验证了 \"从模型到视图\" 的数据流：</p>\n<code-example header=\"Favorite color test - model to view\" path=\"forms-overview/src/app/template/favorite-color/favorite-color.component.spec.ts\" region=\"model-to-view\">\nit('should update the favorite color on the input field', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  component.favoriteColor = 'Blue';\n\n  fixture.detectChanges();\n\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"96sz3xae4hctlw3c8lr135gu8\">这个 \"模型到视图\" 测试的执行步骤如下：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1jazn4yg4fc8tjgduh0dewut1\">使用组件实例来设置 <code>favoriteColor</code> 的值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bm25ip6x2uyryu38qfk2iownq\">通过测试夹具（Fixture）来运行变更检测。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c0a1r0bu9901v5iq1y5d9nlsc\">在 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 任务中使用 <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>()</code> 方法来模拟时间的流逝。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"mgbnxo67xpvb1lb1ifkv4zde\">查询表单中输入框的视图。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b9uxx9lggcy89zr63cw81lbow\">断言输入框的值与该组件实例的 <code>favoriteColor</code> 属性值是匹配的。</li>\n</ol>\n<h2 id=\"next-steps\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c4pkljueu68ifjoi5994e9l8o\">下一步<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#next-steps\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f12x3s8sgeivlj1ki3ee6uv4n\">要进一步了解响应式表单，参阅下列章节：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6eb6f99oqlsb6x0n77wdfb7t\"><a href=\"guide/reactive-forms\">响应式表单</a></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9sz26lkvn9m7ykf69q69cwz1v\"><a href=\"guide/form-validation#reactive-form-validation\">表单验证</a></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5pmfl3i3ug0zdj3rjfydf7bi\"><a href=\"guide/dynamic-form\">动态表单</a></li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"20iahnjug73qams2e9h6znh4d\">要进一步了解模板驱动表单，参阅下列章节：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5n836lphbfoybjnf08hma68i\"><a href=\"guide/forms\">构建模板驱动表单</a>教程</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bcz4qt742vjnjywp70aq9dobw\"><a href=\"guide/form-validation#template-driven-validation\">表单验证</a></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5m7in0dyrov163os1t0nql89t\"><code><a href=\"api/forms/NgForm\" class=\"code-anchor\">NgForm</a></code> 指令 API 参考手册</li>\n</ul>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Thu Sep 07 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/forms\n - api/forms/ReactiveFormsModule\n - features\n - guide/architecture-next-steps\n - guide/developer-guide-overview\n - guide/docs-style-guide\n - guide/example-apps-list\n - guide/form-validation\n - guide/forms\n - guide/glossary\n - guide/npm-packages\n - guide/reactive-forms\n - guide/user-input\n - guide/what-is-angular\n - scaling\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/testing/fakeAsync\n - api/core/testing/tick\n - api/forms/ControlValueAccessor\n - api/forms/FormArray\n - api/forms/FormControl\n - api/forms/FormGroup\n - api/forms/FormsModule\n - api/forms/NgForm\n - api/forms/NgModel\n - api/forms/NgModel#viewToModelUpdate\n - api/forms/ReactiveFormsModule\n - guide/architecture\n - guide/architecture-components#template-syntax\n - guide/dynamic-form\n - guide/form-validation\n - guide/form-validation#reactive-form-validation\n - guide/form-validation#template-driven-validation\n - guide/forms\n - guide/forms-overview#choosing-an-approach\n - guide/forms-overview#common-form-foundation-classes\n - guide/forms-overview#data-flow-in-forms\n - guide/forms-overview#data-flow-in-reactive-forms\n - guide/forms-overview#data-flow-in-template-driven-forms\n - guide/forms-overview#form-validation\n - guide/forms-overview#introduction-to-forms-in-angular\n - guide/forms-overview#key-differences\n - guide/forms-overview#mutability-of-the-data-model\n - guide/forms-overview#next-steps\n - guide/forms-overview#prerequisites\n - guide/forms-overview#scalability\n - guide/forms-overview#setting-up-the-form-model\n - guide/forms-overview#setup\n - guide/forms-overview#setup-in-reactive-forms\n - guide/forms-overview#setup-in-template-driven-forms\n - guide/forms-overview#testing\n - guide/forms-overview#testing-reactive-forms\n - guide/forms-overview#testing-template-driven-forms\n - guide/forms-overview#validation\n - guide/reactive-forms\n - https://www.typescriptlang.org/\n-->"}