{"id":"guide/rxjs-interop","title":"RxJS 互操作","contents":"<div class=\"content\">\n  <h1 id=\"rxjs-interop\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4dgfms6hzrp30whv8dgni5yt8\">RxJS 互操作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#rxjs-interop\"><i class=\"material-icons\">link</i></a></h1>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d9e5ue8dj7lr1po172y86xt29\">RxJS 互操作性套件已經提供了<a href=\"/guide/releases#developer-preview\">開發者預覽版</a>。你已經可以嘗試使用它，但在穩定之前可能會發生變化。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6r0o5yyyrt0ig9ls9isfr1j0r\">Angular 的 <code>@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a></code> 套件，它提供了有用的實用程式來將 <a href=\"/guide/signals\">Angular 訊號（Signal）</a> 與 RxJS 可觀察物件（Observable）整合起來。</p>\n<h2 id=\"tosignal\"><code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#tosignal\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eq73o3wg8w43ttlc81lnibp4w\"><code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>函式建立一個訊號，跟蹤可觀察物件的值。它類似於樣板中的\n<code>async</code>通道，但更靈活，可在應用程式中的任何位置使用。</p>\n<code-example language=\"ts\">\nimport {<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>} from '@angular/core';\nimport {<a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a>} from '@angular/common';\nimport {interval} from 'rxjs';\nimport { <a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a> } from '@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  template: `{{ counter() }}`,\n})\nexport class Ticker {\n  counterObservable = interval(1000);\n\n  // Get a `<a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>` representing the `counterObservable`'s value.\n  counter = <a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a>(this.counterObservable, {initialValue: 0});\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3wxk7tlgxrj9un8togmh8zpi\">與\n<code>async</code>通道類似，\n<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>立即訂閱可觀察物件，這可能會觸發副作用。由\n<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>建立的訂閱會在元件銷燬時自動取消訂閱給定的可觀察物件。</p>\n<h3 id=\"initial-values\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"34l32l1ha5h6vhdqna6eo4o04\">初始值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#initial-values\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wrkrkl8dex4cdoon8mpp2m0u\">Observable 可能不會在訂閱時同步產生一個值，但訊號總是需要一個當前值。有幾種方法可以處理 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 訊號的這個『初始』值。</p>\n<h4 id=\"the-initialvalue-option\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1z7zpbpl8vp1ruigacexkkmhg\"><code>initialValue</code> 選項<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-initialvalue-option\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91ul3mbyb702ticcsyl5wy6um\">如上例所示，<code>initialValue</code> 選項指定訊號在 Observable 首次發射之前應回傳的值。</p>\n<h4 id=\"undefined-initial-values\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jw943plkvsesunn6hot0e8o6\"><code>undefined</code> 初始值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#undefined-initial-values\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"754o7zctyridff4p1udhgyjrf\">如果省略\n<code>initialValue</code>，\n<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>回傳的訊號在可觀察物件發出值之前回傳\n<code>undefined</code>。這類似於\n<code>async</code>通道在沒有值時回傳\n<code>null</code>的行為。</p>\n<h4 id=\"the-requiresync-option\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"21fop5l9gi6f1d3t9u50g2o07\"><code>requireSync</code> 選項<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-requiresync-option\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68ysg07e4f9u8iz3tloti6mv3\">已知一些 Observable 是同步發出的，例如 <code>BehaviorSubject</code>。在這些情況下，你可以指定 <code>requireSync: true</code> 選項。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ut2801qfeofpw6dd4yl3r1p6\">當 <code>requiredSync</code> 為 <code>true</code> 時，<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 強制 Observable 在訂閱時同步發出值。這保證了訊號總是有一個值，並且不需要用 <code>undefined</code> 型別或初始值。</p>\n<h3 id=\"manualcleanup\"><code>manualCleanup</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#manualcleanup\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dz8c7dgd0s1sxjosg2phmapg1\">預設情況下，<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 在建立它的上下文被銷燬時自動取消訂閱 Observable。例如，如果在元件建立期間呼叫 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>，它會在元件銷燬時清除其訂閱。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7fsmcbpr4sq4jgfr0egb6zd7i\"><code>manualCleanup</code> 選項會停用此自動清理。你可以將此設定用於會自然結束的 Observable。</p>\n<h3 id=\"error-and-completion\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6qa3mqgys3lg88ug8y0te1ksv\">出錯與結束<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#error-and-completion\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7g589zbfv873vdj7fh36hxqew\">如果\n<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>中使用的可觀察物件產生錯誤，則在讀取訊號時會丟擲該錯誤。建議在可觀察物件的上游處理錯誤，並將其轉換為值（這可能表示需要在樣板中顯示錯誤頁面）。可以使用RxJS中的\n<code>catchError</code>運算子來實現這一點。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"z3d8e4ayraavnheprq33z5x1\">如果 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 中使用的 Observable 結束了，則訊號會繼續回傳結束前最近發出的值。</p>\n<h4 id=\"the-rejecterrors-option\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"160mo7v9fxgb5fszr0j9pe5qc\">拒絕錯誤選項<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-rejecterrors-option\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8uhm5x39r9sevknolqcxgzb5d\"><code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>對錯誤的預設行為是將\n<code>Observable</code>的錯誤通道傳播到訊號。另一種方法是完全拒絕錯誤，使用\n<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>的\n<code>rejectErrors</code>選項。使用此選項，錯誤會被拋回到RxJS中，在全域應用程式錯誤處理程式中作為未捕獲的異常被捕獲。由於可觀察物件在出現錯誤後不再產生值，\n<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>回傳的訊號將永遠回傳從可觀察物件收到的最後一個成功值。這與\n<code>async</code>通道在出現錯誤時的行為相同。</p>\n<h2 id=\"toobservable\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#toobservable\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"61oezv0npx986pdnqgnvqp2zd\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> 實用程式會建立一個跟蹤訊號值的 <code>Observable</code>。訊號的值由一個 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 監控，它會在值發生變化時將值傳送給 Observable。</p>\n<code-example language=\"ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/signal\" class=\"code-anchor\">signal</a> } from '@angular/core';\nimport { <a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a> } from '@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>(...)\nexport class SearchResults {\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: <a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>&lt;string&gt; = inject(QueryService).query;\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>$ = <a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a>(this.query);\n\n  results$ = this.query$.pipe(\n    switchMap(<a href=\"api/animations/query\" class=\"code-anchor\">query</a> =&gt; this.http.get('/search?q=' + <a href=\"api/animations/query\" class=\"code-anchor\">query</a> ))\n  );\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6i36n00avuc437h9f9201l0l\">隨著 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> 訊號的變化，<code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>$</code> Observable 發出最新的查詢並觸發一個新的 HTTP 請求。</p>\n<h3 id=\"injection-context\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6i2331m8j8vxiqrm3m7o9qbot\">注入上下文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#injection-context\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9mo9c7gbjv7ea69rf3ifw9x5k\">預設情況下，\n<code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code>需要在\n<em>注入上下文</em>中執行，例如在元件或服務的建立期間。如果沒有可用的注入上下文，可以明確指定一個\n<code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code>。</p>\n<h3 id=\"timing-of-toobservable\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59h30952bhrswkbr5l9umz4pd\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> 的時序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#timing-of-toobservable\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1zowrbxhe7eulgap6pmou5vy0\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> 使用 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 來跟蹤 <code>ReplaySubject</code> 中的訊號值。在訂閱時，第一個值（如果可用）可以同步發出，所有後續值都將是非同步的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dh6sdyl50azr2868janl2cupu\">與 Observable 不同，訊號從來不會提供同步的變化通知。即使你的程式碼多次更新訊號值，依賴於訊號值的 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 也只會在訊號『穩定』後執行。</p>\n<code-example language=\"ts\">\nconst obs$ = <a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a>(mySignal);\nobs$.subscribe((value) =&gt; console.log(value));\n\nmySignal.set(1);\nmySignal.set(2);\nmySignal.set(3);\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4ux31glrysjnefpx04bzm0wi\">在這裡，只會記錄最後一個值（3）。</p>\n\n  \n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /guide/dependency-injection-context\n - /guide/releases#developer-preview\n - /guide/signals\n - api/animations/query\n - api/common/AsyncPipe\n - api/core/Component\n - api/core/Injector\n - api/core/Signal\n - api/core/effect\n - api/core/rxjs-interop\n - api/core/rxjs-interop/toObservable\n - api/core/rxjs-interop/toSignal\n - api/core/signal\n - guide/rxjs-interop#error-and-completion\n - guide/rxjs-interop#initial-values\n - guide/rxjs-interop#injection-context\n - guide/rxjs-interop#manualcleanup\n - guide/rxjs-interop#rxjs-interop\n - guide/rxjs-interop#the-initialvalue-option\n - guide/rxjs-interop#the-rejecterrors-option\n - guide/rxjs-interop#the-requiresync-option\n - guide/rxjs-interop#timing-of-toobservable\n - guide/rxjs-interop#toobservable\n - guide/rxjs-interop#tosignal\n - guide/rxjs-interop#undefined-initial-values\n-->"}