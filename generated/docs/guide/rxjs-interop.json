{"id":"guide/rxjs-interop","title":"RxJS 互操作","contents":"<div class=\"content\">\n  <h1 id=\"rxjs-interop\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4dgfms6hzrp30whv8dgni5yt8\">RxJS 互操作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#rxjs-interop\"><i class=\"material-icons\">link</i></a></h1>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d9e5ue8dj7lr1po172y86xt29\">RxJS 互操作性包已经提供了<a href=\"/guide/releases#developer-preview\">开发者预览版</a>。你已经可以尝试使用它，但在稳定之前可能会发生变化。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6r0o5yyyrt0ig9ls9isfr1j0r\">Angular 的 <code>@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a></code> 包，它提供了有用的实用程序来将 <a href=\"/guide/signals\">Angular 信号（Signal）</a> 与 RxJS 可观察对象（Observable）集成起来。</p>\n<h2 id=\"tosignal\"><code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#tosignal\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eq73o3wg8w43ttlc81lnibp4w\"><code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>函数创建一个信号，跟踪可观察对象的值。它类似于模板中的\n<code>async</code>管道，但更灵活，可在应用程序中的任何位置使用。</p>\n<code-example language=\"ts\">\nimport {<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>} from '@angular/core';\nimport {<a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a>} from '@angular/common';\nimport {interval} from 'rxjs';\nimport { <a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a> } from '@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  template: `{{ counter() }}`,\n})\nexport class Ticker {\n  counterObservable = interval(1000);\n\n  // Get a `<a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>` representing the `counterObservable`'s value.\n  counter = <a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a>(this.counterObservable, {initialValue: 0});\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3wxk7tlgxrj9un8togmh8zpi\">与\n<code>async</code>管道类似，\n<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>立即订阅可观察对象，这可能会触发副作用。由\n<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>创建的订阅会在组件销毁时自动取消订阅给定的可观察对象。</p>\n<h3 id=\"initial-values\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"34l32l1ha5h6vhdqna6eo4o04\">初始值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#initial-values\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wrkrkl8dex4cdoon8mpp2m0u\">Observable 可能不会在订阅时同步产生一个值，但信号总是需要一个当前值。有几种方法可以处理 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 信号的这个“初始”值。</p>\n<h4 id=\"the-initialvalue-option\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1z7zpbpl8vp1ruigacexkkmhg\"><code>initialValue</code> 选项<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-initialvalue-option\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91ul3mbyb702ticcsyl5wy6um\">如上例所示，<code>initialValue</code> 选项指定信号在 Observable 首次发射之前应返回的值。</p>\n<h4 id=\"undefined-initial-values\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jw943plkvsesunn6hot0e8o6\"><code>undefined</code> 初始值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#undefined-initial-values\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"754o7zctyridff4p1udhgyjrf\">如果省略\n<code>initialValue</code>，\n<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>返回的信号在可观察对象发出值之前返回\n<code>undefined</code>。这类似于\n<code>async</code>管道在没有值时返回\n<code>null</code>的行为。</p>\n<h4 id=\"the-requiresync-option\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"21fop5l9gi6f1d3t9u50g2o07\"><code>requireSync</code> 选项<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-requiresync-option\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68ysg07e4f9u8iz3tloti6mv3\">已知一些 Observable 是同步发出的，例如 <code>BehaviorSubject</code>。在这些情况下，你可以指定 <code>requireSync: true</code> 选项。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ut2801qfeofpw6dd4yl3r1p6\">当 <code>requiredSync</code> 为 <code>true</code> 时，<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 强制 Observable 在订阅时同步发出值。这保证了信号总是有一个值，并且不需要用 <code>undefined</code> 类型或初始值。</p>\n<h3 id=\"manualcleanup\"><code>manualCleanup</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#manualcleanup\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dz8c7dgd0s1sxjosg2phmapg1\">默认情况下，<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 在创建它的上下文被销毁时自动取消订阅 Observable。例如，如果在组件创建期间调用 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>，它会在组件销毁时清除其订阅。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7fsmcbpr4sq4jgfr0egb6zd7i\"><code>manualCleanup</code> 选项会禁用此自动清理。你可以将此设置用于会自然结束的 Observable。</p>\n<h3 id=\"error-and-completion\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6qa3mqgys3lg88ug8y0te1ksv\">出错与结束<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#error-and-completion\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7g589zbfv873vdj7fh36hxqew\">如果\n<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>中使用的可观察对象产生错误，则在读取信号时会抛出该错误。建议在可观察对象的上游处理错误，并将其转换为值（这可能表示需要在模板中显示错误页面）。可以使用RxJS中的\n<code>catchError</code>操作符来实现这一点。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"z3d8e4ayraavnheprq33z5x1\">如果 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 中使用的 Observable 结束了，则信号会继续返回结束前最近发出的值。</p>\n<h4 id=\"the-rejecterrors-option\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"160mo7v9fxgb5fszr0j9pe5qc\">拒绝错误选项<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-rejecterrors-option\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8uhm5x39r9sevknolqcxgzb5d\"><code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>对错误的默认行为是将\n<code>Observable</code>的错误通道传播到信号。另一种方法是完全拒绝错误，使用\n<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>的\n<code>rejectErrors</code>选项。使用此选项，错误会被抛回到RxJS中，在全局应用程序错误处理程序中作为未捕获的异常被捕获。由于可观察对象在出现错误后不再产生值，\n<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>返回的信号将永远返回从可观察对象收到的最后一个成功值。这与\n<code>async</code>管道在出现错误时的行为相同。</p>\n<h2 id=\"toobservable\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#toobservable\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"61oezv0npx986pdnqgnvqp2zd\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> 实用程序会创建一个跟踪信号值的 <code>Observable</code>。信号的值由一个 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 监控，它会在值发生变化时将值发送给 Observable。</p>\n<code-example language=\"ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/signal\" class=\"code-anchor\">signal</a> } from '@angular/core';\nimport { <a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a> } from '@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>(...)\nexport class SearchResults {\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: <a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>&lt;string&gt; = inject(QueryService).query;\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>$ = <a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a>(this.query);\n\n  results$ = this.query$.pipe(\n    switchMap(<a href=\"api/animations/query\" class=\"code-anchor\">query</a> =&gt; this.http.get('/search?q=' + <a href=\"api/animations/query\" class=\"code-anchor\">query</a> ))\n  );\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6i36n00avuc437h9f9201l0l\">随着 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> 信号的变化，<code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>$</code> Observable 发出最新的查询并触发一个新的 HTTP 请求。</p>\n<h3 id=\"injection-context\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6i2331m8j8vxiqrm3m7o9qbot\">注入上下文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#injection-context\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9mo9c7gbjv7ea69rf3ifw9x5k\">默认情况下，\n<code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code>需要在\n<em>注入上下文</em>中运行，例如在组件或服务的构建期间。如果没有可用的注入上下文，可以明确指定一个\n<code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code>。</p>\n<h3 id=\"timing-of-toobservable\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59h30952bhrswkbr5l9umz4pd\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> 的时序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#timing-of-toobservable\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1zowrbxhe7eulgap6pmou5vy0\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> 使用 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 来跟踪 <code>ReplaySubject</code> 中的信号值。在订阅时，第一个值（如果可用）可以同步发出，所有后续值都将是异步的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dh6sdyl50azr2868janl2cupu\">与 Observable 不同，信号从来不会提供同步的变化通知。即使你的代码多次更新信号值，依赖于信号值的 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 也只会在信号“稳定”后运行。</p>\n<code-example language=\"ts\">\nconst obs$ = <a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a>(mySignal);\nobs$.subscribe((value) =&gt; console.log(value));\n\nmySignal.set(1);\nmySignal.set(2);\nmySignal.set(3);\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4ux31glrysjnefpx04bzm0wi\">在这里，只会记录最后一个值（3）。</p>\n\n  \n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /guide/dependency-injection-context\n - /guide/releases#developer-preview\n - /guide/signals\n - api/animations/query\n - api/common/AsyncPipe\n - api/core/Component\n - api/core/Injector\n - api/core/Signal\n - api/core/effect\n - api/core/rxjs-interop\n - api/core/rxjs-interop/toObservable\n - api/core/rxjs-interop/toSignal\n - api/core/signal\n - guide/rxjs-interop#error-and-completion\n - guide/rxjs-interop#initial-values\n - guide/rxjs-interop#injection-context\n - guide/rxjs-interop#manualcleanup\n - guide/rxjs-interop#rxjs-interop\n - guide/rxjs-interop#the-initialvalue-option\n - guide/rxjs-interop#the-rejecterrors-option\n - guide/rxjs-interop#the-requiresync-option\n - guide/rxjs-interop#timing-of-toobservable\n - guide/rxjs-interop#toobservable\n - guide/rxjs-interop#tosignal\n - guide/rxjs-interop#undefined-initial-values\n-->"}