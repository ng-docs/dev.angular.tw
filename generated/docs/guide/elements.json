{"id":"guide/elements","title":"Angular 元素（Elements）概览","contents":"<div class=\"content\">\n  <h1 id=\"angular-elements-overview\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"70vwf79cqe87pphkxcutgjrtw\">Angular 元素（Elements）概览<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#angular-elements-overview\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8l3j1lokhtpgee37s02emi8gr\"><em>Angular 元素</em>就是打包成<em>自定义元素</em>的 Angular 组件。所谓自定义元素就是一套与具体框架无关的用于定义新 HTML 元素的 Web 标准。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d5oeh6bf2o8adlc4yerbj497y\">这里所说的范例应用，参阅<live-example></live-example>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"663dqoal4caletntr3vf5m2kf\"><a href=\"https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements\">自定义元素</a>这项特性目前受到了 Chrome、Edge（基于 Chromium 的版本）、Opera 和 Safari 的支持，在其它浏览器中也能通过腻子脚本（参阅<a href=\"guide/elements#browser-support\">浏览器支持</a>）加以支持。\n自定义元素扩展了 HTML，它允许你定义一个由 JavaScript 代码创建和控制的标签。\n浏览器会维护一个自定义元素的注册表 <code>CustomElementRegistry</code>，它把一个可实例化的 JavaScript 类映射到 HTML 标签上。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8522j5k3ngiurtm7777s3505\"><code>@angular/elements</code> 包导出了一个 \n<code><a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>()</code> API 函数，它提供了一个从 Angular 组件接口和变更检测功能到内置 DOM API 的桥梁。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aqyi9lw9d1wibqofycfo63qgp\">把组件转换成自定义元素可以让所有所需的 Angular 基础设施都在浏览器中可用。\n创建自定义元素的方式简单直观，它会自动把你组件定义的视图连同变更检测与数据绑定等 Angular 的功能映射为相应的内置 HTML 等价物。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6z5elhln4szp2tglhsu555lgp\">我们正在持续开发自定义元素功能，让它们可以用在由其它框架所构建的 Web 应用中。\nAngular 框架的一个小型的、自包含的版本将会作为服务注入进去，以提供组件的变更检测和数据绑定功能。\n要了解这个开发方向的更多内容，参阅<a href=\"https://www.youtube.com/watch?v=Z1gLFPLVJjY&amp;t=4s\">这个视频演讲</a>。</p>\n</div>\n<h2 id=\"using-custom-elements\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"21rx1tlx2girh9z5jm06b0eb1\">使用自定义元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#using-custom-elements\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4tee6petclum9uaz9t6nioyl\">自定义元素会自举 —— 它们在添加到 DOM 中时就会自行启动自己，并在从 DOM 中移除时自行销毁自己。一旦自定义元素添加到了任何页面的 DOM 中，它的外观和行为就和其它的 HTML 元素一样了，不需要对 Angular 的术语或使用约定有任何特殊的了解。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xf133tv7ogf2fd5j9azyrvxs\">在 Angular 应用程序中轻松实现动态内容</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9zrxrgh50dlfexddz1486a631\">将组件转换为自定义元素为您的 Angular 应用程序创建动态 HTML 内容提供了一条直接的路径。在 Angular 应用程序中直接添加到 DOM 的 HTML 内容通常不会经过 Angular 处理，除非您定义一个\n<em>动态组件</em>，添加自己的代码来连接 HTML 标记和应用程序数据，并参与变更检测。使用自定义元素，所有这些连接都会自动处理。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cos7ngxgx91app8yzvynncxxq\">内容丰富的应用程序</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a76hj8740oielrn5eccs691gu\">如果您有一个内容丰富的应用程序，例如呈现本文档的 Angular 应用程序，自定义元素让您可以为您的内容提供者提供复杂的 Angular 功能，而无需了解 Angular。例如，像这样的 Angular 指南直接通过 Angular 导航工具添加到 DOM，但可以包含执行复杂操作的特殊元素，如 \n<code>&lt;code-snippet&gt;</code>。您只需告诉您的内容提供者自定义元素的语法。他们不需要了解 Angular，也不需要了解您组件的数据结构或实现。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"how-it-works\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gzj52d14rjscz4pktlc7xfw0\">工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#how-it-works\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwkx73tcsilzx1x13i2f30l7s\">使用 <code><a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>()</code> 函数来把组件转换成一个可注册成浏览器中自定义元素的类。\n注册完这个配置好的类之后，就可以在内容中像内置 HTML 元素一样使用这个新元素了，比如直接把它加到 DOM 中：</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;my-popup message=\"Use Angular!\"&gt;&lt;/my-popup&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"27u90t0fvqrg488eri8zh3nz5\">当你的自定义元素放进页面中时，浏览器会创建一个已注册类的实例。其内容是由组件模板提供的，它使用 Angular 模板语法，并且使用组件和 DOM 数据进行渲染。组件的输入属性（Property）对应于该元素的输入属性（Attribute）。</p>\n<div class=\"lightbox\">\n<img alt=\"Custom element in browser\" class=\"left\" src=\"generated/images/guide/elements/customElement1.png\" width=\"600\" height=\"360\">\n</div>\n<h2 id=\"transforming-components-to-custom-elements\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4va7o1np5cx88w5ozgr69qosq\">把组件转换成自定义元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#transforming-components-to-custom-elements\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5to18a74jmwtctw74pe6nf9kr\">Angular 提供了 <code><a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>()</code> 函数，以支持把 Angular 组件及其依赖转换成自定义元素。该函数会收集该组件的 <code>Observable</code> 型属性，提供浏览器创建和销毁实例时所需的 Angular 功能，还会对变更进行检测并做出响应。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dtddoau7q5796m3otqvfg6p2f\">这个转换过程实现了 <code><a href=\"api/elements/NgElementConstructor\" class=\"code-anchor\">NgElementConstructor</a></code> 接口，并创建了一个构造器类，用于生成该组件的一个自举型实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aprgro2hqe9mk6m073l5xuoaj\">使用内置的 <a href=\"https://developer.mozilla.org/docs/Web/API/CustomElementRegistry/define\"><code>customElements.define()</code></a> 函数把这个配置好的构造器和相关的自定义元素标签注册到浏览器的 <a href=\"https://developer.mozilla.org/docs/Web/API/CustomElementRegistry\"><code>CustomElementRegistry</code></a> 中。\n当浏览器遇到这个已注册元素的标签时，就会使用该构造器来创建一个自定义元素的实例。</p>\n<div class=\"lightbox\">\n<img alt=\"Transform a component to a custom element\" class=\"left\" src=\"generated/images/guide/elements/createElement.png\" width=\"600\" height=\"400\">\n</div>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e85v001d4mlkc22f4dqn1xpi5\">不要将 <a href=\"api/core/Component\"><code>@Component</code></a> 的<a href=\"api/core/Directive#selector\">选择器</a>用作自定义元素的标记名称。由于 Angular 会为单个 DOM 元素创建两个组件实例，所以这可能导致意外行为：一个是常规的 Angular 组件，而另一个是自定义元素。</p>\n</div>\n<h3 id=\"mapping\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6a9xgezps7x9ff84vnbvslw\">映射<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#mapping\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gi57842xewk851g0vrg8ubnh\"><em>寄宿</em>着 Angular 组件的自定义元素在组件中定义的\"数据及逻辑\"和标准的 DOM API 之间建立了一座桥梁。组件的属性和逻辑会直接映射到 HTML 属性和浏览器的事件系统中。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dgczkjmfgkbho32k5j2y9cz8\">用于创建的 API 会解析该组件，以查找输入属性（Property），并在这个自定义元素上定义相应的属性（Attribute）。\n它把属性名转换成与自定义元素兼容的形式（自定义元素不区分大小写），生成的属性名会使用中线分隔的小写形式。\n比如，对于带有 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('myInputProp') inputProp</code> 的组件，其对应的自定义元素会带有一个 <code>my-input-prop</code> 属性。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8mw13h9efmt9dbvg1k2szyi3s\">组件输出作为 HTML \n<a href=\"https://developer.mozilla.org/docs/Web/API/CustomEvent\">自定义事件</a> 发送，自定义事件的名称与输出名称匹配。 例如，对于具有 \n<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() valueChanged = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>()</code> 的组件，相应的自定义元素将使用名称 \n<code>valueChanged</code> 发送事件，并且发出的数据存储在事件的 \n<code>detail</code> 属性上。 如果提供了别名，那么该值将被使用；例如，\n<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>('myClick') clicks = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;string&gt;();</code> 将导致使用名称 \n<code>myClick</code> 发送事件。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e5vug4ta3vcl9z4ofsmpxndpw\">要了解更多，参阅 Web Component 的文档：<a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events#Creating_custom_events\">Creating custom events</a>。</p>\n<p><a id=\"browser-support\"></a></p>\n<h2 id=\"browser-support-for-custom-elements\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4qzdfvhtj568jb5lc9wjz4eqr\">自定义元素的浏览器支持<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#browser-support-for-custom-elements\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6lgny3prd16mbngu61065d9j7\">最近开发的 Web 平台特性：<a href=\"https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements\">自定义元素</a>目前在一些浏览器中实现了原生支持，而其它浏览器或者尚未决定，或者已经制订了计划。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e5k6nj4n8sj4kanfrmjqhlggj\">浏览器</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xu1r4b21oiz9onx025lbz12z\">自定义元素支持</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"90uu4i5p0ervrs5kpuj3irbn8\">Chrome</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3ifnt3qpmpojkixqxzraunhp\">原生支持。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37dxicnef4n7vkuv2avv3b6y5\">Edge（基于 Chromium）</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3ifnt3qpmpojkixqxzraunhp\">原生支持。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"700qkytcb5orzru854md002sp\">Firefox</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3ifnt3qpmpojkixqxzraunhp\">原生支持。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a0wss74zhwx5k78j0f9w90ffe\">Opera</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3ifnt3qpmpojkixqxzraunhp\">原生支持。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4sctpqy9f3lnpcim24bmprihs\">Safari</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3ifnt3qpmpojkixqxzraunhp\">原生支持。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5kav18i9k6z7ols7u6mvkeuhn\">要往工作空间中添加 <code>@angular/elements</code> 包，请运行如下命令：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @angular/elements --save\n\n</code-example>\n<h2 id=\"example-a-popup-service\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dco0arv9fa8a5aza7j2wybkja\">范例：弹窗服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#example-a-popup-service\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74qom11zejv95uqzat3sm5jhy\">以前，如果你要在运行期间把一个组件添加到应用中，就得定义成<em>动态组件</em>，然后还要加载它、把它附加到 DOM 中的元素上，并且装配所有的依赖、变更检测和事件处理，详见<a href=\"guide/dynamic-component-loader\">动态组件加载器</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xuqm4o9a1mcaj1yuxmc888kg\">使用 Angular 自定义元素使整个过程更简单、更透明，自动提供所有基础设施和框架，你只需定义你想要的事件处理方式。</p>\n<div class=\"alert is-helpful\">\n  You do still have to exclude the component from compilation, if you are not going to use it in your application.\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8w71ljxnsbefcaje6ig7syib6\">这个弹窗服务的范例应用（见后面）定义了一个组件，你可以动态加载它也可以把它转换成自定义组件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8n2c7wfntpyw9gnmnqx5bqxht\">文件</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>popup.component.ts</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ewhg0sd0f0aekiu0wfh9qb9ik\">定义一个简单的弹出框元素，显示一个输入消息，带有一些动画和样式。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>popup.service.ts</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qo0thbkklwpigbjh719fnaqj\">创建一个可注入的服务，提供两种不同的方式来调用 \n<code>PopupComponent</code>；作为动态组件，或作为自定义元素。注意，对于动态加载方法，需要进行更多的设置。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>app.component.ts</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8w1b6ebdzlb9e8hnxpt8pjf70\">定义应用程序的根组件，该组件使用 \n<code>PopupService</code> 在运行时向 DOM 添加弹出框。当应用程序运行时，根组件的构造函数将 \n<code>PopupComponent</code> 转换为自定义元素。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"88m0lxppfzjmw4ydb2dju7dvo\">为了对比，这个范例中同时演示了这两种方式。一个按钮使用动态加载的方式添加弹窗，另一个按钮使用自定义元素的方式。可以看到，两者的结果是一样的，其差别只是准备过程不同。</p>\n<code-tabs>\n    <code-pane header=\"popup.component.ts\" path=\"elements/src/app/popup.component.ts\">\nimport {<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a>} from '@angular/core';\nimport {<a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>, state, <a href=\"api/animations/style\" class=\"code-anchor\">style</a>, <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>, <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>} from '@angular/animations';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'my-popup',\n  template: `\n    &lt;span&gt;Popup: {{ message }}&lt;/span&gt;\n    &lt;button type=\"button\" (click)=\"closed.next()\"&gt;&amp;#x2716;&lt;/button&gt;\n  `,\n  animations: [\n    <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>('state', [\n      state('opened', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({transform: 'translateY(0%)'})),\n      state('void, closed', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({transform: 'translateY(100%)', opacity: 0})),\n      <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>('* =&gt; *', <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>('100ms ease-in')),\n    ]),\n  ],\n  styles: [\n    `\n      :host {\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        background: #009cff;\n        height: 48px;\n        padding: 16px;\n        display: flex;\n        justify-content: space-between;\n        align-items: center;\n        border-top: 1px solid black;\n        font-size: 24px;\n      }\n\n      button {\n        border-radius: 50%;\n      }\n    `,\n  ],\n})\nexport class PopupComponent {\n  @<a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a>('@state')\n  state: 'opened' | 'closed' = 'closed';\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  get message(): string {\n    return this._message;\n  }\n  set message(message: string) {\n    this._message = message;\n    this.state = 'opened';\n  }\n  private _message = '';\n\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()\n  closed = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;void&gt;();\n}\n\n\n</code-pane>\n    <code-pane header=\"popup.service.ts\" path=\"elements/src/app/popup.service.ts\">\nimport {<a href=\"api/core/ApplicationRef\" class=\"code-anchor\">ApplicationRef</a>, <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>, <a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a>, <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>} from '@angular/core';\nimport {<a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a>, <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>} from '@angular/elements';\nimport {PopupComponent} from './popup.component';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class PopupService {\n  constructor(\n    private injector: <a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a>,\n    private applicationRef: <a href=\"api/core/ApplicationRef\" class=\"code-anchor\">ApplicationRef</a>,\n  ) {}\n\n  // Previous dynamic-loading method required you to set up infrastructure\n  // before adding the popup to the DOM.\n  showAsComponent(message: string) {\n    // Create element\n    const popup = document.createElement('popup-component');\n\n    // Create the component and wire it up with the element\n    const popupComponentRef = <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(PopupComponent, {\n      environmentInjector: this.injector,\n      hostElement: popup,\n    });\n\n    // Attach to the view so that the change detector knows to run\n    this.applicationRef.attachView(popupComponentRef.hostView);\n\n    // Listen to the close event\n    popupComponentRef.instance.closed.subscribe(() =&gt; {\n      document.body.removeChild(popup);\n      this.applicationRef.detachView(popupComponentRef.hostView);\n    });\n\n    // Set the message\n    popupComponentRef.instance.message = message;\n\n    // Add to the DOM\n    document.body.appendChild(popup);\n  }\n\n  // This uses the new custom-element method to add the popup to the DOM.\n  showAsElement(message: string) {\n    // Create element\n    const popupEl: <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;PopupComponent&gt; = document.createElement(\n      'popup-element',\n    ) as any;\n\n    // Listen to the close event\n    popupEl.addEventListener('closed', () =&gt; document.body.removeChild(popupEl));\n\n    // Set the message\n    popupEl.message = message;\n\n    // Add to the DOM\n    document.body.appendChild(popupEl);\n  }\n}\n\n\n</code-pane>\n    <code-pane header=\"app.component.ts\" path=\"elements/src/app/app.component.ts\">\nimport {<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>} from '@angular/core';\nimport {<a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>} from '@angular/elements';\nimport {PopupComponent} from './popup.component';\nimport {PopupService} from './popup.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-root',\n  template: `\n    &lt;input #input value=\"Message\" /&gt;\n    &lt;button type=\"button\" (click)=\"popup.showAsComponent(input.value)\"&gt;Show as component&lt;/button&gt;\n    &lt;button type=\"button\" (click)=\"popup.showAsElement(input.value)\"&gt;Show as element&lt;/button&gt;\n  `,\n  providers: [PopupService],\n  imports: [PopupComponent],\n})\nexport class AppComponent {\n  constructor(\n    injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>,\n    public popup: PopupService,\n  ) {\n    // Convert `PopupComponent` to a custom element.\n    const PopupElement = <a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>(PopupComponent, {injector});\n    // Register the custom element with the browser.\n    customElements.define('popup-element', PopupElement);\n  }\n}\n\n\n</code-pane>\n</code-tabs>\n<h2 id=\"typings-for-custom-elements\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a7evs83p2945tqfgqihtzvqop\">为自定义元素添加类型支持<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#typings-for-custom-elements\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a0m9u7hryyjmnqk09gzfpwsxo\">一般的 DOM API，比如 <code>document.createElement()</code> 或 <code>document.querySelector()</code>，会返回一个与指定的参数相匹配的元素类型。比如，调用 <code>document.createElement('a')</code> 会返回 <code>HTMLAnchorElement</code>，这样 TypeScript 就会知道它有一个 <code>href</code> 属性，而 <code>document.createElement('div')</code> 会返回 <code>HTMLDivElement</code>，这样 TypeScript 就会知道它没有 <code>href</code> 属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"l4z5xvdkd9jly6jr07o83py1\">当调用未知元素（比如自定义的元素名 <code>popup-element</code>）时，该方法会返回泛化类型，比如 <code>HTMLELement</code>，这时候 TypeScript 就无法推断出所返回元素的正确类型。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"21u5t91in4lftsk45vnyyc9ki\">用 Angular 创建的自定义元素会扩展 <code><a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a></code> 类型（而它扩展了 <code>HTMLElement</code>）。除此之外，这些自定义元素还拥有相应组件的每个输入属性。比如，<code>popup-element</code> 元素具有一个 <code>string</code> 型的 <code>message</code> 属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"83sdjhsyv19t3yg9la7ubdprd\">如果你想要为自定义元素获取正确的类型，有几个选项。 假设你根据以下组件创建了一个名为 \n<code>my-dialog</code> 的自定义元素：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>(…)\nclass MyDialog {\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() content: string;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ll6hq8jsbufw5eub81wtl5xe\">要获得精确类型，最直白的方式是把相关 DOM 方法的返回值转换成正确的类型。要做到这一点，可以使用 <code><a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a></code> 和 <code><a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a></code> 类型（都导出自 <code>@angular/elements</code>）：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst aDialog = document.createElement('my-dialog') as <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;{content: string}&gt;;\naDialog.content = 'Hello, world!';\naDialog.content = 123; // &lt;-- ERROR: TypeScript knows this should be a string.\naDialog.body = 'News'; // &lt;-- ERROR: TypeScript knows there is no `body` property on `aDialog`.\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5smjiuwg87d82g5doga81v992\">这是一种让你的自定义元素快速获得 TypeScript 特性（比如类型检查和自动完成支持）的好办法，不过如果你要在多个地方使用它，可能会有点啰嗦，因为不得不在每个地方对返回类型做转换。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eoq9iw164ki4e6ty7dooie4jk\">另一种方式可以对每个自定义元素的类型只声明一次。你可以扩展 <code>HTMLElementTagNameMap</code>，TypeScript 会在 DOM 方法（如 <code>document.createElement()</code>、<code>document.querySelector()</code> 等）中用它来根据标签名推断返回元素的类型。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\ndeclare global {\ninterface HTMLElementTagNameMap {\n'my-dialog': <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;{content: string}&gt;;\n'my-other-element': <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;{foo: 'bar'}&gt;;\n…\n}\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cz0ofhglq2ev850d5tlg2n16\">现在，TypeScript 就可以像内置元素一样推断出它的正确类型了：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\ndocument.createElement('div') //--&gt; HTMLDivElement (built-in element)\ndocument.querySelector('foo') //--&gt; Element (unknown element)\ndocument.createElement('my-dialog') //--&gt; <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;{content: string}&gt; (custom element)\ndocument.querySelector('my-other-element') //--&gt; <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;{foo: 'bar'}&gt; (custom element)\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Wed Aug 30 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/elements\n - api/elements/NgElementConstructor\n - api/elements/createCustomElement\n - guide/architecture-next-steps\n - guide/example-apps-list\n - guide/glossary\n - guide/libraries\n-->\n<!-- links from this doc:\n - api/animations/animate\n - api/animations/style\n - api/animations/transition\n - api/animations/trigger\n - api/core/ApplicationRef\n - api/core/Component\n - api/core/Directive#selector\n - api/core/EnvironmentInjector\n - api/core/EventEmitter\n - api/core/HostBinding\n - api/core/Injectable\n - api/core/Injector\n - api/core/Input\n - api/core/Output\n - api/core/createComponent\n - api/elements/NgElement\n - api/elements/NgElementConstructor\n - api/elements/WithProperties\n - api/elements/createCustomElement\n - guide/dynamic-component-loader\n - guide/elements#angular-elements-overview\n - guide/elements#browser-support\n - guide/elements#browser-support-for-custom-elements\n - guide/elements#example-a-popup-service\n - guide/elements#how-it-works\n - guide/elements#mapping\n - guide/elements#transforming-components-to-custom-elements\n - guide/elements#typings-for-custom-elements\n - guide/elements#using-custom-elements\n - https://developer.mozilla.org/docs/Web/API/CustomElementRegistry\n - https://developer.mozilla.org/docs/Web/API/CustomElementRegistry/define\n - https://developer.mozilla.org/docs/Web/API/CustomEvent\n - https://developer.mozilla.org/docs/Web/Guide/Events/Creating_and_triggering_events#Creating_custom_events\n - https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements\n - https://www.youtube.com/watch?v=Z1gLFPLVJjY&t=4s\n-->"}