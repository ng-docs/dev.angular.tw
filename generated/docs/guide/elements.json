{"id":"guide/elements","title":"Angular 元素（Elements）概覽","contents":"<div class=\"content\">\n  <h1 id=\"angular-elements-overview\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"70vwf79cqe87pphkxcutgjrtw\">Angular 元素（Elements）概覽<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#angular-elements-overview\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8l3j1lokhtpgee37s02emi8gr\"><em>Angular 元素</em>就是打包成<em>自定義元素</em>的 Angular 元件。所謂自定義元素就是一套與具體框架無關的用於定義新 HTML 元素的 Web 標準。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d5oeh6bf2o8adlc4yerbj497y\">這裡所說的範例應用，參閱<live-example></live-example>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"663dqoal4caletntr3vf5m2kf\"><a href=\"https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements\">自定義元素</a>這項屬性目前受到了 Chrome、Edge（基於 Chromium 的版本）、Opera 和 Safari 的支援，在其它瀏覽器中也能透過膩子指令碼（參閱<a href=\"guide/elements#browser-support\">瀏覽器支援</a>）加以支援。\n自定義元素擴充套件了 HTML，它允許你定義一個由 JavaScript 程式碼建立和控制的標籤。\n瀏覽器會維護一個自定義元素的登錄檔 <code>CustomElementRegistry</code>，它把一個可實例化的 JavaScript 類別對映到 HTML 標籤上。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8522j5k3ngiurtm7777s3505\"><code>@angular/elements</code> 套件匯出了一個 \n<code><a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>()</code> API 函式，它提供了一個從 Angular 元件介面和變更檢測功能到內建 DOM API 的橋樑。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aqyi9lw9d1wibqofycfo63qgp\">把元件轉換成自定義元素可以讓所有所需的 Angular 基礎設施都在瀏覽器中可用。\n建立自定義元素的方式簡單直觀，它會自動把你元件定義的檢視連同變更檢測與資料繫結等 Angular 的功能對映為相應的內建 HTML 等價物。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6z5elhln4szp2tglhsu555lgp\">我們正在持續開發自定義元素功能，讓它們可以用在由其它框架所建立的 Web 應用中。\nAngular 框架的一個小型的、自包含的版本將會作為服務注入進去，以提供元件的變更檢測和數據繫結功能。\n要了解這個開發方向的更多內容，參閱<a href=\"https://www.youtube.com/watch?v=Z1gLFPLVJjY&amp;t=4s\">這個影片演講</a>。</p>\n</div>\n<h2 id=\"using-custom-elements\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"21rx1tlx2girh9z5jm06b0eb1\">使用自定義元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#using-custom-elements\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4tee6petclum9uaz9t6nioyl\">自定義元素會自舉 —— 它們在新增到 DOM 中時就會自行啟動自己，並在從 DOM 中移除時自行銷燬自己。一旦自定義元素新增到了任何頁面的 DOM 中，它的外觀和行為就和其它的 HTML 元素一樣了，不需要對 Angular 的術語或使用約定有任何特殊的瞭解。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xf133tv7ogf2fd5j9azyrvxs\">在 Angular 應用程式中輕鬆實現動態內容</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9zrxrgh50dlfexddz1486a631\">將元件轉換為自定義元素為您的 Angular 應用程式建立動態 HTML 內容提供了一條直接的路徑。在 Angular 應用程式中直接新增到 DOM 的 HTML 內容通常不會經過 Angular 處理，除非您定義一個\n<em>動態元件</em>，新增自己的程式碼來連線 HTML 標記和應用程式資料，並參與變更檢測。使用自定義元素，所有這些連線都會自動處理。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cos7ngxgx91app8yzvynncxxq\">內容豐富的應用程式</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a76hj8740oielrn5eccs691gu\">如果您有一個內容豐富的應用程式，例如呈現本文件的 Angular 應用程式，自定義元素讓您可以為您的內容提供者提供複雜的 Angular 功能，而無需瞭解 Angular。例如，像這樣的 Angular 指南直接透過 Angular 導向工具新增到 DOM，但可以包含執行複雜操作的特殊元素，如 \n<code>&lt;code-snippet&gt;</code>。您只需告訴您的內容提供者自定義元素的語法。他們不需要瞭解 Angular，也不需要瞭解您元件的資料結構或實現。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"how-it-works\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gzj52d14rjscz4pktlc7xfw0\">工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#how-it-works\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwkx73tcsilzx1x13i2f30l7s\">使用 <code><a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>()</code> 函式來把元件轉換成一個可註冊成瀏覽器中自定義元素的類別。\n註冊完這個設定好的類別之後，就可以在內容中像內建 HTML 元素一樣使用這個新元素了，比如直接把它加到 DOM 中：</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;my-popup message=\"Use Angular!\"&gt;&lt;/my-popup&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"27u90t0fvqrg488eri8zh3nz5\">當你的自定義元素放進頁面中時，瀏覽器會建立一個已註冊類別的實例。其內容是由元件範本提供的，它使用 Angular 範本語法，並且使用元件和 DOM 資料進行渲染。元件的輸入屬性（Property）對應於該元素的輸入屬性（Attribute）。</p>\n<div class=\"lightbox\">\n<img alt=\"Custom element in browser\" class=\"left\" src=\"generated/images/guide/elements/customElement1.png\" width=\"600\" height=\"360\">\n</div>\n<h2 id=\"transforming-components-to-custom-elements\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4va7o1np5cx88w5ozgr69qosq\">把元件轉換成自定義元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#transforming-components-to-custom-elements\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5to18a74jmwtctw74pe6nf9kr\">Angular 提供了 <code><a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>()</code> 函式，以支援把 Angular 元件及其依賴轉換成自定義元素。該函式會收集該組件的 <code>Observable</code> 型屬性，提供瀏覽器建立和銷燬實例時所需的 Angular 功能，還會對變更進行檢測並做出回應。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dtddoau7q5796m3otqvfg6p2f\">這個轉換過程實現了 <code><a href=\"api/elements/NgElementConstructor\" class=\"code-anchor\">NgElementConstructor</a></code> 介面，並建立了一個構造器類別，用於生成該組件的一個自舉型實例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aprgro2hqe9mk6m073l5xuoaj\">使用內建的 <a href=\"https://developer.mozilla.org/docs/Web/API/CustomElementRegistry/define\"><code>customElements.define()</code></a> 函式把這個設定好的構造器和相關的自定義元素標籤註冊到瀏覽器的 <a href=\"https://developer.mozilla.org/docs/Web/API/CustomElementRegistry\"><code>CustomElementRegistry</code></a> 中。\n當瀏覽器遇到這個已註冊元素的標籤時，就會使用該構造器來建立一個自定義元素的實例。</p>\n<div class=\"lightbox\">\n<img alt=\"Transform a component to a custom element\" class=\"left\" src=\"generated/images/guide/elements/createElement.png\" width=\"600\" height=\"400\">\n</div>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e85v001d4mlkc22f4dqn1xpi5\">不要將 <a href=\"api/core/Component\"><code>@Component</code></a> 的<a href=\"api/core/Directive#selector\">選擇器</a>用作自定義元素的標記名稱。由於 Angular 會為單個 DOM 元素建立兩個元件實例，所以這可能導致意外行為：一個是常規的 Angular 元件，而另一個是自定義元素。</p>\n</div>\n<h3 id=\"mapping\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6a9xgezps7x9ff84vnbvslw\">對映<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#mapping\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gi57842xewk851g0vrg8ubnh\"><em>寄宿</em>著 Angular 元件的自定義元素在元件中定義的\"資料及邏輯\"和標準的 DOM API 之間建立了一座橋樑。元件的屬性和邏輯會直接對映到 HTML 屬性和瀏覽器的事件系統中。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dgczkjmfgkbho32k5j2y9cz8\">用於建立的 API 會解析該組件，以查詢輸入屬性（Property），並在這個自定義元素上定義相應的屬性（Attribute）。\n它把屬性名轉換成與自定義元素相容的形式（自定義元素不區分大小寫），生成的屬性名會使用中線分隔的小寫形式。\n比如，對於帶有 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('myInputProp') inputProp</code> 的元件，其對應的自定義元素會帶有一個 <code>my-input-prop</code> 屬性。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8mw13h9efmt9dbvg1k2szyi3s\">元件輸出作為 HTML \n<a href=\"https://developer.mozilla.org/docs/Web/API/CustomEvent\">自定義事件</a> 傳送，自定義事件的名稱與輸出名稱對應。 例如，對於具有 \n<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() valueChanged = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>()</code> 的元件，相應的自定義元素將使用名稱 \n<code>valueChanged</code> 傳送事件，並且發出的資料儲存在事件的 \n<code>detail</code> 屬性上。 如果提供了別名，那麼該值將被使用；例如，\n<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>('myClick') clicks = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;string&gt;();</code> 將導致使用名稱 \n<code>myClick</code> 傳送事件。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e5vug4ta3vcl9z4ofsmpxndpw\">要了解更多，參閱 Web Component 的文件：<a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events#Creating_custom_events\">Creating custom events</a>。</p>\n<p><a id=\"browser-support\"></a></p>\n<h2 id=\"browser-support-for-custom-elements\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4qzdfvhtj568jb5lc9wjz4eqr\">自定義元素的瀏覽器支援<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#browser-support-for-custom-elements\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6lgny3prd16mbngu61065d9j7\">最近開發的 Web 平台屬性：<a href=\"https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements\">自定義元素</a>目前在一些瀏覽器中實現了原生支援，而其它瀏覽器或者尚未決定，或者已經制訂了計劃。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e5k6nj4n8sj4kanfrmjqhlggj\">瀏覽器</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xu1r4b21oiz9onx025lbz12z\">自定義元素支援</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"90uu4i5p0ervrs5kpuj3irbn8\">Chrome</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3ifnt3qpmpojkixqxzraunhp\">原生支援。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37dxicnef4n7vkuv2avv3b6y5\">Edge（基於 Chromium）</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3ifnt3qpmpojkixqxzraunhp\">原生支援。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"700qkytcb5orzru854md002sp\">Firefox</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3ifnt3qpmpojkixqxzraunhp\">原生支援。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a0wss74zhwx5k78j0f9w90ffe\">Opera</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3ifnt3qpmpojkixqxzraunhp\">原生支援。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4sctpqy9f3lnpcim24bmprihs\">Safari</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3ifnt3qpmpojkixqxzraunhp\">原生支援。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5kav18i9k6z7ols7u6mvkeuhn\">要往工作空間中新增 <code>@angular/elements</code> 套件，請執行如下指令：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @angular/elements --save\n\n</code-example>\n<h2 id=\"example-a-popup-service\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dco0arv9fa8a5aza7j2wybkja\">範例：彈窗服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#example-a-popup-service\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74qom11zejv95uqzat3sm5jhy\">以前，如果你要在執行期間把一個元件新增到應用中，就得定義成<em>動態元件</em>，然後還要載入它、把它附加到 DOM 中的元素上，並且裝配所有的依賴、變更檢測和事件處理，詳見<a href=\"guide/dynamic-component-loader\">動態元件載入器</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xuqm4o9a1mcaj1yuxmc888kg\">使用 Angular 自定義元素使整個過程更簡單、更透明，自動提供所有基礎設施和框架，你只需定義你想要的事件處理方式。</p>\n<div class=\"alert is-helpful\">\n  You do still have to exclude the component from compilation, if you are not going to use it in your application.\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8w71ljxnsbefcaje6ig7syib6\">這個彈窗服務的範例應用（見後面）定義了一個元件，你可以動態載入它也可以把它轉換成自定義元件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8n2c7wfntpyw9gnmnqx5bqxht\">檔案</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>popup.component.ts</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ewhg0sd0f0aekiu0wfh9qb9ik\">定義一個簡單的彈出框元素，顯示一個輸入訊息，帶有一些動畫和樣式。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>popup.service.ts</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qo0thbkklwpigbjh719fnaqj\">建立一個可注入的服務，提供兩種不同的方式來呼叫 \n<code>PopupComponent</code>；作為動態元件，或作為自定義元素。注意，對於動態載入方法，需要進行更多的設定。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>app.component.ts</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8w1b6ebdzlb9e8hnxpt8pjf70\">定義應用程式的根元件，該組件使用 \n<code>PopupService</code> 在執行時向 DOM 新增彈出框。當應用程式執行時，根元件的建構式函式將 \n<code>PopupComponent</code> 轉換為自定義元素。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"88m0lxppfzjmw4ydb2dju7dvo\">為了對比，這個範例中同時示範了這兩種方式。一個按鈕使用動態載入的方式新增彈窗，另一個按鈕使用自定義元素的方式。可以看到，兩者的結果是一樣的，其差別只是準備過程不同。</p>\n<code-tabs>\n    <code-pane header=\"popup.component.ts\" path=\"elements/src/app/popup.component.ts\">\nimport {<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a>} from '@angular/core';\nimport {<a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>, state, <a href=\"api/animations/style\" class=\"code-anchor\">style</a>, <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>, <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>} from '@angular/animations';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'my-popup',\n  template: `\n    &lt;span&gt;Popup: {{ message }}&lt;/span&gt;\n    &lt;button type=\"button\" (click)=\"closed.next()\"&gt;&amp;#x2716;&lt;/button&gt;\n  `,\n  animations: [\n    <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>('state', [\n      state('opened', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({transform: 'translateY(0%)'})),\n      state('void, closed', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({transform: 'translateY(100%)', opacity: 0})),\n      <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>('* =&gt; *', <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>('100ms ease-in')),\n    ]),\n  ],\n  styles: [\n    `\n      :host {\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        background: #009cff;\n        height: 48px;\n        padding: 16px;\n        display: flex;\n        justify-content: space-between;\n        align-items: center;\n        border-top: 1px solid black;\n        font-size: 24px;\n      }\n\n      button {\n        border-radius: 50%;\n      }\n    `,\n  ],\n})\nexport class PopupComponent {\n  @<a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a>('@state')\n  state: 'opened' | 'closed' = 'closed';\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  get message(): string {\n    return this._message;\n  }\n  set message(message: string) {\n    this._message = message;\n    this.state = 'opened';\n  }\n  private _message = '';\n\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()\n  closed = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;void&gt;();\n}\n\n\n</code-pane>\n    <code-pane header=\"popup.service.ts\" path=\"elements/src/app/popup.service.ts\">\nimport {<a href=\"api/core/ApplicationRef\" class=\"code-anchor\">ApplicationRef</a>, <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>, <a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a>, <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>} from '@angular/core';\nimport {<a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a>, <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>} from '@angular/elements';\nimport {PopupComponent} from './popup.component';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class PopupService {\n  constructor(\n    private injector: <a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a>,\n    private applicationRef: <a href=\"api/core/ApplicationRef\" class=\"code-anchor\">ApplicationRef</a>,\n  ) {}\n\n  // Previous dynamic-loading method required you to set up infrastructure\n  // before adding the popup to the DOM.\n  showAsComponent(message: string) {\n    // Create element\n    const popup = document.createElement('popup-component');\n\n    // Create the component and wire it up with the element\n    const popupComponentRef = <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(PopupComponent, {\n      environmentInjector: this.injector,\n      hostElement: popup,\n    });\n\n    // Attach to the view so that the change detector knows to run\n    this.applicationRef.attachView(popupComponentRef.hostView);\n\n    // Listen to the close event\n    popupComponentRef.instance.closed.subscribe(() =&gt; {\n      document.body.removeChild(popup);\n      this.applicationRef.detachView(popupComponentRef.hostView);\n    });\n\n    // Set the message\n    popupComponentRef.instance.message = message;\n\n    // Add to the DOM\n    document.body.appendChild(popup);\n  }\n\n  // This uses the new custom-element method to add the popup to the DOM.\n  showAsElement(message: string) {\n    // Create element\n    const popupEl: <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;PopupComponent&gt; = document.createElement(\n      'popup-element',\n    ) as any;\n\n    // Listen to the close event\n    popupEl.addEventListener('closed', () =&gt; document.body.removeChild(popupEl));\n\n    // Set the message\n    popupEl.message = message;\n\n    // Add to the DOM\n    document.body.appendChild(popupEl);\n  }\n}\n\n\n</code-pane>\n    <code-pane header=\"app.component.ts\" path=\"elements/src/app/app.component.ts\">\nimport {<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>} from '@angular/core';\nimport {<a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>} from '@angular/elements';\nimport {PopupComponent} from './popup.component';\nimport {PopupService} from './popup.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-root',\n  template: `\n    &lt;input #input value=\"Message\" /&gt;\n    &lt;button type=\"button\" (click)=\"popup.showAsComponent(input.value)\"&gt;Show as component&lt;/button&gt;\n    &lt;button type=\"button\" (click)=\"popup.showAsElement(input.value)\"&gt;Show as element&lt;/button&gt;\n  `,\n  providers: [PopupService],\n  imports: [PopupComponent],\n})\nexport class AppComponent {\n  constructor(\n    injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>,\n    public popup: PopupService,\n  ) {\n    // Convert `PopupComponent` to a custom element.\n    const PopupElement = <a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>(PopupComponent, {injector});\n    // Register the custom element with the browser.\n    customElements.define('popup-element', PopupElement);\n  }\n}\n\n\n</code-pane>\n</code-tabs>\n<h2 id=\"typings-for-custom-elements\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a7evs83p2945tqfgqihtzvqop\">為自定義元素新增型別支援<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#typings-for-custom-elements\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a0m9u7hryyjmnqk09gzfpwsxo\">一般的 DOM API，比如 <code>document.createElement()</code> 或 <code>document.querySelector()</code>，會回傳一個與指定的引數相對應的元素型別。比如，呼叫 <code>document.createElement('a')</code> 會回傳 <code>HTMLAnchorElement</code>，這樣 TypeScript 就會知道它有一個 <code>href</code> 屬性，而 <code>document.createElement('div')</code> 會回傳 <code>HTMLDivElement</code>，這樣 TypeScript 就會知道它沒有 <code>href</code> 屬性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"l4z5xvdkd9jly6jr07o83py1\">當呼叫未知元素（比如自定義的元素名 <code>popup-element</code>）時，該方法會回傳泛化型別，比如 <code>HTMLELement</code>，這時候 TypeScript 就無法推斷出所回傳元素的正確型別。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"21u5t91in4lftsk45vnyyc9ki\">用 Angular 建立的自定義元素會擴充套件 <code><a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a></code> 型別（而它擴充套件了 <code>HTMLElement</code>）。除此之外，這些自定義元素還擁有相應元件的每個輸入屬性。比如，<code>popup-element</code> 元素具有一個 <code>string</code> 型的 <code>message</code> 屬性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"83sdjhsyv19t3yg9la7ubdprd\">如果你想要為自定義元素獲取正確的型別，有幾個選項。 假設你根據以下元件建立了一個名為 \n<code>my-dialog</code> 的自定義元素：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>(…)\nclass MyDialog {\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() content: string;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ll6hq8jsbufw5eub81wtl5xe\">要獲得精確型別，最直白的方式是把相關 DOM 方法的回傳值轉換成正確的型別。要做到這一點，可以使用 <code><a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a></code> 和 <code><a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a></code> 型別（都匯出自 <code>@angular/elements</code>）：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst aDialog = document.createElement('my-dialog') as <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;{content: string}&gt;;\naDialog.content = 'Hello, world!';\naDialog.content = 123; // &lt;-- ERROR: TypeScript knows this should be a string.\naDialog.body = 'News'; // &lt;-- ERROR: TypeScript knows there is no `body` property on `aDialog`.\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5smjiuwg87d82g5doga81v992\">這是一種讓你的自定義元素快速獲得 TypeScript 屬性（比如型別檢查和自動完成支援）的好辦法，不過如果你要在多個地方使用它，可能會有點囉嗦，因為不得不在每個地方對回傳型別做轉換。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eoq9iw164ki4e6ty7dooie4jk\">另一種方式可以對每個自定義元素的型別只宣告一次。你可以擴充套件 <code>HTMLElementTagNameMap</code>，TypeScript 會在 DOM 方法（如 <code>document.createElement()</code>、<code>document.querySelector()</code> 等）中用它來根據標籤名推斷回傳元素的型別。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\ndeclare global {\ninterface HTMLElementTagNameMap {\n'my-dialog': <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;{content: string}&gt;;\n'my-other-element': <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;{foo: 'bar'}&gt;;\n…\n}\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cz0ofhglq2ev850d5tlg2n16\">現在，TypeScript 就可以像內建元素一樣推斷出它的正確型別了：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\ndocument.createElement('div') //--&gt; HTMLDivElement (built-in element)\ndocument.querySelector('foo') //--&gt; Element (unknown element)\ndocument.createElement('my-dialog') //--&gt; <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;{content: string}&gt; (custom element)\ndocument.querySelector('my-other-element') //--&gt; <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;{foo: 'bar'}&gt; (custom element)\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Wed Aug 30 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/elements\n - api/elements/NgElementConstructor\n - api/elements/createCustomElement\n - guide/architecture-next-steps\n - guide/example-apps-list\n - guide/glossary\n - guide/libraries\n-->\n<!-- links from this doc:\n - api/animations/animate\n - api/animations/style\n - api/animations/transition\n - api/animations/trigger\n - api/core/ApplicationRef\n - api/core/Component\n - api/core/Directive#selector\n - api/core/EnvironmentInjector\n - api/core/EventEmitter\n - api/core/HostBinding\n - api/core/Injectable\n - api/core/Injector\n - api/core/Input\n - api/core/Output\n - api/core/createComponent\n - api/elements/NgElement\n - api/elements/NgElementConstructor\n - api/elements/WithProperties\n - api/elements/createCustomElement\n - guide/dynamic-component-loader\n - guide/elements#angular-elements-overview\n - guide/elements#browser-support\n - guide/elements#browser-support-for-custom-elements\n - guide/elements#example-a-popup-service\n - guide/elements#how-it-works\n - guide/elements#mapping\n - guide/elements#transforming-components-to-custom-elements\n - guide/elements#typings-for-custom-elements\n - guide/elements#using-custom-elements\n - https://developer.mozilla.org/docs/Web/API/CustomElementRegistry\n - https://developer.mozilla.org/docs/Web/API/CustomElementRegistry/define\n - https://developer.mozilla.org/docs/Web/API/CustomEvent\n - https://developer.mozilla.org/docs/Web/Guide/Events/Creating_and_triggering_events#Creating_custom_events\n - https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements\n - https://www.youtube.com/watch?v=Z1gLFPLVJjY&t=4s\n-->"}