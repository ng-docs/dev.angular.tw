{"id":"guide/http-optimize-server-interaction","title":"HTTP - 透過防抖最佳化伺服器互動","contents":"<div class=\"content\">\n  <h1 id=\"http---optimize-server-interaction-with-debouncing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"39hxm8dyyv78gx7svna1po8er\">HTTP - 透過防抖最佳化伺服器互動<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-optimize-server-interaction#http---optimize-server-interaction-with-debouncing\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"82l7wfppkop723hbpl4xbbkio\">如果你需要發一個 HTTP 請求來回應使用者的輸入，那麼每次按鍵就傳送一個請求的效率顯然不高。最好等使用者停止輸入後再發送請求。這種技術叫做防抖。</p>\n<h2 id=\"implement-debouncing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cflvy04edp40pg8bzgyp3jdje\">實現防抖<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-optimize-server-interaction#implement-debouncing\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5w7kafxf4pglc1vloitvwn8fu\">考慮下面這個樣板，它讓使用者輸入一個搜尋詞來按名字查詢套件。當用戶在搜尋框中輸入名字時，<code>PackageSearchComponent</code> 就會把這個根據名字搜尋套件的請求發給套件搜尋 API。</p>\n<code-example header=\"app/package-search/package-search.component.html (search)\" path=\"http/src/app/package-search/package-search.component.html\" region=\"search\">\n&lt;input type=\"text\" (keyup)=\"search(getValue($event))\" id=\"name\" placeholder=\"Search\"/&gt;\n\n&lt;ul&gt;\n  &lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let package of packages$ | <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a>\"&gt;\n    &lt;strong&gt;{{package.name}} v.{{package.version}}&lt;/strong&gt; -\n    &lt;em&gt;{{package.description}}&lt;/em&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b8kz8eaad1rrud03u9ji6wrys\">在這裡，<code>keyup</code> 事件繫結會將每個按鍵都發送到元件的 <code>search()</code> 方法。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4spjxmfmjnja8io0lkclbwput\">在樣板中，<code>$event.target</code> 的型別只是 <code>EventTarget</code>。在 <code>getValue()</code> 方法中，要將目標轉換為 <code>HTMLInputElement</code>，以便透過型別安全的方式訪問其 <code>value</code> 屬性。</p>\n<code-example path=\"http/src/app/package-search/package-search.component.ts\" region=\"getValue\">\ngetValue(event: <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>): string {\n  return (event.target as HTMLInputElement).value;\n}\n\n</code-example>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2a14o77t0ylh0yl7t7xuedujy\">下面的程式碼片段使用 RxJS 的運算子為這個輸入實現了防抖。</p>\n<code-example header=\"app/package-search/package-search.component.ts (excerpt)\" path=\"http/src/app/package-search/package-search.component.ts\" region=\"debounce\">\nwithRefresh = false;\npackages$!: Observable&lt;NpmPackageInfo[]&gt;;\nprivate searchText$ = new Subject&lt;string&gt;();\n\nsearch(packageName: string) {\n  this.searchText$.next(packageName);\n}\n\nngOnInit() {\n  this.packages$ = this.searchText$.pipe(\n    debounceTime(500),\n    distinctUntilChanged(),\n    switchMap(packageName =&gt;\n      this.searchService.search(packageName, this.withRefresh))\n  );\n}\n\nconstructor(private searchService: PackageSearchService) { }\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cjahd0q525ufc6hzyxvnyv4vs\"><code>searchText$</code> 是來自使用者的搜尋框值的序列。它被定義為 RxJS <code>Subject</code> 型別，這意味著它是一個多播 <code>Observable</code>，它還可以透過呼叫 <code>next(value)</code> 來自行發出值，就像在 <code>search()</code> 方法中一樣。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3zgh96gi47hauu3mmribmrpsg\">除了把每個 <code>searchText</code> 的值都直接轉發給 <code>PackageSearchService</code> 之外，<code>ngOnInit()</code> 中的程式碼還透過下列三個運算子對這些搜尋值進行<em>通道</em>處理，以便只有當它是一個新值並且使用者已經停止輸入時，要搜尋的值才會抵達該服務。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qndn7pqn4jsl97rgz1tdgcux\">RxJS運算子</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"caxrzqjg755bpeedkm53di390\"><code>debounceTime(500)</code>⁠</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1k11zhd8iaj5jn3fj3rsts1ld\">等待使用者停止輸入，這裡是1/2秒。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>distinctUntilChanged()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7m4tkjnzj0lsuwqs0cuwr8o7i\">等待搜尋文字更改。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7oag1ytas82y1wbk4sx5t7cnk\"><code>switchMap()</code>⁠</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eejpot0eivk93ph9j1uv26fz1\">向服務傳送搜尋請求。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b841214w33b3klpbdvc2drpny\">這些程式碼把 <code>packages$</code> 設定成了使用搜尋結果組合出的 <code>Observable</code> 物件。樣板中使用 <a href=\"api/common/AsyncPipe\">AsyncPipe</a> 訂閱了 <code>packages$</code>，一旦搜尋結果的值發回來了，就顯示這些搜尋結果。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6lmc54ql4jci9i4ur50wns5yx\">有關 <code>withRefresh</code> 選項的更多訊息，請參見<a href=\"guide/http-interceptor-use-cases#cache-refresh\">使用攔截器請求多個值</a>。</p>\n</div>\n<h2 id=\"using-the-switchmap-operator\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ecmabjhigcnejdtdjnhete8yu\">使用 <code>switchMap()</code> 運算子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-optimize-server-interaction#using-the-switchmap-operator\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2rmtpn5spb7bogao6xxahif57\"><code>switchMap()</code> 運算子接受一個回傳 <code>Observable</code> 的函式型引數。在這個例子中，<code>PackageSearchService.search</code> 像其它資料服務方法那樣回傳一個 <code>Observable</code>。如果先前的搜尋請求仍在<em>進行中</em>（如網路連線不良），它將取消該請求併發送新的請求。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91xim9rtmksuajxvn8mzaqpze\"><strong>注意</strong>：<br>\n即使伺服器是以任意順序回傳的回應，<code>switchMap()</code> 也會按照它們最初的請求順序回傳它們。</p>\n</div>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9eeir3anl97ra5ekzzwe4edh2\">如果你認為自己會複用這個防抖邏輯，請考慮將它移動到一個實用工具函式或者 <code>PackageSearchService</code> 本身中。</p>\n</div>\n\n  <div class=\"reviewed\">最後複查時間：Mon Feb 27 2023</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/common/AsyncPipe\n - api/common/NgFor\n - api/platform-browser/animations/async\n - api/router/Event\n - guide/http-interceptor-use-cases#cache-refresh\n - guide/http-optimize-server-interaction#http---optimize-server-interaction-with-debouncing\n - guide/http-optimize-server-interaction#implement-debouncing\n - guide/http-optimize-server-interaction#using-the-switchmap-operator\n-->"}