{"id":"guide/service-worker-devops","title":"生产环境下的 Service Worker","contents":"<div class=\"content\">\n  <h1 id=\"service-worker-in-production\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bsw3a3w4jwe2a12gg6enp7uxj\">生产环境下的 Service Worker<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#service-worker-in-production\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2nut8sqkdh8ijfnscfqwssc4n\">本页讲的是如何使用 Angular Service Worker 发布和支持生产环境下的应用。它解释了 Angular Service Worker 如何满足大规模生产环境的需求、Service Worker 在多种条件下有哪些行为以及有哪些可用的资源和故障保护机制。</p>\n<h2 id=\"prerequisites\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e44b21uig1fakj5vcfuvz1bdu\">前提条件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#prerequisites\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xq8keqzpcinu80uje7xu3rbf\">对下列知识有基本的了解：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3chpa91gkd8kngrnffrmr754r\"><a href=\"guide/service-worker-communications\">与 Service Worker 通讯</a>.</li>\n</ul>\n<h2 id=\"service-worker-and-caching-of-application-resources\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"60bp6ioemxve2wjs5d5a13us9\">Service Worker 与应用资源的缓存<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#service-worker-and-caching-of-application-resources\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cxf5dcd2pgbixx6wzngoe5tn1\">你可以把 Angular Service Worker 想象成一个转发式缓存或装在最终用户浏览器中的 CDN（内容分发网络）边缘。Service Worker 的工作是从本地缓存中响应 Angular 应用对资源或数据的请求，而不用等待网络。和所有缓存一样，它有一些规则来决定内容该如何过期或更新。</p>\n<p><a id=\"versions\"></a></p>\n<h3 id=\"application-versions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5bwh5dyy4nlq80szbp7ebk8w6\">应用的版本<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#application-versions\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"952rushaq124nbrmoqim1alox\">在 Angular Service Worker 的语境下，“版本”是指用来表示 Angular 应用的某一次构建成果的一组资源。当应用的一个新的构建发布时，Service Worker 就把它看做此应用的一个新版本。就算只修改了一个文件，也同样如此。在任何一个给定的时间，Service Worker 可能会在它的缓存中拥有此应用的多个版本，这几个版本也都能用于提供服务。要了解更多，参阅 <a href=\"guide/service-worker-devops#tabs\">App 选项卡</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eji39uaj2ce87zeib1eesww5s\">要保持应用的整体性，Angular Service Worker 会用所有的文件共同组成一个版本。组成版本的这些文件通常包括 HTML、JS 和 CSS 文件。把这些文件分成一组是至关重要的，因为它们会互相引用，并且依赖于一些特定内容。比如，<code>index.html</code> 文件可能有个引用 <code>bundle.js</code> 的 <code>&lt;script&gt;</code> 标签，它可能会试图从这个脚本中调用一个 <code>startApp()</code> 函数。任何时候，只要这个版本的 <code>index.html</code> 被提供了，与它对应的 <code>bundle.js</code> 也必须同时提供。这种情况下，使用调用了 <code>startApp()</code> 的老的 <code>index.html</code> 并同时使用定义了 <code>runApp()</code> 的新 bundle 就是无效的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekhitpa1fzjbzdytid7gb98om\">懒加载时，文件完整性尤为重要。 一个 JS 捆绑包可能引用许多懒加载块，而懒加载块的文件名对应应用程序的特定构建是唯一的。 如果正在运行版本为 \n<code>X</code> 的应用程序尝试加载一个懒加载块，但服务器已更新到版本 \n<code>X + 1</code>，懒加载操作将失败。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1x5qfpzcbbo2wkbjj87kit9jc\">本应用的版本标识符由其所有资源的内容决定，如果它们中的任何一个发生了变化，则版本标识符也随之改变。实际上，版本是由 <code>ngsw.json</code> 文件的内容决定的，包含了所有已知内容的哈希值。如果任何一个被缓存的文件发生了变化，则该文件的哈希也将在 <code>ngsw.json</code> 中随之变化，从而导致 Angular Service Worker 将这个活动文件的集合视为一个新版本。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8z22e4ahjymdkl9jpmp38mc0k\">此构建过程会使用来自 <code>ngsw-config.json</code> 的信息创建清单文件（<code>ngsw.json</code>）。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bls3y9r1imwjqjug9hoh2frf4\">借助 Angular Service Worker 的这种版本控制行为，应用服务器就可以确保这个 Angular 应用中的这组文件始终保持一致。</p>\n<h4 id=\"update-checks\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amysa1zxmz0ft7ifyf5l96ut3\">更新检测<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#update-checks\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29lpwacx0axhk1sdw93aznodk\">每当用户打开或刷新应用程序时，Angular Service Worker 都会通过查看清单（manifest）文件 “ngsw.json” 的更新来检查该应用程序的更新。如果它找到了更新，就会自动下载并缓存这个版本，并在下次加载应用程序时提供。</p>\n<h3 id=\"resource-integrity\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37obfigzne4rvau7emo7yv3um\">资源整体性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#resource-integrity\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54g5h7y5d6khm86qi1cujiyps\">长周期缓存的潜在副作用之一就是可能无意中缓存了无效的资源。在普通的 HTTP 缓存中，硬刷新或缓存过期限制了缓存这种无效文件导致的负面影响。而 Service Worker 会忽略这样的约束，事实上会对整个应用程序进行长期缓存。因此，让 Service Worker 获得正确的内容就显得至关重要，所以它会保持这些资源的哈希值，以维护其完整性。</p>\n<h4 id=\"hashed-content\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"62mx63wzetwa3e760dpyby3ng\">哈希内容<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#hashed-content\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3rq1q0pr75oavs6yi2grm1lj6\">为了确保资源的整体性，Angular Service Worker 会验证所有带哈希的资源的哈希值。通常，对于 <a href=\"cli\">Angular CLI</a> 应用程序，用户的 <code>src/ngsw-config.json</code> 配置文件中会涵盖 <code>dist</code> 目录下的所有内容。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2pfui98zyd8pvmpseuodfuhdi\">如果某个特定的文件未能通过验证，Angular Service Worker 就会尝试用 “cache-busting” URL 为参数重新获取内容，以消除浏览器或中间缓存的影响。如果该内容也未能通过验证，则 Service Worker 会认为该应用的整个版本都无效，并停止用它提供服务。如有必要，Service Worker 会进入安全模式，这些请求将退化为直接访问网络。如果服务无效、损坏或内容过期的风险很高，则会选择不使用缓存。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ngjch7l61brixh4x67t8vr9q\">导致哈希值不匹配的原因有很多：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f1el3650tjyallh2pv4iylg8u\">在源服务器和最终用户之间缓存图层可能会提供陈旧的内容。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"788ey3fnj9f5youijeqcffk2u\">非原子化的部署可能会导致 Angular Service Worker 看到部分更新后的内容。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1h5zczwtx6f1pwbmy3g6878j0\">构建过程中的错误可能会导致更新了资源，却没有更新 <code>ngsw.json</code>。反之，也可能发生没有更新资源，却更新了 <code>ngsw.json</code> 的情况。</li>\n</ul>\n<h4 id=\"unhashed-content\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1culj5eol0vjvud0cudv1zdh9\">不带哈希的内容<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#unhashed-content\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eivxj3ykt5hdpwhf3n2x1n56l\"><code>ngsw.json</code> 清单中唯一带哈希值的资源就是构建清单时 <code>dist</code> 目录中的资源。而其它资源，特别是从 CDN 加载的资源，其内容在构建时是未知的，或者会比应用程序部署得更频繁。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3rb4c6badvcc8swk2sxlluynw\">如果 Angular Service Worker 没有哈希可以验证给定的资源，它仍然会缓存它的内容，但会使用 “重新验证时失效” 的策略来承认 HTTP 缓存头。也就是说，即使被缓存资源的 HTTP 缓存头指出该资源已不再有效，Angular Service Worker 仍然会继续提供内容。同时它会在后台刷新资源。这样，那些被破坏的非哈希资源留在缓存中的时间就不会超出为它配置的生命周期。</p>\n<p><a id=\"tabs\"></a></p>\n<h3 id=\"application-tabs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eb2lzfyktm15fy79whjs7htz2\">App 选项卡<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#application-tabs\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35vg8boipatd1om463vxze7bt\">如果应用程序的资源版本突然发生了变化或没有给出警告，就可能会有问题。关于这些问题的描述，请参阅前面的 <a href=\"guide/service-worker-devops#versions\">版本</a> 部分。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bfoxra5xa9e5ecx6nx535avul\">Angular Service Worker 会保证：正在运行的应用程序会继续运行和当前应用相同的版本。而如果在新的 Web 浏览器选项卡中打开了该应用的另一个实例，则会提供该应用的最新版本。因此，这个新标签可以和原始标签同时运行不同版本的应用。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3sjwfmn9asby5dfgnm0hzrmgt\"><strong>重要</strong>：<br>\n这种担保比普通的 Web 部署模型提供的担保还要<strong>更强一点</strong>。\n如果没有 Service Worker，则不能保证稍后在这个惰性加载的代码\n和其初始代码的版本是一样的。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"60bi1xqzndwtiylhjqgwlzzkh\">Angular Service Worker 可能会在错误条件下更改正在运行的应用程序的版本，例如：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44u2zx34ix6ho16qmzwl60cqi\">由于哈希失败，当前版本变得无效</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"emyre21hot5f7cg4g2w5cncy\">不相关的错误导致 Service Worker 进入安全模式并暂时停用它</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24pj7doswjjwns7r5xnhou9dn\">当没有标签页使用它们时，Angular Service Worker 会清理应用版本。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ap7gxcxdx3jcnvq05xo2e2f35\">另一些可能导致 Angular Service Worker 在运行期间改变版本的因素是一些正常事件：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xqi7ywfwbjdasvwx0ccyhwc3\">页面被重新加载/刷新。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bosog1jd8wp8e8ob635eqmus3\">该页面通过 <code><a href=\"api/service-worker/SwUpdate\" class=\"code-anchor\">SwUpdate</a></code> 服务请求立即激活这个更新。</li>\n</ul>\n<h3 id=\"service-worker-updates\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6sx4vyva0fc0p8re7jk9uad10\">Service Worker 更新<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#service-worker-updates\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jfjkrf61e3dvv83q5x3ce1b\">Angular Service Worker 是一个运行在 Web 浏览器中的小脚本。有时，这个 Service Worker 也可能会需要更新，以修复错误和增强特性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"edloa4899bhpdja1pairbefw3\">首次打开应用时或在一段非活动时间之后再访问应用程序时，就会下载 Angular Service Worker。如果 Service Worker 发生了变化，就会在后台进行更新。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"45qcmbeys80prtogd0tmzip1b\">Angular Service Worker 的大部分更新对应用程序来说都是透明的。旧缓存仍然有效，其内容仍然能正常使用。但是，在 Angular Service Worker 中可能偶尔会有错误修复或新功能，需要让旧的缓存失效。这时，应用程序就从会网络上透明地进行刷新。</p>\n<h3 id=\"bypassing-the-service-worker\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlscbyq8xt6wiw0bvkid6bdmb\">绕过 Service Worker<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#bypassing-the-service-worker\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5lfrndazg0egvvzjv71vo2lls\">某些情况下，你可能想要完全绕过 Service Worker，转而让浏览器处理请求。比如当你要用到某些 Service Worker 尚不支持的特性时（比如<a href=\"https://github.com/w3c/ServiceWorker/issues/1141\">报告文件上传的进度</a>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6thahpmuztjjgqszqz5kcbozs\">要想绕过 Service Worker，你可以设置一个名叫 <code>ngsw-bypass</code> 的请求头或查询参数。这个请求头或查询参数的值会被忽略，可以把它设为空字符串或略去。</p>\n<h3 id=\"service-worker-requests-when-the-server-cant-be-reached\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f2zpu2tasz7l8u2arh9btwxst\">无法访问服务器时的 Service Worker 请求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#service-worker-requests-when-the-server-cant-be-reached\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"22qcm3mjmov3vy3ikcbi2nbk9\">除非<a href=\"guide/service-worker-devops#bypassing-the-service-worker\">显式绕过 Service Worker</a>，否则 Service Worker 会处理所有请求。根据缓存的状态和配置，Service Worker 可以返回缓存的响应或将请求发送到服务器。Service Worker 仅缓存对非修改型请求的响应，例如 <code>GET</code> 和 <code>HEAD</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekqh0vjzybvb4z7b2orpq5tw9\">如果 Service Worker 收到来自服务器的错误或没有收到响应，它会返回一个错误状态，以表明调用的结果。例如，如果 Service Worker 没有收到响应，它会创建并返回一个 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504\">504 Gateway Timeout</a> 状态。此示例中的 <code>504</code> 状态可能是因为服务器脱机或客户端已断开连接而返回的。</p>\n<h2 id=\"debugging-the-angular-service-worker\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6u0i3eftdh5oi2q2ijmw3e42q\">调试 Angular Service Worker<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#debugging-the-angular-service-worker\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ckpc2ojdshiscgt81nf017ivr\">偶尔，可能会需要检查运行中的 Angular Service Worker，以调查问题或确保它在按设计运行。浏览器提供了用于调试 Service Worker 的内置工具，而且 Angular Service Worker 本身也包含了一些有用的调试功能。</p>\n<h3 id=\"locating-and-analyzing-debugging-information\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b988j1j9ijm47m2mi2amln092\">定位并分析调试信息<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#locating-and-analyzing-debugging-information\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekvfdwysq6429q1jxlw6ie5zf\">Angular Service Worker 会在虚拟目录 <code>ngsw/</code> 下暴露出调试信息。目前，它暴露的唯一的 URL 是 <code>ngsw/state</code>。下面是这个调试页面中的一段范例内容：</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nNGSW Debug Info:\n\nDriver version: 13.3.7\nDriver state: NORMAL ((nominal))\nLatest manifest hash: eea7f5f464f90789b621170af5a569d6be077e5c\nLast update check: never\n\n=== Version eea7f5f464f90789b621170af5a569d6be077e5c ===\n\nClients: 7b79a015-69af-4d3d-9ae6-95ba90c79486, 5bc08295-aaf2-42f3-a4cc-9e4ef9100f65\n\n=== Idle Task Queue ===\nLast update tick: 1s496u\nLast update run: never\nTask queue:\n * init post-load (update, cleanup)\n\nDebug log:\n\n</code-example>\n<h4 id=\"driver-state\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bomzqghnmiehvwbxvqttt7oew\">驱动程序的状态<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#driver-state\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9yzpxr71wv90tigp1uxbqdn1z\">第一行表示驱动程序的状态：</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nDriver state: NORMAL ((nominal))\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"354s9jzrr6zr9t9m9tni4w4is\"><code>NORMAL</code> 表示这个 Service Worker 正在正常运行，并且没有处于降级运行的状态。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c9l2u9xclnaj8zhfl0ntbbpep\">有两种可能的降级状态：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29b4zobe0ssxocv4xdr7c5fra\">降级状态</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>EXISTING_CLIENTS_ONLY</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5fb9izaboy7mf8gx80lo49626\">服务工作线程没有最新已知版本的应用程序的清洁副本。旧的缓存版本可以安全使用，因此现有标签继续从缓存中运行，但应用程序的新加载将从网络提供。当检测到并安装应用程序的新版本时，服务工作线程将尝试从此状态恢复。这发生在新的 \n<code>ngsw.json</code> 可用时。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>SAFE_MODE</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8cix4yskjcuex0o8496i2nh94\">服务工作线程无法保证使用缓存数据的安全性。发生了意外错误，或所有缓存版本都无效。所有流量将从网络提供，尽可能少地运行服务工作线程代码。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eqgsnca502c193rd8jevbyz37\">在这两种情况下，后面的括号注解中都会提供导致 Service Worker 进入降级状态的错误信息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c1jm7os82vsupp37zzmp8zwp\">这两种状态都是暂时的；它们仅在 <a href=\"https://developer.mozilla.org/docs/Web/API/ServiceWorkerGlobalScope\">ServiceWorker 实例</a> 的生命周期内保存。浏览器有时会终止空闲的 Service Worker，以节省内存和处理能力，并创建一个新的 Service Worker 实例来响应网络事件。无论先前实例的状态如何，新实例均以 <code>NORMAL</code> 模式启动。</p>\n<h4 id=\"latest-manifest-hash\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5hghq674h9y5e7ohjd20hfbk\">最新清单的哈希<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#latest-manifest-hash\"><i class=\"material-icons\">link</i></a></h4>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nLatest manifest hash: eea7f5f464f90789b621170af5a569d6be077e5c\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"81c64p9oyyholr6uj0p7n4mpr\">这是 Service Worker 所知道的应用最新版本的 SHA1 哈希值。</p>\n<h4 id=\"last-update-check\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7f04u1t9zipd9uxpg0ffm6te0\">最后一次更新检查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#last-update-check\"><i class=\"material-icons\">link</i></a></h4>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nLast update check: never\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9t9t8q5g5kerc7w6pmcf81btr\">这表示 Service Worker 最后一次检查应用程序的新版本或更新的时间。“never” 表示 Service Worker 从未检查过更新。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ay3br0epdnf9ohvaz5edxpb7n\">在这个调试文件范例中，这次更新检查目前是已排期的，如下一节所述。</p>\n<h4 id=\"version\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"34ck2qsr4jsfv24ims2mht0vy\">版本<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#version\"><i class=\"material-icons\">link</i></a></h4>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\n=== Version eea7f5f464f90789b621170af5a569d6be077e5c ===\n\nClients: 7b79a015-69af-4d3d-9ae6-95ba90c79486, 5bc08295-aaf2-42f3-a4cc-9e4ef9100f65\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aphwoh8vnyio1yhwi5e3uqaxa\">在这个例子中，Service Worker 拥有一个版本的应用程序缓存并用它服务于两个不同的选项卡。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9d5a2y15vaebkp5y8vzi31dlt\"><strong>注意</strong>：<br>\n这个版本哈希值是上面列出的“最新清单的哈希”。\n它的两个客户运行的都是最新版本。每个客户都用浏览器中 <code>Clients</code> API 的 ID 列了出来。</p>\n</div>\n<h4 id=\"idle-task-queue\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71baiwjkvpc4nrgobmsyrhrcx\">空闲任务队列<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#idle-task-queue\"><i class=\"material-icons\">link</i></a></h4>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\n=== Idle Task Queue ===\nLast update tick: 1s496u\nLast update run: never\nTask queue:\n * init post-load (update, cleanup)\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rxwd7o3r9p6dhm0u1cb1zm9j\">空闲任务队列是 Service Worker 中所有在后台发生的未决任务的队列。如果这个队列中存在任何任务，则列出它们的描述。在这个例子中，Service Worker 安排的任务是一个用于更新检查和清除过期缓存的后期初始化操作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b69sp4apt3ay41fqw1bogbdv2\">最后的 tick/run 计数器给出了与特定事件发生有关的空闲队列中的时间。“Last update run” 计数器显示的是上次执行空闲任务的时间。“Last update tick” 显示的是自上次事件以来可能要处理的队列的时间。</p>\n<h4 id=\"debug-log\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c64x6ha0w0v4d8hpdaq2k3sjc\">调试日志<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#debug-log\"><i class=\"material-icons\">link</i></a></h4>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nDebug log:\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dpz0h3xxnn2s8scsfpm601ck1\">Service Worker 中发生的错误会记录在此。</p>\n<h3 id=\"developer-tools\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e9wabhoy9semoioyr50kpqp69\">开发者工具<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#developer-tools\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9du9akc46lt4t4jrgyax2k7ku\">Chrome 等浏览器提供了能与 Service Worker 交互的开发者工具。这些工具在使用得当时非常强大，但也要牢记一些事情。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1sbyalg5qg3ggtg38tv1lga4x\">使用开发人员工具时，Service Worker 将继续在后台运行，并且不会重新启动。这可能会导致开着 Dev Tools 时的行为与用户实际遇到的行为不一样。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43wo0e2110957p8x9qp1jh0v9\">如果你查看缓存存储器的查看器，缓存就会经常过期。右键单击缓存存储器的标题并刷新缓存。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csdsdzqtn3gsu3svd4ewhiye\">在 Service Worker 页停止并重新启动这个 Service Worker 将会触发一次更新检查。</p>\n</li>\n</ul>\n<h2 id=\"service-worker-safety\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f2wcvq0zgf6gnorhl2xjppiqo\">Service Worker 的安全性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#service-worker-safety\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3c5nixhjx6bt2tntujmzb26t7\">错误或损坏的配置可能会导致 Angular Service Worker 以不可预知的方式工作。如果出现了这种情况，管理员需要快速停用 Service Worker，Angular Service Worker 也包含多种故障保护机制。</p>\n<h3 id=\"fail-safe\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9e3cv7qzw4kfkak3n0fd0n7dt\">故障保护机制<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#fail-safe\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jtrkva4c05fnmfyexcy7cdkh\">要停用 Service Worker，请删除或重命名 <code>ngsw.json</code> 文件。当 Service Worker 对 <code>ngsw.json</code> 的请求返回 <code>404</code> 时，Service Worker 就会删除它的所有缓存并注销自己，本质上就是自毁。</p>\n<h3 id=\"safety-worker\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2hn87j75ffkjo5kwzpu6pxnym\">安全工作者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#safety-worker\"><i class=\"material-icons\">link</i></a></h3>\n<!-- vale Angular.Google_Acronyms = NO -->\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"31r75x479qx62mov2qeviuw7y\"><code>@angular/service-worker</code> NPM 包中还包含一个小脚本 <code>safety-worker.js</code>。当加载它时，就会把它从浏览器中注销，并移除此 Service Worker 的缓存。这个脚本可以作为终极武器来摆脱那些已经安装在客户端页面上的不想要的 Service Worker。</p>\n<!-- vale Angular.Google_Acronyms = YES -->\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ogaqihw6kenqgxopimp06ks0\"><strong>重要</strong>：<br>\n你不能直接注册这个 Safety Worker，因为具有已缓存状态的旧客户端可能无法看到一个新的、用来安装 另一个 worker 脚本的 <code>index.html</code>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9tu5dcdyw425bxnqhwlsqzv76\">你必须在想要注销的 Service Worker 脚本的 URL 中提供 <code>safety-worker.js</code> 的内容，\n而且必须持续这样做，直到确定所有用户都已成功注销了原有的 Worker。\n对大多数网站而言，这意味着你应该永远为旧的 Service Worker URL 提供 这个 Safety Worker。\n这个脚本可以用来停用 <code>@angular/service-worker</code>（并移除相应的缓存）以及任何其它曾在你的站点上提供过的 Service Worker。</p>\n<h3 id=\"changing-your-applications-location\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3z4xrnvkw00kzjimjbv8nwy7w\">更改应用的位置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#changing-your-applications-location\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5fr6nob87wir1pvupsx6a5s0h\"><strong>重要</strong>：<br>\nService Worker 无法在重定向后工作。你可能已经遇到过这种错误：<code>The script resource is behind a redirect, which is disallowed</code>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ucc7qbcpk4uf4alxzt6y2ga1\">如果你不得不更改应用的位置，就可能会出现问题。如果你设置了从旧位置（比如 <code>example.com</code>）到新位置（比如 <code>www.example.com</code>）的重定向，则 Service Worker 将停止工作。同样，对于完全从 Service Worker 加载该网站的用户，甚至都不会触发重定向。老的 Worker（注册在 <code>example.com</code>）会尝试更新并将请求发送到原来的位置 <code>example.com</code>，该位置重定向到新位置 <code>www.example.com</code> 就会导致错误 <code>The script resource is behind a redirect, which is disallowed</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"98jg0ucr52q4v172lr6m1j9ry\">为了解决这个问题，你可能需要用上述技巧（<a href=\"guide/service-worker-devops#fail-safe\">故障安全</a>或<a href=\"guide/service-worker-devops#safety-worker\">Safety Worker</a>）之一移除老的 Worker。</p>\n<h2 id=\"more-on-angular-service-workers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e9jl51v338pdg88lkv1cl8f1i\">关于 Angular Service Worker 的更多信息<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/service-worker-devops#more-on-angular-service-workers\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1oolgylns9kaynftarwog49tq\">你可能还对下列内容感兴趣：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ew4ab2vokoabifajmxtyb01m1\"><a href=\"guide/service-worker-config\">Service Worker 配置</a>。</li>\n</ul>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Wed Sep 06 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/service-worker-config\n - guide/service-worker-intro\n - guide/service-worker-notifications\n-->\n<!-- links from this doc:\n - api/service-worker/SwUpdate\n - cli\n - guide/service-worker-communications\n - guide/service-worker-config\n - guide/service-worker-devops#application-tabs\n - guide/service-worker-devops#application-versions\n - guide/service-worker-devops#bypassing-the-service-worker\n - guide/service-worker-devops#changing-your-applications-location\n - guide/service-worker-devops#debug-log\n - guide/service-worker-devops#debugging-the-angular-service-worker\n - guide/service-worker-devops#developer-tools\n - guide/service-worker-devops#driver-state\n - guide/service-worker-devops#fail-safe\n - guide/service-worker-devops#hashed-content\n - guide/service-worker-devops#idle-task-queue\n - guide/service-worker-devops#last-update-check\n - guide/service-worker-devops#latest-manifest-hash\n - guide/service-worker-devops#locating-and-analyzing-debugging-information\n - guide/service-worker-devops#more-on-angular-service-workers\n - guide/service-worker-devops#prerequisites\n - guide/service-worker-devops#resource-integrity\n - guide/service-worker-devops#safety-worker\n - guide/service-worker-devops#service-worker-and-caching-of-application-resources\n - guide/service-worker-devops#service-worker-in-production\n - guide/service-worker-devops#service-worker-requests-when-the-server-cant-be-reached\n - guide/service-worker-devops#service-worker-safety\n - guide/service-worker-devops#service-worker-updates\n - guide/service-worker-devops#tabs\n - guide/service-worker-devops#unhashed-content\n - guide/service-worker-devops#update-checks\n - guide/service-worker-devops#version\n - guide/service-worker-devops#versions\n - https://developer.mozilla.org/docs/Web/API/ServiceWorkerGlobalScope\n - https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504\n - https://github.com/w3c/ServiceWorker/issues/1141\n-->"}