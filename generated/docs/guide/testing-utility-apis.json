{"id":"guide/testing-utility-apis","title":"測試實用工具 API","contents":"<div class=\"content\">\n  <h1 id=\"testing-utility-apis\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebvbxxp2lwm71m7q7b2xvbvg4\">測試實用工具 API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#testing-utility-apis\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8trgspubuw3qk2vb89e3u31p5\">本頁面描述了一些最有用的 Angular 測試屬性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7y0hjp5h3wvtt2xql7hmgke37\">Angular 測試實用工具包括 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>、<code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 以及一些控制測試環境的函式。<a href=\"guide/testing-utility-apis#testbed-api-summary\"><code>TestBed</code></a> 和 <a href=\"guide/testing-utility-apis#component-fixture-api-summary\"><code>ComponentFixture</code></a> 類是單獨介紹的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xfmr3bkgdsj428agchzu9574\">下面是一些獨立函式的摘要，以使用頻率排序：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7y4o0j30ltpz4br769esy6uld\">函式</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dawwwic0wyjhin647lm13352o\">在特殊的\n<em>非同步測試區域</em>中執行測試（\n<code>it</code>）或設定（\n<code>beforeEach</code>）函式的內容。請參見\n<a href=\"guide/testing-components-scenarios#waitForAsync\">waitForAsync</a>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6i1zrrgm20u69fw2lkajpt95p\">在特殊的\n<em>fakeAsync 測試區域</em>中執行測試（\n<code>it</code>），實現線性控制流編碼風格。請參見\n<a href=\"guide/testing-components-scenarios#fake-async\">fakeAsync</a>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d382jn074a78kh5694rcetabw\">在\n<em>fakeAsync 測試區域</em>內重新整理\n<em>定時器</em>和\n<em>微任務</em>佇列，模擬時間流逝和待處理非同步活動的完成。\n<div class=\"alert is-helpful\">\n  好奇的、專注的讀者可能會喜歡這篇冗長的博文，\n <a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules\">\"<em>任務、微任務、佇列和計劃</em>\"</a>。 \n</div> 接受一個可選引數，按指定的毫秒數向前移動虛擬時鐘，清除在此時間範圍內安排的非同步活動。請參見\n<a href=\"guide/testing-components-scenarios#tick\">tick</a>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>inject</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2z1vzc1hn537sgjzixmribss9\">將當前\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>注入器中的一個或多個服務注入到測試函式中。它無法注入由元件本身提供的服務。請參見\n<a href=\"guide/testing-components-scenarios#get-injected-services\">debugElement.injector</a>中關於此的討論。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/discardPeriodicTasks\" class=\"code-anchor\">discardPeriodicTasks</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4bh9rekgytqq6hynwjrrg8bq8\">當一個\n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>測試以待處理的計時器事件\n<em>任務</em>（排隊的\n<code>setTimeOut</code>和\n<code>setInterval</code>回呼）結束時，測試將失敗並顯示清晰的錯誤訊息。\n<br>通常情況下，一個測試應該在沒有排隊任務的情況下結束。當需要等待待處理的計時器任務時，呼叫\n<code><a href=\"api/core/testing/discardPeriodicTasks\" class=\"code-anchor\">discardPeriodicTasks</a></code>來清空\n<em>任務</em>佇列以避免錯誤。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/flushMicrotasks\" class=\"code-anchor\">flushMicrotasks</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvrbttgh4a5w2cib46mwb3emy\">當一個\n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>測試以待處理的\n<em>微任務</em>（如未解決的Promise）結束時，測試將失敗並顯示清晰的錯誤訊息。\n<br>通常情況下，一個測試應該等待微任務完成。當預期有待處理的微任務時，呼叫\n<code><a href=\"api/core/testing/flushMicrotasks\" class=\"code-anchor\">flushMicrotasks</a></code>來清空\n<em>微任務</em>佇列以避免錯誤。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cy0ypwzyf6p9nbr8c11tphxhm\">為開啟\n<a href=\"guide/testing-components-scenarios#automatic-change-detection\">自動變更檢測</a>的服務提供者令牌。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/getTestBed\" class=\"code-anchor\">getTestBed</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7treez1ghsuesrgp3h0g4askq\">獲取當前\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>的實例。通常情況下不需要，因為\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>類別的靜態類方法通常已經足夠。\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>實例暴露了一些不常用的成員，這些成員在靜態方法中不可用。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"testbed-class-summary\"></a></p>\n<h2 id=\"testbed-class-summary\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5w4h25ntjz2vkbiyz1y528fo7\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 類摘要<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#testbed-class-summary\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1tim3leh2zebfhnlow2tp7e88\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 類是 Angular 測試工具的主要類之一。它的 API 很龐大，可能有點過於複雜，直到你一點一點的探索它們。閱讀本章前面的部分，瞭解了基本的知識以後，再試著瞭解完整 API。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9jtymcp6nyp0dcpknxp7gqnbs\">傳給 <code>configureTestingModule</code> 的模組定義是 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 元資料屬性的子集。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\ntype <a href=\"api/core/testing/TestModuleMetadata\" class=\"code-anchor\">TestModuleMetadata</a> = {\n  providers?: any[];\n  declarations?: any[];\n  imports?: any[];\n  schemas?: Array&lt;<a href=\"api/core/SchemaMetadata\" class=\"code-anchor\">SchemaMetadata</a> | any[]&gt;;\n};\n\n</code-example>\n<p><a id=\"metadata-override-object\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1n4d1cir7wjhucdlq8v6g3to8\">每一個過載方法接受一個 <code><a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&lt;T&gt;</code>，這裡 <code>T</code> 是適合這個方法的元資料型別，也就是 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>、<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>、<code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 或者 <code>@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code> 的引數。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\ntype <a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&lt;T&gt; = {\n  add?: Partial&lt;T&gt;;\n  remove?: Partial&lt;T&gt;;\n  set?: Partial&lt;T&gt;;\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"18yk0dok8s10tukf2rkjadwmg\"><a id=\"testbed-methods\"></a>\n<a id=\"testbed-api-summary\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ew9jj41i8cc0x9am0sweo4akb\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的 API 包含了一系列靜態類方法，它們更新或者引用<strong>全域</strong>的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 實例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bcjfsvd1qy3u0rqr3243m77mz\">在內部，所有靜態方法在 <code><a href=\"api/core/testing/getTestBed\" class=\"code-anchor\">getTestBed</a>()</code> 函式回傳的當前執行時間的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 實例上都有對應的方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebkiuu3lh1v5myuwz366l52p3\">在 <code>BeforeEach()</code> 內呼叫 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 方法，以確保在執行每個單獨測試時，都有嶄新的開始。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bo5rtabfl0612hhvd3ph25se5\">這裡列出了最重要的靜態方法，以使用頻率排序。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xubgaqmffibk0p3s7z4lwoiw\">方法</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>configureTestingModule</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"48vsx9690lmm4831n286wnvh9\">測試填充物（\n<code>karma-test-shim</code>、\n<code>browser-test-shim</code>）建立了\n<a href=\"guide/testing\">初始測試環境</a>和一個預設的測試模組。預設的測試模組設定了基本的宣告和一些Angular服務替代品，每個測試者都需要。呼叫\n<code>configureTestingModule</code>來透過新增和移除匯入、宣告（元件、指令和通道）、和提供者來完善特定一組測試的測試模組設定。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>compileComponents</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5gqdyie7nnuy5b2mv3il3u63x\">在完成設定測試模組後非同步編譯它。如果任何測試模組元件具有\n<code>templateUrl</code>或\n<code>styleUrls</code>，必須呼叫此方法，因為獲取元件樣板和樣式檔案必須是非同步的。參見\n<a href=\"guide/testing-components-scenarios#compile-components\">compileComponents</a>。\n<br>呼叫\n<code>compileComponents</code>後，\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>設定將在當前規範的持續時間內被凍結。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>&lt;T&gt;</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dnzovlh0brxir14xbhqzfj64t\">根據當前\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>設定建立一個型別為\n<code>T</code>的元件實例。呼叫\n<code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code>後，\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>設定將在當前規範的持續時間內被凍結。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>overrideModule</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dcwlurxa90s9g1t0yw4p630rj\">替換給定\n<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>的元資料。請記住模組可以匯入其他模組。\n<code>overrideModule</code>方法可以深入到當前測試模組中修改其中一個內部模組。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>overrideComponent</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"65x37t4w0t08uav41bu94zk81\">替換給定元件類別的元資料，該組件類可能深嵌於內部模組中。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>overrideDirective</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qxbkcwad4phpironiv1fp0v\">替換給定指令類的元資料，該指令類可能深嵌於內部模組中。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>overridePipe</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cwdrpvzeeqzmtqiukud4kk794\">替換給定通道類的元資料，該通道類可能深嵌於內部模組中。</td>\n</tr>\n</tbody>\n</table>\n<p>|\n<a id=\"testbed-inject\"></a>\n<code>inject</code>                           | Retrieve a service from the current <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> injector. The <code>inject</code> function is often adequate for this purpose. But <code>inject</code> throws an error if it can't provide the service. <br> What if the service is optional? <br> The <code>TestBed.inject()</code> method takes an optional second parameter, the object to return if Angular can't find the provider (<code>null</code> in this example): <code-example header=\"app/demo/demo.testbed.spec.ts\" path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"testbed-get-w-null\">\nexpect(TestBed.inject(NotProvided, null)).toBeNull();\n\n</code-example> After calling <code>TestBed.inject</code>, the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration is frozen for the duration of the current spec. |\n|\n<a id=\"testbed-initTestEnvironment\"></a>\n<code>initTestEnvironment</code> | Initialize the testing environment for the entire test run. <br> The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>) call it for you so there is rarely a reason for you to call it yourself. <br> Call this method <em>exactly once</em>. To change this default in the middle of a test run, call <code>resetTestEnvironment</code> first. <br> Specify the Angular compiler factory, a <code><a href=\"api/core/PlatformRef\" class=\"code-anchor\">PlatformRef</a></code>, and a default Angular testing module. Alternatives for non-browser platforms are available in the general form <code>@angular/platform-&lt;platform_name&gt;/testing/&lt;platform_name&gt;</code>.                                                                  |\n| <code>resetTestEnvironment</code>                                         | Reset the initial test environment, including the default testing module.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ciaa4fwk1y8kqs3h3u537bqko\">少數 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 實例方法沒有對應的靜態方法。它們很少被使用。</p>\n<p><a id=\"component-fixture-api-summary\"></a></p>\n<h2 id=\"the-componentfixture\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"du0sspe0fcsr8tispqc16v6cr\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 類<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#the-componentfixture\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8jxu75pjtaer6ar696zjxo8tz\"><code>TestBed.createComponent&lt;T&gt;</code> 會建立一個元件 <code>T</code> 的實例，併為該組件回傳一個強型別的 <code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"x7819ug205elh76ht3fm9vu4\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 的屬性和方法提供了對元件、它的 DOM 和它的 Angular 環境方面的訪問。</p>\n<p><a id=\"component-fixture-properties\"></a></p>\n<h3 id=\"componentfixture-properties\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e3huah6nwu81loqdnmihmq6wy\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 的屬性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#componentfixture-properties\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5erhswfokpke60pfl8ftj2ovp\">下面是對測試最重要的屬性，以使用頻率排序。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ghvm54f9feewnb0zbrlubp2h\">屬性</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>componentInstance</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"y5xihbd28dnmdyzaudgthxaw\"><code>TestBed.createComponent</code>建立的元件類別實例。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>debugElement</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7v6ldcnlw38o2wqmzwoahbzhj\">與該組件根元素關聯的\n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。\n<br>\n<code>debugElement</code>在測試和除錯期間提供關於元件及其DOM元素的見解。對於測試者來說，這是一個關鍵屬性。其中最有趣的成員在\n<a href=\"guide/testing-utility-apis#debug-element-details\">下面</a>有介紹。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>nativeElement</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4bx76gykh2bj263ordzmaxwnh\">該組件根部的原生DOM元素。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>changeDetectorRef</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ojru5l1yc3ntvrvxnc490hd7\">該組件的\n<code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code>。\n<br>\n<code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code>在測試具有\n<code><a href=\"api/core/ChangeDetectionStrategy#OnPush\" class=\"code-anchor\">ChangeDetectionStrategy.OnPush</a></code>方法或元件的變更檢測受您的程式控制時最有價值。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"component-fixture-methods\"></a></p>\n<h3 id=\"componentfixture-methods\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"826ye353l6p6sygu841q6cqk9\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 方法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#componentfixture-methods\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8isoy0gf8gtnjq5ob28umaeit\"><strong>fixture</strong> 方法使 Angular 對元件樹執行某些任務。在觸發 Angular 行為來模擬的使用者行為時，呼叫這些方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9rge64b4zkeic42ufdz0ewwez\">下面是對測試最有用的方法。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xubgaqmffibk0p3s7z4lwoiw\">方法</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>detectChanges</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3gab8gkd90nxkfiqzsx6i1ajc\">為該組件觸發一個變更檢測週期。\n<br>呼叫它來初始化元件（呼叫\n<code>ngOnInit</code>）並在測試程式碼之後更改元件的資料繫結屬性值。Angular無法察覺您已經更改了\n<code>personComponent.name</code>，直到您呼叫\n<code>detectChanges</code>。呼叫\n<code>detectChanges</code>後執行\n<code>checkNoChanges</code>來確認沒有迴圈更新，除非以\n<code>detectChanges(false)</code>呼叫。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>autoDetectChanges</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"740s4usk78jokyzwxsbicek\">當您希望夾具自動檢測變化時，請將其設定為\n<code>true</code>。\n<br>當自動檢測為\n<code>true</code>時，測試夾具在建立元件後立即呼叫\n<code>detectChanges</code>。然後它監聽相關區域事件並相應呼叫\n<code>detectChanges</code>。當測試程式碼直接修改元件屬性值時，您可能仍需要呼叫\n<code>fixture.detectChanges</code>來觸發資料繫結更新。\n<br>預設值為\n<code>false</code>。喜歡對測試行為進行精細控制的測試者傾向於保持為\n<code>false</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>checkNoChanges</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e89qpncijtzcmhplhx3pmc5ge\">執行變更檢測執行以確保沒有待處理的更改。如果有待處理更改，則會丟擲異常。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>isStable</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cr3adby9pzk4ksw5v8pcnra7k\">如果夾具當前\n<em>穩定</em>，則回傳\n<code>true</code>。如果有尚未完成的非同步任務，則回傳\n<code>false</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>whenStable</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"578qgdgogeawlih5ty8fxi4r7\">回傳一個在夾具穩定時解析的Promise。\n<br>在完成非同步活動或非同步變更檢測後恢復測試時，請連線該Promise。檢視\n<a href=\"guide/testing-components-scenarios#when-stable\">whenStable</a>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>destroy</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4qt5og7tutemtxiw5qbiw1u8\">觸發元件的銷燬。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"debug-element-details\"></a></p>\n<h4 id=\"debugelement\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#debugelement\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"h70kbrvqjdc5y6090e7s8gka\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 提供了對元件的 DOM 的訪問。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ajhijkdjdz4fao8b6lc4djs1r\"><code>fixture.debugElement</code> 回傳測試根元件的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>，透過它你可以訪問（查詢）fixture 的整個元素和元件子樹。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"36d5302u6jvz20rpeef4akojn\">下面是 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 最有用的成員，以使用頻率排序。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e62kgm2ztk7rgk6auybfiv91o\">成員</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>nativeElement</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dkb0s45orw521d0pkobqk7vsh\">瀏覽器中對應的 DOM 元素</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ghiykb3aaaebayh6qik71057\">呼叫 \n<code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&lt;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>&gt;)</code> 回傳在子樹中任意深度對應 \n<a href=\"guide/testing-utility-apis#query-predicate\">謂詞</a> 的第一個 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>queryAll</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"emrmbdlple9yz6w84csy4q5ww\">呼叫 \n<code>queryAll(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&lt;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>&gt;)</code> 回傳在子樹中任意深度對應 \n<a href=\"guide/testing-utility-apis#query-predicate\">謂詞</a> 的所有 \n<code>DebugElement</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>injector</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1yyfov98r97huxz9pmipkq99f\">宿主依賴注入器。例如，根元素的元件實例注入器。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>componentInstance</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bx8lkfdxy9d5a7lqvgrjv63cq\">元素自己的元件實例（如果有）。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>context</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1bf6yxcsm704022irvjked14c\">為該元素提供父上下文的物件。通常是控制該元素的祖先元件實例。\n<br> 當一個元素在 \n<code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 中重複時，上下文是一個 \n<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code>，其 \n<code>$implicit</code> 屬性是行實例值的值。例如，在 \n<code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"</code> 中的 \n<code>hero</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>children</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6fbeyiffh9vkkaasrs0nqx269\">直接的 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 子元素。透過向下遍歷 \n<code>children</code> 遍歷樹。\n<div class=\"alert is-helpful\"> \n <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 還有 \n <code>childNodes</code>，一個 \n <code><a href=\"api/core/DebugNode\" class=\"code-anchor\">DebugNode</a></code> 物件清單。 \n <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 源自 \n <code><a href=\"api/core/DebugNode\" class=\"code-anchor\">DebugNode</a></code> 物件，通常節點比元素多。測試人員通常可以忽略普通節點。 \n</div></td>\n</tr>\n<tr>\n<td align=\"left\"><code>parent</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1dj53aq360hj12jwabl2f3hb8\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 的父元素。如果這是根元素，則為 Null。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>name</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cbepw70acdtphjqvvurasmrph\">元素令牌名稱（如果是元素）。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>triggerEventHandler</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5wy91v2z7l2znwrzb2khedxc2\">如果元素的 \n<code>listeners</code> 集合中存在相應的監聽器，則觸發事件的名稱。第二個引數是處理程式期望的 \n<em>事件物件</em>。參見 \n<a href=\"guide/testing-components-scenarios#trigger-event-handler\">triggerEventHandler</a>。 \n<br> 如果事件缺少監聽器或存在其他問題，請考慮呼叫 \n<code>nativeElement.dispatchEvent(eventObject)</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>listeners</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4h318sfg8s6m8f4zmxgl33xeb\">附加到元件的 \n<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 屬性和/或元素的事件屬性的回呼。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>providerTokens</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29hd6bn1yhrbf64nsrs1y7a8e\">該組件的注入器查詢令牌。包括元件本身和元件在其 \n<code>providers</code> 元資料中列出的令牌。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>source</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c5w6zws5rt4fuwyfua0ff831o\">在源元件樣板中查詢此元素的位置。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>references</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4zdpmsmry1zmzstlbnyvkkary\">與樣板區域性變數（例如，\n<code>#foo</code>）關聯的物件字典，按本地變數名稱索引。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"query-predicate\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"be3egqzam3i45izu2jr4gvqi\"><code>DebugElement.query(predicate)</code> 和 <code>DebugElement.queryAll(predicate)</code> 方法接受一個條件方法，它過濾源元素的子樹，回傳對應的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7khwhyi0djva20qs82kiizt8k\">這個條件方法是任何接受一個 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 並回傳真值的方法。下面的例子查詢所有擁有名為 <code>content</code> 的模組本地變數的所有 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>：</p>\n<code-example header=\"app/demo/demo.testbed.spec.ts\" path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"custom-predicate\">\n// Filter for DebugElements with a #content reference\nconst contentRefs = el.queryAll((de) =&gt; de.references['content']);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2g7nx3c239ssvmer9ummwxmd1\">Angular 的 <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 類為常用條件方法提供了三個靜態方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9zoyyca4y8znurrr61rj7hxy5\">靜態方法</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>By.all</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"87rly5szcna46j3sqogoax2b3\">回傳所有元素</td>\n</tr>\n<tr>\n<td align=\"left\"><code>By.css(selector)</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efnrayosjm3j82avjr8fcs2r1\">回傳具有對應的 CSS 選擇器的元素</td>\n</tr>\n<tr>\n<td align=\"left\"><code>By.directive(directive)</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ax2pgez6g5hflk977bjzqt2ry\">回傳 Angular 對應到指令類的實例的元素</td>\n</tr>\n</tbody>\n</table>\n<code-example header=\"app/hero/hero-list.component.spec.ts\" path=\"testing/src/app/hero/hero-list.component.spec.ts\" region=\"by\">\n// Can find <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> either by css selector or by directive\nconst h2 = fixture.debugElement.query(By.css('h2'));\nconst directive = fixture.debugElement.query(By.directive(HighlightDirective));\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Thu Sep 07 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/DebugElement\n - guide/testing\n - guide/testing-components-scenarios\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/NgFor\n - api/common/NgForOf\n - api/core/ChangeDetectionStrategy#OnPush\n - api/core/ChangeDetectorRef\n - api/core/Component\n - api/core/DebugElement\n - api/core/DebugNode\n - api/core/Directive\n - api/core/NgModule\n - api/core/Output\n - api/core/Pipe\n - api/core/PlatformRef\n - api/core/Predicate\n - api/core/SchemaMetadata\n - api/core/createComponent\n - api/core/testing/ComponentFixture\n - api/core/testing/ComponentFixtureAutoDetect\n - api/core/testing/MetadataOverride\n - api/core/testing/TestBed\n - api/core/testing/TestModuleMetadata\n - api/core/testing/discardPeriodicTasks\n - api/core/testing/fakeAsync\n - api/core/testing/flushMicrotasks\n - api/core/testing/getTestBed\n - api/core/testing/tick\n - api/core/testing/waitForAsync\n - api/platform-browser/By\n - guide/testing\n - guide/testing-components-scenarios#automatic-change-detection\n - guide/testing-components-scenarios#compile-components\n - guide/testing-components-scenarios#fake-async\n - guide/testing-components-scenarios#get-injected-services\n - guide/testing-components-scenarios#tick\n - guide/testing-components-scenarios#trigger-event-handler\n - guide/testing-components-scenarios#waitForAsync\n - guide/testing-components-scenarios#when-stable\n - guide/testing-utility-apis#component-fixture-api-summary\n - guide/testing-utility-apis#componentfixture-methods\n - guide/testing-utility-apis#componentfixture-properties\n - guide/testing-utility-apis#debug-element-details\n - guide/testing-utility-apis#debugelement\n - guide/testing-utility-apis#query-predicate\n - guide/testing-utility-apis#testbed-api-summary\n - guide/testing-utility-apis#testbed-class-summary\n - guide/testing-utility-apis#testing-utility-apis\n - guide/testing-utility-apis#the-componentfixture\n - https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules\n-->"}