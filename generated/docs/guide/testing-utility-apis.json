{"id":"guide/testing-utility-apis","title":"测试实用工具 API","contents":"<div class=\"content\">\n  <h1 id=\"testing-utility-apis\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebvbxxp2lwm71m7q7b2xvbvg4\">测试实用工具 API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#testing-utility-apis\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8trgspubuw3qk2vb89e3u31p5\">本页面描述了一些最有用的 Angular 测试特性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7y0hjp5h3wvtt2xql7hmgke37\">Angular 测试实用工具包括 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>、<code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 以及一些控制测试环境的函数。<a href=\"guide/testing-utility-apis#testbed-api-summary\"><code>TestBed</code></a> 和 <a href=\"guide/testing-utility-apis#component-fixture-api-summary\"><code>ComponentFixture</code></a> 类是单独介绍的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xfmr3bkgdsj428agchzu9574\">下面是一些独立函数的摘要，以使用频率排序：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7y4o0j30ltpz4br769esy6uld\">函数</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dawwwic0wyjhin647lm13352o\">在特殊的\n<em>异步测试区域</em>中运行测试（\n<code>it</code>）或设置（\n<code>beforeEach</code>）函数的内容。请参见\n<a href=\"guide/testing-components-scenarios#waitForAsync\">waitForAsync</a>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6i1zrrgm20u69fw2lkajpt95p\">在特殊的\n<em>fakeAsync 测试区域</em>中运行测试（\n<code>it</code>），实现线性控制流编码风格。请参见\n<a href=\"guide/testing-components-scenarios#fake-async\">fakeAsync</a>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d382jn074a78kh5694rcetabw\">在\n<em>fakeAsync 测试区域</em>内刷新\n<em>定时器</em>和\n<em>微任务</em>队列，模拟时间流逝和待处理异步活动的完成。\n<div class=\"alert is-helpful\">\n  好奇的、专注的读者可能会喜欢这篇冗长的博文，\n <a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules\">\"<em>任务、微任务、队列和计划</em>\"</a>。 \n</div> 接受一个可选参数，按指定的毫秒数向前移动虚拟时钟，清除在此时间范围内安排的异步活动。请参见\n<a href=\"guide/testing-components-scenarios#tick\">tick</a>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>inject</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2z1vzc1hn537sgjzixmribss9\">将当前\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>注入器中的一个或多个服务注入到测试函数中。它无法注入由组件本身提供的服务。请参见\n<a href=\"guide/testing-components-scenarios#get-injected-services\">debugElement.injector</a>中关于此的讨论。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/discardPeriodicTasks\" class=\"code-anchor\">discardPeriodicTasks</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4bh9rekgytqq6hynwjrrg8bq8\">当一个\n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>测试以待处理的计时器事件\n<em>任务</em>（排队的\n<code>setTimeOut</code>和\n<code>setInterval</code>回调）结束时，测试将失败并显示清晰的错误消息。\n<br>通常情况下，一个测试应该在没有排队任务的情况下结束。当需要等待待处理的计时器任务时，调用\n<code><a href=\"api/core/testing/discardPeriodicTasks\" class=\"code-anchor\">discardPeriodicTasks</a></code>来清空\n<em>任务</em>队列以避免错误。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/flushMicrotasks\" class=\"code-anchor\">flushMicrotasks</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvrbttgh4a5w2cib46mwb3emy\">当一个\n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>测试以待处理的\n<em>微任务</em>（如未解决的Promise）结束时，测试将失败并显示清晰的错误消息。\n<br>通常情况下，一个测试应该等待微任务完成。当预期有待处理的微任务时，调用\n<code><a href=\"api/core/testing/flushMicrotasks\" class=\"code-anchor\">flushMicrotasks</a></code>来清空\n<em>微任务</em>队列以避免错误。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cy0ypwzyf6p9nbr8c11tphxhm\">为打开\n<a href=\"guide/testing-components-scenarios#automatic-change-detection\">自动变更检测</a>的服务提供者令牌。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/getTestBed\" class=\"code-anchor\">getTestBed</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7treez1ghsuesrgp3h0g4askq\">获取当前\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>的实例。通常情况下不需要，因为\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>类的静态类方法通常已经足够。\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>实例暴露了一些不常用的成员，这些成员在静态方法中不可用。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"testbed-class-summary\"></a></p>\n<h2 id=\"testbed-class-summary\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5w4h25ntjz2vkbiyz1y528fo7\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 类摘要<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#testbed-class-summary\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1tim3leh2zebfhnlow2tp7e88\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 类是 Angular 测试工具的主要类之一。它的 API 很庞大，可能有点过于复杂，直到你一点一点的探索它们。阅读本章前面的部分，了解了基本的知识以后，再试着了解完整 API。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9jtymcp6nyp0dcpknxp7gqnbs\">传给 <code>configureTestingModule</code> 的模块定义是 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 元数据属性的子集。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\ntype <a href=\"api/core/testing/TestModuleMetadata\" class=\"code-anchor\">TestModuleMetadata</a> = {\n  providers?: any[];\n  declarations?: any[];\n  imports?: any[];\n  schemas?: Array&lt;<a href=\"api/core/SchemaMetadata\" class=\"code-anchor\">SchemaMetadata</a> | any[]&gt;;\n};\n\n</code-example>\n<p><a id=\"metadata-override-object\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1n4d1cir7wjhucdlq8v6g3to8\">每一个重载方法接受一个 <code><a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&lt;T&gt;</code>，这里 <code>T</code> 是适合这个方法的元数据类型，也就是 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>、<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>、<code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 或者 <code>@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code> 的参数。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\ntype <a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&lt;T&gt; = {\n  add?: Partial&lt;T&gt;;\n  remove?: Partial&lt;T&gt;;\n  set?: Partial&lt;T&gt;;\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"18yk0dok8s10tukf2rkjadwmg\"><a id=\"testbed-methods\"></a>\n<a id=\"testbed-api-summary\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ew9jj41i8cc0x9am0sweo4akb\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的 API 包含了一系列静态类方法，它们更新或者引用<strong>全局</strong>的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bcjfsvd1qy3u0rqr3243m77mz\">在内部，所有静态方法在 <code><a href=\"api/core/testing/getTestBed\" class=\"code-anchor\">getTestBed</a>()</code> 函数返回的当前运行时间的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 实例上都有对应的方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebkiuu3lh1v5myuwz366l52p3\">在 <code>BeforeEach()</code> 内调用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 方法，以确保在运行每个单独测试时，都有崭新的开始。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bo5rtabfl0612hhvd3ph25se5\">这里列出了最重要的静态方法，以使用频率排序。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xubgaqmffibk0p3s7z4lwoiw\">方法</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>configureTestingModule</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"48vsx9690lmm4831n286wnvh9\">测试填充物（\n<code>karma-test-shim</code>、\n<code>browser-test-shim</code>）建立了\n<a href=\"guide/testing\">初始测试环境</a>和一个默认的测试模块。默认的测试模块配置了基本的声明和一些Angular服务替代品，每个测试者都需要。调用\n<code>configureTestingModule</code>来通过添加和移除导入、声明（组件、指令和管道）、和提供者来完善特定一组测试的测试模块配置。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>compileComponents</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5gqdyie7nnuy5b2mv3il3u63x\">在完成配置测试模块后异步编译它。如果任何测试模块组件具有\n<code>templateUrl</code>或\n<code>styleUrls</code>，必须调用此方法，因为获取组件模板和样式文件必须是异步的。参见\n<a href=\"guide/testing-components-scenarios#compile-components\">compileComponents</a>。\n<br>调用\n<code>compileComponents</code>后，\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>配置将在当前规范的持续时间内被冻结。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>&lt;T&gt;</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dnzovlh0brxir14xbhqzfj64t\">根据当前\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>配置创建一个类型为\n<code>T</code>的组件实例。调用\n<code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code>后，\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>配置将在当前规范的持续时间内被冻结。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>overrideModule</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dcwlurxa90s9g1t0yw4p630rj\">替换给定\n<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>的元数据。请记住模块可以导入其他模块。\n<code>overrideModule</code>方法可以深入到当前测试模块中修改其中一个内部模块。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>overrideComponent</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"65x37t4w0t08uav41bu94zk81\">替换给定组件类的元数据，该组件类可能深嵌于内部模块中。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>overrideDirective</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qxbkcwad4phpironiv1fp0v\">替换给定指令类的元数据，该指令类可能深嵌于内部模块中。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>overridePipe</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cwdrpvzeeqzmtqiukud4kk794\">替换给定管道类的元数据，该管道类可能深嵌于内部模块中。</td>\n</tr>\n</tbody>\n</table>\n<p>|\n<a id=\"testbed-inject\"></a>\n<code>inject</code>                           | Retrieve a service from the current <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> injector. The <code>inject</code> function is often adequate for this purpose. But <code>inject</code> throws an error if it can't provide the service. <br> What if the service is optional? <br> The <code>TestBed.inject()</code> method takes an optional second parameter, the object to return if Angular can't find the provider (<code>null</code> in this example): <code-example header=\"app/demo/demo.testbed.spec.ts\" path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"testbed-get-w-null\">\nexpect(TestBed.inject(NotProvided, null)).toBeNull();\n\n</code-example> After calling <code>TestBed.inject</code>, the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration is frozen for the duration of the current spec. |\n|\n<a id=\"testbed-initTestEnvironment\"></a>\n<code>initTestEnvironment</code> | Initialize the testing environment for the entire test run. <br> The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>) call it for you so there is rarely a reason for you to call it yourself. <br> Call this method <em>exactly once</em>. To change this default in the middle of a test run, call <code>resetTestEnvironment</code> first. <br> Specify the Angular compiler factory, a <code><a href=\"api/core/PlatformRef\" class=\"code-anchor\">PlatformRef</a></code>, and a default Angular testing module. Alternatives for non-browser platforms are available in the general form <code>@angular/platform-&lt;platform_name&gt;/testing/&lt;platform_name&gt;</code>.                                                                  |\n| <code>resetTestEnvironment</code>                                         | Reset the initial test environment, including the default testing module.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ciaa4fwk1y8kqs3h3u537bqko\">少数 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 实例方法没有对应的静态方法。它们很少被使用。</p>\n<p><a id=\"component-fixture-api-summary\"></a></p>\n<h2 id=\"the-componentfixture\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"du0sspe0fcsr8tispqc16v6cr\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 类<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#the-componentfixture\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8jxu75pjtaer6ar696zjxo8tz\"><code>TestBed.createComponent&lt;T&gt;</code> 会创建一个组件 <code>T</code> 的实例，并为该组件返回一个强类型的 <code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"x7819ug205elh76ht3fm9vu4\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 的属性和方法提供了对组件、它的 DOM 和它的 Angular 环境方面的访问。</p>\n<p><a id=\"component-fixture-properties\"></a></p>\n<h3 id=\"componentfixture-properties\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e3huah6nwu81loqdnmihmq6wy\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 的属性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#componentfixture-properties\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5erhswfokpke60pfl8ftj2ovp\">下面是对测试最重要的属性，以使用频率排序。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ghvm54f9feewnb0zbrlubp2h\">属性</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>componentInstance</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"y5xihbd28dnmdyzaudgthxaw\"><code>TestBed.createComponent</code>创建的组件类实例。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>debugElement</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7v6ldcnlw38o2wqmzwoahbzhj\">与该组件根元素关联的\n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。\n<br>\n<code>debugElement</code>在测试和调试期间提供关于组件及其DOM元素的见解。对于测试者来说，这是一个关键属性。其中最有趣的成员在\n<a href=\"guide/testing-utility-apis#debug-element-details\">下面</a>有介绍。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>nativeElement</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4bx76gykh2bj263ordzmaxwnh\">该组件根部的原生DOM元素。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>changeDetectorRef</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ojru5l1yc3ntvrvxnc490hd7\">该组件的\n<code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code>。\n<br>\n<code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code>在测试具有\n<code><a href=\"api/core/ChangeDetectionStrategy#OnPush\" class=\"code-anchor\">ChangeDetectionStrategy.OnPush</a></code>方法或组件的变更检测受您的程序控制时最有价值。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"component-fixture-methods\"></a></p>\n<h3 id=\"componentfixture-methods\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"826ye353l6p6sygu841q6cqk9\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 方法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#componentfixture-methods\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8isoy0gf8gtnjq5ob28umaeit\"><strong>fixture</strong> 方法使 Angular 对组件树执行某些任务。在触发 Angular 行为来模拟的用户行为时，调用这些方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9rge64b4zkeic42ufdz0ewwez\">下面是对测试最有用的方法。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xubgaqmffibk0p3s7z4lwoiw\">方法</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>detectChanges</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3gab8gkd90nxkfiqzsx6i1ajc\">为该组件触发一个变更检测周期。\n<br>调用它来初始化组件（调用\n<code>ngOnInit</code>）并在测试代码之后更改组件的数据绑定属性值。Angular无法察觉您已经更改了\n<code>personComponent.name</code>，直到您调用\n<code>detectChanges</code>。调用\n<code>detectChanges</code>后运行\n<code>checkNoChanges</code>来确认没有循环更新，除非以\n<code>detectChanges(false)</code>调用。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>autoDetectChanges</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"740s4usk78jokyzwxsbicek\">当您希望夹具自动检测变化时，请将其设置为\n<code>true</code>。\n<br>当自动检测为\n<code>true</code>时，测试夹具在创建组件后立即调用\n<code>detectChanges</code>。然后它监听相关区域事件并相应调用\n<code>detectChanges</code>。当测试代码直接修改组件属性值时，您可能仍需要调用\n<code>fixture.detectChanges</code>来触发数据绑定更新。\n<br>默认值为\n<code>false</code>。喜欢对测试行为进行精细控制的测试者倾向于保持为\n<code>false</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>checkNoChanges</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e89qpncijtzcmhplhx3pmc5ge\">执行变更检测运行以确保没有待处理的更改。如果有待处理更改，则会抛出异常。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>isStable</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cr3adby9pzk4ksw5v8pcnra7k\">如果夹具当前\n<em>稳定</em>，则返回\n<code>true</code>。如果有尚未完成的异步任务，则返回\n<code>false</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>whenStable</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"578qgdgogeawlih5ty8fxi4r7\">返回一个在夹具稳定时解析的Promise。\n<br>在完成异步活动或异步变更检测后恢复测试时，请连接该Promise。查看\n<a href=\"guide/testing-components-scenarios#when-stable\">whenStable</a>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>destroy</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4qt5og7tutemtxiw5qbiw1u8\">触发组件的销毁。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"debug-element-details\"></a></p>\n<h4 id=\"debugelement\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#debugelement\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"h70kbrvqjdc5y6090e7s8gka\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 提供了对组件的 DOM 的访问。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ajhijkdjdz4fao8b6lc4djs1r\"><code>fixture.debugElement</code> 返回测试根组件的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>，通过它你可以访问（查询）fixture 的整个元素和组件子树。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"36d5302u6jvz20rpeef4akojn\">下面是 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 最有用的成员，以使用频率排序。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e62kgm2ztk7rgk6auybfiv91o\">成员</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>nativeElement</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dkb0s45orw521d0pkobqk7vsh\">浏览器中对应的 DOM 元素</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ghiykb3aaaebayh6qik71057\">调用 \n<code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&lt;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>&gt;)</code> 返回在子树中任意深度匹配 \n<a href=\"guide/testing-utility-apis#query-predicate\">谓词</a> 的第一个 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>queryAll</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"emrmbdlple9yz6w84csy4q5ww\">调用 \n<code>queryAll(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&lt;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>&gt;)</code> 返回在子树中任意深度匹配 \n<a href=\"guide/testing-utility-apis#query-predicate\">谓词</a> 的所有 \n<code>DebugElement</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>injector</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1yyfov98r97huxz9pmipkq99f\">宿主依赖注入器。例如，根元素的组件实例注入器。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>componentInstance</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bx8lkfdxy9d5a7lqvgrjv63cq\">元素自己的组件实例（如果有）。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>context</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1bf6yxcsm704022irvjked14c\">为该元素提供父上下文的对象。通常是控制该元素的祖先组件实例。\n<br> 当一个元素在 \n<code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 中重复时，上下文是一个 \n<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code>，其 \n<code>$implicit</code> 属性是行实例值的值。例如，在 \n<code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"</code> 中的 \n<code>hero</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>children</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6fbeyiffh9vkkaasrs0nqx269\">直接的 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 子元素。通过向下遍历 \n<code>children</code> 遍历树。\n<div class=\"alert is-helpful\"> \n <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 还有 \n <code>childNodes</code>，一个 \n <code><a href=\"api/core/DebugNode\" class=\"code-anchor\">DebugNode</a></code> 对象列表。 \n <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 源自 \n <code><a href=\"api/core/DebugNode\" class=\"code-anchor\">DebugNode</a></code> 对象，通常节点比元素多。测试人员通常可以忽略普通节点。 \n</div></td>\n</tr>\n<tr>\n<td align=\"left\"><code>parent</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1dj53aq360hj12jwabl2f3hb8\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 的父元素。如果这是根元素，则为 Null。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>name</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cbepw70acdtphjqvvurasmrph\">元素令牌名称（如果是元素）。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>triggerEventHandler</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5wy91v2z7l2znwrzb2khedxc2\">如果元素的 \n<code>listeners</code> 集合中存在相应的监听器，则触发事件的名称。第二个参数是处理程序期望的 \n<em>事件对象</em>。参见 \n<a href=\"guide/testing-components-scenarios#trigger-event-handler\">triggerEventHandler</a>。 \n<br> 如果事件缺少监听器或存在其他问题，请考虑调用 \n<code>nativeElement.dispatchEvent(eventObject)</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>listeners</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4h318sfg8s6m8f4zmxgl33xeb\">附加到组件的 \n<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 属性和/或元素的事件属性的回调。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>providerTokens</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29hd6bn1yhrbf64nsrs1y7a8e\">该组件的注入器查找令牌。包括组件本身和组件在其 \n<code>providers</code> 元数据中列出的令牌。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>source</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c5w6zws5rt4fuwyfua0ff831o\">在源组件模板中查找此元素的位置。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>references</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4zdpmsmry1zmzstlbnyvkkary\">与模板局部变量（例如，\n<code>#foo</code>）关联的对象字典，按本地变量名称索引。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"query-predicate\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"be3egqzam3i45izu2jr4gvqi\"><code>DebugElement.query(predicate)</code> 和 <code>DebugElement.queryAll(predicate)</code> 方法接受一个条件方法，它过滤源元素的子树，返回匹配的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7khwhyi0djva20qs82kiizt8k\">这个条件方法是任何接受一个 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 并返回真值的方法。下面的例子查询所有拥有名为 <code>content</code> 的模块本地变量的所有 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>：</p>\n<code-example header=\"app/demo/demo.testbed.spec.ts\" path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"custom-predicate\">\n// Filter for DebugElements with a #content reference\nconst contentRefs = el.queryAll((de) =&gt; de.references['content']);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2g7nx3c239ssvmer9ummwxmd1\">Angular 的 <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 类为常用条件方法提供了三个静态方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9zoyyca4y8znurrr61rj7hxy5\">静态方法</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>By.all</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"87rly5szcna46j3sqogoax2b3\">返回所有元素</td>\n</tr>\n<tr>\n<td align=\"left\"><code>By.css(selector)</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efnrayosjm3j82avjr8fcs2r1\">返回具有匹配的 CSS 选择器的元素</td>\n</tr>\n<tr>\n<td align=\"left\"><code>By.directive(directive)</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ax2pgez6g5hflk977bjzqt2ry\">返回 Angular 匹配到指令类的实例的元素</td>\n</tr>\n</tbody>\n</table>\n<code-example header=\"app/hero/hero-list.component.spec.ts\" path=\"testing/src/app/hero/hero-list.component.spec.ts\" region=\"by\">\n// Can find <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> either by css selector or by directive\nconst h2 = fixture.debugElement.query(By.css('h2'));\nconst directive = fixture.debugElement.query(By.directive(HighlightDirective));\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Thu Sep 07 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/DebugElement\n - guide/testing\n - guide/testing-components-scenarios\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/NgFor\n - api/common/NgForOf\n - api/core/ChangeDetectionStrategy#OnPush\n - api/core/ChangeDetectorRef\n - api/core/Component\n - api/core/DebugElement\n - api/core/DebugNode\n - api/core/Directive\n - api/core/NgModule\n - api/core/Output\n - api/core/Pipe\n - api/core/PlatformRef\n - api/core/Predicate\n - api/core/SchemaMetadata\n - api/core/createComponent\n - api/core/testing/ComponentFixture\n - api/core/testing/ComponentFixtureAutoDetect\n - api/core/testing/MetadataOverride\n - api/core/testing/TestBed\n - api/core/testing/TestModuleMetadata\n - api/core/testing/discardPeriodicTasks\n - api/core/testing/fakeAsync\n - api/core/testing/flushMicrotasks\n - api/core/testing/getTestBed\n - api/core/testing/tick\n - api/core/testing/waitForAsync\n - api/platform-browser/By\n - guide/testing\n - guide/testing-components-scenarios#automatic-change-detection\n - guide/testing-components-scenarios#compile-components\n - guide/testing-components-scenarios#fake-async\n - guide/testing-components-scenarios#get-injected-services\n - guide/testing-components-scenarios#tick\n - guide/testing-components-scenarios#trigger-event-handler\n - guide/testing-components-scenarios#waitForAsync\n - guide/testing-components-scenarios#when-stable\n - guide/testing-utility-apis#component-fixture-api-summary\n - guide/testing-utility-apis#componentfixture-methods\n - guide/testing-utility-apis#componentfixture-properties\n - guide/testing-utility-apis#debug-element-details\n - guide/testing-utility-apis#debugelement\n - guide/testing-utility-apis#query-predicate\n - guide/testing-utility-apis#testbed-api-summary\n - guide/testing-utility-apis#testbed-class-summary\n - guide/testing-utility-apis#testing-utility-apis\n - guide/testing-utility-apis#the-componentfixture\n - https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules\n-->"}