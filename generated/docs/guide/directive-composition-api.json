{"id":"guide/directive-composition-api","title":"指令组合 API","contents":"<div class=\"content\">\n  <h1 id=\"directive-composition-api\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8a1v1libqy1ysmkczr9wna5t8\">指令组合 API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-composition-api\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6d097y7skqha9j20sfq2xq4cc\">Angular 指令提供了一种封装可复用行为的好方法 —— 指令可以将属性、CSS 类和事件侦听器应用于元素。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ws6ob45twscc2spkxm67g5da\"><em>指令组合 API</em> 允许你从组件的 TypeScript 类<strong>内部</strong>将指令应用于组件的宿主元素。</p>\n<h2 id=\"adding-directives-to-a-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bfznth9bruqo3y02n45jciu14\">向组件添加指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-a-component\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35z02jxvt7a2ebduo48nz2gda\">你可以通过将 <code>hostDirectives</code> 属性添加到组件的装饰器来将指令应用于组件。我们称这样的指令为<em>宿主指令</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vsgsro5a7qeoru36zp6ps9o3\">在此示例中，我们将指令 <code>MenuBehavior</code> 应用于 <code>AdminMenu</code> 的宿主元素。这类似于将 <code>MenuBehavior</code> 应用于模板中的 <code>&lt;admin-menu&gt;</code> 元素。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [MenuBehavior],\n})\nexport class AdminMenu { }\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rmbpbsmljwdcuwxehna308th\">当框架渲染组件时，Angular 还会创建每个宿主指令的实例。指令的宿主绑定被应用于组件的宿主元素。默认情况下，宿主指令的输入和输出不会作为组件公共 API 的一部分公开。有关更多信息，请参阅下面的<a href=\"guide/directive-composition-api#including-inputs-and-outputs\">包含输入属性和输出属性</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7h9j7dah45e32dz1vn7kydiuw\"><strong>Angular 会在编译时静态应用宿主指令</strong>。你不能在运行时动态添加指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35np9bo495typccy16f7ya8ey\"><strong><code>hostDirectives</code> 中使用的指令必须是 <code>standalone: true</code> 的。</strong></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ddwd7tmtq1khu04633qnst0fe\"><strong>Angular 会忽略 <code>hostDirectives</code> 属性中所应用的那些指令的 <code>selector</code>。</strong></p>\n<h2 id=\"including-inputs-and-outputs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"buwbz4db0oufcnpjc6hf6azr6\">包含输入属性和输出属性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#including-inputs-and-outputs\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dbk6kqocg818k13k81mt6yyr3\">默认情况下，当你将 <code>hostDirectives</code> 应用于组件时，宿主指令的输入属性和输出属性不会包含在组件的 API 中。你可以通过扩展 <code>hostDirectives</code> 中的条目来在组件的 API 中显式包含输入和输出：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId'],\n    outputs: ['menuClosed'],\n  }],\n})\nexport class AdminMenu { }\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2a3kwvu0e0pfmbjpllepgsv7i\">通过显式指定输入和输出，使用 <code>hostDirective</code> 的组件的使用者可以将它们绑定在模板中：</p>\n<code-example language=\"html\">\n&lt;admin-menu menuId=\"top-menu\" (menuClosed)=\"logMenuClosed()\"&gt;\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76n85hjd6yz6qh60isti0zr88\">此外，你可以为 <code>hostDirective</code> 的输入和输出起别名来自定义组件的 API：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId: id'],\n    outputs: ['menuClosed: closed'],\n  }],\n})\nexport class AdminMenu { }\n</code-example>\n<code-example language=\"html\">\n&lt;admin-menu id=\"top-menu\" (closed)=\"logMenuClosed()\"&gt;\n</code-example>\n<h2 id=\"adding-directives-to-another-directive\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekgryson3ukx8dynkbxh78gty\">将指令添加到另一个指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-another-directive\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3841u34bqq02ly39zpb3ih9x9\">除了组件之外，你还可以将 <code>hostDirectives</code> 添加到其他指令。这启用了多个行为的可传递聚合能力。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4djqwfu6szsadf0ht15g1pawy\">在以下示例中，我们定义了两个指令，<code>Menu</code> 和 <code>Tooltip</code>。然后，我们会在 <code>MenuWithTooltip</code> 中组合这两个指令的行为。最后，我们将 <code>MenuWithTooltip</code> 应用到 <code>SpecializedMenuWithTooltip</code> 上。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xttbk8auccnhk2vw86h5mv4x\">在模板中使用 <code>SpecializedMenuWithTooltip</code> 时，它会创建 <code>Menu</code>、<code>Tooltip</code> 和 <code>MenuWithTooltip</code> 的所有实例。这些指令的宿主绑定中的每一个都会应用于 <code>SpecializedMenuWithTooltip</code> 的宿主元素。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Menu { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Tooltip { }\n\n// MenuWithTooltip can compose behaviors from <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> other directives\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  standalone: true,\n  hostDirectives: [Tooltip, Menu],\n})\nexport class MenuWithTooltip { }\n\n// CustomWidget can apply the already-composed behaviors from MenuWithTooltip\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  standalone: true,\n  hostDirectives: [MenuWithTooltip],\n})\nexport class SpecializedMenuWithTooltip { }\n</code-example>\n<h2 id=\"host-directive-semantics\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"23msxy7v94bus6ywl0qxavacw\">宿主指令语义<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#host-directive-semantics\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"directive-execution-order\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"13x6o5s56edpkaqkyobjz9oh1\">指令的执行顺序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-execution-order\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cuikgzlmee9hp708dictk9nk7\">宿主指令与直接在模板中使用的组件和指令具有相同的生命周期。但是，宿主指令总是先执行它们的构造函数、生命周期钩子和绑定，然后再执行应用它们的组件或指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aytf36j1wcvhopntf3v2htwd\">以下示例显示了宿主指令的最小化使用：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [MenuBehavior],\n})\nexport class AdminMenu { }\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3lvx2has93wkhvsd7lpoxcu7p\">这里的执行顺序是：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4u6sd4pqngp9zfpj1xelnv9sa\"><code>MenuBehavior</code> 实例化</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4n5cq9dnev1lwqhbi9qbvwrzg\"><code>AdminMenu</code> 实例化</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9quff6k5xi1fy8rxoxloqg0kw\"><code>MenuBehavior</code> 接收输入（ <code>ngOnInit</code> ）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44apjcz2oj66djenrxdiwjyks\"><code>AdminMenu</code> 接收输入（<code>ngOnInit</code>）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"881trtoldxhtf2upj60g5v7rt\"><code>MenuBehavior</code> 应用宿主绑定</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"22j5dc683xt5zl04ok0il14bf\"><code>AdminMenu</code> 应用宿主绑定</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a02c9odxjrgn7lqmkjdcjvlcf\">这种操作顺序意味着带有 <code>hostDirectives</code> 的组件可以改写（override）宿主指令指定的任何宿主绑定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"525haxl4283e1e2vv0hbiimwl\">展开宿主指令的嵌套链的操作顺序，如下例所示。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Tooltip { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  standalone: true,\n  hostDirectives: [Tooltip],\n})\nexport class CustomTooltip { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  standalone: true,\n  hostDirectives: [CustomTooltip],\n})\nexport class EvenMoreCustomTooltip { }\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xsdsy62sz91ii5rk01isruez\">在上面的示例中，执行顺序是：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2yioat4wd1bf4jzqcs9dmtrdh\"><code>Tooltip</code> 实例化</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6sz9w2687vzpkxghaoxq2ymxk\"><code>CustomTooltip</code> 实例化</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3mpc1umjzhx31b5j2z4y63pp\"><code>EvenMoreCustomTooltip</code> 实例化</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1wpw7bh0bleqb1fxn7z1dgwm6\"><code>Tooltip</code> 接收输入（<code>ngOnInit</code>）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cu7hhy4qavyl7ciojwlotz46q\"><code>CustomTooltip</code> 接收输入（<code>ngOnInit</code>）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dfg1cm3c2f6ld1q5736if4pfv\"><code>EvenMoreCustomTooltip</code> 接收输入（<code>ngOnInit</code>）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3v939gumd2siow60l6uysl5ax\"><code>Tooltip</code> 应用宿主绑定</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46m0mrul2vzlwkv1kn5647wu8\"><code>CustomTooltip</code> 应用宿主绑定</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"chekmqubml9zqwwo34pc129lh\"><code>EvenMoreCustomTooltip</code> 应用宿主绑定</li>\n</ol>\n<h3 id=\"dependency-injection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ev35fdpq1f46jvj853hmazgoj\">依赖注入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#dependency-injection\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brmjdpq54dqhlzq4f4nxcugo3\">指定了 <code>hostDirectives</code> 的组件或指令可以注入这些宿主指令的实例，反之亦然。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2rfnva1z92ijdxg6ggmc87u0s\">当把宿主指令应用于组件时，组件和宿主指令都可以定义提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ds3avc82pdau0leelb4heixm3\">如果带有 <code>hostDirectives</code> 的组件或指令以及这些宿主指令都提供相同的注入令牌，则带有 <code>hostDirectives</code> 的类定义的提供者会优先于宿主指令定义的提供者。</p>\n<h3 id=\"performance\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8s0ocbaf1jhr9dof0kznoo4ov\">性能<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#performance\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"egcrgkkv45s854w3p546k9azc\">虽然指令组合 API 提供了一个强大的工具来复用常见行为，但过度使用宿主指令会影响应用程序的内存使用。如果你创建使用<em>许多个</em>宿主指令的组件或指令，你可能会无意中让应用程序占用的内存膨胀。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"20vldkngtq1qdalhpywvzxtvx\">以下示例显示了一个应用多个宿主指令的组件。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  hostDirectives: [\n    DisabledState,\n    RequiredState,\n    ValidationState,\n    ColorState,\n    RippleBehavior,\n  ],\n})\nexport class CustomCheckbox { }\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6p2mwsotk87w6ouslk0rr2wk8\">此示例声明了一个自定义复选框组件，其中包含五个宿主指令。这意味着每次 <code>CustomCheckbox</code> 渲染时，Angular 将创建六个对象 —— 组件用一个，每个宿主指令用一个。对于页面上的少量复选框，这不会构成任何重大问题。但是，如果你的页面渲染<em>数百个</em>复选框（例如在表格中），那么你可能会开始看到额外对象分配的影响。始终确保对你的应用程序进行性能剖析，以便为你的用例确定正确的组合模式。</p>\n\n  <div class=\"reviewed\">最后复查时间：Sun Dec 11 2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/Directive\n - api/forms/SelectMultipleControlValueAccessor\n - guide/directive-composition-api#adding-directives-to-a-component\n - guide/directive-composition-api#adding-directives-to-another-directive\n - guide/directive-composition-api#dependency-injection\n - guide/directive-composition-api#directive-composition-api\n - guide/directive-composition-api#directive-execution-order\n - guide/directive-composition-api#host-directive-semantics\n - guide/directive-composition-api#including-inputs-and-outputs\n - guide/directive-composition-api#performance\n-->"}