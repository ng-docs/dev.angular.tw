{"id":"guide/directive-composition-api","title":"指令組合 API","contents":"<div class=\"content\">\n  <h1 id=\"directive-composition-api\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8a1v1libqy1ysmkczr9wna5t8\">指令組合 API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-composition-api\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6d097y7skqha9j20sfq2xq4cc\">Angular 指令提供了一種封裝可複用行為的好方法 —— 指令可以將屬性、CSS 類別和事件偵聽器應用於元素。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ws6ob45twscc2spkxm67g5da\"><em>指令組合 API</em> 允許你從元件的 TypeScript 類別<strong>內部</strong>將指令應用於元件的宿主元素。</p>\n<h2 id=\"adding-directives-to-a-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bfznth9bruqo3y02n45jciu14\">向元件新增指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-a-component\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35z02jxvt7a2ebduo48nz2gda\">你可以透過將 <code>hostDirectives</code> 屬性新增到元件的裝飾器來將指令應用於元件。我們稱這樣的指令為<em>宿主指令</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vsgsro5a7qeoru36zp6ps9o3\">在此範例中，我們將指令 <code>MenuBehavior</code> 應用於 <code>AdminMenu</code> 的宿主元素。這類似於將 <code>MenuBehavior</code> 應用於範本中的 <code>&lt;admin-menu&gt;</code> 元素。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [MenuBehavior],\n})\nexport class AdminMenu { }\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rmbpbsmljwdcuwxehna308th\">當框架渲染元件時，Angular 還會建立每個宿主指令的實例。指令的宿主繫結被應用於元件的宿主元素。預設情況下，宿主指令的輸入和輸出不會作為元件公共 API 的一部分公開。有關更多訊息，請參閱下面的<a href=\"guide/directive-composition-api#including-inputs-and-outputs\">包含輸入屬性和輸出屬性</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7h9j7dah45e32dz1vn7kydiuw\"><strong>Angular 會在編譯時靜態應用宿主指令</strong>。你不能在執行時動態新增指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35np9bo495typccy16f7ya8ey\"><strong><code>hostDirectives</code> 中使用的指令必須是 <code>standalone: true</code> 的。</strong></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ddwd7tmtq1khu04633qnst0fe\"><strong>Angular 會忽略 <code>hostDirectives</code> 屬性中所應用的那些指令的 <code>selector</code>。</strong></p>\n<h2 id=\"including-inputs-and-outputs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"buwbz4db0oufcnpjc6hf6azr6\">包含輸入屬性和輸出屬性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#including-inputs-and-outputs\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dbk6kqocg818k13k81mt6yyr3\">預設情況下，當你將 <code>hostDirectives</code> 應用於元件時，宿主指令的輸入屬性和輸出屬性不會包含在元件的 API 中。你可以透過擴充套件 <code>hostDirectives</code> 中的條目來在元件的 API 中顯式包含輸入和輸出：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId'],\n    outputs: ['menuClosed'],\n  }],\n})\nexport class AdminMenu { }\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2a3kwvu0e0pfmbjpllepgsv7i\">透過顯式指定輸入和輸出，使用 <code>hostDirective</code> 的元件的使用者可以將它們繫結在範本中：</p>\n<code-example language=\"html\">\n&lt;admin-menu menuId=\"top-menu\" (menuClosed)=\"logMenuClosed()\"&gt;\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76n85hjd6yz6qh60isti0zr88\">此外，你可以為 <code>hostDirective</code> 的輸入和輸出起別名來自定義元件的 API：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId: id'],\n    outputs: ['menuClosed: closed'],\n  }],\n})\nexport class AdminMenu { }\n</code-example>\n<code-example language=\"html\">\n&lt;admin-menu id=\"top-menu\" (closed)=\"logMenuClosed()\"&gt;\n</code-example>\n<h2 id=\"adding-directives-to-another-directive\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekgryson3ukx8dynkbxh78gty\">將指令新增到另一個指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-another-directive\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3841u34bqq02ly39zpb3ih9x9\">除了元件之外，你還可以將 <code>hostDirectives</code> 新增到其他指令。這啟用了多個行為的可傳遞聚合能力。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4djqwfu6szsadf0ht15g1pawy\">在以下範例中，我們定義了兩個指令，<code>Menu</code> 和 <code>Tooltip</code>。然後，我們會在 <code>MenuWithTooltip</code> 中組合這兩個指令的行為。最後，我們將 <code>MenuWithTooltip</code> 應用到 <code>SpecializedMenuWithTooltip</code> 上。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xttbk8auccnhk2vw86h5mv4x\">在範本中使用 <code>SpecializedMenuWithTooltip</code> 時，它會建立 <code>Menu</code>、<code>Tooltip</code> 和 <code>MenuWithTooltip</code> 的所有實例。這些指令的宿主繫結中的每一個都會應用於 <code>SpecializedMenuWithTooltip</code> 的宿主元素。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Menu { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Tooltip { }\n\n// MenuWithTooltip can compose behaviors from <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> other directives\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  standalone: true,\n  hostDirectives: [Tooltip, Menu],\n})\nexport class MenuWithTooltip { }\n\n// CustomWidget can apply the already-composed behaviors from MenuWithTooltip\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  standalone: true,\n  hostDirectives: [MenuWithTooltip],\n})\nexport class SpecializedMenuWithTooltip { }\n</code-example>\n<h2 id=\"host-directive-semantics\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"23msxy7v94bus6ywl0qxavacw\">宿主指令語義<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#host-directive-semantics\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"directive-execution-order\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"13x6o5s56edpkaqkyobjz9oh1\">指令的執行順序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-execution-order\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cuikgzlmee9hp708dictk9nk7\">宿主指令與直接在範本中使用的元件和指令具有相同的生命週期。但是，宿主指令總是先執行它們的建構式函式、生命週期鉤子和繫結，然後再執行應用它們的元件或指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aytf36j1wcvhopntf3v2htwd\">以下範例顯示了宿主指令的最小化使用：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [MenuBehavior],\n})\nexport class AdminMenu { }\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3lvx2has93wkhvsd7lpoxcu7p\">這裡的執行順序是：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4u6sd4pqngp9zfpj1xelnv9sa\"><code>MenuBehavior</code> 實例化</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4n5cq9dnev1lwqhbi9qbvwrzg\"><code>AdminMenu</code> 實例化</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9quff6k5xi1fy8rxoxloqg0kw\"><code>MenuBehavior</code> 接收輸入（ <code>ngOnInit</code> ）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44apjcz2oj66djenrxdiwjyks\"><code>AdminMenu</code> 接收輸入（<code>ngOnInit</code>）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"881trtoldxhtf2upj60g5v7rt\"><code>MenuBehavior</code> 應用宿主繫結</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"22j5dc683xt5zl04ok0il14bf\"><code>AdminMenu</code> 應用宿主繫結</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a02c9odxjrgn7lqmkjdcjvlcf\">這種操作順序意味著帶有 <code>hostDirectives</code> 的元件可以改寫（override）宿主指令指定的任何宿主繫結。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"525haxl4283e1e2vv0hbiimwl\">展開宿主指令的巢狀鏈的操作順序，如下例所示。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Tooltip { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  standalone: true,\n  hostDirectives: [Tooltip],\n})\nexport class CustomTooltip { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  standalone: true,\n  hostDirectives: [CustomTooltip],\n})\nexport class EvenMoreCustomTooltip { }\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xsdsy62sz91ii5rk01isruez\">在上面的範例中，執行順序是：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2yioat4wd1bf4jzqcs9dmtrdh\"><code>Tooltip</code> 實例化</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6sz9w2687vzpkxghaoxq2ymxk\"><code>CustomTooltip</code> 實例化</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3mpc1umjzhx31b5j2z4y63pp\"><code>EvenMoreCustomTooltip</code> 實例化</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1wpw7bh0bleqb1fxn7z1dgwm6\"><code>Tooltip</code> 接收輸入（<code>ngOnInit</code>）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cu7hhy4qavyl7ciojwlotz46q\"><code>CustomTooltip</code> 接收輸入（<code>ngOnInit</code>）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dfg1cm3c2f6ld1q5736if4pfv\"><code>EvenMoreCustomTooltip</code> 接收輸入（<code>ngOnInit</code>）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3v939gumd2siow60l6uysl5ax\"><code>Tooltip</code> 應用宿主繫結</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46m0mrul2vzlwkv1kn5647wu8\"><code>CustomTooltip</code> 應用宿主繫結</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"chekmqubml9zqwwo34pc129lh\"><code>EvenMoreCustomTooltip</code> 應用宿主繫結</li>\n</ol>\n<h3 id=\"dependency-injection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ev35fdpq1f46jvj853hmazgoj\">依賴注入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#dependency-injection\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brmjdpq54dqhlzq4f4nxcugo3\">指定了 <code>hostDirectives</code> 的元件或指令可以注入這些宿主指令的實例，反之亦然。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2rfnva1z92ijdxg6ggmc87u0s\">當把宿主指令應用於元件時，元件和宿主指令都可以定義提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ds3avc82pdau0leelb4heixm3\">如果帶有 <code>hostDirectives</code> 的元件或指令以及這些宿主指令都提供相同的注入令牌，則帶有 <code>hostDirectives</code> 的類別定義的提供者會優先於宿主指令定義的提供者。</p>\n<h3 id=\"performance\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8s0ocbaf1jhr9dof0kznoo4ov\">效能<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#performance\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"egcrgkkv45s854w3p546k9azc\">雖然指令組合 API 提供了一個強大的工具來復用常見行為，但過度使用宿主指令會影響應用程式的記憶體使用。如果你建立使用<em>許多個</em>宿主指令的元件或指令，你可能會無意中讓應用程式佔用的記憶體膨脹。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"20vldkngtq1qdalhpywvzxtvx\">以下範例顯示了一個應用多個宿主指令的元件。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  hostDirectives: [\n    DisabledState,\n    RequiredState,\n    ValidationState,\n    ColorState,\n    RippleBehavior,\n  ],\n})\nexport class CustomCheckbox { }\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6p2mwsotk87w6ouslk0rr2wk8\">此範例宣告了一個自定義複選框元件，其中包含五個宿主指令。這意味著每次 <code>CustomCheckbox</code> 渲染時，Angular 將建立六個物件 —— 元件用一個，每個宿主指令用一個。對於頁面上的少量複選框，這不會構成任何重大問題。但是，如果你的頁面渲染<em>數百個</em>複選框（例如在表格中），那麼你可能會開始看到額外物件分配的影響。始終確保對你的應用程式進行效能剖析，以便為你的用例確定正確的組合模式。</p>\n\n  <div class=\"reviewed\">最後複查時間：Sun Dec 11 2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/Directive\n - api/forms/SelectMultipleControlValueAccessor\n - guide/directive-composition-api#adding-directives-to-a-component\n - guide/directive-composition-api#adding-directives-to-another-directive\n - guide/directive-composition-api#dependency-injection\n - guide/directive-composition-api#directive-composition-api\n - guide/directive-composition-api#directive-execution-order\n - guide/directive-composition-api#host-directive-semantics\n - guide/directive-composition-api#including-inputs-and-outputs\n - guide/directive-composition-api#performance\n-->"}