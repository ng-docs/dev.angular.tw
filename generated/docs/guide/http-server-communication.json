{"id":"guide/http-server-communication","title":"HTTP 服务器通信","contents":"<div class=\"content\">\n  <h1 id=\"http-server-communication\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c6jyhy0apt7egi5vz3v7fhxi0\">HTTP 服务器通信<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#http-server-communication\"><i class=\"material-icons\">link</i></a></h1>\n<div class=\"callout is-critical\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4r7c5x5y77wbuducanio6c3fk\">已标记为归档</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58k4b2kechaaj13ikfgyyx6om\">为确保你拥有最佳的体验，本主题已标记为归档，直到我们确定其清楚地传达了最准确的信息为止。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"14o6dxnk9jlkg9rvrp8rwgbxx\">同时，这个主题可能会有所帮助：\n<a href=\"guide/understanding-communicating-with-http\">理解 HTTP</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ck2tsrjevyy0r4iofzx0sxxow\">如果你认为不应将此内容归档，请提交 <a href=\"https://github.com/angular/angular/issues/new?template=3-docs-bug.md\">GitHub 问题</a>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ltroklxc89e67u8z64sjywja\">大多数前端应用程序都要通过 HTTP 协议与服务器通信，以下载或上传数据以及访问其他后端服务。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"825eao4iba4fhy9p6nqsxm4rv\">你可以运行伴随本指南的\n<live-example name=\"http\"></live-example>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1sk4fms7erqf4qx3irr8zszi3\">示例应用不需要数据服务器。它依赖于 <a href=\"https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api\">Angular 的 <em>in-memory-web-api</em></a>，该模块替换了 <em>HttpClient</em> 模块的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>。这个替代服务模拟了 REST 后端的行为。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b6ph0mm4o8imlqvq821l565tf\">查看\n<code>main.ts</code>中的\n<code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>()</code>方法，了解它的配置方式。</p>\n</div>\n<h2 id=\"setup-for-server-communication\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drfz25zlex7bh5azzvm789p2g\">服务器通讯的准备工作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#setup-for-server-communication\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5kfjdwvvplbde9u7aqeyu8mz0\">在使用\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>之前，你需要提供 Angular 的\n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，以便将其注入到需要的类中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"93o4x5ug8shpbv7cfuwuexjub\">大多数开发人员在\n<code>main.ts</code>中使用\n<code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code>初始化应用程序时提供\n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，使用\n<code>app.config.ts</code>导出的\n<code><a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a></code>，如下所示：</p>\n<code-example header=\"main.ts (excerpt)\" path=\"http/src/main.ts\" region=\"sketch\">\nimport { <a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a> } from '@angular/platform-browser';\n\nimport {AppComponent} from './app/app.component';\nimport { appConfig } from './app/app.config';\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(AppComponent, appConfig);\n\n</code-example>\n<code-example header=\"app.config.ts (excerpt)\" path=\"http/src/app/app.config.ts\" region=\"sketch\">\nimport { <a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\nimport { <a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a> } from '@angular/core';\n\nexport const appConfig: <a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a> = {\n  providers: [\n    <a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a>(<a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>),\n  ]\n};\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"331ts4mya4jref7tcaixpsyvo\">然后，你可以把 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务注入成一个应用类的依赖项，如下面的 <code>ConfigService</code> 例子所示。</p>\n<code-example header=\"app/config/config.service.ts (excerpt)\" path=\"http/src/app/config/config.service.ts\" region=\"proto\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class ConfigService {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n}\n\n</code-example>\n<h2 id=\"requesting-data-from-a-server\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"difnh6xnxe57i52vs39z3pfhg\">从服务器请求数据<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#requesting-data-from-a-server\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9iwcu8kvtfnoi1aqwc4ldl2tw\">使用 <a href=\"api/common/http/HttpClient#get\"><code>HttpClient.get()</code></a> 方法从服务器获取数据。该异步方法会发送一个 HTTP 请求，并返回一个 Observable，它会在收到响应时发出所请求到的数据。返回的类型取决于你调用时传入的 <code>observe</code> 和 <code>responseType</code> 参数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvt08oxjx84svpni5zfb128os\"><code>get()</code> 方法有两个参数。要获取的端点 URL，以及一个可以用来配置请求的<em>选项</em>对象。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  headers?: <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a> | {[header: string]: string | string[]},\n  observe?: 'body' | 'events' | 'response',\n  params?: <a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a>|{[param: string]: string | number | boolean | ReadonlyArray&lt;string | number | boolean&gt;},\n  reportProgress?: boolean,\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  withCredentials?: boolean,\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6gnfyfqlgzdzt8qbnoy82r276\">这些重要的选项包括 <em>observe</em> 和 <em>responseType</em> 属性。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3liy686p15pg85we3xy31lzj\"><em>observe</em> 选项用于指定要返回的响应内容。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"avg46mevx4xn0ysr0gdnpmnsp\"><em>responseType</em> 选项指定返回数据的格式。</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ewbie7vv6vw52vehuoye7mfv\">使用 <code>options</code> 对象来配置外发请求的其他方面。例如，在添加标头信息时，此服务会使用 <code>headers</code> 选项的属性来设置默认头信息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d0nb21sd39kbmffze9f2gi7gl\">使用 <code>params</code> 属性来配置带有 HTTP URL 参数的请求，使用 <code>reportProgress</code> 选项来监听传输大量数据时的进度事件。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2067w6sicuum77gf96p6j5spx\">应用经常会从服务器请求 JSON 数据。在 <code>ConfigService</code> 例子中，该应用需要服务器 <code>config.json</code> 上的一个配置文件来指定资源的 URL。</p>\n<code-example header=\"assets/config.json\" path=\"http/src/assets/config.json\">\n{\n  \"heroesUrl\": \"api/heroes\",\n  \"textfile\": \"assets/textfile.txt\",\n  \"date\": \"2020-01-29\"\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"62zlx0mf26khwl8vfs84nmejl\">要获取这类数据，<code>get()</code> 调用需要以下几个选项：<code>{observe: 'body', responseType: 'json'}</code>。这些是这些选项的默认值，所以下面的例子不会传递 options 对象。后面几节展示了一些额外的选项。</p>\n<p><a id=\"config-service\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jd89k2kmvm6v7jr80y5hcnmr\">这个例子符合通过定义一个可复用的可<a href=\"guide/glossary#service\" title=\"服务定义\">注入服务</a>来执行数据处理功能来创建可伸缩解决方案的最佳实践。除了提取数据外，该服务还可以对数据进行后处理，添加错误处理，并添加重试逻辑。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1j2x6ooh7driafi6tiskdc5d5\"><code>ConfigService</code> 使用 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 方法获取这个文件。</p>\n<code-example header=\"app/config/config.service.ts (getConfig v.1)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_1\">\nconfigUrl = 'assets/config.json';\n\ngetConfig() {\n  return this.http.get&lt;Config&gt;(this.configUrl);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5su2w3y7k38fzey13tmcy39w2\"><code>ConfigComponent</code> 注入了 <code>ConfigService</code> 并调用了 <code>getConfig</code> 服务方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6hqt7ahdya6iam3pianmwhmir\">由于该服务方法返回了一个 <code>Observable</code> 配置数据，该组件会<em>订阅</em>该方法的返回值。订阅回调只会对后处理进行最少量的处理。它会把数据字段复制到组件的 <code>config</code> 对象中，该对象在组件模板中是数据绑定的，用于显示。</p>\n<code-example header=\"app/config/config.component.ts (showConfig v.1)\" path=\"http/src/app/config/config.component.ts\" region=\"v1\">\nconstructor(private configService: ConfigService) {}\n\nshowConfig() {\n  this.configService.getConfig()\n    .subscribe(data =&gt; this.config = {\n        heroesUrl: data.heroesUrl,\n        textfile:  data.textfile,\n        date: data.date,\n    });\n}\n\n</code-example>\n<p><a id=\"always-subscribe\"></a></p>\n<h3 id=\"starting-the-request\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3f64p9kp72hh8wn0ryf7ak566\">启动请求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#starting-the-request\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b47uac0hk9haja3jeiido5p15\">对于所有 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法，在你在方法返回的 Observable 上调用 <code>subscribe()</code> 之前，该方法都不会开始其 HTTP 请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5oj5wnpyvs8t8bistwkt24h4z\">这适用于 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的<em>所有方法</em>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ds6hzkgcd69ockyjj837ht1av\">当组件被销毁时，你应该总是取消订阅 Observable。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ednwuymmw9yo46ppdyae7nm2y\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的所有方法返回的可观察对象都设计为<em>冷的</em>。HTTP 请求的执行都是<em>延期执行的</em>，让你可以用 <code>tap</code> 和 <code>catchError</code> 这样的操作符来在实际执行 HTTP 请求之前，先对这个可观察对象进行扩展。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4kp3rihwbcidc9xx9umflfn7j\">调用 <code>subscribe()</code> 会触发此 Observable 的执行，并导致 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 合成 HTTP 请求并将其发送到服务器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"73vgk2ls8b1kjyt2vkd5h4wv1\">可以把这些 Observable 看做实际 HTTP 请求的<em>蓝图</em>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41urw8apt765irjkf3ton8x1\">事实上，每个 <code>subscribe()</code> 都会启动 observable 的一次单独的、独立的执行。订阅两次就会导致两次 HTTP 请求。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst req = http.get&lt;Heroes&gt;('/api/heroes');\n// 0 requests made - .subscribe() not called.\nreq.subscribe();\n// 1 request made.\nreq.subscribe();\n// 2 requests made.\n\n</code-example>\n</div>\n<p><a id=\"typed-response\"></a></p>\n<h3 id=\"requesting-a-typed-response\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7v4lt4mqllm4rrf127nf9oqmw\">请求输入一个类型的响应<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#requesting-a-typed-response\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jit0tmqk6npf3gn2lsmz6tr\">可以构造自己的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 请求来声明响应对象的类型，以便让输出更容易、更明确。所指定的响应类型会在编译时充当类型断言。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bovjfqdjczcbalpn05bpymda7\">指定响应类型是为了告诉 TypeScript 应该将响应视为给定类型的声明。这是一个编译期检查，不能保证服务器的响应一定是这种类型的对象。服务器有责任确保返回服务器 API 所指定的类型。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6zadjxatkq82ma0pcfrg6afy7\">要指定响应对象类型，首先要定义一个具有必需属性的接口。这里要使用接口而不是类，因为响应对象是普通对象，无法自动转换成类的实例。</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"config-interface\">\nexport interface Config {\n  heroesUrl: string;\n  textfile: string;\n  date: any;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"132wt5op65kf46g7fjg3kfqzy\">接下来，在服务器中把该接口指定为 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 调用的类型参数。</p>\n<code-example header=\"app/config/config.service.ts (getConfig v.2)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_2\">\ngetConfig() {\n  // now returns an Observable of Config\n  return this.http.get&lt;Config&gt;(this.configUrl);\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4nrna78l95jl23yil4enitufc\">当你将一个接口作为类型参数传给 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 方法时，要使用 <a href=\"guide/rx-library#operators\">RxJS 的 <code>map</code> 操作符</a>来根据 UI 的需要变换响应数据。然后就可以将转换后的数据传给 <a href=\"api/common/AsyncPipe\">async 管道</a>了。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2r1gota3m36wn7i2l3imjgw8z\">修改后的组件方法，其回调函数中获取一个带类型的对象，它易于使用，且消费起来更安全：</p>\n<code-example header=\"app/config/config.component.ts (showConfig v.2)\" path=\"http/src/app/config/config.component.ts\" region=\"v2\">\nconfig: Config | undefined;\n\nshowConfig() {\n  this.configService.getConfig()\n    // clone the data object, using its known Config shape\n    .subscribe(data =&gt; this.config = { ...data });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dyf74tfsnx8a7k3peq23op3rw\">要访问接口中定义的属性，必须将从 JSON 获得的普通对象显式转换为所需的响应类型。比如，以下 <code>subscribe</code> 回调会将 <code>data</code> 作为对象接收，然后进行类型转换以访问属性。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n.subscribe(data =&gt; this.config = {\n  heroesUrl: (data as any).heroesUrl,\n  textfile:  (data as any).textfile,\n});\n\n</code-example>\n<p><a id=\"string-union-types\"></a></p>\n<div class=\"callout is-important\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8jhf429ofrf7cpphcg11a2kzo\"><code>observe</code> 和 <code>response</code> 类型</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1g77me7oxr7h0a97zu08ftbe8\"><code>observe</code> 和 <code>response</code> 选项的类型是<em>字符串联合</em>类型，而不是普通字符串。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  …\n  observe?: 'body' | 'events' | 'response',\n  …\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  …\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2xbook8zmfdsso24a3x1h70p9\">这可能导致混淆。例如：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n// this works\nclient.get('/foo', {responseType: 'text'})\n\n// but this does NOT work\nconst options = {\n  responseType: 'text',\n};\nclient.get('/foo', options)\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"317l9hcef540n2uo783fkyfav\">在第二种情况中，TypeScript 推断 <code>options</code> 的类型为 <code>{responseType: string}</code>。这个类型过于宽泛，无法传给 <code>HttpClient.get</code>，因为后者期望 <code>responseType</code> 的类型是<em>几个特定的</em>字符串之一。<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 被显式地以这种方式进行了类型化，以便编译器可以根据你提供的选项报告出正确的返回类型。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8uy6g1dgux7mqkxtveg8iwk4\">使用 <code>as const</code> 来让 TypeScript 知道你确实是要使用一个常量字符串类型：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst options = {\n  responseType: 'text' as const,\n};\nclient.get('/foo', options);\n\n</code-example>\n</div>\n<h3 id=\"reading-the-full-response\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"577uv3zv9fpcd3mn40yo8niz9\">读取完整的响应体<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#reading-the-full-response\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drylrrv7mdfwgzfg7zx8y0mre\">在前面的例子中，对 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 的调用没有指定任何选项。默认情况下，它返回了响应体中包含的 JSON 数据。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4az0u2t0hoai7xn261lxf0av\">你可能还需要关于这次对话的更多信息。比如，有时候服务器会返回一个特殊的响应头或状态码，来指出某些在应用的工作流程中很重要的条件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1mkkqt2gz2o3crv7nzaltfmur\">可以用 <code>get()</code> 方法的 <code>observe</code> 选项来告诉 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>，你想要完整的响应对象：</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"getConfigResponse\">\ngetConfigResponse(): Observable&lt;<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;&gt; {\n  return this.http.get&lt;Config&gt;(\n    this.configUrl, { observe: 'response' });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8524a89qnh7jax3z28yuoqxgk\">现在，<code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 会返回一个 <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 类型的 <code>Observable</code>，而不只是 JSON 数据。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efe0aypg6w12eecx77by282oi\">该组件的 <code>showConfigResponse()</code> 方法会像显示配置数据一样显示响应头：</p>\n<code-example header=\"app/config/config.component.ts (showConfigResponse)\" path=\"http/src/app/config/config.component.ts\" region=\"showConfigResponse\">\nshowConfigResponse() {\n  this.configService.getConfigResponse()\n    // resp is of type `<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;`\n    .subscribe(resp =&gt; {\n      // display its headers\n      const keys = resp.headers.keys();\n      this.headers = keys.map(key =&gt;\n        `${key}: ${resp.headers.get(key)}`);\n\n      // access the body directly, which is typed as `Config`.\n      this.config = { ...resp.body! };\n    });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwtspcanbqzl0h2qirj0q20iz\">如你所见，该响应对象具有一个带有正确类型的 <code>body</code> 属性。</p>\n\n  <div class=\"reviewed\">最后复查时间：Wed Aug 16 2023</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/common/AsyncPipe\n - api/common/http\n - api/common/http/HttpBackend\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/common/http/HttpClientModule\n - api/common/http/HttpHeaders\n - api/common/http/HttpParams\n - api/common/http/HttpResponse\n - api/core/ApplicationConfig\n - api/core/Injectable\n - api/core/importProvidersFrom\n - api/platform-browser/bootstrapApplication\n - guide/dependency-injection\n - guide/glossary#service\n - guide/http-server-communication#http-server-communication\n - guide/http-server-communication#reading-the-full-response\n - guide/http-server-communication#requesting-a-typed-response\n - guide/http-server-communication#requesting-data-from-a-server\n - guide/http-server-communication#setup-for-server-communication\n - guide/http-server-communication#starting-the-request\n - guide/rx-library#operators\n - guide/understanding-communicating-with-http\n - https://github.com/angular/angular/issues/new?template=3-docs-bug.md\n - https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api\n-->"}