{"id":"guide/http-server-communication","title":"HTTP 伺服器通訊","contents":"<div class=\"content\">\n  <h1 id=\"http-server-communication\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c6jyhy0apt7egi5vz3v7fhxi0\">HTTP 伺服器通訊<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#http-server-communication\"><i class=\"material-icons\">link</i></a></h1>\n<div class=\"callout is-critical\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4r7c5x5y77wbuducanio6c3fk\">已標記為歸檔</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58k4b2kechaaj13ikfgyyx6om\">為確保你擁有最佳的體驗，本主題已標記為歸檔，直到我們確定其清楚地傳達了最準確的訊息為止。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"14o6dxnk9jlkg9rvrp8rwgbxx\">同時，這個主題可能會有所幫助：\n<a href=\"guide/understanding-communicating-with-http\">理解 HTTP</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ck2tsrjevyy0r4iofzx0sxxow\">如果你認為不應將此內容歸檔，請送出 <a href=\"https://github.com/angular/angular/issues/new?template=3-docs-bug.md\">GitHub 問題</a>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ltroklxc89e67u8z64sjywja\">大多數前端應用程式都要透過 HTTP 協定與伺服器通訊，以下載或上傳資料以及訪問其他後端服務。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"825eao4iba4fhy9p6nqsxm4rv\">你可以執行伴隨本指南的\n<live-example name=\"http\"></live-example>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1sk4fms7erqf4qx3irr8zszi3\">範例應用不需要資料伺服器。它依賴於 <a href=\"https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api\">Angular 的 <em>in-memory-web-api</em></a>，該模組替換了 <em>HttpClient</em> 模組的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>。這個替代服務模擬了 REST 後端的行為。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b6ph0mm4o8imlqvq821l565tf\">檢視\n<code>main.ts</code>中的\n<code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>()</code>方法，瞭解它的設定方式。</p>\n</div>\n<h2 id=\"setup-for-server-communication\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drfz25zlex7bh5azzvm789p2g\">伺服器通訊的準備工作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#setup-for-server-communication\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5kfjdwvvplbde9u7aqeyu8mz0\">在使用\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>之前，你需要提供 Angular 的\n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，以便將其注入到需要的類別中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"93o4x5ug8shpbv7cfuwuexjub\">大多數開發人員在\n<code>main.ts</code>中使用\n<code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code>初始化應用程式時提供\n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，使用\n<code>app.config.ts</code>匯出的\n<code><a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a></code>，如下所示：</p>\n<code-example header=\"main.ts (excerpt)\" path=\"http/src/main.ts\" region=\"sketch\">\nimport { <a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a> } from '@angular/platform-browser';\n\nimport {AppComponent} from './app/app.component';\nimport { appConfig } from './app/app.config';\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(AppComponent, appConfig);\n\n</code-example>\n<code-example header=\"app.config.ts (excerpt)\" path=\"http/src/app/app.config.ts\" region=\"sketch\">\nimport { <a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\nimport { <a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a> } from '@angular/core';\n\nexport const appConfig: <a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a> = {\n  providers: [\n    <a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a>(<a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>),\n  ]\n};\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"331ts4mya4jref7tcaixpsyvo\">然後，你可以把 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務注入成一個應用類別的依賴項，如下麵的 <code>ConfigService</code> 例子所示。</p>\n<code-example header=\"app/config/config.service.ts (excerpt)\" path=\"http/src/app/config/config.service.ts\" region=\"proto\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class ConfigService {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n}\n\n</code-example>\n<h2 id=\"requesting-data-from-a-server\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"difnh6xnxe57i52vs39z3pfhg\">從伺服器請求資料<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#requesting-data-from-a-server\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9iwcu8kvtfnoi1aqwc4ldl2tw\">使用 <a href=\"api/common/http/HttpClient#get\"><code>HttpClient.get()</code></a> 方法從伺服器獲取資料。該非同步方法會發送一個 HTTP 請求，並回傳一個 Observable，它會在收到回應時發出所請求到的資料。回傳的型別取決於你呼叫時傳入的 <code>observe</code> 和 <code>responseType</code> 引數。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvt08oxjx84svpni5zfb128os\"><code>get()</code> 方法有兩個引數。要獲取的端點 URL，以及一個可以用來設定請求的<em>選項</em>物件。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  headers?: <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a> | {[header: string]: string | string[]},\n  observe?: 'body' | 'events' | 'response',\n  params?: <a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a>|{[param: string]: string | number | boolean | ReadonlyArray&lt;string | number | boolean&gt;},\n  reportProgress?: boolean,\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  withCredentials?: boolean,\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6gnfyfqlgzdzt8qbnoy82r276\">這些重要的選項包括 <em>observe</em> 和 <em>responseType</em> 屬性。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3liy686p15pg85we3xy31lzj\"><em>observe</em> 選項用於指定要回傳的回應內容。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"avg46mevx4xn0ysr0gdnpmnsp\"><em>responseType</em> 選項指定回傳資料的格式。</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ewbie7vv6vw52vehuoye7mfv\">使用 <code>options</code> 物件來設定外發請求的其他方面。例如，在新增標頭訊息時，此服務會使用 <code>headers</code> 選項的屬性來設定預設頭訊息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d0nb21sd39kbmffze9f2gi7gl\">使用 <code>params</code> 屬性來設定帶有 HTTP URL 引數的請求，使用 <code>reportProgress</code> 選項來監聽傳輸大量資料時的進度事件。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2067w6sicuum77gf96p6j5spx\">應用經常會從伺服器請求 JSON 資料。在 <code>ConfigService</code> 例子中，該應用需要伺服器 <code>config.json</code> 上的一個設定檔案來指定資源的 URL。</p>\n<code-example header=\"assets/config.json\" path=\"http/src/assets/config.json\">\n{\n  \"heroesUrl\": \"api/heroes\",\n  \"textfile\": \"assets/textfile.txt\",\n  \"date\": \"2020-01-29\"\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"62zlx0mf26khwl8vfs84nmejl\">要獲取這類別資料，<code>get()</code> 呼叫需要以下幾個選項：<code>{observe: 'body', responseType: 'json'}</code>。這些是這些選項的預設值，所以下面的例子不會傳遞 options 物件。後面幾節展示了一些額外的選項。</p>\n<p><a id=\"config-service\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jd89k2kmvm6v7jr80y5hcnmr\">這個例子符合透過定義一個可複用的可<a href=\"guide/glossary#service\" title=\"服務定義\">注入服務</a>來執行資料處理功能來建立可伸縮解決方案的最佳實踐。除了提取資料外，該服務還可以對資料進行後處理，新增錯誤處理，並新增重試邏輯。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1j2x6ooh7driafi6tiskdc5d5\"><code>ConfigService</code> 使用 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 方法獲取這個檔案。</p>\n<code-example header=\"app/config/config.service.ts (getConfig v.1)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_1\">\nconfigUrl = 'assets/config.json';\n\ngetConfig() {\n  return this.http.get&lt;Config&gt;(this.configUrl);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5su2w3y7k38fzey13tmcy39w2\"><code>ConfigComponent</code> 注入了 <code>ConfigService</code> 並呼叫了 <code>getConfig</code> 服務方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6hqt7ahdya6iam3pianmwhmir\">由於該服務方法回傳了一個 <code>Observable</code> 設定資料，該組件會<em>訂閱</em>該方法的回傳值。訂閱回呼只會對後處理進行最少量的處理。它會把資料欄位複製到元件的 <code>config</code> 物件中，該物件在元件範本中是資料繫結的，用於顯示。</p>\n<code-example header=\"app/config/config.component.ts (showConfig v.1)\" path=\"http/src/app/config/config.component.ts\" region=\"v1\">\nconstructor(private configService: ConfigService) {}\n\nshowConfig() {\n  this.configService.getConfig()\n    .subscribe(data =&gt; this.config = {\n        heroesUrl: data.heroesUrl,\n        textfile:  data.textfile,\n        date: data.date,\n    });\n}\n\n</code-example>\n<p><a id=\"always-subscribe\"></a></p>\n<h3 id=\"starting-the-request\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3f64p9kp72hh8wn0ryf7ak566\">啟動請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#starting-the-request\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b47uac0hk9haja3jeiido5p15\">對於所有 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法，在你在方法回傳的 Observable 上呼叫 <code>subscribe()</code> 之前，該方法都不會開始其 HTTP 請求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5oj5wnpyvs8t8bistwkt24h4z\">這適用於 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的<em>所有方法</em>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ds6hzkgcd69ockyjj837ht1av\">當元件被銷燬時，你應該總是取消訂閱 Observable。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ednwuymmw9yo46ppdyae7nm2y\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的所有方法回傳的可觀察物件都設計為<em>冷的</em>。HTTP 請求的執行都是<em>延期執行的</em>，讓你可以用 <code>tap</code> 和 <code>catchError</code> 這樣的運算子來在實際執行 HTTP 請求之前，先對這個可觀察物件進行擴充套件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4kp3rihwbcidc9xx9umflfn7j\">呼叫 <code>subscribe()</code> 會觸發此 Observable 的執行，並導致 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 合成 HTTP 請求並將其傳送到伺服器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"73vgk2ls8b1kjyt2vkd5h4wv1\">可以把這些 Observable 看做實際 HTTP 請求的<em>藍圖</em>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41urw8apt765irjkf3ton8x1\">事實上，每個 <code>subscribe()</code> 都會啟動 observable 的一次單獨的、獨立的執行。訂閱兩次就會導致兩次 HTTP 請求。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst req = http.get&lt;Heroes&gt;('/api/heroes');\n// 0 requests made - .subscribe() not called.\nreq.subscribe();\n// 1 request made.\nreq.subscribe();\n// 2 requests made.\n\n</code-example>\n</div>\n<p><a id=\"typed-response\"></a></p>\n<h3 id=\"requesting-a-typed-response\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7v4lt4mqllm4rrf127nf9oqmw\">請求輸入一個型別的回應<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#requesting-a-typed-response\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jit0tmqk6npf3gn2lsmz6tr\">可以構造自己的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 請求來宣告回應物件的型別，以便讓輸出更容易、更明確。所指定的回應型別會在編譯時充當型別斷言。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bovjfqdjczcbalpn05bpymda7\">指定回應型別是為了告訴 TypeScript 應該將回應視為給定型別的宣告。這是一個編譯期檢查，不能保證伺服器的回應一定是這種型別的物件。伺服器有責任確保回傳伺服器 API 所指定的型別。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6zadjxatkq82ma0pcfrg6afy7\">要指定回應物件型別，首先要定義一個具有必需屬性的介面。這裡要使用介面而不是類別，因為回應物件是普通物件，無法自動轉換成類別的實例。</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"config-interface\">\nexport interface Config {\n  heroesUrl: string;\n  textfile: string;\n  date: any;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"132wt5op65kf46g7fjg3kfqzy\">接下來，在服務器中把該介面指定為 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 呼叫的型別引數。</p>\n<code-example header=\"app/config/config.service.ts (getConfig v.2)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_2\">\ngetConfig() {\n  // now returns an Observable of Config\n  return this.http.get&lt;Config&gt;(this.configUrl);\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4nrna78l95jl23yil4enitufc\">當你將一個介面作為型別引數傳給 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 方法時，要使用 <a href=\"guide/rx-library#operators\">RxJS 的 <code>map</code> 運算子</a>來根據 UI 的需要變換回應資料。然後就可以將轉換後的資料傳給 <a href=\"api/common/AsyncPipe\">async 通道</a>了。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2r1gota3m36wn7i2l3imjgw8z\">修改後的元件方法，其回呼函式中獲取一個帶型別的物件，它易於使用，且消費起來更安全：</p>\n<code-example header=\"app/config/config.component.ts (showConfig v.2)\" path=\"http/src/app/config/config.component.ts\" region=\"v2\">\nconfig: Config | undefined;\n\nshowConfig() {\n  this.configService.getConfig()\n    // clone the data object, using its known Config shape\n    .subscribe(data =&gt; this.config = { ...data });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dyf74tfsnx8a7k3peq23op3rw\">要訪問介面中定義的屬性，必須將從 JSON 獲得的普通物件顯式轉換為所需的回應型別。比如，以下 <code>subscribe</code> 回呼會將 <code>data</code> 作為物件接收，然後進行型別轉換以訪問屬性。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n.subscribe(data =&gt; this.config = {\n  heroesUrl: (data as any).heroesUrl,\n  textfile:  (data as any).textfile,\n});\n\n</code-example>\n<p><a id=\"string-union-types\"></a></p>\n<div class=\"callout is-important\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8jhf429ofrf7cpphcg11a2kzo\"><code>observe</code> 和 <code>response</code> 型別</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1g77me7oxr7h0a97zu08ftbe8\"><code>observe</code> 和 <code>response</code> 選項的型別是<em>字串聯合</em>型別，而不是普通字串。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  …\n  observe?: 'body' | 'events' | 'response',\n  …\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  …\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2xbook8zmfdsso24a3x1h70p9\">這可能導致混淆。例如：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n// this works\nclient.get('/foo', {responseType: 'text'})\n\n// but this does NOT work\nconst options = {\n  responseType: 'text',\n};\nclient.get('/foo', options)\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"317l9hcef540n2uo783fkyfav\">在第二種情況中，TypeScript 推斷 <code>options</code> 的型別為 <code>{responseType: string}</code>。這個型別過於寬泛，無法傳給 <code>HttpClient.get</code>，因為後者期望 <code>responseType</code> 的型別是<em>幾個特定的</em>字串之一。<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 被顯式地以這種方式進行了型別化，以便編譯器可以根據你提供的選項報告出正確的回傳型別。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8uy6g1dgux7mqkxtveg8iwk4\">使用 <code>as const</code> 來讓 TypeScript 知道你確實是要使用一個常數字串型別：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst options = {\n  responseType: 'text' as const,\n};\nclient.get('/foo', options);\n\n</code-example>\n</div>\n<h3 id=\"reading-the-full-response\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"577uv3zv9fpcd3mn40yo8niz9\">讀取完整的回應體<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#reading-the-full-response\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drylrrv7mdfwgzfg7zx8y0mre\">在前面的例子中，對 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 的呼叫沒有指定任何選項。預設情況下，它回傳了回應體中包含的 JSON 資料。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4az0u2t0hoai7xn261lxf0av\">你可能還需要關於這次對話的更多訊息。比如，有時候伺服器會回傳一個特殊的回應頭或狀態碼，來指出某些在應用的工作流程中很重要的條件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1mkkqt2gz2o3crv7nzaltfmur\">可以用 <code>get()</code> 方法的 <code>observe</code> 選項來告訴 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>，你想要完整的回應物件：</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"getConfigResponse\">\ngetConfigResponse(): Observable&lt;<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;&gt; {\n  return this.http.get&lt;Config&gt;(\n    this.configUrl, { observe: 'response' });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8524a89qnh7jax3z28yuoqxgk\">現在，<code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 會回傳一個 <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 型別的 <code>Observable</code>，而不只是 JSON 資料。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efe0aypg6w12eecx77by282oi\">該組件的 <code>showConfigResponse()</code> 方法會像顯示設定資料一樣顯示回應頭：</p>\n<code-example header=\"app/config/config.component.ts (showConfigResponse)\" path=\"http/src/app/config/config.component.ts\" region=\"showConfigResponse\">\nshowConfigResponse() {\n  this.configService.getConfigResponse()\n    // resp is of type `<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;`\n    .subscribe(resp =&gt; {\n      // display its headers\n      const keys = resp.headers.keys();\n      this.headers = keys.map(key =&gt;\n        `${key}: ${resp.headers.get(key)}`);\n\n      // access the body directly, which is typed as `Config`.\n      this.config = { ...resp.body! };\n    });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwtspcanbqzl0h2qirj0q20iz\">如你所見，該回應物件具有一個帶有正確型別的 <code>body</code> 屬性。</p>\n\n  <div class=\"reviewed\">最後複查時間：Wed Aug 16 2023</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/common/AsyncPipe\n - api/common/http\n - api/common/http/HttpBackend\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/common/http/HttpClientModule\n - api/common/http/HttpHeaders\n - api/common/http/HttpParams\n - api/common/http/HttpResponse\n - api/core/ApplicationConfig\n - api/core/Injectable\n - api/core/importProvidersFrom\n - api/platform-browser/bootstrapApplication\n - guide/dependency-injection\n - guide/glossary#service\n - guide/http-server-communication#http-server-communication\n - guide/http-server-communication#reading-the-full-response\n - guide/http-server-communication#requesting-a-typed-response\n - guide/http-server-communication#requesting-data-from-a-server\n - guide/http-server-communication#setup-for-server-communication\n - guide/http-server-communication#starting-the-request\n - guide/rx-library#operators\n - guide/understanding-communicating-with-http\n - https://github.com/angular/angular/issues/new?template=3-docs-bug.md\n - https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api\n-->"}