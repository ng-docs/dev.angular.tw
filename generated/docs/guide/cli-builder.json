{"id":"guide/cli-builder","title":"Angular CLI 构建器（Builder）","contents":"<div class=\"content\">\n  <h1 id=\"angular-cli-builders\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7l4r5ksly876d1b8swxh2gkax\">Angular CLI 构建器（Builder）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#angular-cli-builders\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4wzrri37s9he8d3zetohpa7lf\">很多 Angular CLI 命令都要在你的代码上执行一些复杂的处理，比如风格检查（lint）构建或测试。这些命令会通过一个叫做建筑师（Architect）的内部工具来运行 <em>CLI 构建器</em>，而这些构建器会运用一些第三方工具来完成目标任务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ukmghke4q5jatt82lc2udafr\">在 Angular 的版本 8 中，CLI 构建器的 API 是稳定的，想要通过添加或修改命令来自定义 Angular CLI 的开发人员可以使用它。比如，你可以提供一个构建器来执行全新的任务，或者更改一个现有命令所使用的第三方工具。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"j2d0mdqv4nwj03y9kz41rl8a\">本文档介绍了 CLI 构建器是如何与工作区配置文件集成的，还展示了如何创建你自己的构建器。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46v4j6efymdih8ja7iupyst5w\">可以在这个 <a href=\"https://github.com/mgechev/cli-builders-demo\">GitHub 仓库</a>中的例子中找到代码。</p>\n</div>\n<h2 id=\"cli-builders\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6kgou0phblc70g8sr36snxabc\">CLI 构建器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#cli-builders\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3acn0lrnb615o34itqoxxvvg1\">内部建筑师工具会把工作委托给名叫<a href=\"guide/glossary#builder\"><em>构建器</em></a>的处理器函数。处理器函数接收两个参数：一组 <code>options</code> 输入（JSON 对象）和一个 <code>context</code>（<code>BuilderContext</code> 对象）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d1s3y8b4n9qpr4giro6dmsd0i\">这里对关注点的分离和<a href=\"guide/glossary#schematic\">原理图</a>中是一样的，它也适用于其它要接触（touch）代码的 CLI 命令（比如 <code>ng generate</code>）。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ef05575377s7l5070sbcmc52b\">此 <code>options</code> 对象是由本 CLI 的用户提供的，而 <code>context</code> 对象则由 CLI 构建器的 API 提供</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7nglyiseu6k4cn7cz2rxagr40\">除了上下文信息之外，此 <code>context</code> 对象（它是 <code>BuilderContext</code> 的实例）还允许你访问调度方法 <code>context.scheduleTarget()</code>。调度器会用指定的<a href=\"guide/glossary#target\">目标配置</a>来执行构建器处理函数。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bdh162d4rltuhi8z7oos42ezx\">这个构建器处理函数可以是同步的（返回一个值）或异步的（返回一个 Promise），也可以监视并返回多个值（返回一个 Observable）。最终返回的值全都是 <code>BuilderOutput</code> 类型的。该对象包含一个逻辑字段 <code>success</code> 和一个可以包含错误信息的可选字段 <code>error</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37011gi4t616lscyl3rlr8a01\">Angular 提供了一些构建器，供 CLI 命令使用，如 <code>ng build</code> 和 <code>ng test</code> 等。这些内置 CLI 构建器的默认目标配置可以在<a href=\"guide/workspace-config\">工作区配置文件</a> <code>angular.json</code> 的 <code>architect</code> 部分找到（并进行自定义）。可以通过创建自己的构建器来扩展和自定义 Angular，你可以使用 <a href=\"cli/run\"><code>ng run</code> CLI 命令</a>来运行你自己的构建器。</p>\n<h3 id=\"builder-project-structure\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5r1ispfd7rgbbazpo0kgauejo\">构建器的项目结构<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-project-structure\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6grnrmnf7umtltqo3rh1rat1\">构建器位于一个 <code>project</code> 文件夹中，该文件夹的结构类似于 Angular 工作区，包括位于顶层的全局配置文件，以及位于工作代码所在源文件夹中的更具体的配置。比如，<code>myBuilder</code> 文件夹中可能包含如下文件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8n2c7wfntpyw9gnmnqx5bqxht\">文件</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"297niinze7mn1fnajtyjcs0tb\">目的</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>src/my-builder.ts</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ahr5s0k61d5dbzq2vkwmj08qr\">构建器定义的主要源文件。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>src/my-builder.spec.ts</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66qowvh1zht2uzvl0ikg904hy\">测试用的源文件。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>src/schema.json</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vsplc0qiumt6y2vozgwf87t7\">构建器输入选项的定义。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>builders.json</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b3m621w2ry61vdwtsymyvne68\">构建器定义。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>package.json</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2v56x4bo1ubnrqi5ndiwz5m8x\">依赖项。请参阅\n<a href=\"https://docs.npmjs.com/files/package.json\">https://docs.npmjs.com/files/package.json</a>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>tsconfig.json</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwwsw8xc8xni0juif25znc4tk\"><a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\">TypeScript 配置</a>。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"clpdiih2dch8m0vws0ztcue0c\">将此构建器发布到 <code>npm</code>（参阅<a href=\"guide/creating-libraries#publishing-your-library\">发布你的库</a>）。如果你将其发布为 <code>&amp;commat;example/my-builder</code>，请使用以下命令安装它。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @example/my-builder\n\n</code-example>\n<h2 id=\"creating-a-builder\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9n6khelrjscrzq171a67lbxxu\">创建构建器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#creating-a-builder\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"84lsyisl4as1t64f1q465vcvf\">举个例子，让我们创建一个用来复制文件的构建器。要创建构建器，请使用 CLI 构建器函数 <code>createBuilder()</code>，并返回一个 <code>Promise&lt;BuilderOutput&gt;</code> 对象。</p>\n<code-example header=\"src/my-builder.ts (builder skeleton)\" path=\"cli-builder/src/my-builder.ts\" region=\"builder-skeleton\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\n<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&lt;BuilderOutput&gt; {\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"296su3b2zeymtqn1u4m0dgdme\">现在，让我们为它添加一些逻辑。下列代码会从用户选项中获取源文件和目标文件的路径，并且把源文件复制到目标文件（使用 <a href=\"https://nodejs.org/api/fs.html#fs_fspromises_copyfile_src_dest_mode\">NodeJS 内置函数 <code>copyFile()</code> 的 Promise 版本</a>）。如果文件操作失败了，它会返回一个带有底层错误信息的 error 对象。</p>\n<code-example header=\"src/my-builder.ts (builder)\" path=\"cli-builder/src/my-builder.ts\" region=\"builder\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\n<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&lt;BuilderOutput&gt; {\n  try {\n    await fs.copyFile(options.source, options.destination);\n  } catch (err) {\n    return {\n      success: false,\n      error: err.message,\n    };\n  }\n\n  return { success: true };\n}\n\n\n</code-example>\n<h3 id=\"handling-output\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3x6r7cwe0w52kmwvxzbr9x5n0\">处理输出<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#handling-output\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3tkec7wy22ldo3l0spl6zfa96\">默认情况下，<code>copyFile()</code> 方法不会往标准输出或标准错误中打印任何信息。如果发生了错误，可能很难理解构建器到底做了什么。可以使用 <code>Logger</code> API 来记录一些额外的信息，以提供额外的上下文。这样还能让构建器本身可以在一个单独的进程中执行，即使其标准输出和标准错误被停用了也无所谓（就像在 <a href=\"https://electronjs.org/\">Electron 应用中一样</a>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7kgarbtoeyjq81dmaswy4mtoa\">你可以从上下文中检索一个 <code>Logger</code> 实例。</p>\n<code-example header=\"src/my-builder.ts (handling output)\" path=\"cli-builder/src/my-builder.ts\" region=\"handling-output\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\n<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&lt;BuilderOutput&gt; {\n  try {\n    await fs.copyFile(options.source, options.destination);\n  } catch (err) {\n    context.logger.error('Failed to copy file.');\n    return {\n      success: false,\n      error: err.message,\n    };\n  }\n\n  return { success: true };\n}\n\n\n</code-example>\n<h3 id=\"progress-and-status-reporting\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cuz0pn5szvgyi9hhwxlztzh9w\">进度和状态报告<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#progress-and-status-reporting\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1v2vr412xyj4jsu3cnnxe0njj\">CLI 构建器 API 包含一些进度报告和状态报告工具，可以为某些函数和接口提供提示信息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"boofserp57q4napvq817guy7v\">要报告进度，请使用 <code>context.reportProgress()</code> 方法，它接受一个当前值（value）、一个（可选的）总值（total）和状态（status）字符串作为参数。总值可以是任意数字，比如，如果你知道有多少个文件需要处理，那么总值可能是这些文件的数量，而当前值是已处理过的数量。除非传入了新的字符串，否则这个状态字符串不会改变。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"r2wsn4e7xhfa8vmhsrgglwo4\">你可以看看 <code>tslint</code> 构建器如何报告进度的<a href=\"https://github.com/angular/angular-cli/blob/ba21c855c0c8b778005df01d4851b5a2176edc6f/packages/angular_devkit/build_angular/src/tslint/index.ts#L107\">例子</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9suu21epk3evbq957b236ktw8\">在我们的例子中，这种复制操作或者已完成或者正在执行，所以不需要进度报告，但是可以报告状态，以便调用此构建器的父构建器知道发生了什么。可以用 <code>context.reportStatus()</code> 方法生成一个任意长度的状态字符串。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2izibw1ezeefmwl6efd4mjvcc\"><strong>注意</strong>：<br>\n无法保证长字符串会完全显示出来，可以裁剪它以适应界面显示。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"33ic1reyfdyf4bzokpq4i2k27\">传入一个空字符串可以移除状态。</p>\n<code-example header=\"src/my-builder.ts (progress reporting)\" path=\"cli-builder/src/my-builder.ts\" region=\"progress-reporting\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\n<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&lt;BuilderOutput&gt; {\n  context.reportStatus(`Copying ${options.source} to ${options.destination}.`);\n  try {\n    await fs.copyFile(options.source, options.destination);\n  } catch (err) {\n    context.logger.error('Failed to copy file.');\n    return {\n      success: false,\n      error: err.message,\n    };\n  }\n\n  context.reportStatus('Done.');\n  return { success: true };\n}\n\n\n</code-example>\n<h2 id=\"builder-input\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"sbsbuw84666j6o1ltiwslp71\">构建器的输入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-input\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d8g116xeo1voeh3hk9jq5gen5\">你可以通过 CLI 命令间接调用一个构建器，也可以直接用 Angular CLI 的 <code>ng run</code> 命令来调用它。无论哪种情况，你都必须提供所需的输入，但是可以用特定<a href=\"guide/glossary#target\"><em>目标</em></a>中预配置的值作为其默认值，然后指定一个预定义的、指定的配置进行覆盖，最后在命令行中进一步覆盖这些选项的值。</p>\n<h3 id=\"input-validation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8zp0j3nlgyvlg4excdxtxvofq\">对输入的验证<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#input-validation\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5ui1ca5hi0wp5ietnumiuo58\">你可以在该构建器的相关 JSON 模式中定义构建器都有哪些输入。建筑师工具会把解析后的输入值收集到一个 <code>options</code> 对象中，并在将其传给构建器函数之前先根据这个模式验证它们的类型。（Schematics 库也对用户输入做了同样的验证）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eltipty4fnaicv43a15hvtc8l\">对于这个范例构建器，你希望 <code>options</code> 的值是带有两个键的 <code>JsonObject</code>：一个是 <code>source</code>，一个是 <code>destination</code>，它们都是字符串。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dud81slq4btbplmmqds9hc9o6\">你可以提供如下模式来对这些值的类型进行验证。</p>\n<code-example header=\"src/schema.json\" format=\"json\" language=\"json\">\n\n{\n  \"$schema\": \"http://json-schema.org/schema\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"source\": {\n      \"type\": \"string\"\n    },\n    \"destination\": {\n      \"type\": \"string\"\n    }\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wm7yclw5hqny5aym16sluoq7\">这是一个非常简单的例子，但这种模式验证也可以非常强大。欲知详情，参阅 <a href=\"http://json-schema.org\">JSON 模式网站</a>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"49ftuezbb6rk0bnryjsviyvz5\">要把构建器的实现与它的模式和名称关联起来，你需要创建一个<em>构建器定义</em>文件，可以在 <code>package.json</code> 中指向该文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9s0wtwjyqyy3eks004lwoeafy\">创建一个名为 <code>builders.json</code> 文件，它看起来像这样。</p>\n<code-example header=\"builders.json\" format=\"json\" language=\"json\">\n\n{\n  \"builders\": {\n    \"copy\": {\n      \"implementation\": \"./dist/my-builder.js\",\n      \"schema\": \"./src/schema.json\",\n      \"description\": \"Copies a file.\"\n    }\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ap3klge1omnmmbyvlhp6p9a8h\">在 <code>package.json</code> 文件中，添加一个 <code>builders</code> 键，告诉建筑师工具可以在哪里找到这个构建器定义文件。</p>\n<code-example header=\"package.json\" format=\"json\" language=\"json\">\n\n{\n  \"name\": \"@example/copy-file\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Builder for copying files\",\n  \"builders\": \"builders.json\",\n  \"dependencies\": {\n    \"@angular-devkit/architect\": \"~0.1200.0\",\n    \"@angular-devkit/core\": \"^12.0.0\"\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2plu27hzzxo1s678e8rzmd4ht\">我们构建器的官方名称现在是\n<code>@example/copy-file:copy</code>。这个名称的第一部分是包名称（使用节点解析解析），第二部分是构建器名称（使用\n<code>builders.json</code>文件解析）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6p8n93vvzi6pt3lu4hy5czxlf\">使用某个 <code>options</code> 是非常简单的。在上一节，你就曾用过 <code>options.source</code> 和 <code>options.destination</code>。</p>\n<code-example header=\"src/my-builder.ts (report status)\" path=\"cli-builder/src/my-builder.ts\" region=\"report-status\">\ncontext.reportStatus(`Copying ${options.source} to ${options.destination}.`);\ntry {\n  await fs.copyFile(options.source, options.destination);\n} catch (err) {\n  context.logger.error('Failed to copy file.');\n  return {\n    success: false,\n    error: err.message,\n  };\n}\n\ncontext.reportStatus('Done.');\nreturn { success: true };\n\n</code-example>\n<h3 id=\"target-configuration\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ap4qp9spjlry1ho1c60c9q7i0\">目标配置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-configuration\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9aup2ryb6ua6l0rx7qaeci0ol\">构建器必须有一个已定义的目标，此目标会把构建器与特定的输入配置和<a href=\"guide/glossary#project\">项目</a>关联起来。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4u7cj5oceixkw1mmx60hiry7i\">目标是在 <a href=\"guide/workspace-config\">CLI 配置文件</a> <code>angular.json</code> 中定义的。目标用于指定要使用的构建器、默认的选项配置，以及指定的备用配置。建筑师工具使用目标定义来为一次特定的执行解析输入选项。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"316bj7oe4l9jc8hz8wfft6auk\"><code>angular.json</code> 文件中为每个项目都有一节配置，每个项目的 <code>architect</code> 部分都会为 CLI 命令（比如 <code>build</code>、<code>test</code> 和 <code>lint</code>）配置构建器目标。默认情况下，<code>build</code> 命令会运行 <code>@angular-devkit/build-angular:<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a></code> 构建器来执行 <code>build</code> 任务，并传入 <code>angular.json</code> 中为 <code>build</code> 目标指定的默认选项值。</p>\n<code-example format=\"json\" header=\"angular.json\" language=\"json\">\n{\n  \"myApp\": {\n    …\n    \"architect\": {\n      \"build\": {\n        \"builder\": \"@angular-devkit/build-angular:browser\",\n        \"options\": {\n          \"outputPath\": \"dist/myApp\",\n          \"index\": \"src/index.html\",\n          …\n        },\n        \"configurations\": {\n          \"production\": {\n            \"fileReplacements\": [\n              {\n                \"replace\": \"src/environments/environment.ts\",\n                \"with\": \"src/environments/environment.prod.ts\"\n              }\n            ],\n            \"optimization\": true,\n            \"outputHashing\": \"all\",\n            …\n          }\n        }\n      },\n      …\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5cncb3m0vs07ihc72lpw9aqe1\">该命令会给构建器传递 <code>options</code> 节中指定的一组默认选项。如果你传入了 <code>--configuration=production</code> 标志，它就会使用 <code>production</code> 备用配置中指定的值进行覆盖。可以在命令行中单独指定其它选项进行覆盖，还可以为 <code>build</code> 目标添加更多备用配置，以定义其它环境，比如 <code>stage</code> 或 <code>qa</code>。</p>\n<h4 id=\"target-strings\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dat3zwzlefm6chdua35ukj6vs\">目标字符串<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-strings\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8af6583cxip4hdmda40v4u18e\">通用的 <code>ng run</code> CLI 命令将以下格式的目标字符串作为其第一个参数。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nproject:target[:configuration]\n\n</code-example>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">project</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"xe7zxgogglxp43ocx7mv7xhh\">与目标相关联的 Angular CLI 项目的名称。</td>\n</tr>\n<tr>\n<td align=\"left\">target</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4q2aeminbjb51gnx01abjeckn\">来自\n<code>angular.json</code>文件中\n<code>architect</code>部分的命名构建器配置。</td>\n</tr>\n<tr>\n<td align=\"left\">configuration</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"64p2jryo7rbjs5n2t200z6yc3\">(可选)给定目标的特定配置覆盖的名称，在\n<code>angular.json</code>文件中定义。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4t61j0b1s0jlq0newc1hwotmg\">如果你的构建器调用另一个构建器，它可能需要读取一个传入的目标字符串。可以使用 <code>@angular-devkit/architect</code> 中的工具函数 <code>targetFromTargetString()</code> 把这个字符串解析成一个对象。</p>\n<h2 id=\"schedule-and-run\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8loj29v6qd1xkvdwzrc9s7hlj\">调度并运行<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#schedule-and-run\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1es39azpn7uf5m3h3nma254xn\">建筑师会异步运行构建器。要调用某个构建器，就要在所有配置解析完成之后安排一个要运行的任务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekq5y231idg6kef0fzzg0us94\">在调度器返回 <code>BuilderRun</code> 控件对象之前，不会执行该构建器函数。CLI 通常会通过调用 <code>context.scheduleTarget()</code> 函数来调度任务，然后使用 <code>angular.json</code> 文件中的目标定义来解析输入选项。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2y7c8zxy5neoqtytzxsas3x66\">建筑师会接受默认的选项对象来解析指定目标的输入选项，然后覆盖所用配置中的值（如果有的话），然后再从传给 <code>context.scheduleTarget()</code> 的覆盖对象中覆盖这些值。对于 Angular CLI，覆盖对象是从命令行参数中构建的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ekj848pozzkwzl0liow9vbdb\">建筑师会根据构建器的模式对生成的选项值进行验证。如果输入有效，建筑师会创建上下文并执行该构建器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ik8qjkbjext78pfy0fw3gose\">欲知详情，参阅<a href=\"guide/workspace-config\">工作区配置</a>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"65vje017chty4ap4voljr2cvf\">你还可以通过调用 <code>context.scheduleBuilder()</code> 从另一个构建器或测试中调用某个构建器。你可以直接把 <code>options</code> 对象传给该方法，并且这些选项值会根据这个构建器的模式进行验证，而无需进一步调整。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"73l0g32a2mbxl8r0i3l0u1nxm\">只有 <code>context.scheduleTarget()</code> 方法来解析这些配置和并通过 <code>angular.json</code> 文件进行覆盖。</p>\n</div>\n<h3 id=\"default-architect-configuration\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9nozhnfbaf3yyhzkadlg9zrdr\">默认建筑师配置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#default-architect-configuration\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4l58ytmuf1unpfz649fij7oj0\">让我们创建一个简单的 <code>angular.json</code> 文件，它会把目标配置放到上下文中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9y50tm39yxo4e1d8i61w6v44d\">你可以把这个构建器发布到 npm（参阅<a href=\"guide/creating-libraries#publishing-your-library\">发布你的库</a>），并使用如下命令来安装它：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @example/copy-file\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"14zx9jczm1sbzkvexzh8apq8a\">如果用 <code>ng new builder-test</code> 创建一个新项目，那么生成的 <code>angular.json</code> 文件就是这样的，它只有默认的构建器参数。</p>\n<code-example format=\"json\" header=\"angular.json\" language=\"json\">\n\n{\n  // …\n  \"projects\": {\n    // …\n    \"builder-test\": {\n      // …\n      \"architect\": {\n        // …\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser\",\n          \"options\": {\n            // … more options…\n            \"outputPath\": \"dist/builder-test\",\n            \"index\": \"src/index.html\",\n            \"main\": \"src/main.ts\",\n            \"polyfills\": \"src/polyfills.ts\",\n            \"tsConfig\": \"src/tsconfig.app.json\"\n          },\n          \"configurations\": {\n            \"production\": {\n              // … more options…\n              \"optimization\": true,\n              \"aot\": true,\n              \"buildOptimizer\": true\n            }\n          }\n        }\n      }\n    }\n  }\n  // …\n}\n\n</code-example>\n<h3 id=\"adding-a-target\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dpaaal8hv3zp02d3ah4mnilj1\">添加一个目标<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#adding-a-target\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44xjuwbbf5vrorwzs09zwrbf3\">添加一个新的目标，来运行我们的构建器以复制文件。该目标告诉构建器，复制 <code>package.json</code> 文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dtsjbfwz1mncn34h1rdz9jm8z\">你需要更新 <code>angular.json</code> 文件，把这个构建器的目标添加到新项目的 <code>architect</code> 部分。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46v3xsiq5tr8n758yr4z8zxin\">我们会为项目的 <code>architect</code> 对象添加一个新的目标小节</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dnmzk6eu91tzxqsv8njkrdmhk\">名为 <code>copy-package</code> 的目标使用了我们的构建器，它发布到了 <code>@example/copy-file</code>。（参阅<a href=\"guide/creating-libraries#publishing-your-library\">发布你的库</a>）</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bd556occfqdsb95khotpqs6ug\">这个配置对象为我们定义的两个输入提供了默认值：<code>source</code>（你要复制的现有文件）和 <code>destination</code>（你要复制到的路径）</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ygqswxuxgrf05d95cta4eyfo\">这些配置键都是可选的，但我们先不展开</p>\n</li>\n</ul>\n<code-example format=\"json\" header=\"angular.json\" language=\"json\">\n\n{\n  \"projects\": {\n    \"builder-test\": {\n      \"architect\": {\n        \"copy-package\": {\n          \"builder\": \"@example/copy-file:copy\",\n          \"options\": {\n            \"source\": \"package.json\",\n            \"destination\": \"package-copy.json\"\n          }\n        },\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser\",\n          \"options\": {\n            \"outputPath\": \"dist/builder-test\",\n            \"index\": \"src/index.html\",\n            \"main\": \"src/main.ts\",\n            \"polyfills\": \"src/polyfills.ts\",\n            \"tsConfig\": \"src/tsconfig.app.json\"\n          },\n          \"configurations\": {\n            \"production\": {\n              \"fileReplacements\": [\n                {\n                  \"replace\": \"src/environments/environment.ts\",\n                  \"with\": \"src/environments/environment.prod.ts\"\n                }\n              ],\n              \"optimization\": true,\n              \"aot\": true,\n              \"buildOptimizer\": true\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n</code-example>\n<h3 id=\"running-the-builder\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7j4jdrwbywskac2u890ftsrm9\">运行这个构建器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#running-the-builder\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5oabbdx5cx5023vt2e2ulgpqj\">要想使用这个新目标的默认配置运行我们的构建器，请使用以下 CLI 命令。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng run builder-test:copy-package\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dcw5w0nq8lhbrbhs8kqvpud9m\">这将把 <code>package.json</code> 文件复制成 <code>package-copy.json</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bqnzgbnfa02j3dv97r5da0wna\">你可以使用命令行参数来覆盖已配置的默认值。比如，要改用其它 <code>destination</code> 值运行，请使用以下 CLI 命令。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng run builder-test:copy-package --destination=package-other.json\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"elbe6car4u2g6hepj4k5ixb7c\">这将把此文件复制为 <code>package-other.json</code> 而不再是 <code>package-copy.json</code>。因为我们没有覆盖 <em>source</em> 选项，所以它仍然会从 <code>package.json</code> 文件复制（提供给该目标的默认值）。</p>\n<h2 id=\"testing-a-builder\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76v60t367d30jnmj6ny5c3pgg\">测试一个构建器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#testing-a-builder\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"oa4qisnipr2d8cqiikd6xciq\">对构建器进行集成测试，以便你可以使用建筑师的调度器来创建一个上下文，就像这个<a href=\"https://github.com/mgechev/cli-builders-demo\">例子</a>中一样。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ubxb25cne72fuogi4lghup27\">在构建器的源码目录下，你创建了一个新的测试文件 <code>my-builder.spec.ts</code>。该代码创建了 <code>JsonSchemaRegistry</code>（用于模式验证）、<code>TestingArchitectHost</code>（对 <code>ArchitectHost</code> 的内存实现）和 <code>Architect</code> 的新实例。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ej1hk3rdwusfl9c3438cd7u0\">我们紧挨着这个构建器的 <code>package.json</code> 文件添加了一个 <code>builders.json</code> 文件，并修改了 <code>package.json</code> 文件以指向它。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7an6uvui2e4vw4o8e2ufwuvrx\">下面是运行此复制文件构建器的测试范例。该测试使用该构建器来复制 <code>package.json</code> 文件，并验证复制后的文件内容与源文件相同。</p>\n<code-example header=\"src/my-builder.spec.ts\" path=\"cli-builder/src/my-builder.spec.ts\">\nimport { Architect } from '@angular-devkit/architect';\nimport { TestingArchitectHost } from '@angular-devkit/architect/testing';\nimport { schema } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\nimport { join } from 'path';\n\ndescribe('Copy File Builder', () =&gt; {\n  let architect: Architect;\n  let architectHost: TestingArchitectHost;\n\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    const registry = new schema.CoreSchemaRegistry();\n    registry.addPostTransform(schema.transforms.addUndefinedDefaults);\n\n    // TestingArchitectHost() takes workspace and current directories.\n    // Since we don't use those, both are the same in this case.\n    architectHost = new TestingArchitectHost(__dirname, __dirname);\n    architect = new Architect(architectHost, registry);\n\n    // This will either take a Node package name, or a path to the directory\n    // for the package.json file.\n    await architectHost.addBuilderFromPackage(join(__dirname, '..'));\n  });\n\n  it('can copy files', <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    // A \"run\" can have <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> outputs, and contains progress information.\n    const run = await architect.scheduleBuilder('@example/copy-file:copy', {\n      source: 'package.json',\n      destination: 'package-copy.json',\n    });\n\n    // The \"result\" member (of type BuilderOutput) is the next output.\n    const output = await run.result;\n\n    // Stop the builder from running. This stops Architect from keeping\n    // the builder-associated states in memory, since builders keep waiting\n    // to be scheduled.\n    await run.stop();\n\n    // Expect that the copied file is the same as its source.\n    const sourceContent = await fs.readFile('package.json', 'utf8');\n    const destinationContent = await fs.readFile('package-copy.json', 'utf8');\n    expect(destinationContent).toBe(sourceContent);\n  });\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xcfonzn6tqegmbw6dx5wnlwm\">在你的仓库中运行这个测试时，需要使用 <a href=\"https://github.com/TypeStrong/ts-node\"><code>ts-node</code></a> 包。你可以把 <code>index.spec.ts</code> 重命名为 <code>index.spec.js</code> 来回避它。</p>\n</div>\n<h3 id=\"watch-mode\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3kp0kq6h4xp3h8xnjsuxa6pem\">监视（watch）模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#watch-mode\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8mtgmtjih9h43lxrwdm79o1yi\">建筑师希望构建器运行一次（默认情况下）并返回。这种行为与那些需要监视文件更改的构建器（比如 Webpack）并不完全兼容。建筑师可以支持监视模式，但要注意一些问题。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1nil5ygyx5to0n3227bsa35s1\">要在监视模式下使用，构建器处理函数应返回一个 Observable。建筑师会订阅这个 Observable，直到这个 Observable 完成（complete）为止。此外，如果使用相同的参数再次调度这个构建器，建筑师还能复用这个 Observable。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7xff05bi636ga5y7xes72pq6r\">这个构建器应该总是在每次执行后发出一个 <code>BuilderOutput</code> 对象。一旦它被执行，就会进入一个由外部事件触发的监视模式。如果一个事件导致它重启，那么此构建器应该执行 <code>context.reportRunning()</code> 函数来告诉建筑师再次运行它。如果调度器还计划了另一次运行，就会阻止建筑师停掉这个构建器。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cg8iqzw1yb40gak9h2irtjm8o\">当你的构建器通过调用 <code>BuilderRun.stop()</code> 来退出监视模式时，建筑师会从构建器的 Observable 中取消订阅，并调用构建器的退出逻辑进行清理。（这种行为也允许停止和清理运行时间过长的构建。）</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94ot10c8uub5h3bphdmprmn7t\">一般来说，如果你的构建器正在监视一个外部事件，你应该把你的运行分成三个阶段。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2v8iozxk892ni0taax8ij1mry\">阶段</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5frl2ir0exfvl8imvuiuljuo9\">运行</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76xv6htgsrvpctesr9fhjeaxr\">例如，webpack进行编译。当webpack完成并且你的构建器发出\n<code>BuilderOutput</code>对象时，此阶段结束。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37f7flgry1x95bjv914i9u06v\">监视</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"57snsnk7nkvzgj5rqjx65ps4i\">在两次运行之间，监视外部事件流。例如，webpack监视文件系统的任何更改。当webpack重新开始构建，并调用\n<code>context.reportRunning()</code>时，此阶段结束。然后回到步骤1。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2u4dioitnz04de7ge1ldln80e\">完成</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f19hv1mdzycnposb08asfywp\">任务完全完成（例如，webpack应该运行多次），或者构建器运行被停止（使用\n<code>BuilderRun.stop()</code>）。你的清理逻辑将被执行，并且Architect会取消订阅你的构建器的Observable。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"summary\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2fflknbbur8ttwdtn3o9w4vat\">总结<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#summary\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c9hxf90nlwcr4k2g8vcdsod1t\">CLI 构建器 API 提供了一种通过构建器执行自定义逻辑，以改变 Angular CLI 行为的新方式。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqzemm3vet7aytz0v627tbdb1\">构建器既可以是同步的，也可以是异步的，它可以只执行一次也可以监视外部事件，还可以调度其它构建器或目标</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2v44ljs7tudqb5upt6pvv0mk1\">构建器在 <code>angular.json</code> 配置文件中指定了选项的默认值，它可以被目标的备用配置覆盖，还可以进一步被命令行标志所覆盖</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"28gkxmead7b3ls0hnaidu1h52\">建议你使用集成测试来测试建筑师的构建器。还可以用单元测试来验证这个构建器的执行逻辑。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4irnrmnw0x778vrl1wg25dhwv\">如果你的构建器返回一个 Observable，你应该在那个 Observable 的退出逻辑中进行清理</p>\n</li>\n</ul>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/architecture-next-steps\n - guide/deployment\n - guide/workspace-config\n-->\n<!-- links from this doc:\n - api/animations/browser\n - api/forms/SelectMultipleControlValueAccessor\n - api/platform-browser/animations/async\n - cli/run\n - guide/cli-builder#adding-a-target\n - guide/cli-builder#angular-cli-builders\n - guide/cli-builder#builder-input\n - guide/cli-builder#builder-project-structure\n - guide/cli-builder#cli-builders\n - guide/cli-builder#creating-a-builder\n - guide/cli-builder#default-architect-configuration\n - guide/cli-builder#handling-output\n - guide/cli-builder#input-validation\n - guide/cli-builder#progress-and-status-reporting\n - guide/cli-builder#running-the-builder\n - guide/cli-builder#schedule-and-run\n - guide/cli-builder#summary\n - guide/cli-builder#target-configuration\n - guide/cli-builder#target-strings\n - guide/cli-builder#testing-a-builder\n - guide/cli-builder#watch-mode\n - guide/creating-libraries#publishing-your-library\n - guide/glossary#builder\n - guide/glossary#project\n - guide/glossary#schematic\n - guide/glossary#target\n - guide/workspace-config\n - http://json-schema.org\n - https://docs.npmjs.com/files/package.json\n - https://electronjs.org\n - https://github.com/TypeStrong/ts-node\n - https://github.com/angular/angular-cli/blob/ba21c855c0c8b778005df01d4851b5a2176edc6f/packages/angular_devkit/build_angular/src/tslint/index.ts#L107\n - https://github.com/mgechev/cli-builders-demo\n - https://nodejs.org/api/fs.html#fs_fspromises_copyfile_src_dest_mode\n - https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\n-->"}