{"id":"guide/cli-builder","title":"Angular CLI 建構式（Builder）","contents":"<div class=\"content\">\n  <h1 id=\"angular-cli-builders\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7l4r5ksly876d1b8swxh2gkax\">Angular CLI 建構式（Builder）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#angular-cli-builders\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4wzrri37s9he8d3zetohpa7lf\">很多 Angular CLI 指令都要在你的程式碼上執行一些複雜的處理，比如風格檢查（lint）建立或測試。這些指令會通過一個叫做建築師（Architect）的內部工具來執行 <em>CLI 建構式</em>，而這些建構式會運用一些第三方工具來完成目標任務。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ukmghke4q5jatt82lc2udafr\">在 Angular 的版本 8 中，CLI 建構式的 API 是穩定的，想要透過新增或修改指令來自定義 Angular CLI 的開發人員可以使用它。比如，你可以提供一個建構式來執行全新的任務，或者更改一個現有指令所使用的第三方工具。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"j2d0mdqv4nwj03y9kz41rl8a\">本文件介紹了 CLI 建構式是如何與工作區設定檔案整合的，還展示了如何建立你自己的建構式。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46v4j6efymdih8ja7iupyst5w\">可以在這個 <a href=\"https://github.com/mgechev/cli-builders-demo\">GitHub 倉庫</a>中的例子中找到程式碼。</p>\n</div>\n<h2 id=\"cli-builders\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6kgou0phblc70g8sr36snxabc\">CLI 建構式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#cli-builders\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3acn0lrnb615o34itqoxxvvg1\">內部建築師工具會把工作委託給名叫<a href=\"guide/glossary#builder\"><em>建構式</em></a>的處理器函式。處理器函式接收兩個引數：一組 <code>options</code> 輸入（JSON 物件）和一個 <code>context</code>（<code>BuilderContext</code> 物件）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d1s3y8b4n9qpr4giro6dmsd0i\">這裡對關注點的分離和<a href=\"guide/glossary#schematic\">原理圖</a>中是一樣的，它也適用於其它要接觸（touch）程式碼的 CLI 指令（比如 <code>ng generate</code>）。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ef05575377s7l5070sbcmc52b\">此 <code>options</code> 物件是由本 CLI 的使用者提供的，而 <code>context</code> 物件則由 CLI 建構式的 API 提供</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7nglyiseu6k4cn7cz2rxagr40\">除了上下文訊息之外，此 <code>context</code> 物件（它是 <code>BuilderContext</code> 的實例）還允許你訪問排程方法 <code>context.scheduleTarget()</code>。排程器會用指定的<a href=\"guide/glossary#target\">目標設定</a>來執行建構式處理函式。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bdh162d4rltuhi8z7oos42ezx\">這個建構式處理函式可以是同步的（回傳一個值）或非同步的（回傳一個 Promise），也可以監視並回傳多個值（回傳一個 Observable）。最終回傳的值全都是 <code>BuilderOutput</code> 型別的。該物件包含一個邏輯欄位 <code>success</code> 和一個可以包含錯誤訊息的可選欄位 <code>error</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37011gi4t616lscyl3rlr8a01\">Angular 提供了一些建構式，供 CLI 指令使用，如 <code>ng build</code> 和 <code>ng test</code> 等。這些內建 CLI 建構式的預設目標設定可以在<a href=\"guide/workspace-config\">工作區設定檔案</a> <code>angular.json</code> 的 <code>architect</code> 部分找到（並進行自定義）。可以透過建立自己的建構式來擴充套件和自定義 Angular，你可以使用 <a href=\"cli/run\"><code>ng run</code> CLI 指令</a>來執行你自己的建構式。</p>\n<h3 id=\"builder-project-structure\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5r1ispfd7rgbbazpo0kgauejo\">建構式的專案結構<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-project-structure\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6grnrmnf7umtltqo3rh1rat1\">建構式位於一個 <code>project</code> 資料夾中，該資料夾的結構類似於 Angular 工作區，包括位於頂層的全域設定檔案，以及位於工作程式碼所在源資料夾中的更具體的設定。比如，<code>myBuilder</code> 資料夾中可能包含如下檔案。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8n2c7wfntpyw9gnmnqx5bqxht\">檔案</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"297niinze7mn1fnajtyjcs0tb\">目的</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>src/my-builder.ts</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ahr5s0k61d5dbzq2vkwmj08qr\">建構式定義的主要源檔案。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>src/my-builder.spec.ts</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66qowvh1zht2uzvl0ikg904hy\">測試用的源檔案。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>src/schema.json</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vsplc0qiumt6y2vozgwf87t7\">建構式輸入選項的定義。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>builders.json</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b3m621w2ry61vdwtsymyvne68\">建構式定義。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>package.json</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2v56x4bo1ubnrqi5ndiwz5m8x\">依賴項。請參閱\n<a href=\"https://docs.npmjs.com/files/package.json\">https://docs.npmjs.com/files/package.json</a>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>tsconfig.json</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwwsw8xc8xni0juif25znc4tk\"><a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\">TypeScript 設定</a>。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"clpdiih2dch8m0vws0ztcue0c\">將此建構式發布到 <code>npm</code>（參閱<a href=\"guide/creating-libraries#publishing-your-library\">發布你的函式庫</a>）。如果你將其發布為 <code>&amp;commat;example/my-builder</code>，請使用以下指令安裝它。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @example/my-builder\n\n</code-example>\n<h2 id=\"creating-a-builder\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9n6khelrjscrzq171a67lbxxu\">建立建構式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#creating-a-builder\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"84lsyisl4as1t64f1q465vcvf\">舉個例子，讓我們建立一個用來複製檔案的建構式。要建立建構式，請使用 CLI 建構式函式 <code>createBuilder()</code>，並回傳一個 <code>Promise&lt;BuilderOutput&gt;</code> 物件。</p>\n<code-example header=\"src/my-builder.ts (builder skeleton)\" path=\"cli-builder/src/my-builder.ts\" region=\"builder-skeleton\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\n<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&lt;BuilderOutput&gt; {\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"296su3b2zeymtqn1u4m0dgdme\">現在，讓我們為它新增一些邏輯。下列程式碼會從使用者選項中獲取源檔案和目標檔案的路徑，並且把源檔案複製到目標檔案（使用 <a href=\"https://nodejs.org/api/fs.html#fs_fspromises_copyfile_src_dest_mode\">NodeJS 內建函式 <code>copyFile()</code> 的 Promise 版本</a>）。如果檔案操作失敗了，它會回傳一個帶有底層錯誤訊息的 error 物件。</p>\n<code-example header=\"src/my-builder.ts (builder)\" path=\"cli-builder/src/my-builder.ts\" region=\"builder\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\n<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&lt;BuilderOutput&gt; {\n  try {\n    await fs.copyFile(options.source, options.destination);\n  } catch (err) {\n    return {\n      success: false,\n      error: err.message,\n    };\n  }\n\n  return { success: true };\n}\n\n\n</code-example>\n<h3 id=\"handling-output\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3x6r7cwe0w52kmwvxzbr9x5n0\">處理輸出<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#handling-output\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3tkec7wy22ldo3l0spl6zfa96\">預設情況下，<code>copyFile()</code> 方法不會往標準輸出或標準錯誤中列印任何訊息。如果發生了錯誤，可能很難理解建構式到底做了什麼。可以使用 <code>Logger</code> API 來記錄一些額外的訊息，以提供額外的上下文。這樣還能讓建構式本身可以在一個單獨的程序中執行，即使其標準輸出和標準錯誤被停用了也無所謂（就像在 <a href=\"https://electronjs.org/\">Electron 應用中一樣</a>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7kgarbtoeyjq81dmaswy4mtoa\">你可以從上下文中檢索一個 <code>Logger</code> 實例。</p>\n<code-example header=\"src/my-builder.ts (handling output)\" path=\"cli-builder/src/my-builder.ts\" region=\"handling-output\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\n<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&lt;BuilderOutput&gt; {\n  try {\n    await fs.copyFile(options.source, options.destination);\n  } catch (err) {\n    context.logger.error('Failed to copy file.');\n    return {\n      success: false,\n      error: err.message,\n    };\n  }\n\n  return { success: true };\n}\n\n\n</code-example>\n<h3 id=\"progress-and-status-reporting\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cuz0pn5szvgyi9hhwxlztzh9w\">進度和狀態報告<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#progress-and-status-reporting\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1v2vr412xyj4jsu3cnnxe0njj\">CLI 建構式 API 包含一些進度報告和狀態報告工具，可以為某些函式和介面提供提示訊息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"boofserp57q4napvq817guy7v\">要報告進度，請使用 <code>context.reportProgress()</code> 方法，它接受一個當前值（value）、一個（可選的）總值（total）和狀態（status）字串作為引數。總值可以是任意數字，比如，如果你知道有多少個檔案需要處理，那麼總值可能是這些檔案的數量，而當前值是已處理過的數量。除非傳入了新的字串，否則這個狀態字串不會改變。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"r2wsn4e7xhfa8vmhsrgglwo4\">你可以看看 <code>tslint</code> 建構式如何報告進度的<a href=\"https://github.com/angular/angular-cli/blob/ba21c855c0c8b778005df01d4851b5a2176edc6f/packages/angular_devkit/build_angular/src/tslint/index.ts#L107\">例子</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9suu21epk3evbq957b236ktw8\">在我們的例子中，這種複製操作或者已完成或者正在執行，所以不需要進度報告，但是可以報告狀態，以便呼叫此建構式的父建構式知道發生了什麼。可以用 <code>context.reportStatus()</code> 方法生成一個任意長度的狀態字串。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2izibw1ezeefmwl6efd4mjvcc\"><strong>注意</strong>：<br>\n無法保證長字串會完全顯示出來，可以裁剪它以適應介面顯示。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"33ic1reyfdyf4bzokpq4i2k27\">傳入一個空字串可以移除狀態。</p>\n<code-example header=\"src/my-builder.ts (progress reporting)\" path=\"cli-builder/src/my-builder.ts\" region=\"progress-reporting\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\n<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&lt;BuilderOutput&gt; {\n  context.reportStatus(`Copying ${options.source} to ${options.destination}.`);\n  try {\n    await fs.copyFile(options.source, options.destination);\n  } catch (err) {\n    context.logger.error('Failed to copy file.');\n    return {\n      success: false,\n      error: err.message,\n    };\n  }\n\n  context.reportStatus('Done.');\n  return { success: true };\n}\n\n\n</code-example>\n<h2 id=\"builder-input\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"sbsbuw84666j6o1ltiwslp71\">建構式的輸入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-input\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d8g116xeo1voeh3hk9jq5gen5\">你可以透過 CLI 指令間接呼叫一個建構式，也可以直接用 Angular CLI 的 <code>ng run</code> 指令來呼叫它。無論哪種情況，你都必須提供所需的輸入，但是可以用特定<a href=\"guide/glossary#target\"><em>目標</em></a>中預設定的值作為其預設值，然後指定一個預定義的、指定的設定進行覆蓋，最後在指令行中進一步覆蓋這些選項的值。</p>\n<h3 id=\"input-validation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8zp0j3nlgyvlg4excdxtxvofq\">對輸入的驗證<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#input-validation\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5ui1ca5hi0wp5ietnumiuo58\">你可以在該建構式的相關 JSON 模式中定義建構式都有哪些輸入。建築師工具會把解析後的輸入值收集到一個 <code>options</code> 物件中，並在將其傳給建構式函式之前先根據這個模式驗證它們的型別。（Schematics 函式庫也對使用者輸入做了同樣的驗證）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eltipty4fnaicv43a15hvtc8l\">對於這個範例建構式，你希望 <code>options</code> 的值是帶有兩個鍵的 <code>JsonObject</code>：一個是 <code>source</code>，一個是 <code>destination</code>，它們都是字串。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dud81slq4btbplmmqds9hc9o6\">你可以提供如下模式來對這些值的型別進行驗證。</p>\n<code-example header=\"src/schema.json\" format=\"json\" language=\"json\">\n\n{\n  \"$schema\": \"http://json-schema.org/schema\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"source\": {\n      \"type\": \"string\"\n    },\n    \"destination\": {\n      \"type\": \"string\"\n    }\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wm7yclw5hqny5aym16sluoq7\">這是一個非常簡單的例子，但這種模式驗證也可以非常強大。欲知詳情，參閱 <a href=\"http://json-schema.org\">JSON 模式網站</a>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"49ftuezbb6rk0bnryjsviyvz5\">要把建構式的實現與它的模式和名稱關聯起來，你需要建立一個<em>建構式定義</em>檔案，可以在 <code>package.json</code> 中指向該檔案。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9s0wtwjyqyy3eks004lwoeafy\">建立一個名為 <code>builders.json</code> 檔案，它看起來像這樣。</p>\n<code-example header=\"builders.json\" format=\"json\" language=\"json\">\n\n{\n  \"builders\": {\n    \"copy\": {\n      \"implementation\": \"./dist/my-builder.js\",\n      \"schema\": \"./src/schema.json\",\n      \"description\": \"Copies a file.\"\n    }\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ap3klge1omnmmbyvlhp6p9a8h\">在 <code>package.json</code> 檔案中，新增一個 <code>builders</code> 鍵，告訴建築師工具可以在哪裡找到這個建構式定義檔案。</p>\n<code-example header=\"package.json\" format=\"json\" language=\"json\">\n\n{\n  \"name\": \"@example/copy-file\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Builder for copying files\",\n  \"builders\": \"builders.json\",\n  \"dependencies\": {\n    \"@angular-devkit/architect\": \"~0.1200.0\",\n    \"@angular-devkit/core\": \"^12.0.0\"\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2plu27hzzxo1s678e8rzmd4ht\">我們建構式的官方名稱現在是\n<code>@example/copy-file:copy</code>。這個名稱的第一部分是套件名稱（使用節點解析解析），第二部分是建構式名稱（使用\n<code>builders.json</code>檔案解析）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6p8n93vvzi6pt3lu4hy5czxlf\">使用某個 <code>options</code> 是非常簡單的。在上一節，你就曾用過 <code>options.source</code> 和 <code>options.destination</code>。</p>\n<code-example header=\"src/my-builder.ts (report status)\" path=\"cli-builder/src/my-builder.ts\" region=\"report-status\">\ncontext.reportStatus(`Copying ${options.source} to ${options.destination}.`);\ntry {\n  await fs.copyFile(options.source, options.destination);\n} catch (err) {\n  context.logger.error('Failed to copy file.');\n  return {\n    success: false,\n    error: err.message,\n  };\n}\n\ncontext.reportStatus('Done.');\nreturn { success: true };\n\n</code-example>\n<h3 id=\"target-configuration\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ap4qp9spjlry1ho1c60c9q7i0\">目標設定<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-configuration\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9aup2ryb6ua6l0rx7qaeci0ol\">建構式必須有一個已定義的目標，此目標會把建構式與特定的輸入設定和<a href=\"guide/glossary#project\">專案</a>關聯起來。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4u7cj5oceixkw1mmx60hiry7i\">目標是在 <a href=\"guide/workspace-config\">CLI 設定檔案</a> <code>angular.json</code> 中定義的。目標用於指定要使用的建構式、預設的選項設定，以及指定的備用設定。建築師工具使用目標定義來為一次特定的執行解析輸入選項。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"316bj7oe4l9jc8hz8wfft6auk\"><code>angular.json</code> 檔案中為每個專案都有一節設定，每個專案的 <code>architect</code> 部分都會為 CLI 指令（比如 <code>build</code>、<code>test</code> 和 <code>lint</code>）設定建構式目標。預設情況下，<code>build</code> 指令會執行 <code>@angular-devkit/build-angular:<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a></code> 建構式來執行 <code>build</code> 任務，並傳入 <code>angular.json</code> 中為 <code>build</code> 目標指定的預設選項值。</p>\n<code-example format=\"json\" header=\"angular.json\" language=\"json\">\n{\n  \"myApp\": {\n    …\n    \"architect\": {\n      \"build\": {\n        \"builder\": \"@angular-devkit/build-angular:browser\",\n        \"options\": {\n          \"outputPath\": \"dist/myApp\",\n          \"index\": \"src/index.html\",\n          …\n        },\n        \"configurations\": {\n          \"production\": {\n            \"fileReplacements\": [\n              {\n                \"replace\": \"src/environments/environment.ts\",\n                \"with\": \"src/environments/environment.prod.ts\"\n              }\n            ],\n            \"optimization\": true,\n            \"outputHashing\": \"all\",\n            …\n          }\n        }\n      },\n      …\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5cncb3m0vs07ihc72lpw9aqe1\">該指令會給建構式傳遞 <code>options</code> 節中指定的一組預設選項。如果你傳入了 <code>--configuration=production</code> 標誌，它就會使用 <code>production</code> 備用設定中指定的值進行覆蓋。可以在指令行中單獨指定其它選項進行覆蓋，還可以為 <code>build</code> 目標新增更多備用設定，以定義其它環境，比如 <code>stage</code> 或 <code>qa</code>。</p>\n<h4 id=\"target-strings\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dat3zwzlefm6chdua35ukj6vs\">目標字串<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-strings\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8af6583cxip4hdmda40v4u18e\">通用的 <code>ng run</code> CLI 指令將以下格式的目標字串作為其第一個引數。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nproject:target[:configuration]\n\n</code-example>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">project</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"xe7zxgogglxp43ocx7mv7xhh\">與目標相關聯的 Angular CLI 專案的名稱。</td>\n</tr>\n<tr>\n<td align=\"left\">target</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4q2aeminbjb51gnx01abjeckn\">來自\n<code>angular.json</code>檔案中\n<code>architect</code>部分的命名建構式設定。</td>\n</tr>\n<tr>\n<td align=\"left\">configuration</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"64p2jryo7rbjs5n2t200z6yc3\">(可選)給定目標的特定設定覆蓋的名稱，在\n<code>angular.json</code>檔案中定義。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4t61j0b1s0jlq0newc1hwotmg\">如果你的建構式呼叫另一個建構式，它可能需要讀取一個傳入的目標字串。可以使用 <code>@angular-devkit/architect</code> 中的工具函式 <code>targetFromTargetString()</code> 把這個字串解析成一個物件。</p>\n<h2 id=\"schedule-and-run\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8loj29v6qd1xkvdwzrc9s7hlj\">排程並執行<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#schedule-and-run\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1es39azpn7uf5m3h3nma254xn\">建築師會非同步執行建構式。要呼叫某個建構式，就要在所有設定解析完成之後安排一個要執行的任務。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekq5y231idg6kef0fzzg0us94\">在排程器回傳 <code>BuilderRun</code> 控制元件物件之前，不會執行該建構式函式。CLI 通常會通過呼叫 <code>context.scheduleTarget()</code> 函式來排程任務，然後使用 <code>angular.json</code> 檔案中的目標定義來解析輸入選項。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2y7c8zxy5neoqtytzxsas3x66\">建築師會接受預設的選項物件來解析指定目標的輸入選項，然後覆蓋所用設定中的值（如果有的話），然後再從傳給 <code>context.scheduleTarget()</code> 的覆蓋物件中覆蓋這些值。對於 Angular CLI，覆蓋物件是從命令行引數中建立的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ekj848pozzkwzl0liow9vbdb\">建築師會根據建構式的模式對生成的選項值進行驗證。如果輸入有效，建築師會建立上下文並執行該建構式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ik8qjkbjext78pfy0fw3gose\">欲知詳情，參閱<a href=\"guide/workspace-config\">工作區設定</a>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"65vje017chty4ap4voljr2cvf\">你還可以透過呼叫 <code>context.scheduleBuilder()</code> 從另一個建構式或測試中呼叫某個建構式。你可以直接把 <code>options</code> 物件傳給該方法，並且這些選項值會根據這個建構式的模式進行驗證，而無需進一步調整。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"73l0g32a2mbxl8r0i3l0u1nxm\">只有 <code>context.scheduleTarget()</code> 方法來解析這些設定和並透過 <code>angular.json</code> 檔案進行覆蓋。</p>\n</div>\n<h3 id=\"default-architect-configuration\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9nozhnfbaf3yyhzkadlg9zrdr\">預設建築師設定<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#default-architect-configuration\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4l58ytmuf1unpfz649fij7oj0\">讓我們建立一個簡單的 <code>angular.json</code> 檔案，它會把目標設定放到上下文中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9y50tm39yxo4e1d8i61w6v44d\">你可以把這個建構式發布到 npm（參閱<a href=\"guide/creating-libraries#publishing-your-library\">發布你的函式庫</a>），並使用如下指令來安裝它：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @example/copy-file\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"14zx9jczm1sbzkvexzh8apq8a\">如果用 <code>ng new builder-test</code> 建立一個新專案，那麼生成的 <code>angular.json</code> 檔案就是這樣的，它只有預設的建構式引數。</p>\n<code-example format=\"json\" header=\"angular.json\" language=\"json\">\n\n{\n  // …\n  \"projects\": {\n    // …\n    \"builder-test\": {\n      // …\n      \"architect\": {\n        // …\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser\",\n          \"options\": {\n            // … more options…\n            \"outputPath\": \"dist/builder-test\",\n            \"index\": \"src/index.html\",\n            \"main\": \"src/main.ts\",\n            \"polyfills\": \"src/polyfills.ts\",\n            \"tsConfig\": \"src/tsconfig.app.json\"\n          },\n          \"configurations\": {\n            \"production\": {\n              // … more options…\n              \"optimization\": true,\n              \"aot\": true,\n              \"buildOptimizer\": true\n            }\n          }\n        }\n      }\n    }\n  }\n  // …\n}\n\n</code-example>\n<h3 id=\"adding-a-target\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dpaaal8hv3zp02d3ah4mnilj1\">新增一個目標<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#adding-a-target\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44xjuwbbf5vrorwzs09zwrbf3\">新增一個新的目標，來執行我們的建構式以複製檔案。該目標告訴建構式，複製 <code>package.json</code> 檔案。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dtsjbfwz1mncn34h1rdz9jm8z\">你需要更新 <code>angular.json</code> 檔案，把這個建構式的目標新增到新專案的 <code>architect</code> 部分。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46v3xsiq5tr8n758yr4z8zxin\">我們會為專案的 <code>architect</code> 物件新增一個新的目標小節</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dnmzk6eu91tzxqsv8njkrdmhk\">名為 <code>copy-package</code> 的目標使用了我們的建構式，它發布到了 <code>@example/copy-file</code>。（參閱<a href=\"guide/creating-libraries#publishing-your-library\">發布你的函式庫</a>）</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bd556occfqdsb95khotpqs6ug\">這個設定物件為我們定義的兩個輸入提供了預設值：<code>source</code>（你要複製的現有檔案）和 <code>destination</code>（你要複製到的路徑）</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ygqswxuxgrf05d95cta4eyfo\">這些設定鍵都是可選的，但我們先不展開</p>\n</li>\n</ul>\n<code-example format=\"json\" header=\"angular.json\" language=\"json\">\n\n{\n  \"projects\": {\n    \"builder-test\": {\n      \"architect\": {\n        \"copy-package\": {\n          \"builder\": \"@example/copy-file:copy\",\n          \"options\": {\n            \"source\": \"package.json\",\n            \"destination\": \"package-copy.json\"\n          }\n        },\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser\",\n          \"options\": {\n            \"outputPath\": \"dist/builder-test\",\n            \"index\": \"src/index.html\",\n            \"main\": \"src/main.ts\",\n            \"polyfills\": \"src/polyfills.ts\",\n            \"tsConfig\": \"src/tsconfig.app.json\"\n          },\n          \"configurations\": {\n            \"production\": {\n              \"fileReplacements\": [\n                {\n                  \"replace\": \"src/environments/environment.ts\",\n                  \"with\": \"src/environments/environment.prod.ts\"\n                }\n              ],\n              \"optimization\": true,\n              \"aot\": true,\n              \"buildOptimizer\": true\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n</code-example>\n<h3 id=\"running-the-builder\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7j4jdrwbywskac2u890ftsrm9\">執行這個建構式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#running-the-builder\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5oabbdx5cx5023vt2e2ulgpqj\">要想使用這個新目標的預設設定執行我們的建構式，請使用以下 CLI 指令。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng run builder-test:copy-package\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dcw5w0nq8lhbrbhs8kqvpud9m\">這將把 <code>package.json</code> 檔案複製成 <code>package-copy.json</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bqnzgbnfa02j3dv97r5da0wna\">你可以使用指令行引數來覆蓋已設定的預設值。比如，要改用其它 <code>destination</code> 值執行，請使用以下 CLI 指令。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng run builder-test:copy-package --destination=package-other.json\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"elbe6car4u2g6hepj4k5ixb7c\">這將把此檔案複製為 <code>package-other.json</code> 而不再是 <code>package-copy.json</code>。因為我們沒有覆蓋 <em>source</em> 選項，所以它仍然會從 <code>package.json</code> 檔案複製（提供給該目標的預設值）。</p>\n<h2 id=\"testing-a-builder\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76v60t367d30jnmj6ny5c3pgg\">測試一個建構式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#testing-a-builder\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"oa4qisnipr2d8cqiikd6xciq\">對建構式進行整合測試，以便你可以使用建築師的排程器來建立一個上下文，就像這個<a href=\"https://github.com/mgechev/cli-builders-demo\">例子</a>中一樣。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ubxb25cne72fuogi4lghup27\">在建構式的原始碼目錄下，你建立了一個新的測試檔案 <code>my-builder.spec.ts</code>。該程式碼建立了 <code>JsonSchemaRegistry</code>（用於模式驗證）、<code>TestingArchitectHost</code>（對 <code>ArchitectHost</code> 的記憶體實現）和 <code>Architect</code> 的新實例。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ej1hk3rdwusfl9c3438cd7u0\">我們緊挨著這個建構式的 <code>package.json</code> 檔案新增了一個 <code>builders.json</code> 檔案，並修改了 <code>package.json</code> 檔案以指向它。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7an6uvui2e4vw4o8e2ufwuvrx\">下面是執行此復制檔案建構式的測試範例。該測試使用該建構式來復制 <code>package.json</code> 檔案，並驗證複製後的檔案內容與源檔案相同。</p>\n<code-example header=\"src/my-builder.spec.ts\" path=\"cli-builder/src/my-builder.spec.ts\">\nimport { Architect } from '@angular-devkit/architect';\nimport { TestingArchitectHost } from '@angular-devkit/architect/testing';\nimport { schema } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\nimport { join } from 'path';\n\ndescribe('Copy File Builder', () =&gt; {\n  let architect: Architect;\n  let architectHost: TestingArchitectHost;\n\n  beforeEach(<a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    const registry = new schema.CoreSchemaRegistry();\n    registry.addPostTransform(schema.transforms.addUndefinedDefaults);\n\n    // TestingArchitectHost() takes workspace and current directories.\n    // Since we don't use those, both are the same in this case.\n    architectHost = new TestingArchitectHost(__dirname, __dirname);\n    architect = new Architect(architectHost, registry);\n\n    // This will either take a Node package name, or a path to the directory\n    // for the package.json file.\n    await architectHost.addBuilderFromPackage(join(__dirname, '..'));\n  });\n\n  it('can copy files', <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n    // A \"run\" can have <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> outputs, and contains progress information.\n    const run = await architect.scheduleBuilder('@example/copy-file:copy', {\n      source: 'package.json',\n      destination: 'package-copy.json',\n    });\n\n    // The \"result\" member (of type BuilderOutput) is the next output.\n    const output = await run.result;\n\n    // Stop the builder from running. This stops Architect from keeping\n    // the builder-associated states in memory, since builders keep waiting\n    // to be scheduled.\n    await run.stop();\n\n    // Expect that the copied file is the same as its source.\n    const sourceContent = await fs.readFile('package.json', 'utf8');\n    const destinationContent = await fs.readFile('package-copy.json', 'utf8');\n    expect(destinationContent).toBe(sourceContent);\n  });\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xcfonzn6tqegmbw6dx5wnlwm\">在你的倉庫中執行這個測試時，需要使用 <a href=\"https://github.com/TypeStrong/ts-node\"><code>ts-node</code></a> 套件。你可以把 <code>index.spec.ts</code> 重新命名為 <code>index.spec.js</code> 來回避它。</p>\n</div>\n<h3 id=\"watch-mode\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3kp0kq6h4xp3h8xnjsuxa6pem\">監視（watch）模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#watch-mode\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8mtgmtjih9h43lxrwdm79o1yi\">建築師希望建構式執行一次（預設情況下）並回傳。這種行為與那些需要監視檔案更改的建構式（比如 Webpack）並不完全相容。建築師可以支援監視模式，但要注意一些問題。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1nil5ygyx5to0n3227bsa35s1\">要在監視模式下使用，建構式處理函式應回傳一個 Observable。建築師會訂閱這個 Observable，直到這個 Observable 完成（complete）為止。此外，如果使用相同的引數再次排程這個建構式，建築師還能複用這個 Observable。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7xff05bi636ga5y7xes72pq6r\">這個建構式應該總是在每次執行後發出一個 <code>BuilderOutput</code> 物件。一旦它被執行，就會進入一個由外部事件觸發的監視模式。如果一個事件導致它重啟，那麼此建構式應該執行 <code>context.reportRunning()</code> 函式來告訴建築師再次執行它。如果排程器還計劃了另一次執行，就會阻止建築師停掉這個建構式。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cg8iqzw1yb40gak9h2irtjm8o\">當你的建構式透過呼叫 <code>BuilderRun.stop()</code> 來退出監視模式時，建築師會從建構式的 Observable 中取消訂閱，並呼叫建構式的退出邏輯進行清理。（這種行為也允許停止和清理執行時間過長的建立。）</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94ot10c8uub5h3bphdmprmn7t\">一般來說，如果你的建構式正在監視一個外部事件，你應該把你的執行分成三個階段。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2v8iozxk892ni0taax8ij1mry\">階段</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5frl2ir0exfvl8imvuiuljuo9\">執行</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76xv6htgsrvpctesr9fhjeaxr\">例如，webpack進行編譯。當webpack完成並且你的建構式發出\n<code>BuilderOutput</code>物件時，此階段結束。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37f7flgry1x95bjv914i9u06v\">監視</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"57snsnk7nkvzgj5rqjx65ps4i\">在兩次執行之間，監視外部事件流。例如，webpack監視檔案系統的任何更改。當webpack重新開始建立，並呼叫\n<code>context.reportRunning()</code>時，此階段結束。然後回到步驟1。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2u4dioitnz04de7ge1ldln80e\">完成</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f19hv1mdzycnposb08asfywp\">任務完全完成（例如，webpack應該執行多次），或者建構式執行被停止（使用\n<code>BuilderRun.stop()</code>）。你的清理邏輯將被執行，並且Architect會取消訂閱你的建構式的Observable。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"summary\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2fflknbbur8ttwdtn3o9w4vat\">總結<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#summary\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c9hxf90nlwcr4k2g8vcdsod1t\">CLI 建構式 API 提供了一種透過建構式執行自定義邏輯，以改變 Angular CLI 行為的新方式。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqzemm3vet7aytz0v627tbdb1\">建構式既可以是同步的，也可以是非同步的，它可以只執行一次也可以監視外部事件，還可以排程其它建構式或目標</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2v44ljs7tudqb5upt6pvv0mk1\">建構式在 <code>angular.json</code> 設定檔案中指定了選項的預設值，它可以被目標的備用設定覆蓋，還可以進一步被指令行標誌所覆蓋</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"28gkxmead7b3ls0hnaidu1h52\">建議你使用整合測試來測試建築師的建構式。還可以用單元測試來驗證這個建構式的執行邏輯。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4irnrmnw0x778vrl1wg25dhwv\">如果你的建構式回傳一個 Observable，你應該在那個 Observable 的退出邏輯中進行清理</p>\n</li>\n</ul>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/architecture-next-steps\n - guide/deployment\n - guide/workspace-config\n-->\n<!-- links from this doc:\n - api/animations/browser\n - api/forms/SelectMultipleControlValueAccessor\n - api/platform-browser/animations/async\n - cli/run\n - guide/cli-builder#adding-a-target\n - guide/cli-builder#angular-cli-builders\n - guide/cli-builder#builder-input\n - guide/cli-builder#builder-project-structure\n - guide/cli-builder#cli-builders\n - guide/cli-builder#creating-a-builder\n - guide/cli-builder#default-architect-configuration\n - guide/cli-builder#handling-output\n - guide/cli-builder#input-validation\n - guide/cli-builder#progress-and-status-reporting\n - guide/cli-builder#running-the-builder\n - guide/cli-builder#schedule-and-run\n - guide/cli-builder#summary\n - guide/cli-builder#target-configuration\n - guide/cli-builder#target-strings\n - guide/cli-builder#testing-a-builder\n - guide/cli-builder#watch-mode\n - guide/creating-libraries#publishing-your-library\n - guide/glossary#builder\n - guide/glossary#project\n - guide/glossary#schematic\n - guide/glossary#target\n - guide/workspace-config\n - http://json-schema.org\n - https://docs.npmjs.com/files/package.json\n - https://electronjs.org\n - https://github.com/TypeStrong/ts-node\n - https://github.com/angular/angular-cli/blob/ba21c855c0c8b778005df01d4851b5a2176edc6f/packages/angular_devkit/build_angular/src/tslint/index.ts#L107\n - https://github.com/mgechev/cli-builders-demo\n - https://nodejs.org/api/fs.html#fs_fspromises_copyfile_src_dest_mode\n - https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\n-->"}