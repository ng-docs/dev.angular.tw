{"id":"guide/observables","title":"使用可觀察物件處理值流","contents":"<div class=\"content\">\n  <p><a id=\"using-observables-to-pass-values\"></a></p>\n<h1 id=\"using-observables-for-streams-of-values\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3j7r9wgo2a7sf4jfs4zwsnemv\">使用可觀察物件處理值流<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#using-observables-for-streams-of-values\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ivxqncgyh1j9cx8mc7ybrw8l\">Observables 是一種用於事件處理、非同步程式設計和處理隨時間發出的多個值的技術。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ebhgd3awjtf2way6v6ew0n0f\">觀察者（Observer）模式是一個軟體設計模式，它有一個物件，稱之為<em>主體 Subject</em>，負責維護一個依賴項（稱之為觀察者 Observer）的清單，並且在狀態變化時自動通知它們。該模式和<a href=\"https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\">發布/訂閱</a>模式非常相似（但不完全一樣）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cun2dg8few7x2rrob18tia8tg\">Angular 應用程式通常使用 \n<a href=\"https://rxjs.dev/\">RxJS 函式庫來處理 Observables</a>。本概覽僅涵蓋了該函式庫實現的 Observables 基礎知識。</p>\n<h2 id=\"basic-usage-and-terms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drib7yu0iwcbvhn7sansue1ou\">基本用法和詞彙<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#basic-usage-and-terms\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bdi7bs83waqsgbkrfc4zn8urw\">Observables 是宣告式的。你定義一個用於發布值的函式 —— \n<em>源</em> —— 但該函式直到消費者透過呼叫 observable 的 \n<code>subscribe</code> 方法訂閱該 observable 時才會執行。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"q08pgynxcl1zneqlvkbobz1t\">然後，這個 \n<em>訂閱者</em> 將從 observable 接收通知，直到完成、發出錯誤或消費者取消訂閱為止。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"egfvn5xtohad3pk83pvv3406d\">Observable 可以傳遞任何型別的多個值 —— 字面量、訊息或事件 —— 取決於上下文。按照典型的 observable 源，按鍵的流、HTTP 回應和間隔計時器的滴答聲均在其中。Observable API 在所有這些不同的源上都保持一致。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jf2m5mdmhddt271kxrugloot\">Observable 在訂閱時可以發出一個、多個或零個值。它可以同步發出（立即發出第一個值）或非同步發出（隨時間發出值）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3rz2ihs5cqzl014iaaoi7zmxa\">由於 observable 處理了設定和拆卸邏輯，你的應用程式碼只需關注訂閱以消費值，並在完成後取消訂閱。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"924dgbminpmn8xm3ye20tqmyc\"><a href=\"guide/rx-library#operators\">RxJS <em>運算子</em></a> 可以對 observable 值進行轉換。一個 \n<em>運算子</em> 獲取一個 observable 源，以某種有用的方式操縱來自該源的值，並回傳一個經過轉換的新 observable。當你訂閱該新 observable 時，你將獲得中間轉換的結果。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5qkqqlvrsymzvup2au3cbe9io\">逐步轉換 observable 值的能力 —— 甚至將多個 observable 源組合成一個統一的 observable —— 是 RxJS 功能中最強大和吸引人的之一。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dbzedku2w8cpllx9mp7q4lv18\">因此，在 Angular 應用程式內部以及 Angular 本身中廣泛使用 observables。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"daln8fepedktqhxo0h1hc063s\">公平地說，RxJS 有陡峭的學習曲線，有時會有令人困惑的行為。要謹慎使用。</p>\n</div>\n<h2 id=\"observable\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekbi3pmy2k9b83xgx9cjqwdyg\">可觀察物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#observable\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26pakqheu0319mfx8188srpln\">Observable 是一個可以隨時間發出一個或多個值的物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bf9zg72zzi3s0505psabvksq8\">以下是一個簡單的 observable，它將依次發出 \n<code>1</code>、然後 \n<code>2</code>、然後 \n<code>3</code>，然後完成。</p>\n<code-example header=\"An observable emitting 3 integers\" path=\"observables/src/subscribing.ts\" region=\"observable\">\nimport { of } from 'rxjs';\n\nconst numbers$ = of(1, 2, 3); // simple observable that emits three values\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bkgzk07fwrshay7ha79chyg5r\">RxJS 方法 \n<code>of(...values)</code> 建立一個 \n<code>Observable</code> 實例，同步傳遞提供的每個值作為引數。</p>\n</div>\n<h3 id=\"naming-conventions-for-observables\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8v08yzzckvuqsgqvxx7l7wj04\">可觀察物件的命名約定<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#naming-conventions-for-observables\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9bd0n0abfuidppe0u7gwi1a2x\">注意 observable 名稱末尾的\"$\"。\"$\" 表示該變數是一個值的 \"$tream\" observable。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5dixi2jyqepv7n00cjo6mof1r\">這是廣泛採用的 observables 命名約定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5i27bqrrii8bpvhvh9wdjqjg5\">並非所有人都喜歡它。因為 Angular 應用程式是用 TypeScript 編寫的，程式碼編輯器擅長顯示物件型別，通常可以判斷變數是否為 observable。許多人認為 \"$\" 字尾是不必要的，甚至可能會產生誤導。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3u48sq83oekif188rw7gjlq15\">另一方面，末尾的 \"$\" 可以幫助你在掃描程式碼時快速識別 observables。此外，如果你希望一個屬性儲存來自 observable 發出的最新值，使用源 observable 的根名稱而不帶 \"$\" 可能會更方便。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"15r36vixvi02vxc263znhs3za\">Angular 框架和工具不強制執行這個約定。可以選擇使用或不使用。</p>\n<h2 id=\"subscribing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"abjukavuezeeqios1shy0zdmg\">訂閱<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#subscribing\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xscr7mzugv18zu6v0x383rld\">可觀察物件僅在有人訂閱時開始發布值。只有當你呼叫可觀察物件的\n<code>subscribe()</code>方法訂閱時，『1-2-3』可觀察物件才會發出任何數字。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f6hkvi7rzosky4k1yfgvu15h\">如果你想開始發布但不關心值或完成時間，可以呼叫沒有任何引數的subscribe</p>\n<code-example header=\"Start publishing\" path=\"observables/src/subscribing.ts\" region=\"no-params\">\nnumbers$.subscribe();\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3odgcinrwp4syx66p0exbwgjc\">你更有可能對值做一些操作。傳入一個方法 - 稱為『next』處理程式 - 每次可觀察物件發出一個值時都會執行一些操作。</p>\n<code-example header=\"Subscribe to emitted values\" path=\"observables/src/subscribing.ts\" region=\"next-param\">\nnumbers$.subscribe(\n  value =&gt; console.log('Observable emitted the next value: ' + value)\n);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94rn472u7cbivunamhcqvmope\">將一個\n<code>next()</code>函式傳入\n<code>subscribe</code>是這種最典型情況的一種方便語法。如果你還需要知道可觀察物件何時發出錯誤或完成，你將需要傳入一個\n<code>Observer</code>。</p>\n<h2 id=\"defining-observers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c5cie6dmexfyn5l77wgo51psc\">定義觀察者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#defining-observers\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ukfemwgd8g9tuogeehr1q7yt\">可觀察物件有三種型別的通知：『next』，『error』和『complete』。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9625506xva0lecd0jl7f181jw\">一個\n<code>Observer</code>是一個物件，其屬性包含這些通知的處理程式。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dw3f9054kvreov32y22g1o93\">通知型別</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>next</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eph59qa69uigq6eoav7lzvkiq\">每個傳遞值的處理程式。在執行開始後被呼叫零次或多次。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>error</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bf5o3gcmhk21sxpfz207ja3tq\">錯誤通知的處理程式。錯誤會停止可觀察實例的執行並取消訂閱。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>complete</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5rs0rzdbds1lqvzw8z2chzwou\">執行完成通知的處理程式。不要期望\n<code>next</code>或\n<code>error</code>會再次被呼叫。會自動取消訂閱。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ncauk1rcjpbosowxw7tdrquo\">這裡是一個將觀察者物件傳遞給\n<code>subscribe</code>的範例：</p>\n<code-example header=\"Subscribe with full observer object\" path=\"observables/src/subscribing.ts\" region=\"object-param\">\nnumbers$.subscribe({\n  next: value =&gt; console.log('Observable emitted the next value: ' + value),\n  error: err =&gt; console.error('Observable emitted an error: ' + err),\n  complete: () =&gt; console.log('Observable emitted the complete notification')\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cohmazb30y4lreios41f4w8u\">另外，你可以使用名稱為\n<code>next()</code>、\n<code>error()</code>和\n<code>complete()</code>的函式建立\n<code>Observer</code>物件。</p>\n<code-example path=\"observables/src/subscribing.ts\" region=\"object-with-fns\">\nnumbers$.subscribe({\n  next(value) { console.log('Observable emitted the next value: ' + value); },\n  error(err)  { console.error('Observable emitted an error: ' + err); },\n  complete()  { console.log('Observable emitted the complete notification'); }\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"48n94i2rry4qbxoqabfxasyqu\">這是因為JavaScript將函式名轉換為屬性名。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c81j8bwu08oj4bw3tmfpci38j\">所有處理程式屬性都是可選的。 如果省略這些屬性中的一個處理程式，觀察者會忽略該類別型的通知。</p>\n<h2 id=\"error-handling\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ad0cx4y7txhii62pgdd0mpma9\">錯誤處理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#error-handling\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"edvp72w7268uk5zzr9hg3cyfc\">因為可觀察物件可以非同步產生值，try/catch將無法有效捕獲錯誤。 相反，你透過在觀察者上指定一個\n<code>error</code>函式來處理錯誤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"85ijoxmllvw0vx6gjg7lpm07n\">產生錯誤還會導致可觀察物件清理訂閱並停止產生值。</p>\n<code-example path=\"observables/src/subscribing.ts\" region=\"next-or-error\">\nnumbers$.subscribe({\n  next: value =&gt; console.log('Observable emitted the next value: ' + value),\n  error: err =&gt; console.error('Observable emitted an error: ' + err),\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dm3fcc1bq4batxa7v7psb1jr7\">錯誤處理（特別是從錯誤中恢復）在後麵的部分中有更詳細的介紹。</p>\n<h2 id=\"creating-observables\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vlw1a2xvtkucxf3ztvurtcc2\">建立可觀察物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#creating-observables\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1e4vsfsgrn1p4uc09h5mvxck2\">RxJS函式庫套件含許多用於建立可觀察物件的函式。一些最有用的函式將在後面介紹。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gorra7ve16tytvzy2gogmeol\">你也可以使用\n<code>Observable</code>建構式函式建立任何型別的可觀察流。 建構式函式的引數是\n<em>訂閱者函式</em>，當可觀察物件的\n<code>subscribe()</code>方法執行時運行。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3gt6h1x77vjugsjpx7stdsbl3\">訂閱者函式接收一個\n<code>Observer</code>物件，並可以將值發布到觀察者的\n<code>next()</code>、\n<code>error</code>和\n<code>complete</code>處理程式中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8x4e7j3so1v2x7egxzsgubw05\">例如，要建立一個與上面的 \n<code>of(1, 2, 3)</code> 等效的可觀察物件，你可以這樣寫：</p>\n<code-example header=\"Create observable with constructor\" path=\"observables/src/creating.ts\" region=\"subscriber\">\n// This function runs when subscribe() is called\nfunction sequenceSubscriber(observer: Observer&lt;number&gt;) {\n  // synchronously deliver 1, 2, and 3, then completes\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.complete();\n\n  // Return the unsubscribe function.\n  // This one doesn't do anything\n  // because values are delivered synchronously\n  // and there is nothing to clean up.\n  return {unsubscribe() {}};\n}\n\n// Create a new Observable that will deliver the above <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\nconst <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> = new Observable(sequenceSubscriber);\n\n// Execute the Observable and print the result of each notification\nsequence.subscribe({\n  next(num) { console.log(num); },\n  complete() { console.log('Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>'); }\n});\n\n// Logs:\n// 1\n// 2\n// 3\n// Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\n\n</code-example>\n<h2 id=\"geolocation-example\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"55mtt2qkcmkxa83cukt6i70zv\">地理位置範例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#geolocation-example\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"swi06fb270l6hbrc1xyq5tlg\">以下範例示範了如何透過展示如何建立和使用報告地理位置更新的可觀察物件來展示上述概念。</p>\n<code-example header=\"Observe geolocation updates\" class=\"no-auto-link\" path=\"observables/src/geolocation.ts\">\n\n// Create an Observable that will start listening to browser geolocation updates\n// when a consumer subscribes.\nconst locations = new Observable((observer) =&gt; {\n  let watchId: number;\n\n  // The geolocation API (if it exists) provides values to publish\n  if ('geolocation' in navigator) {\n    watchId = navigator.geolocation.watchPosition(\n      (position: GeolocationPosition) =&gt; observer.next(position),\n      (error: GeolocationPositionError) =&gt; observer.error(error)\n    );\n  } else {\n    observer.error('Geolocation not available');\n  }\n\n  // When the consumer unsubscribes, stop listening to geolocation changes.\n  return {\n    unsubscribe() {\n      navigator.geolocation.clearWatch(watchId);\n    }\n  };\n});\n\n// Call subscribe() to start listening for geolocation updates.\nconst locationsSubscription = locations.subscribe({\n  next(position) {\n    console.log('Current Position: ', position);\n  },\n  error(msg) {\n    console.log('Error Getting Location: ', msg);\n  }\n});\n\n// Stop listening for location after 10 seconds\nsetTimeout(() =&gt; {\n  locationsSubscription.unsubscribe();\n}, 10000);\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Fri Aug 25 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/service-worker/SwRegistrationOptions\n - guide/architecture-next-steps\n - guide/glossary\n - guide/http-interceptor-use-cases\n - guide/pipes\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/animations/sequence\n - guide/observables#basic-usage-and-terms\n - guide/observables#creating-observables\n - guide/observables#defining-observers\n - guide/observables#error-handling\n - guide/observables#geolocation-example\n - guide/observables#naming-conventions-for-observables\n - guide/observables#observable\n - guide/observables#subscribing\n - guide/observables#using-observables-for-streams-of-values\n - guide/rx-library#error-handling\n - guide/rx-library#observable-creation-functions\n - guide/rx-library#operators\n - https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\n - https://rxjs.dev/\n-->"}