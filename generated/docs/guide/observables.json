{"id":"guide/observables","title":"使用可观察对象处理值流","contents":"<div class=\"content\">\n  <p><a id=\"using-observables-to-pass-values\"></a></p>\n<h1 id=\"using-observables-for-streams-of-values\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3j7r9wgo2a7sf4jfs4zwsnemv\">使用可观察对象处理值流<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#using-observables-for-streams-of-values\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ivxqncgyh1j9cx8mc7ybrw8l\">Observables 是一种用于事件处理、异步编程和处理随时间发出的多个值的技术。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ebhgd3awjtf2way6v6ew0n0f\">观察者（Observer）模式是一个软件设计模式，它有一个对象，称之为<em>主体 Subject</em>，负责维护一个依赖项（称之为观察者 Observer）的列表，并且在状态变化时自动通知它们。该模式和<a href=\"https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\">发布/订阅</a>模式非常相似（但不完全一样）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cun2dg8few7x2rrob18tia8tg\">Angular 应用程序通常使用 \n<a href=\"https://rxjs.dev/\">RxJS 库来处理 Observables</a>。本概览仅涵盖了该库实现的 Observables 基础知识。</p>\n<h2 id=\"basic-usage-and-terms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drib7yu0iwcbvhn7sansue1ou\">基本用法和词汇<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#basic-usage-and-terms\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bdi7bs83waqsgbkrfc4zn8urw\">Observables 是声明式的。你定义一个用于发布值的函数 —— \n<em>源</em> —— 但该函数直到消费者通过调用 observable 的 \n<code>subscribe</code> 方法订阅该 observable 时才会执行。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"q08pgynxcl1zneqlvkbobz1t\">然后，这个 \n<em>订阅者</em> 将从 observable 接收通知，直到完成、发出错误或消费者取消订阅为止。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"egfvn5xtohad3pk83pvv3406d\">Observable 可以传递任何类型的多个值 —— 字面量、消息或事件 —— 取决于上下文。按照典型的 observable 源，按键的流、HTTP 响应和间隔计时器的滴答声均在其中。Observable API 在所有这些不同的源上都保持一致。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jf2m5mdmhddt271kxrugloot\">Observable 在订阅时可以发出一个、多个或零个值。它可以同步发出（立即发出第一个值）或异步发出（随时间发出值）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3rz2ihs5cqzl014iaaoi7zmxa\">由于 observable 处理了设置和拆卸逻辑，你的应用代码只需关注订阅以消费值，并在完成后取消订阅。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"924dgbminpmn8xm3ye20tqmyc\"><a href=\"guide/rx-library#operators\">RxJS <em>操作符</em></a> 可以对 observable 值进行转换。一个 \n<em>操作符</em> 获取一个 observable 源，以某种有用的方式操纵来自该源的值，并返回一个经过转换的新 observable。当你订阅该新 observable 时，你将获得中间转换的结果。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5qkqqlvrsymzvup2au3cbe9io\">逐步转换 observable 值的能力 —— 甚至将多个 observable 源组合成一个统一的 observable —— 是 RxJS 功能中最强大和吸引人的之一。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dbzedku2w8cpllx9mp7q4lv18\">因此，在 Angular 应用程序内部以及 Angular 本身中广泛使用 observables。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"daln8fepedktqhxo0h1hc063s\">公平地说，RxJS 有陡峭的学习曲线，有时会有令人困惑的行为。要谨慎使用。</p>\n</div>\n<h2 id=\"observable\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekbi3pmy2k9b83xgx9cjqwdyg\">可观察对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#observable\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26pakqheu0319mfx8188srpln\">Observable 是一个可以随时间发出一个或多个值的对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bf9zg72zzi3s0505psabvksq8\">以下是一个简单的 observable，它将依次发出 \n<code>1</code>、然后 \n<code>2</code>、然后 \n<code>3</code>，然后完成。</p>\n<code-example header=\"An observable emitting 3 integers\" path=\"observables/src/subscribing.ts\" region=\"observable\">\nimport { of } from 'rxjs';\n\nconst numbers$ = of(1, 2, 3); // simple observable that emits three values\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bkgzk07fwrshay7ha79chyg5r\">RxJS 方法 \n<code>of(...values)</code> 创建一个 \n<code>Observable</code> 实例，同步传递提供的每个值作为参数。</p>\n</div>\n<h3 id=\"naming-conventions-for-observables\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8v08yzzckvuqsgqvxx7l7wj04\">可观察对象的命名约定<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#naming-conventions-for-observables\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9bd0n0abfuidppe0u7gwi1a2x\">注意 observable 名称末尾的\"$\"。\"$\" 表示该变量是一个值的 \"$tream\" observable。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5dixi2jyqepv7n00cjo6mof1r\">这是广泛采用的 observables 命名约定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5i27bqrrii8bpvhvh9wdjqjg5\">并非所有人都喜欢它。因为 Angular 应用程序是用 TypeScript 编写的，代码编辑器擅长显示对象类型，通常可以判断变量是否为 observable。许多人认为 \"$\" 后缀是不必要的，甚至可能会产生误导。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3u48sq83oekif188rw7gjlq15\">另一方面，末尾的 \"$\" 可以帮助你在扫描代码时快速识别 observables。此外，如果你希望一个属性保存来自 observable 发出的最新值，使用源 observable 的根名称而不带 \"$\" 可能会更方便。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"15r36vixvi02vxc263znhs3za\">Angular 框架和工具不强制执行这个约定。可以选择使用或不使用。</p>\n<h2 id=\"subscribing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"abjukavuezeeqios1shy0zdmg\">订阅<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#subscribing\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xscr7mzugv18zu6v0x383rld\">可观察对象仅在有人订阅时开始发布值。只有当你调用可观察对象的\n<code>subscribe()</code>方法订阅时，“1-2-3”可观察对象才会发出任何数字。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f6hkvi7rzosky4k1yfgvu15h\">如果你想开始发布但不关心值或完成时间，可以调用没有任何参数的subscribe</p>\n<code-example header=\"Start publishing\" path=\"observables/src/subscribing.ts\" region=\"no-params\">\nnumbers$.subscribe();\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3odgcinrwp4syx66p0exbwgjc\">你更有可能对值做一些操作。传入一个方法 - 称为“next”处理程序 - 每次可观察对象发出一个值时都会执行一些操作。</p>\n<code-example header=\"Subscribe to emitted values\" path=\"observables/src/subscribing.ts\" region=\"next-param\">\nnumbers$.subscribe(\n  value =&gt; console.log('Observable emitted the next value: ' + value)\n);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94rn472u7cbivunamhcqvmope\">将一个\n<code>next()</code>函数传入\n<code>subscribe</code>是这种最典型情况的一种方便语法。如果你还需要知道可观察对象何时发出错误或完成，你将需要传入一个\n<code>Observer</code>。</p>\n<h2 id=\"defining-observers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c5cie6dmexfyn5l77wgo51psc\">定义观察者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#defining-observers\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ukfemwgd8g9tuogeehr1q7yt\">可观察对象有三种类型的通知：“next”，“error”和“complete”。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9625506xva0lecd0jl7f181jw\">一个\n<code>Observer</code>是一个对象，其属性包含这些通知的处理程序。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dw3f9054kvreov32y22g1o93\">通知类型</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>next</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eph59qa69uigq6eoav7lzvkiq\">每个传递值的处理程序。在执行开始后被调用零次或多次。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>error</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bf5o3gcmhk21sxpfz207ja3tq\">错误通知的处理程序。错误会停止可观察实例的执行并取消订阅。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>complete</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5rs0rzdbds1lqvzw8z2chzwou\">执行完成通知的处理程序。不要期望\n<code>next</code>或\n<code>error</code>会再次被调用。会自动取消订阅。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ncauk1rcjpbosowxw7tdrquo\">这里是一个将观察者对象传递给\n<code>subscribe</code>的示例：</p>\n<code-example header=\"Subscribe with full observer object\" path=\"observables/src/subscribing.ts\" region=\"object-param\">\nnumbers$.subscribe({\n  next: value =&gt; console.log('Observable emitted the next value: ' + value),\n  error: err =&gt; console.error('Observable emitted an error: ' + err),\n  complete: () =&gt; console.log('Observable emitted the complete notification')\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cohmazb30y4lreios41f4w8u\">另外，你可以使用名称为\n<code>next()</code>、\n<code>error()</code>和\n<code>complete()</code>的函数创建\n<code>Observer</code>对象。</p>\n<code-example path=\"observables/src/subscribing.ts\" region=\"object-with-fns\">\nnumbers$.subscribe({\n  next(value) { console.log('Observable emitted the next value: ' + value); },\n  error(err)  { console.error('Observable emitted an error: ' + err); },\n  complete()  { console.log('Observable emitted the complete notification'); }\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"48n94i2rry4qbxoqabfxasyqu\">这是因为JavaScript将函数名转换为属性名。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c81j8bwu08oj4bw3tmfpci38j\">所有处理程序属性都是可选的。 如果省略这些属性中的一个处理程序，观察者会忽略该类型的通知。</p>\n<h2 id=\"error-handling\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ad0cx4y7txhii62pgdd0mpma9\">错误处理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#error-handling\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"edvp72w7268uk5zzr9hg3cyfc\">因为可观察对象可以异步产生值，try/catch将无法有效捕获错误。 相反，你通过在观察者上指定一个\n<code>error</code>函数来处理错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"85ijoxmllvw0vx6gjg7lpm07n\">产生错误还会导致可观察对象清理订阅并停止产生值。</p>\n<code-example path=\"observables/src/subscribing.ts\" region=\"next-or-error\">\nnumbers$.subscribe({\n  next: value =&gt; console.log('Observable emitted the next value: ' + value),\n  error: err =&gt; console.error('Observable emitted an error: ' + err),\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dm3fcc1bq4batxa7v7psb1jr7\">错误处理（特别是从错误中恢复）在后面的部分中有更详细的介绍。</p>\n<h2 id=\"creating-observables\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vlw1a2xvtkucxf3ztvurtcc2\">创建可观察对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#creating-observables\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1e4vsfsgrn1p4uc09h5mvxck2\">RxJS库包含许多用于创建可观察对象的函数。一些最有用的函数将在后面介绍。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gorra7ve16tytvzy2gogmeol\">你也可以使用\n<code>Observable</code>构造函数创建任何类型的可观察流。 构造函数的参数是\n<em>订阅者函数</em>，当可观察对象的\n<code>subscribe()</code>方法执行时运行。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3gt6h1x77vjugsjpx7stdsbl3\">订阅者函数接收一个\n<code>Observer</code>对象，并可以将值发布到观察者的\n<code>next()</code>、\n<code>error</code>和\n<code>complete</code>处理程序中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8x4e7j3so1v2x7egxzsgubw05\">例如，要创建一个与上面的 \n<code>of(1, 2, 3)</code> 等效的可观察对象，你可以这样写：</p>\n<code-example header=\"Create observable with constructor\" path=\"observables/src/creating.ts\" region=\"subscriber\">\n// This function runs when subscribe() is called\nfunction sequenceSubscriber(observer: Observer&lt;number&gt;) {\n  // synchronously deliver 1, 2, and 3, then completes\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.complete();\n\n  // Return the unsubscribe function.\n  // This one doesn't do anything\n  // because values are delivered synchronously\n  // and there is nothing to clean up.\n  return {unsubscribe() {}};\n}\n\n// Create a new Observable that will deliver the above <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\nconst <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> = new Observable(sequenceSubscriber);\n\n// Execute the Observable and print the result of each notification\nsequence.subscribe({\n  next(num) { console.log(num); },\n  complete() { console.log('Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>'); }\n});\n\n// Logs:\n// 1\n// 2\n// 3\n// Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\n\n</code-example>\n<h2 id=\"geolocation-example\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"55mtt2qkcmkxa83cukt6i70zv\">地理位置示例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#geolocation-example\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"swi06fb270l6hbrc1xyq5tlg\">以下示例演示了如何通过展示如何创建和使用报告地理位置更新的可观察对象来展示上述概念。</p>\n<code-example header=\"Observe geolocation updates\" class=\"no-auto-link\" path=\"observables/src/geolocation.ts\">\n\n// Create an Observable that will start listening to browser geolocation updates\n// when a consumer subscribes.\nconst locations = new Observable((observer) =&gt; {\n  let watchId: number;\n\n  // The geolocation API (if it exists) provides values to publish\n  if ('geolocation' in navigator) {\n    watchId = navigator.geolocation.watchPosition(\n      (position: GeolocationPosition) =&gt; observer.next(position),\n      (error: GeolocationPositionError) =&gt; observer.error(error)\n    );\n  } else {\n    observer.error('Geolocation not available');\n  }\n\n  // When the consumer unsubscribes, stop listening to geolocation changes.\n  return {\n    unsubscribe() {\n      navigator.geolocation.clearWatch(watchId);\n    }\n  };\n});\n\n// Call subscribe() to start listening for geolocation updates.\nconst locationsSubscription = locations.subscribe({\n  next(position) {\n    console.log('Current Position: ', position);\n  },\n  error(msg) {\n    console.log('Error Getting Location: ', msg);\n  }\n});\n\n// Stop listening for location after 10 seconds\nsetTimeout(() =&gt; {\n  locationsSubscription.unsubscribe();\n}, 10000);\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Fri Aug 25 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/service-worker/SwRegistrationOptions\n - guide/architecture-next-steps\n - guide/glossary\n - guide/http-interceptor-use-cases\n - guide/pipes\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/animations/sequence\n - guide/observables#basic-usage-and-terms\n - guide/observables#creating-observables\n - guide/observables#defining-observers\n - guide/observables#error-handling\n - guide/observables#geolocation-example\n - guide/observables#naming-conventions-for-observables\n - guide/observables#observable\n - guide/observables#subscribing\n - guide/observables#using-observables-for-streams-of-values\n - guide/rx-library#error-handling\n - guide/rx-library#observable-creation-functions\n - guide/rx-library#operators\n - https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\n - https://rxjs.dev/\n-->"}