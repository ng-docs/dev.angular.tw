{"id":"guide/rx-library","title":"RxJS 函式庫","contents":"<div class=\"content\">\n  <h1 id=\"the-rxjs-library\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9oessfy3od8pm2dvyizdfw3a3\">RxJS 函式庫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#the-rxjs-library\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dsxg0dbla2dn33rslfa6dc0kq\">回應式程式設計是關注資料流和變化傳播的一種非同步程式設計正規化（\n<a href=\"https://en.wikipedia.org/wiki/Reactive_programming\">維基百科</a>）。 RxJS（JavaScript的回應式擴充套件）是一個使用可觀察者進行回應式程式設計的函式庫，使得組合非同步或基於回呼的程式碼更容易。 檢視 \n<a href=\"https://rxjs.dev/guide/overview\">RxJS 文件</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8xyp2rbhhtyxpd745mvcny2o2\">RxJS 提供了一種對 <code>Observable</code> 型別的實現，直到 <code>Observable</code> 成為了 JavaScript 語言的一部分並且瀏覽器支援它之前，它都是必要的。這個函式庫還提供了一些工具函式，用於建立和使用可觀察物件。這些工具函式可用於：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8uz6o9m2vb8jrgch3j6yb5tf\">把現有的非同步程式碼轉換成可觀察物件</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ayyao4s960piqnbe78h2n9xq\">迭代流中的各個值</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"can9as43ly37mceqffp2d1d61\">把這些值對映成其它型別</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e8t8rhm99fmosbn17bduhp4u0\">對流進行過濾</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c1vmdo7h9e1zy5j63hbyka23e\">組合多個流</li>\n</ul>\n<h2 id=\"observable-creation-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9fdwaf1uudsdkfrj1l5n2noyg\">建立可觀察物件的函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#observable-creation-functions\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cbehffh7cgrcvg55iqbd1eoj\">RxJS 提供了許多函式，可用於建立新的可觀察者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ad0fblw08p122jrxw06brujdm\">這些函式可以簡化從事件、計時器和承諾等事物建立可觀察者的過程。 例如：</p>\n<code-example header=\"Create an observable from a promise\" path=\"rx-library/src/simple-creation.1.ts\" region=\"promise\">\nimport { from, Observable } from 'rxjs';\n\n// Create an Observable out of a promise\nconst data = from(fetch('/api/endpoint'));\n// Subscribe to begin listening for <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> result\ndata.subscribe({\n  next(response) { console.log(response); },\n  error(err) { console.error('Error: ' + err); },\n  complete() { console.log('Completed'); }\n});\n\n\n</code-example>\n<code-example header=\"Create an observable from a counter\" path=\"rx-library/src/simple-creation.2.ts\" region=\"interval\">\nimport { interval } from 'rxjs';\n\n// Create an Observable that will publish a value on an interval\nconst secondsCounter = interval(1000);\n// Subscribe to begin publishing values\nconst subscription = secondsCounter.subscribe(n =&gt;\n  console.log(`It's been ${n + 1} seconds since subscribing!`));\n\n\n</code-example>\n<code-example header=\"Create an observable from an event\" path=\"rx-library/src/simple-creation.3.ts\" region=\"event\">\nimport { fromEvent } from 'rxjs';\n\nconst el = document.getElementById('my-element')!;\n\n// Create an Observable that will publish mouse movements\nconst mouseMoves = fromEvent&lt;MouseEvent&gt;(el, 'mousemove');\n\n// Subscribe to start listening for mouse-move events\nconst subscription = mouseMoves.subscribe(evt =&gt; {\n  // Log coords of mouse movements\n  console.log(`Coords: ${evt.clientX} X ${evt.clientY}`);\n\n  // When the mouse is over the upper-left of the screen,\n  // unsubscribe to stop listening for mouse movements\n  if (evt.clientX &lt; 40 &amp;&amp; evt.clientY &lt; 40) {\n    subscription.unsubscribe();\n  }\n});\n\n\n</code-example>\n<code-example header=\"Create an observable that creates an AJAX request\" path=\"rx-library/src/simple-creation.ts\" region=\"ajax\">\nimport { Observable } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\n\n// Create an Observable that will create an AJAX request\nconst apiData = ajax('/api/data');\n// Subscribe to create the request\napiData.subscribe(res =&gt; console.log(res.status, res.response));\n\n</code-example>\n<h3 id=\"subject\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bt9nmj9k80btz2dgjnnxi4qvk\">Subject<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#subject\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2j8knvjbl5zyc1e4ebdyle3gz\">RxJS 的 \n<a href=\"https://rxjs.dev/guide/subject\"><code>Subject</code></a> 是建立和控制自定義可觀察者的一種常用方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xfb96o9q23g5v0pgif7w4ce\"><code>Subject</code> 是一種特殊型別的 \n<code>Observable</code>。在兩個重要方面上具有特殊性：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2dy7ldijbmmqy8kcmxu82tl0j\">您可以透過呼叫其 \n<code>next(value)</code> 方法將值推送到該 \n<code>Observable</code> 中。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3mdd2i4tquzso4y6sehdif6b6\">它是一個『多播』可觀察者，這意味著 \n<code>Subject</code> 實例的所有訂閱者都從該實例接收相同的值。</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bcunabwc4xdngg6x75t5obp1w\"><code>Subject</code> 的這些方面使得建立一個『松耦合』的訊息服務變得容易。應用程式的一部分可以透過該服務傳送訊息；應用程式的其他部分可以監聽這些訊息；所有部分互不瞭解。</p>\n<p><a id=\"message-service\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0nei99us166shsxe0tcwmtkp\">以下是一個 \n<code>MessageService</code> 範例： \n<code-example header=\"MessageService\" path=\"rx-library/src/app/message.service.ts\">\n  import { \n <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core'; import { Subject } from 'rxjs'; /** 被 Message Service 發射的值的介面 */ export interface Message { type: 'Warning' | 'Error'; text: string; } @\n <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({providedIn: 'root'}) export class MessageService { // 提示：永遠不要暴露 Subject 本身。 private messageSubject = new Subject&lt;Message&gt;(); /** 所有訊息的可觀察者 */ messages$ = this.messageSubject.asObservable(); /** 向 Subject 新增一個錯誤訊息 */ addError(text: string) { this.messageSubject.next({ type: 'Error', text }); } /** 向 Subject 新增一個警告訊息 */ addWarning(text: string) { this.messageSubject.next({ type: 'Warning', text }); } } \n</code-example></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqdo8yhizelozmlp93z7pit0v\">關鍵特點：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eyt7gedghf8tkq5sfqzwalm2i\"><code>Subject</code> 是 \n<em>私有的</em>。服務的消費者透過受控的公共API訪問 \n<code>Subject</code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dmje2h2yceywnbqpz80qqwpn2\"><code>messages$</code> 屬性僅公開了 \n<code>Subject</code> 的 \n<em>可觀察</em> 方面；消費者不能透過這個可觀察者向 \n<code>Subject</code> 推送值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2i1qaaw8mghdcy47697i01i8k\">專門的方法（\n<code>addError</code> 和 \n<code>addWarning</code>）嚴格管理服務消費者如何向隱藏的 \n<code>Subject</code> 新增值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bcz7qidhh060wx2pojcdpjzrj\"><code>Subject</code> 的值始終是 \n<code>Message</code> 型別；\n<code>messages$</code> 可觀察者的消費者可以依賴這些值的形狀。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8aplp5vo75p9rp4a149g0h62\"><a href=\"guide/rx-library#loosely-coupled-apps\">檢視下面</a>如何使用此服務建立一個松耦合的應用程式。</p>\n<h2 id=\"operators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"an57klyawyw99dnz7jlqbaqbm\">操作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#operators\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6z274jr0kvbzg16dl6se1ms4v\"><a href=\"https://rxjs.dev/guide/operators\">運算子</a> 允許對可觀察值進行轉換。運算子是一個函式，接受一個可觀察源和設定選項，以某種有用的方式操縱來自該源的值，並回傳轉換值的新可觀察者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"16dz3qj2gpn0v9psjisvwh1qt\">您可以按順序鏈式使用運算子，以生成符合您需求的自定義可觀察者。當您訂閱該新的可觀察者時，您會得到中間轉換的結果。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"s203gastcs0fj0m5c2m834hg\">RxJS 提供了許多內建運算子，用於常見用例，如 \n<code>map()</code>、\n<code>filter()</code>、\n<code>concat()</code> 和 \n<code>mergeMap()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6yzsoctytqk89qr2tq2jjf87q\">以下是一個使用 \n<code>map</code> 運算子將一系列整數平方的範例：</p>\n<code-example header=\"Map operator\" path=\"rx-library/src/operators.ts\">\nimport { of, map } from 'rxjs';\n\n/** source observable of integers. */\nconst nums = of(1, 2, 3);\n\n/** A new squares observable created by piping through the `map` operator. */\nconst squares = nums.pipe(\n  map(num =&gt; num * num) // `map` configured with a function that squares each value.\n);\n\n// subscribe to the new observable\nsquares.subscribe(value =&gt; console.log(value));\n\n// Logs\n// 1\n// 4\n// 9\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ewr1ur85g2dtc5y2ghbgqykv2\">注意，你將 \n<code>map</code> 運算子傳遞給可觀察物件的 \n<code>pipe</code> 方法。這被稱為透過運算子 \"通道化\" 源可觀察物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"am3o3syng0ye7h5mm4m51ddr4\">你可以透過將它們作為引數新增到 \n<code>pipe</code> 呼叫中來將多個運算子連結在一起。下面的例子首先對奇數進行 \n<code>filters</code> 然後在 \n<code>map</code> 中對它們的值進行平方。產生的可觀察物件會發出源中奇數的平方值。</p>\n<code-example header=\"Observable.pipe function\" path=\"rx-library/src/operators.2.ts\">\nimport { of, filter, map } from 'rxjs';\n\nconst squareOdd = of(1, 2, 3, 4, 5)\n  .pipe(\n    filter(n =&gt; n % 2 === 1),\n    map(n =&gt; n * n)\n  );\n\n// Subscribe to get values\nsquareOdd.subscribe(x =&gt; console.log(x));\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8zfbu678vhfazs5dwicc48z2g\">你可以使用 \n<code>pipe</code> 方法建立自定義運算子，以封裝可重用的運算子鏈。下面的例子建立一個 \n<code>squareOddValues</code> 運算子，然後透過它對源整數進行通道處理。</p>\n<code-example header=\"Standalone pipe function\" path=\"rx-library/src/operators.1.ts\">\nimport { of, filter, map, pipe } from 'rxjs';\n\nconst nums = of(1, 2, 3, 4, 5);\n\n// Create a function that accepts an Observable.\nconst squareOddVals = pipe(\n  filter((n: number) =&gt; n % 2 === 1),\n  map(n =&gt; n * n)\n);\n\n// Create an Observable that will run the filter and map functions\nconst squareOdd = squareOddVals(nums);\n\n// Subscribe to run the combined functions\nsquareOdd.subscribe(x =&gt; console.log(x));\n\n\n</code-example>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ct7vsmxyyjos6jpn6rt0n9bm8\">將一系列運算子視為最終可觀察物件的配方，作為產生你感興趣的值的一套指導。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dnexg4r1lng2vmz2bwd7zec8x\">請記住，單獨的配方本身不會執行任何操作；你需要呼叫 \n<code>subscribe()</code> 來透過配方產生結果。</p>\n<p><a id=\"loosely-coupled-apps\"></a></p>\n<h3 id=\"loosely-coupled-transformations\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ciloba7pwtfh07x25rxsir9c\">松耦合的轉換<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#loosely-coupled-transformations\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"btj1kazmvjxbfjhma0dgnfjml\">RxJS 運算子有助於開發 \n<a href=\"https://en.wikipedia.org/wiki/Loose_coupling\">松耦合</a> 應用程式。應用程式的一部分可以向可觀察物件新增值，而不知道可觀察物件將如何被消費或由誰消費。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2rzvxuilllo0bcz0pzq4p36tt\">應用程式的另一部分可以將運算子通道到該可觀察物件上，以將其值轉換為對其有用的形式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5r1d43iuzf9wehxm6hwua5o4q\">前面描述的 \n<code>MessageService</code> 範例示範了這些要點。 \n<code>AppComponent</code> 向用戶展示按鈕來新增訊息，可以是錯誤或警告型別。按鈕點選處理程式將這些訊息傳送到服務中。</p>\n<code-example header=\"AppComponent (excerpt)\" path=\"rx-library/src/app/app.component.ts\" region=\"add-messages\">\nconstructor(private messageService: MessageService) { }\n\naddError(text: string) {\n  this.messageService.addError(text);\n}\n\naddWarning(text: string) {\n  this.messageService.addWarning(text);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92x5ud6vvcc9di3c7u6yosou2\">無論是 \n<code>AppComponent</code> 還是服務都不知道這些訊息將會發生什麼。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7oacfzjx8xxl9hue7ugny1fvp\">在其他地方，\n<code>MessageComponent</code> 將訊息過濾並對映到單獨的 \n<code>string</code> 可觀察物件中，一個用於錯誤，另一個用於警告。</p>\n<code-example header=\"MessageComponent (excerpt)\" path=\"rx-library/src/app/message.component.ts\" region=\"observables\">\n// Observable of ALL messages\nthis.messages$ = messageService.messages$;\n\n// Derived string observable of just the error message texts\nthis.errors$ = this.messages$.pipe(\n  filter(m =&gt; m.type === 'Error'),\n  map(m =&gt; m.text),\n);\n\n// Derived string observable of just the warning message texts\nthis.warnings$ = this.messages$.pipe(\n  filter(m =&gt; m.type === 'Warning'),\n  map(m =&gt; m.text),\n);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2guvs67ewwu5ptoa22pzqvynb\">該組件繼續向用戶顯示這些可觀察物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d90i21f2rs3pohvyap4avbpv4\">以松耦合方式操作非同步資料流的能力或許是你在應用程式中使用 RxJS 的最佳用例。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9oi82deiwbx7yog17epggsbjt\">要檢視這個訊息範例的實際效果，請嘗試 \n<live-example name=\"rx-library\"></live-example>。</p>\n</div>\n<h3 id=\"common-operators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78g2qp12pizac8tokqsl3okne\">常用運算子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#common-operators\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6tohjt9dxjal6amtb1ex2cy7i\">RxJS 提供了許多運算子，但只有少數經常使用。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d742luiuirvtpjq6i9pf70lxw\">區域</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"an57klyawyw99dnz7jlqbaqbm\">操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"65aoee8m9iko3yov1zjh599wy\">建立</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71lxp4gy6x6ogymjl7u6jqd45\"><code>from</code>, \n<code>fromEvent</code>, \n<code>of</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"48rahxmxpog6m0gafxeklkgvv\">組合</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2ec3edrguqwwao7qcihz0xca\"><code>combineLatest</code>, \n<code>concat</code>, \n<code>merge</code>, \n<code>startWith</code> , \n<code>withLatestFrom</code>, \n<code>zip</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94ye9s2javqh643hiahgawu6w\">過濾</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2y9u8pe1ol58aew7sxxnelulj\"><code>debounceTime</code>, \n<code>distinctUntilChanged</code>, \n<code>filter</code>, \n<code>take</code>, \n<code>takeUntil</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72ukel3br3qslodz8jbw6u19b\">轉換</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ceeumeil6cl0wgobg3ppdy4x\"><code>bufferTime</code>, \n<code>concatMap</code>, \n<code>map</code>, \n<code>mergeMap</code>, \n<code>scan</code>, \n<code>switchMap</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8tadsrgfaa9f0q28cmet8e9fd\">實用</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"p0w6es2q6qf8z7xbhd5t2ckw\"><code>startWith</code>, \n<code>tap</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"75w6lif46mxdlj13k02e4kbzg\">多播</td>\n<td align=\"left\"><code>shareReplay</code></td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aamzmhgfl92030pcrqjuo1juh\">要檢視完整的運算子清單和使用範例，請訪問\n<a href=\"https://rxjs.dev/api\">RxJS API 文件</a>。</p>\n<h2 id=\"error-handling\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ad0cx4y7txhii62pgdd0mpma9\">錯誤處理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#error-handling\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d0t26l7awxevxrv17psh2m8q9\">除了可以在訂閱時提供 <code>error()</code> 處理器外，RxJS 還提供了 <code>catchError</code> 運算子，它允許你在通道中處理已知錯誤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d9js4i8g9qy7qztd18ruv2rpc\">例如，假設你有一個 Observable，它發出一個 API 請求並對映來自伺服器的回應。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7l8ia5gsvj7ksm5juuyoq1x31\">如果伺服器回傳錯誤或值不存在，則會產生錯誤。 如果你使用 \n<code>catchError</code> 運算子捕獲此錯誤並回傳一個預設值的 Observable，你的流將繼續處理值而不是出錯。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4lcfnthaqoa7584arn1yxxqc9\">例子如下：</p>\n<code-example header=\"catchError operator\" path=\"rx-library/src/error-handling.ts\">\nimport { Observable, of } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { map, catchError } from 'rxjs/operators';\n\n// Return good response from the API.\n// If the response is bad, throw an error.\nconst apiData = ajax('/api/data').pipe(\n  map((res: any) =&gt; {\n    if (!res?.response) {\n      throw new Error('Value expected!');\n    }\n    return res.response;\n  }),\n  /*\n   * Catch the error, either from the AJAX call or from the map operator,\n   * and return an observable of empty array.\n   * The `catchError` argument must be a function that returns an observable.\n   */\n  catchError(() =&gt; of([]))\n);\n\napiData.subscribe({\n  next(x: T) { console.log('data: ', x); },\n  error() { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<h3 id=\"multiple-subscribers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6qlbbg809zr5u74rgv7s3dsq\">多個訂閱者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#multiple-subscribers\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"439ur9vj2x6dei57swoclv0tk\">大多數 Observable 都是『單播』的，這意味著每個新訂閱者都會獲得自己執行的那個 Observable。驅動源 Observable 的任何內容都會為新增的訂閱者重新開始。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8vlgggzfgzyxkndk6xp0jzj4c\">以下範例中的 RxJS \n<code>interval()</code> 函式產生一個每半秒發出一個整數的『單播』 Observable。 \n<code-example header=\"單播\" path=\"rx-library/src/app/uni-multi-cast.component.ts\" region=\"unicast-observable\">\n  /** 每隔 1/2 秒發出整數的單播 Observable。 */ numbers$: Observable&lt;number&gt; = interval(500); \n</code-example></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"tb6f6hdpsvhdnxcs6q9lziio\">每個新訂閱者都會從零開始接收一組新的整數。</p>\n<blockquote>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c21eldpk6l9wv1elbtma0qp1u\"><strong>單播訂閱者：</strong>\n<br> 單播訂閱者 #1 收到 9\n<br> 單播訂閱者 #2 收到 5\n<br> 單播訂閱者 #3 收到 0</p>\n</blockquote>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"17umixdl6dtpgtxajdw12gkln\">大多數 Observable 像 \n<code>interval</code> 一樣是『單播』的。 例如，從 Angular 的 \n<a href=\"guide/understanding-communicating-with-http\"><code>HttpClient.get()</code></a> 回傳的 Observable 是『單播』的。每次訂閱時都會向伺服器發出新請求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cpzmwgiooushkdnzf8ecld6i4\">這也許是你想要的。 但有時你希望共享相同的值源給所有訂閱者。例如，一旦你要求 \n<code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 回傳一些設定，你可能不希望下次訂閱時再向伺服器發出請求；你希望獲取上次得到的相同設定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bev3vknidfrgz05906oa90hfd\">你希望 \n<code>HttpClient.get</code> Observable 行為類似於『多播』 Observable。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"au8mzuvzci8uyfimcriu7l6ks\">一個像 \n<code>MessageService</code> 中的 \n<code>Subject</code> 設計上就是一個『多播』 Observable。它的訂閱者始終獲得相同的最新訊息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cuidozgc2plzblh34vylsw6ec\">我們需要做一些特殊的處理，將來自 \n<code>interval</code> 和 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的『單播』 Observable 轉換為『多播』 Observable。一個典型的解決方案是在通道中新增 \n<a href=\"https://rxjs.dev/api/index/function/shareReplay\"><code>shareReplay()</code></a> 運算子；如果有一系列運算子，則將其新增到末尾。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c0aa8klzj7xhl9m92hdjq8ui0\">這裡是帶有 \n<code>shareReplay</code> 的 \n<code>interval</code>。</p>\n<code-example header=\"multicast with shareReplay\" path=\"rx-library/src/app/uni-multi-cast.component.ts\" region=\"shareReplay-observable\">\n/** Multicast the interval by extending `numbers$` with `shareReplay` */\nmultiCastNumber$ = this.numbers$.pipe(\n  // Replay 1 item; never forgets, never completes.\n  shareReplay({ bufferSize: 1, refCount: false })\n);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"85x7om3ipjimde96kwbw9eq7h\">選項 \n<code>bufferSize=1</code> 表示新的訂閱者會接收 Observable 先前發出的最新值（緩衝值）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2kgxsbyspo4ozizreegprumhy\">如果 \n<code>refCount=false</code> 選項意味著如果 \n<em>所有人都取消訂閱</em> 然後有人重新訂閱，那麼新的訂閱者將獲得最後發出的值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e2jhdy11brby7y8c096oapj27\">如果 \n<code>refCount</code> 是 \n<code>true</code>，當所有人都取消訂閱然後有人重新訂閱時，新的訂閱者會啟動源可觀察物件的全新執行。 \n<code>interval</code> 範例將重新從零開始。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"62lx3vox49dcc1jgu8rbru62k\">每個新的訂閱者都會收到可觀察物件發出的相同整數。</p>\n<blockquote>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a9xg1odnhp8pqsyffj7ggol1o\"><strong>多播 ShareReplay 訂閱者：</strong>\n<br>ShareReplay 訂閱者 #1 收到了 9\n<br>ShareReplay 訂閱者 #2 收到了 9\n<br>ShareReplay 訂閱者 #3 收到了 9</p>\n</blockquote>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wpqthbhncbr2hu4gkdbbapt7\">要檢視單播 / 多播比較的實際效果，請嘗試 \n<live-example name=\"rx-library\"></live-example>。</p>\n</div>\n<h3 id=\"retry-failed-observable\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74w470n1ay7a5lj6iddro8tnz\">重試失敗的可觀察物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#retry-failed-observable\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"82eg4udsgxnmsmjkngpst76m9\"><code>catchError</code> 提供了一種簡單的方式進行恢復，而 <code>retry</code> 運算子讓你可以嘗試失敗的請求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6772pfagi5379xpf575dzd97g\">可以在 <code>catchError</code> 之前使用 <code>retry</code> 運算子。它會訂閱到原始的來源可觀察物件，它可以重新執行導致結果出錯的動作序列。如果其中包含 HTTP 請求，它就會重新發起那個 HTTP 請求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cb4et1uhw0poe1xf8yk1rxoql\">下列程式碼把前面的例子改成了在捕獲錯誤之前重發請求：</p>\n<code-example header=\"retry operator\" path=\"rx-library/src/retry-on-error.ts\">\nimport { Observable, of } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { map, retry, catchError } from 'rxjs/operators';\n\nconst apiData = ajax('/api/data').pipe(\n  map((res: any) =&gt; {\n    if (!res.response) {\n      console.log('Error occurred.');\n      throw new Error('Value expected!');\n    }\n    return res.response;\n  }),\n  retry(3), // Retry up to 3 times before failing\n  catchError(() =&gt; of([]))\n);\n\napiData.subscribe({\n  next(x: T) { console.log('data: ', x); },\n  error() { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6wbbzyno9yvd92sdelxh7wipg\">不要重試<strong>登入認證</strong>請求，這些請求只應該由使用者操作觸發。我們肯定不會希望自動重複傳送登入請求導致使用者的賬號被鎖定。</p>\n</div>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Fri Aug 25 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/http-handle-request-errors\n - guide/http-server-communication\n - guide/observables\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/core/Injectable\n - api/platform-browser/animations/async\n - guide/rx-library#common-operators\n - guide/rx-library#error-handling\n - guide/rx-library#loosely-coupled-apps\n - guide/rx-library#loosely-coupled-transformations\n - guide/rx-library#message-service\n - guide/rx-library#multiple-subscribers\n - guide/rx-library#observable-creation-functions\n - guide/rx-library#operators\n - guide/rx-library#retry-failed-observable\n - guide/rx-library#subject\n - guide/rx-library#the-rxjs-library\n - guide/understanding-communicating-with-http\n - https://en.wikipedia.org/wiki/Loose_coupling\n - https://en.wikipedia.org/wiki/Reactive_programming\n - https://rxjs.dev/api\n - https://rxjs.dev/api/index/function/shareReplay\n - https://rxjs.dev/guide/glossary-and-semantics#multicast\n - https://rxjs.dev/guide/operators\n - https://rxjs.dev/guide/overview\n - https://rxjs.dev/guide/subject\n-->"}