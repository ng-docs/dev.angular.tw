{"id":"guide/rx-library","title":"RxJS 库","contents":"<div class=\"content\">\n  <h1 id=\"the-rxjs-library\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9oessfy3od8pm2dvyizdfw3a3\">RxJS 库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#the-rxjs-library\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dsxg0dbla2dn33rslfa6dc0kq\">响应式编程是关注数据流和变化传播的一种异步编程范式（\n<a href=\"https://en.wikipedia.org/wiki/Reactive_programming\">维基百科</a>）。 RxJS（JavaScript的响应式扩展）是一个使用可观察者进行响应式编程的库，使得组合异步或基于回调的代码更容易。 查看 \n<a href=\"https://rxjs.dev/guide/overview\">RxJS 文档</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8xyp2rbhhtyxpd745mvcny2o2\">RxJS 提供了一种对 <code>Observable</code> 类型的实现，直到 <code>Observable</code> 成为了 JavaScript 语言的一部分并且浏览器支持它之前，它都是必要的。这个库还提供了一些工具函数，用于创建和使用可观察对象。这些工具函数可用于：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8uz6o9m2vb8jrgch3j6yb5tf\">把现有的异步代码转换成可观察对象</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ayyao4s960piqnbe78h2n9xq\">迭代流中的各个值</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"can9as43ly37mceqffp2d1d61\">把这些值映射成其它类型</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e8t8rhm99fmosbn17bduhp4u0\">对流进行过滤</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c1vmdo7h9e1zy5j63hbyka23e\">组合多个流</li>\n</ul>\n<h2 id=\"observable-creation-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9fdwaf1uudsdkfrj1l5n2noyg\">创建可观察对象的函数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#observable-creation-functions\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cbehffh7cgrcvg55iqbd1eoj\">RxJS 提供了许多函数，可用于创建新的可观察者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ad0fblw08p122jrxw06brujdm\">这些函数可以简化从事件、计时器和承诺等事物创建可观察者的过程。 例如：</p>\n<code-example header=\"Create an observable from a promise\" path=\"rx-library/src/simple-creation.1.ts\" region=\"promise\">\nimport { from, Observable } from 'rxjs';\n\n// Create an Observable out of a promise\nconst data = from(fetch('/api/endpoint'));\n// Subscribe to begin listening for <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> result\ndata.subscribe({\n  next(response) { console.log(response); },\n  error(err) { console.error('Error: ' + err); },\n  complete() { console.log('Completed'); }\n});\n\n\n</code-example>\n<code-example header=\"Create an observable from a counter\" path=\"rx-library/src/simple-creation.2.ts\" region=\"interval\">\nimport { interval } from 'rxjs';\n\n// Create an Observable that will publish a value on an interval\nconst secondsCounter = interval(1000);\n// Subscribe to begin publishing values\nconst subscription = secondsCounter.subscribe(n =&gt;\n  console.log(`It's been ${n + 1} seconds since subscribing!`));\n\n\n</code-example>\n<code-example header=\"Create an observable from an event\" path=\"rx-library/src/simple-creation.3.ts\" region=\"event\">\nimport { fromEvent } from 'rxjs';\n\nconst el = document.getElementById('my-element')!;\n\n// Create an Observable that will publish mouse movements\nconst mouseMoves = fromEvent&lt;MouseEvent&gt;(el, 'mousemove');\n\n// Subscribe to start listening for mouse-move events\nconst subscription = mouseMoves.subscribe(evt =&gt; {\n  // Log coords of mouse movements\n  console.log(`Coords: ${evt.clientX} X ${evt.clientY}`);\n\n  // When the mouse is over the upper-left of the screen,\n  // unsubscribe to stop listening for mouse movements\n  if (evt.clientX &lt; 40 &amp;&amp; evt.clientY &lt; 40) {\n    subscription.unsubscribe();\n  }\n});\n\n\n</code-example>\n<code-example header=\"Create an observable that creates an AJAX request\" path=\"rx-library/src/simple-creation.ts\" region=\"ajax\">\nimport { Observable } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\n\n// Create an Observable that will create an AJAX request\nconst apiData = ajax('/api/data');\n// Subscribe to create the request\napiData.subscribe(res =&gt; console.log(res.status, res.response));\n\n</code-example>\n<h3 id=\"subject\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bt9nmj9k80btz2dgjnnxi4qvk\">Subject<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#subject\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2j8knvjbl5zyc1e4ebdyle3gz\">RxJS 的 \n<a href=\"https://rxjs.dev/guide/subject\"><code>Subject</code></a> 是创建和控制自定义可观察者的一种常用方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xfb96o9q23g5v0pgif7w4ce\"><code>Subject</code> 是一种特殊类型的 \n<code>Observable</code>。在两个重要方面上具有特殊性：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2dy7ldijbmmqy8kcmxu82tl0j\">您可以通过调用其 \n<code>next(value)</code> 方法将值推送到该 \n<code>Observable</code> 中。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3mdd2i4tquzso4y6sehdif6b6\">它是一个“多播”可观察者，这意味着 \n<code>Subject</code> 实例的所有订阅者都从该实例接收相同的值。</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bcunabwc4xdngg6x75t5obp1w\"><code>Subject</code> 的这些方面使得创建一个“松耦合”的消息服务变得容易。应用程序的一部分可以通过该服务发送消息；应用程序的其他部分可以监听这些消息；所有部分互不了解。</p>\n<p><a id=\"message-service\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0nei99us166shsxe0tcwmtkp\">以下是一个 \n<code>MessageService</code> 示例： \n<code-example header=\"MessageService\" path=\"rx-library/src/app/message.service.ts\">\n  import { \n <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core'; import { Subject } from 'rxjs'; /** 被 Message Service 发射的值的接口 */ export interface Message { type: 'Warning' | 'Error'; text: string; } @\n <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({providedIn: 'root'}) export class MessageService { // 提示：永远不要暴露 Subject 本身。 private messageSubject = new Subject&lt;Message&gt;(); /** 所有消息的可观察者 */ messages$ = this.messageSubject.asObservable(); /** 向 Subject 添加一个错误消息 */ addError(text: string) { this.messageSubject.next({ type: 'Error', text }); } /** 向 Subject 添加一个警告消息 */ addWarning(text: string) { this.messageSubject.next({ type: 'Warning', text }); } } \n</code-example></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqdo8yhizelozmlp93z7pit0v\">关键特点：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eyt7gedghf8tkq5sfqzwalm2i\"><code>Subject</code> 是 \n<em>私有的</em>。服务的消费者通过受控的公共API访问 \n<code>Subject</code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dmje2h2yceywnbqpz80qqwpn2\"><code>messages$</code> 属性仅公开了 \n<code>Subject</code> 的 \n<em>可观察</em> 方面；消费者不能通过这个可观察者向 \n<code>Subject</code> 推送值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2i1qaaw8mghdcy47697i01i8k\">专门的方法（\n<code>addError</code> 和 \n<code>addWarning</code>）严格管理服务消费者如何向隐藏的 \n<code>Subject</code> 添加值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bcz7qidhh060wx2pojcdpjzrj\"><code>Subject</code> 的值始终是 \n<code>Message</code> 类型；\n<code>messages$</code> 可观察者的消费者可以依赖这些值的形状。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8aplp5vo75p9rp4a149g0h62\"><a href=\"guide/rx-library#loosely-coupled-apps\">查看下面</a>如何使用此服务构建一个松耦合的应用程序。</p>\n<h2 id=\"operators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"an57klyawyw99dnz7jlqbaqbm\">操作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#operators\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6z274jr0kvbzg16dl6se1ms4v\"><a href=\"https://rxjs.dev/guide/operators\">操作符</a> 允许对可观察值进行转换。操作符是一个函数，接受一个可观察源和配置选项，以某种有用的方式操纵来自该源的值，并返回转换值的新可观察者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"16dz3qj2gpn0v9psjisvwh1qt\">您可以按顺序链式使用操作符，以生成符合您需求的自定义可观察者。当您订阅该新的可观察者时，您会得到中间转换的结果。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"s203gastcs0fj0m5c2m834hg\">RxJS 提供了许多内置操作符，用于常见用例，如 \n<code>map()</code>、\n<code>filter()</code>、\n<code>concat()</code> 和 \n<code>mergeMap()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6yzsoctytqk89qr2tq2jjf87q\">以下是一个使用 \n<code>map</code> 操作符将一系列整数平方的示例：</p>\n<code-example header=\"Map operator\" path=\"rx-library/src/operators.ts\">\nimport { of, map } from 'rxjs';\n\n/** source observable of integers. */\nconst nums = of(1, 2, 3);\n\n/** A new squares observable created by piping through the `map` operator. */\nconst squares = nums.pipe(\n  map(num =&gt; num * num) // `map` configured with a function that squares each value.\n);\n\n// subscribe to the new observable\nsquares.subscribe(value =&gt; console.log(value));\n\n// Logs\n// 1\n// 4\n// 9\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ewr1ur85g2dtc5y2ghbgqykv2\">注意，你将 \n<code>map</code> 操作符传递给可观察对象的 \n<code>pipe</code> 方法。这被称为通过操作符 \"管道化\" 源可观察对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"am3o3syng0ye7h5mm4m51ddr4\">你可以通过将它们作为参数添加到 \n<code>pipe</code> 调用中来将多个操作符链接在一起。下面的例子首先对奇数进行 \n<code>filters</code> 然后在 \n<code>map</code> 中对它们的值进行平方。产生的可观察对象会发出源中奇数的平方值。</p>\n<code-example header=\"Observable.pipe function\" path=\"rx-library/src/operators.2.ts\">\nimport { of, filter, map } from 'rxjs';\n\nconst squareOdd = of(1, 2, 3, 4, 5)\n  .pipe(\n    filter(n =&gt; n % 2 === 1),\n    map(n =&gt; n * n)\n  );\n\n// Subscribe to get values\nsquareOdd.subscribe(x =&gt; console.log(x));\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8zfbu678vhfazs5dwicc48z2g\">你可以使用 \n<code>pipe</code> 方法创建自定义操作符，以封装可重用的操作符链。下面的例子创建一个 \n<code>squareOddValues</code> 操作符，然后通过它对源整数进行管道处理。</p>\n<code-example header=\"Standalone pipe function\" path=\"rx-library/src/operators.1.ts\">\nimport { of, filter, map, pipe } from 'rxjs';\n\nconst nums = of(1, 2, 3, 4, 5);\n\n// Create a function that accepts an Observable.\nconst squareOddVals = pipe(\n  filter((n: number) =&gt; n % 2 === 1),\n  map(n =&gt; n * n)\n);\n\n// Create an Observable that will run the filter and map functions\nconst squareOdd = squareOddVals(nums);\n\n// Subscribe to run the combined functions\nsquareOdd.subscribe(x =&gt; console.log(x));\n\n\n</code-example>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ct7vsmxyyjos6jpn6rt0n9bm8\">将一系列操作符视为最终可观察对象的配方，作为产生你感兴趣的值的一套指导。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dnexg4r1lng2vmz2bwd7zec8x\">请记住，单独的配方本身不会执行任何操作；你需要调用 \n<code>subscribe()</code> 来通过配方产生结果。</p>\n<p><a id=\"loosely-coupled-apps\"></a></p>\n<h3 id=\"loosely-coupled-transformations\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ciloba7pwtfh07x25rxsir9c\">松耦合的转换<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#loosely-coupled-transformations\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"btj1kazmvjxbfjhma0dgnfjml\">RxJS 操作符有助于开发 \n<a href=\"https://en.wikipedia.org/wiki/Loose_coupling\">松耦合</a> 应用程序。应用程序的一部分可以向可观察对象添加值，而不知道可观察对象将如何被消费或由谁消费。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2rzvxuilllo0bcz0pzq4p36tt\">应用程序的另一部分可以将操作符管道到该可观察对象上，以将其值转换为对其有用的形式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5r1d43iuzf9wehxm6hwua5o4q\">前面描述的 \n<code>MessageService</code> 示例演示了这些要点。 \n<code>AppComponent</code> 向用户展示按钮来添加消息，可以是错误或警告类型。按钮点击处理程序将这些消息发送到服务中。</p>\n<code-example header=\"AppComponent (excerpt)\" path=\"rx-library/src/app/app.component.ts\" region=\"add-messages\">\nconstructor(private messageService: MessageService) { }\n\naddError(text: string) {\n  this.messageService.addError(text);\n}\n\naddWarning(text: string) {\n  this.messageService.addWarning(text);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92x5ud6vvcc9di3c7u6yosou2\">无论是 \n<code>AppComponent</code> 还是服务都不知道这些消息将会发生什么。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7oacfzjx8xxl9hue7ugny1fvp\">在其他地方，\n<code>MessageComponent</code> 将消息过滤并映射到单独的 \n<code>string</code> 可观察对象中，一个用于错误，另一个用于警告。</p>\n<code-example header=\"MessageComponent (excerpt)\" path=\"rx-library/src/app/message.component.ts\" region=\"observables\">\n// Observable of ALL messages\nthis.messages$ = messageService.messages$;\n\n// Derived string observable of just the error message texts\nthis.errors$ = this.messages$.pipe(\n  filter(m =&gt; m.type === 'Error'),\n  map(m =&gt; m.text),\n);\n\n// Derived string observable of just the warning message texts\nthis.warnings$ = this.messages$.pipe(\n  filter(m =&gt; m.type === 'Warning'),\n  map(m =&gt; m.text),\n);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2guvs67ewwu5ptoa22pzqvynb\">该组件继续向用户显示这些可观察对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d90i21f2rs3pohvyap4avbpv4\">以松耦合方式操作异步数据流的能力或许是你在应用程序中使用 RxJS 的最佳用例。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9oi82deiwbx7yog17epggsbjt\">要查看这个消息示例的实际效果，请尝试 \n<live-example name=\"rx-library\"></live-example>。</p>\n</div>\n<h3 id=\"common-operators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78g2qp12pizac8tokqsl3okne\">常用操作符<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#common-operators\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6tohjt9dxjal6amtb1ex2cy7i\">RxJS 提供了许多操作符，但只有少数经常使用。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d742luiuirvtpjq6i9pf70lxw\">区域</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"an57klyawyw99dnz7jlqbaqbm\">操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"65aoee8m9iko3yov1zjh599wy\">创建</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71lxp4gy6x6ogymjl7u6jqd45\"><code>from</code>, \n<code>fromEvent</code>, \n<code>of</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"48rahxmxpog6m0gafxeklkgvv\">组合</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2ec3edrguqwwao7qcihz0xca\"><code>combineLatest</code>, \n<code>concat</code>, \n<code>merge</code>, \n<code>startWith</code> , \n<code>withLatestFrom</code>, \n<code>zip</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94ye9s2javqh643hiahgawu6w\">过滤</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2y9u8pe1ol58aew7sxxnelulj\"><code>debounceTime</code>, \n<code>distinctUntilChanged</code>, \n<code>filter</code>, \n<code>take</code>, \n<code>takeUntil</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72ukel3br3qslodz8jbw6u19b\">转换</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ceeumeil6cl0wgobg3ppdy4x\"><code>bufferTime</code>, \n<code>concatMap</code>, \n<code>map</code>, \n<code>mergeMap</code>, \n<code>scan</code>, \n<code>switchMap</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8tadsrgfaa9f0q28cmet8e9fd\">实用</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"p0w6es2q6qf8z7xbhd5t2ckw\"><code>startWith</code>, \n<code>tap</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"75w6lif46mxdlj13k02e4kbzg\">多播</td>\n<td align=\"left\"><code>shareReplay</code></td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aamzmhgfl92030pcrqjuo1juh\">要查看完整的操作符列表和使用示例，请访问\n<a href=\"https://rxjs.dev/api\">RxJS API 文档</a>。</p>\n<h2 id=\"error-handling\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ad0cx4y7txhii62pgdd0mpma9\">错误处理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#error-handling\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d0t26l7awxevxrv17psh2m8q9\">除了可以在订阅时提供 <code>error()</code> 处理器外，RxJS 还提供了 <code>catchError</code> 操作符，它允许你在管道中处理已知错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d9js4i8g9qy7qztd18ruv2rpc\">例如，假设你有一个 Observable，它发出一个 API 请求并映射来自服务器的响应。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7l8ia5gsvj7ksm5juuyoq1x31\">如果服务器返回错误或值不存在，则会产生错误。 如果你使用 \n<code>catchError</code> 操作符捕获此错误并返回一个默认值的 Observable，你的流将继续处理值而不是出错。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4lcfnthaqoa7584arn1yxxqc9\">例子如下：</p>\n<code-example header=\"catchError operator\" path=\"rx-library/src/error-handling.ts\">\nimport { Observable, of } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { map, catchError } from 'rxjs/operators';\n\n// Return good response from the API.\n// If the response is bad, throw an error.\nconst apiData = ajax('/api/data').pipe(\n  map((res: any) =&gt; {\n    if (!res?.response) {\n      throw new Error('Value expected!');\n    }\n    return res.response;\n  }),\n  /*\n   * Catch the error, either from the AJAX call or from the map operator,\n   * and return an observable of empty array.\n   * The `catchError` argument must be a function that returns an observable.\n   */\n  catchError(() =&gt; of([]))\n);\n\napiData.subscribe({\n  next(x: T) { console.log('data: ', x); },\n  error() { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<h3 id=\"multiple-subscribers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6qlbbg809zr5u74rgv7s3dsq\">多个订阅者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#multiple-subscribers\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"439ur9vj2x6dei57swoclv0tk\">大多数 Observable 都是“单播”的，这意味着每个新订阅者都会获得自己执行的那个 Observable。驱动源 Observable 的任何内容都会为新增的订阅者重新开始。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8vlgggzfgzyxkndk6xp0jzj4c\">以下示例中的 RxJS \n<code>interval()</code> 函数产生一个每半秒发出一个整数的“单播” Observable。 \n<code-example header=\"单播\" path=\"rx-library/src/app/uni-multi-cast.component.ts\" region=\"unicast-observable\">\n  /** 每隔 1/2 秒发出整数的单播 Observable。 */ numbers$: Observable&lt;number&gt; = interval(500); \n</code-example></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"tb6f6hdpsvhdnxcs6q9lziio\">每个新订阅者都会从零开始接收一组新的整数。</p>\n<blockquote>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c21eldpk6l9wv1elbtma0qp1u\"><strong>单播订阅者：</strong>\n<br> 单播订阅者 #1 收到 9\n<br> 单播订阅者 #2 收到 5\n<br> 单播订阅者 #3 收到 0</p>\n</blockquote>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"17umixdl6dtpgtxajdw12gkln\">大多数 Observable 像 \n<code>interval</code> 一样是“单播”的。 例如，从 Angular 的 \n<a href=\"guide/understanding-communicating-with-http\"><code>HttpClient.get()</code></a> 返回的 Observable 是“单播”的。每次订阅时都会向服务器发出新请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cpzmwgiooushkdnzf8ecld6i4\">这也许是你想要的。 但有时你希望共享相同的值源给所有订阅者。例如，一旦你要求 \n<code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 返回一些配置，你可能不希望下次订阅时再向服务器发出请求；你希望获取上次得到的相同配置。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bev3vknidfrgz05906oa90hfd\">你希望 \n<code>HttpClient.get</code> Observable 行为类似于“多播” Observable。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"au8mzuvzci8uyfimcriu7l6ks\">一个像 \n<code>MessageService</code> 中的 \n<code>Subject</code> 设计上就是一个“多播” Observable。它的订阅者始终获得相同的最新消息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cuidozgc2plzblh34vylsw6ec\">我们需要做一些特殊的处理，将来自 \n<code>interval</code> 和 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的“单播” Observable 转换为“多播” Observable。一个典型的解决方案是在管道中添加 \n<a href=\"https://rxjs.dev/api/index/function/shareReplay\"><code>shareReplay()</code></a> 操作符；如果有一系列操作符，则将其添加到末尾。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c0aa8klzj7xhl9m92hdjq8ui0\">这里是带有 \n<code>shareReplay</code> 的 \n<code>interval</code>。</p>\n<code-example header=\"multicast with shareReplay\" path=\"rx-library/src/app/uni-multi-cast.component.ts\" region=\"shareReplay-observable\">\n/** Multicast the interval by extending `numbers$` with `shareReplay` */\nmultiCastNumber$ = this.numbers$.pipe(\n  // Replay 1 item; never forgets, never completes.\n  shareReplay({ bufferSize: 1, refCount: false })\n);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"85x7om3ipjimde96kwbw9eq7h\">选项 \n<code>bufferSize=1</code> 表示新的订阅者会接收 Observable 先前发出的最新值（缓冲值）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2kgxsbyspo4ozizreegprumhy\">如果 \n<code>refCount=false</code> 选项意味着如果 \n<em>所有人都取消订阅</em> 然后有人重新订阅，那么新的订阅者将获得最后发出的值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e2jhdy11brby7y8c096oapj27\">如果 \n<code>refCount</code> 是 \n<code>true</code>，当所有人都取消订阅然后有人重新订阅时，新的订阅者会启动源可观察对象的全新执行。 \n<code>interval</code> 示例将重新从零开始。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"62lx3vox49dcc1jgu8rbru62k\">每个新的订阅者都会收到可观察对象发出的相同整数。</p>\n<blockquote>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a9xg1odnhp8pqsyffj7ggol1o\"><strong>多播 ShareReplay 订阅者：</strong>\n<br>ShareReplay 订阅者 #1 收到了 9\n<br>ShareReplay 订阅者 #2 收到了 9\n<br>ShareReplay 订阅者 #3 收到了 9</p>\n</blockquote>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wpqthbhncbr2hu4gkdbbapt7\">要查看单播 / 多播比较的实际效果，请尝试 \n<live-example name=\"rx-library\"></live-example>。</p>\n</div>\n<h3 id=\"retry-failed-observable\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74w470n1ay7a5lj6iddro8tnz\">重试失败的可观察对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#retry-failed-observable\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"82eg4udsgxnmsmjkngpst76m9\"><code>catchError</code> 提供了一种简单的方式进行恢复，而 <code>retry</code> 操作符让你可以尝试失败的请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6772pfagi5379xpf575dzd97g\">可以在 <code>catchError</code> 之前使用 <code>retry</code> 操作符。它会订阅到原始的来源可观察对象，它可以重新运行导致结果出错的动作序列。如果其中包含 HTTP 请求，它就会重新发起那个 HTTP 请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cb4et1uhw0poe1xf8yk1rxoql\">下列代码把前面的例子改成了在捕获错误之前重发请求：</p>\n<code-example header=\"retry operator\" path=\"rx-library/src/retry-on-error.ts\">\nimport { Observable, of } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { map, retry, catchError } from 'rxjs/operators';\n\nconst apiData = ajax('/api/data').pipe(\n  map((res: any) =&gt; {\n    if (!res.response) {\n      console.log('Error occurred.');\n      throw new Error('Value expected!');\n    }\n    return res.response;\n  }),\n  retry(3), // Retry up to 3 times before failing\n  catchError(() =&gt; of([]))\n);\n\napiData.subscribe({\n  next(x: T) { console.log('data: ', x); },\n  error() { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6wbbzyno9yvd92sdelxh7wipg\">不要重试<strong>登录认证</strong>请求，这些请求只应该由用户操作触发。我们肯定不会希望自动重复发送登录请求导致用户的账号被锁定。</p>\n</div>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Fri Aug 25 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/http-handle-request-errors\n - guide/http-server-communication\n - guide/observables\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/core/Injectable\n - api/platform-browser/animations/async\n - guide/rx-library#common-operators\n - guide/rx-library#error-handling\n - guide/rx-library#loosely-coupled-apps\n - guide/rx-library#loosely-coupled-transformations\n - guide/rx-library#message-service\n - guide/rx-library#multiple-subscribers\n - guide/rx-library#observable-creation-functions\n - guide/rx-library#operators\n - guide/rx-library#retry-failed-observable\n - guide/rx-library#subject\n - guide/rx-library#the-rxjs-library\n - guide/understanding-communicating-with-http\n - https://en.wikipedia.org/wiki/Loose_coupling\n - https://en.wikipedia.org/wiki/Reactive_programming\n - https://rxjs.dev/api\n - https://rxjs.dev/api/index/function/shareReplay\n - https://rxjs.dev/guide/glossary-and-semantics#multicast\n - https://rxjs.dev/guide/operators\n - https://rxjs.dev/guide/overview\n - https://rxjs.dev/guide/subject\n-->"}