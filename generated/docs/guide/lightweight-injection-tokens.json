{"id":"guide/lightweight-injection-tokens","title":"使用輕量級注入令牌最佳化客戶應用的大小","contents":"<div class=\"content\">\n  <h1 id=\"optimizing-client-application-size-with-lightweight-injection-tokens\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dhuttspbij4dxycu2forvevoa\">使用輕量級注入令牌最佳化客戶應用的大小<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#optimizing-client-application-size-with-lightweight-injection-tokens\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wxrqbve456bo02xq2ebntbz0\">本頁面會提供一個概念性的概述，它介紹了一種建議函式庫開發者使用的依賴注入技術。<em>使用輕量級注入令牌</em>設計你的函式庫，這有助於最佳化那些用到你函式庫的客戶應用的發布套件體積。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7d98mti988lsucl99tt9nl4ap\">你可以使用<a href=\"guide/architecture-services#introduction-to-services-and-dependency-injection\">可搖樹最佳化的提供者</a>來管理元件和可注入服務之間的依賴結構，以最佳化發布套件體積。這通常會確保如果提供的元件或服務從未被應用實際使用過，那麼編譯器就可以從發布套件中移除它的程式碼。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1sgvgyhb75n8jpwdfyjmb2ut6\">但是，由於 Angular 儲存注入令牌的方式，可能會導致未用到的元件或服務最終進入發布套件中。本頁描述了依賴注入的一種設計模式，它透過使用輕量級注入令牌來支援正確的搖樹最佳化。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d62oahvyowlp6o8dn7n5391jd\">這種輕量級注入令牌設計模式對於函式庫開發者來說尤其重要。它可以確保當應用只用到了你庫中的某些功能時，可以從客戶應用的發布套件中刪除未使用過的程式碼。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3dszx0x27sp7ksd9s0rj77tku\">當某應用用到了你的函式庫時，你的庫中可能會提供一些客戶應用未用到的服務。在這種情況下，應用開發人員會期望該服務是可搖樹最佳化的，不讓這部分程式碼增加應用的編譯後大小。由於應用開發人員既無法瞭解也無法解決函式庫的搖樹最佳化問題，因此這是函式庫開發人員的責任。為了防止未使用的元件被保留下來，你的函式庫應該使用輕量級注入令牌這種設計模式。</p>\n<h2 id=\"when-tokens-are-retained\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a7kgn5t6xeymvw6j65fqprjrr\">什麼時候令牌會被保留<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#when-tokens-are-retained\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wicduilq93pncgm4skadmaaj\">為了更好地解釋令牌被保留的條件，我們考慮一個提供卡片元件的函式庫。該組件包含一個卡片體，還可以包含一個可選的卡片頭。</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;lib-card&gt;\n  &lt;lib-header&gt;…&lt;/lib-header&gt;\n&lt;/lib-card&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eai65ybf5aeq7lm225nkhl21q\">在一個可能的實現中，<code>&lt;lib-card&gt;</code> 元件使用 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code> 或者 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>()</code> 來獲取 <code>&lt;lib-header&gt;</code> 和 <code>&lt;lib-body&gt;</code>，如下所示。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-header',\n  …,\n})\nclass LibHeaderComponent {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-card',\n  …,\n})\nclass LibCardComponent {\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderComponent)\n  header: LibHeaderComponent|null = null;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56yev0unlsqjb5s8hnsdk4buo\">因為 <code>&lt;lib-header&gt;</code> 是可選的，所以元素可以用最小化的形式 <code>&lt;lib-card&gt;&lt;/lib-card&gt;</code> 出現在樣板中。在這個例子中，<code>&lt;lib-header&gt;</code> 沒有用過，你可能期望它會被搖樹最佳化掉，但事實並非如此。這是因為 <code>LibCardComponent</code> 實際上包含兩個對 <code>LibHeaderComponent</code> 引用。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderComponent) header: LibHeaderComponent;\n\n</code-example>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5en1k8mvdqx3k4inkuabz97dx\">其中一個引用位於<em>型別位置上</em> - 即，它把 <code>LibHeaderComponent</code> 用作了型別：<code>header: LibHeaderComponent;</code>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8az420xaryy75zbe7amgq0yn\">另一個引用位於<em>值的位置</em> - 即，LibHeaderComponent 是 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code> 引數裝飾器的值：<code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderComponent)</code>。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"mzihfmiz6dxrvgitaxbyftez\">編譯器對這些位置的令牌引用的處理方式也不同。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eglrg2abtdsdpwstvg0lsk5se\">編譯器在從 TypeScript 轉換完後會刪除這些<em>型別位置上</em>的引用，所以它們對於搖樹最佳化沒什麼影響。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74wyswfbgg6kxvdvtbwzhs7r9\">編譯器必須在執行時保留<em>值位置上</em>的引用，這就會阻止該組件被搖樹最佳化掉。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3t5dln2q15qn9rck3mlm8lxyt\">在這個例子中，編譯器保留了 <code>LibHeaderComponent</code> 令牌，它出現在了值位置上，這就會防止所引用的元件被搖樹最佳化掉，即使應用開發者實際上沒有在任何地方用過 <code>&lt;lib-header&gt;</code>。如果 <code>LibHeaderComponent</code> 的程式碼、樣板和樣式變得很大，把它包含進來就會不必要地大大增加客戶應用的大小。</p>\n<h2 id=\"when-to-use-the-lightweight-injection-token-pattern\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bw4sbfi4ghch1mq6uce18el40\">什麼時候使用輕量級注入令牌模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#when-to-use-the-lightweight-injection-token-pattern\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8r9c9tpl88mi5l9x4yej76gbx\">當一個元件被用作注入令牌時，就會出現搖樹最佳化的問題。有兩種情況可能會發生。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xhjhg0oitasmrwkw4os2s8pb\">令牌用在<a href=\"guide/lifecycle-hooks#using-aftercontent-hooks\" title=\"詳細瞭解如何使用內容查詢。\">內容查詢</a>中值的位置上。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f4iqatho0y5upbo6sjy6adivx\">該令牌用作建構式函式注入的型別說明符。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3od7yab7eim9lm96ub4unyhc0\">在下面的例子中，兩處對 <code>OtherComponent</code> 令牌的使用導致 <code>OtherComponent</code> 被保留下來，防止它在未用到時被搖樹最佳化掉。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass MyComponent {\n  constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() other: OtherComponent) {}\n\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(OtherComponent)\n  other: OtherComponent|null;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dreh6r2wahcsbk4m0aczhqsb6\">雖然轉換為 JavaScript 時只會刪除那些只用作型別說明符的令牌，但在執行時依賴注入需要所有這些令牌。這些工作把 <code>constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() other: OtherComponent)</code> 改成了 <code>constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(OtherComponent) other)</code>。該令牌現在處於值的位置，並使該搖樹最佳化器保留該引用。</p>\n<div class=\"alert is helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bn7hj3ucd1xl3o4jfo1ieetef\">對於所有服務，函式庫都應該使用<a href=\"guide/architecture-services#introduction-to-services-and-dependency-injection\">可搖樹最佳化的提供者</a>，在根級而不是元件建構式函式中提供依賴。</p>\n</div>\n<h2 id=\"using-lightweight-injection-tokens\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1hmn38j8x4mogevice8fi41fl\">使用輕量級注入令牌<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#using-lightweight-injection-tokens\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ij2nbaojebd1ynq5s8mdm8py\">輕量級注入令牌設計模式包括：使用一個小的抽象類別作為注入令牌，並在稍後為它提供實際實現。該抽象類別固然會被留下（不會被搖樹最佳化掉），但它很小，對應用程式的大小沒有任何重大影響。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"22x3kexqrubmfos7qbcyxromw\">下例舉例說明了這個 <code>LibHeaderComponent</code> 的工作原理。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nabstract class LibHeaderToken {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-header',\n  providers: [\n    {provide: LibHeaderToken, useExisting: LibHeaderComponent}\n  ]\n  …,\n})\nclass LibHeaderComponent extends LibHeaderToken {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-card',\n  …,\n})\nclass LibCardComponent {\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderToken) header: LibHeaderToken|null = null;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e915ru6f068iuklq23f9wqxsr\">在這個例子中，<code>LibCardComponent</code> 的實現裡，<code>LibHeaderComponent</code> 既不會出現在型別的位置也不會出現在值的位置。這樣就可以讓 <code>LibHeaderComponent</code> 完全被搖樹最佳化掉。<code>LibHeaderToken</code> 被留下了，但它只是一個類別宣告，沒有具體的實現。它很小，並且在編譯後保留時對應用程式的大小沒有實質影響。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6aewy9pzmxy03mp9qqaog2ref\">不過，<code>LibHeaderComponent</code> 本身實現了抽象類別 <code>LibHeaderToken</code>。你可以放心使用這個令牌作為元件定義中的提供者，讓 Angular 能夠正確地注入具體型別。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"84khklmk6pjg14mamwhzplvne\">總結一下，輕量級注入令牌模式由以下幾部分組成。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"14ycx3amcb5f82tty6xlc5kjy\">一個輕量級的注入令牌，它表現為一個抽象類別。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9yk2pbksdqk77nf1ow82ubo98\">一個實現該抽象類別的元件定義。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cgowy0qn8s22uczjsfqg8zj7c\">使用輕量級模式的注入，使用\n<code> @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code>或\n<code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>()</code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2pzyka2mr68w6yd83g7uvgwwq\">實現輕量級注入令牌的提供者，它將輕量級注入令牌和它的實現關聯起來。</li>\n</ol>\n<h3 id=\"use-the-lightweight-injection-token-for-api-definition\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cztsj13ynkpl5aqe70khmxa8\">使用輕量級注入令牌進行 API 定義<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#use-the-lightweight-injection-token-for-api-definition\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1axbo4k4qetvl28sqs9wxjtur\">那些注入了輕量級注入令牌的元件可能要呼叫注入的類別中的方法。因為令牌現在是一個抽象類別，並且可注入元件實現了那個抽象類別，所以你還必須在作為輕量級注入令牌的抽象類別中宣告一個抽象方法。該方法的實現程式碼（及其所有相關程式碼）都會留在可注入元件中，但這個元件本身仍可被搖樹最佳化。這樣就能讓父元件以型別安全的方式與子元件（如果存在）進行通訊。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9rwj9wx89ffqcwrabui765u58\">比如，<code>LibCardComponent</code> 現在要查詢 <code>LibHeaderToken</code> 而不是 <code>LibHeaderComponent</code>。這個例子展示了該模式如何讓 <code>LibCardComponent</code> 與 <code>LibHeaderComponent</code> 通訊，卻不用實際引用 <code>LibHeaderComponent</code>。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nabstract class LibHeaderToken {\n  abstract doSomething(): void;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-header',\n  providers: [\n    {provide: LibHeaderToken, useExisting: LibHeaderComponent}\n  ]\n  …,\n})\nclass LibHeaderComponent extends LibHeaderToken {\n  doSomething(): void {\n    // Concrete implementation of `doSomething`\n  }\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-card',\n  …,\n})\nclass LibCardComponent implement <a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a> {\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderToken)\n  header: LibHeaderToken|null = null;\n\n  ngAfterContentInit(): void {\n    this.header &amp;&amp; this.header.doSomething();\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ankgtvjx2onw7hnlx3js8kg4\">在這個例子中，父元件會查詢令牌以獲取子元件，並持有結果元件的引用（如果存在）。在呼叫子元件中的方法之前，父元件會檢查子元件是否存在。如果子元件已經被搖樹最佳化掉，那執行期間就沒有對它的引用，當然也沒有呼叫它的方法。</p>\n<h3 id=\"naming-your-lightweight-injection-token\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1bebxqg84nwu3zxiojkwv58fa\">為你的輕量級注入令牌命名<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#naming-your-lightweight-injection-token\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5i332s6ghhryfqthf8lc8p5w4\">輕量級注入令牌只對元件有用。Angular 風格指南中建議你使用『Component』字尾命名元件。比如『LibHeaderComponent』就遵循這個約定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efm3znufy3sgzas4qznp50j8d\">為了維護元件及其令牌之間的對應關係，同時又要區分它們，推薦的寫法是使用元件基本名加上字尾『<code>Token</code>』來命名你的輕量級注入令牌：『<code>LibHeaderToken</code>』。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/creating-libraries\n-->\n<!-- links from this doc:\n - api/core/AfterContentInit\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/Inject\n - api/core/Optional\n - guide/architecture-services#introduction-to-services-and-dependency-injection\n - guide/lifecycle-hooks#using-aftercontent-hooks\n - guide/lightweight-injection-tokens#naming-your-lightweight-injection-token\n - guide/lightweight-injection-tokens#optimizing-client-application-size-with-lightweight-injection-tokens\n - guide/lightweight-injection-tokens#use-the-lightweight-injection-token-for-api-definition\n - guide/lightweight-injection-tokens#using-lightweight-injection-tokens\n - guide/lightweight-injection-tokens#when-to-use-the-lightweight-injection-token-pattern\n - guide/lightweight-injection-tokens#when-tokens-are-retained\n-->"}