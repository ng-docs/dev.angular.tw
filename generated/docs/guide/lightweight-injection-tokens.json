{"id":"guide/lightweight-injection-tokens","title":"使用轻量级注入令牌优化客户应用的大小","contents":"<div class=\"content\">\n  <h1 id=\"optimizing-client-application-size-with-lightweight-injection-tokens\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dhuttspbij4dxycu2forvevoa\">使用轻量级注入令牌优化客户应用的大小<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#optimizing-client-application-size-with-lightweight-injection-tokens\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wxrqbve456bo02xq2ebntbz0\">本页面会提供一个概念性的概述，它介绍了一种建议库开发者使用的依赖注入技术。<em>使用轻量级注入令牌</em>设计你的库，这有助于优化那些用到你库的客户应用的发布包体积。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7d98mti988lsucl99tt9nl4ap\">你可以使用<a href=\"guide/architecture-services#introduction-to-services-and-dependency-injection\">可摇树优化的提供者</a>来管理组件和可注入服务之间的依赖结构，以优化发布包体积。这通常会确保如果提供的组件或服务从未被应用实际使用过，那么编译器就可以从发布包中移除它的代码。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1sgvgyhb75n8jpwdfyjmb2ut6\">但是，由于 Angular 存储注入令牌的方式，可能会导致未用到的组件或服务最终进入发布包中。本页描述了依赖注入的一种设计模式，它通过使用轻量级注入令牌来支持正确的摇树优化。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d62oahvyowlp6o8dn7n5391jd\">这种轻量级注入令牌设计模式对于库开发者来说尤其重要。它可以确保当应用只用到了你库中的某些功能时，可以从客户应用的发布包中删除未使用过的代码。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3dszx0x27sp7ksd9s0rj77tku\">当某应用用到了你的库时，你的库中可能会提供一些客户应用未用到的服务。在这种情况下，应用开发人员会期望该服务是可摇树优化的，不让这部分代码增加应用的编译后大小。由于应用开发人员既无法了解也无法解决库的摇树优化问题，因此这是库开发人员的责任。为了防止未使用的组件被保留下来，你的库应该使用轻量级注入令牌这种设计模式。</p>\n<h2 id=\"when-tokens-are-retained\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a7kgn5t6xeymvw6j65fqprjrr\">什么时候令牌会被保留<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#when-tokens-are-retained\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wicduilq93pncgm4skadmaaj\">为了更好地解释令牌被保留的条件，我们考虑一个提供卡片组件的库。该组件包含一个卡片体，还可以包含一个可选的卡片头。</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;lib-card&gt;\n  &lt;lib-header&gt;…&lt;/lib-header&gt;\n&lt;/lib-card&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eai65ybf5aeq7lm225nkhl21q\">在一个可能的实现中，<code>&lt;lib-card&gt;</code> 组件使用 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code> 或者 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>()</code> 来获取 <code>&lt;lib-header&gt;</code> 和 <code>&lt;lib-body&gt;</code>，如下所示。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-header',\n  …,\n})\nclass LibHeaderComponent {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-card',\n  …,\n})\nclass LibCardComponent {\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderComponent)\n  header: LibHeaderComponent|null = null;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56yev0unlsqjb5s8hnsdk4buo\">因为 <code>&lt;lib-header&gt;</code> 是可选的，所以元素可以用最小化的形式 <code>&lt;lib-card&gt;&lt;/lib-card&gt;</code> 出现在模板中。在这个例子中，<code>&lt;lib-header&gt;</code> 没有用过，你可能期望它会被摇树优化掉，但事实并非如此。这是因为 <code>LibCardComponent</code> 实际上包含两个对 <code>LibHeaderComponent</code> 引用。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderComponent) header: LibHeaderComponent;\n\n</code-example>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5en1k8mvdqx3k4inkuabz97dx\">其中一个引用位于<em>类型位置上</em> - 即，它把 <code>LibHeaderComponent</code> 用作了类型：<code>header: LibHeaderComponent;</code>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8az420xaryy75zbe7amgq0yn\">另一个引用位于<em>值的位置</em> - 即，LibHeaderComponent 是 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code> 参数装饰器的值：<code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderComponent)</code>。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"mzihfmiz6dxrvgitaxbyftez\">编译器对这些位置的令牌引用的处理方式也不同。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eglrg2abtdsdpwstvg0lsk5se\">编译器在从 TypeScript 转换完后会删除这些<em>类型位置上</em>的引用，所以它们对于摇树优化没什么影响。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74wyswfbgg6kxvdvtbwzhs7r9\">编译器必须在运行时保留<em>值位置上</em>的引用，这就会阻止该组件被摇树优化掉。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3t5dln2q15qn9rck3mlm8lxyt\">在这个例子中，编译器保留了 <code>LibHeaderComponent</code> 令牌，它出现在了值位置上，这就会防止所引用的组件被摇树优化掉，即使应用开发者实际上没有在任何地方用过 <code>&lt;lib-header&gt;</code>。如果 <code>LibHeaderComponent</code> 的代码、模板和样式变得很大，把它包含进来就会不必要地大大增加客户应用的大小。</p>\n<h2 id=\"when-to-use-the-lightweight-injection-token-pattern\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bw4sbfi4ghch1mq6uce18el40\">什么时候使用轻量级注入令牌模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#when-to-use-the-lightweight-injection-token-pattern\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8r9c9tpl88mi5l9x4yej76gbx\">当一个组件被用作注入令牌时，就会出现摇树优化的问题。有两种情况可能会发生。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xhjhg0oitasmrwkw4os2s8pb\">令牌用在<a href=\"guide/lifecycle-hooks#using-aftercontent-hooks\" title=\"详细了解如何使用内容查询。\">内容查询</a>中值的位置上。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f4iqatho0y5upbo6sjy6adivx\">该令牌用作构造函数注入的类型说明符。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3od7yab7eim9lm96ub4unyhc0\">在下面的例子中，两处对 <code>OtherComponent</code> 令牌的使用导致 <code>OtherComponent</code> 被保留下来，防止它在未用到时被摇树优化掉。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass MyComponent {\n  constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() other: OtherComponent) {}\n\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(OtherComponent)\n  other: OtherComponent|null;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dreh6r2wahcsbk4m0aczhqsb6\">虽然转换为 JavaScript 时只会删除那些只用作类型说明符的令牌，但在运行时依赖注入需要所有这些令牌。这些工作把 <code>constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() other: OtherComponent)</code> 改成了 <code>constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(OtherComponent) other)</code>。该令牌现在处于值的位置，并使该摇树优化器保留该引用。</p>\n<div class=\"alert is helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bn7hj3ucd1xl3o4jfo1ieetef\">对于所有服务，库都应该使用<a href=\"guide/architecture-services#introduction-to-services-and-dependency-injection\">可摇树优化的提供者</a>，在根级而不是组件构造函数中提供依赖。</p>\n</div>\n<h2 id=\"using-lightweight-injection-tokens\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1hmn38j8x4mogevice8fi41fl\">使用轻量级注入令牌<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#using-lightweight-injection-tokens\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ij2nbaojebd1ynq5s8mdm8py\">轻量级注入令牌设计模式包括：使用一个小的抽象类作为注入令牌，并在稍后为它提供实际实现。该抽象类固然会被留下（不会被摇树优化掉），但它很小，对应用程序的大小没有任何重大影响。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"22x3kexqrubmfos7qbcyxromw\">下例举例说明了这个 <code>LibHeaderComponent</code> 的工作原理。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nabstract class LibHeaderToken {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-header',\n  providers: [\n    {provide: LibHeaderToken, useExisting: LibHeaderComponent}\n  ]\n  …,\n})\nclass LibHeaderComponent extends LibHeaderToken {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-card',\n  …,\n})\nclass LibCardComponent {\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderToken) header: LibHeaderToken|null = null;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e915ru6f068iuklq23f9wqxsr\">在这个例子中，<code>LibCardComponent</code> 的实现里，<code>LibHeaderComponent</code> 既不会出现在类型的位置也不会出现在值的位置。这样就可以让 <code>LibHeaderComponent</code> 完全被摇树优化掉。<code>LibHeaderToken</code> 被留下了，但它只是一个类声明，没有具体的实现。它很小，并且在编译后保留时对应用程序的大小没有实质影响。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6aewy9pzmxy03mp9qqaog2ref\">不过，<code>LibHeaderComponent</code> 本身实现了抽象类 <code>LibHeaderToken</code>。你可以放心使用这个令牌作为组件定义中的提供者，让 Angular 能够正确地注入具体类型。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"84khklmk6pjg14mamwhzplvne\">总结一下，轻量级注入令牌模式由以下几部分组成。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"14ycx3amcb5f82tty6xlc5kjy\">一个轻量级的注入令牌，它表现为一个抽象类。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9yk2pbksdqk77nf1ow82ubo98\">一个实现该抽象类的组件定义。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cgowy0qn8s22uczjsfqg8zj7c\">使用轻量级模式的注入，使用\n<code> @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code>或\n<code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>()</code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2pzyka2mr68w6yd83g7uvgwwq\">实现轻量级注入令牌的提供者，它将轻量级注入令牌和它的实现关联起来。</li>\n</ol>\n<h3 id=\"use-the-lightweight-injection-token-for-api-definition\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cztsj13ynkpl5aqe70khmxa8\">使用轻量级注入令牌进行 API 定义<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#use-the-lightweight-injection-token-for-api-definition\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1axbo4k4qetvl28sqs9wxjtur\">那些注入了轻量级注入令牌的组件可能要调用注入的类中的方法。因为令牌现在是一个抽象类，并且可注入组件实现了那个抽象类，所以你还必须在作为轻量级注入令牌的抽象类中声明一个抽象方法。该方法的实现代码（及其所有相关代码）都会留在可注入组件中，但这个组件本身仍可被摇树优化。这样就能让父组件以类型安全的方式与子组件（如果存在）进行通信。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9rwj9wx89ffqcwrabui765u58\">比如，<code>LibCardComponent</code> 现在要查询 <code>LibHeaderToken</code> 而不是 <code>LibHeaderComponent</code>。这个例子展示了该模式如何让 <code>LibCardComponent</code> 与 <code>LibHeaderComponent</code> 通信，却不用实际引用 <code>LibHeaderComponent</code>。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nabstract class LibHeaderToken {\n  abstract doSomething(): void;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-header',\n  providers: [\n    {provide: LibHeaderToken, useExisting: LibHeaderComponent}\n  ]\n  …,\n})\nclass LibHeaderComponent extends LibHeaderToken {\n  doSomething(): void {\n    // Concrete implementation of `doSomething`\n  }\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-card',\n  …,\n})\nclass LibCardComponent implement <a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a> {\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderToken)\n  header: LibHeaderToken|null = null;\n\n  ngAfterContentInit(): void {\n    this.header &amp;&amp; this.header.doSomething();\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ankgtvjx2onw7hnlx3js8kg4\">在这个例子中，父组件会查询令牌以获取子组件，并持有结果组件的引用（如果存在）。在调用子组件中的方法之前，父组件会检查子组件是否存在。如果子组件已经被摇树优化掉，那运行期间就没有对它的引用，当然也没有调用它的方法。</p>\n<h3 id=\"naming-your-lightweight-injection-token\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1bebxqg84nwu3zxiojkwv58fa\">为你的轻量级注入令牌命名<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#naming-your-lightweight-injection-token\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5i332s6ghhryfqthf8lc8p5w4\">轻量级注入令牌只对组件有用。Angular 风格指南中建议你使用“Component”后缀命名组件。比如“LibHeaderComponent”就遵循这个约定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efm3znufy3sgzas4qznp50j8d\">为了维护组件及其令牌之间的对应关系，同时又要区分它们，推荐的写法是使用组件基本名加上后缀“<code>Token</code>”来命名你的轻量级注入令牌：“<code>LibHeaderToken</code>”。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/creating-libraries\n-->\n<!-- links from this doc:\n - api/core/AfterContentInit\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/Inject\n - api/core/Optional\n - guide/architecture-services#introduction-to-services-and-dependency-injection\n - guide/lifecycle-hooks#using-aftercontent-hooks\n - guide/lightweight-injection-tokens#naming-your-lightweight-injection-token\n - guide/lightweight-injection-tokens#optimizing-client-application-size-with-lightweight-injection-tokens\n - guide/lightweight-injection-tokens#use-the-lightweight-injection-token-for-api-definition\n - guide/lightweight-injection-tokens#using-lightweight-injection-tokens\n - guide/lightweight-injection-tokens#when-to-use-the-lightweight-injection-token-pattern\n - guide/lightweight-injection-tokens#when-tokens-are-retained\n-->"}