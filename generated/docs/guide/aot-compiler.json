{"id":"guide/aot-compiler","title":"预先（AOT）编译器","contents":"<div class=\"content\">\n  <h1 id=\"ahead-of-time-aot-compilation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"86a6leao0pq5hk3gqyd7aemk7\">预先（AOT）编译器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#ahead-of-time-aot-compilation\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ew39i3g4c1327vynuuu5docu3\">Angular 应用主要由组件及其 HTML 模板组成。由于浏览器无法直接理解 Angular 所提供的组件和模板，因此 Angular 应用程序需要先进行编译才能在浏览器中运行。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bv5jbdhelpg2basa5uz6bpixh\">在浏览器下载和运行代码<em>之前</em>的编译阶段，Angular 预先（AOT）编译器会先把你的 Angular HTML 和 TypeScript 代码转换成高效的 JavaScript 代码。在构建期间编译应用可以让浏览器中的渲染更快速。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amwx61474ikc96wiuenj9cupx\">本指南中解释了如何指定元数据，并使用一些编译器选项以借助 AOT 编译器来更有效的编译应用。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8edqrmynaedl1mr0jquiebk4\"><a href=\"https://www.youtube.com/watch?v=anphffaCZrQ\">观看 Alex Rickabaugh 在 AngularConnect 2019 解释 Angular 编译器的演讲</a>。</p>\n</div>\n<p><a id=\"why-aot\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dbzg1yw2h82txs5p595aat4oa\">下面是你可能要使用 AOT 的部分原因。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"betfffemq5l58dq8mv5vosvwh\">原因</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"50yas5hchrolvftacmen7qcip\">更快的渲染</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"czhuaqdcx6wxhk3ib0b8rdxnw\">使用 AOT，浏览器会下载应用的预编译版本。浏览器加载可执行代码，因此可以立即渲染应用，无需等待首先编译应用。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"qw9t9851prcg2xm3dx5fdjwp\">较少的异步请求</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5wjg0ggevaqvvylw5fowuaxc4\">编译器会内联应用JavaScript中的外部HTML模板和CSS样式表，消除了为这些源文件进行单独ajax请求的需要。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3fdxpt550vicfbbcri4m76afc\">更小的 Angular 框架下载大小</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccnuck7dn9ua3ragnrq7hon36\">如果应用已经编译，就不需要下载 Angular 编译器了。编译器大约占 Angular 本身的一半，因此省略它会显著减少应用的负载。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4lqtwpylqmhgjuvpdbq9aq9hc\">更早地检测模板错误</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5o8jkfxvm9k2kekwhv438cxto\">AOT 编译器在构建阶段检测和报告模板绑定错误，使用户在看到这些错误之前就能知晓。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29jgs05nbj8s9dyo4ys70vpfx\">更好的安全性</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e5xs1i6kax02oxa0itaex5n82\">AOT 将HTML模板和组件提前编译成JavaScript文件，远在它们提供给客户端之前。由于没有模板可读取，也没有危险的客户端HTML或JavaScript评估，因此注入攻击的机会更少。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"overview\"></a></p>\n<h2 id=\"choosing-a-compiler\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2o3e9qme7pht4k6kdg9i6dldk\">选择编译器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#choosing-a-compiler\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7tmjeukt2ijvkq5fzld60dksf\">Angular 提供了两种方式来编译你的应用：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5c1v5byb3pogxaf6r8uyffq2\">Angular 编译</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"30tlatjxu4iem3fjqgus1a6sr\">即时编译（JIT）</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d14pasefti0hkzmn4acic9poo\">在运行时在浏览器中编译您的应用。这是 Angular 8 之前的默认设置。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c376oxdtbp8nfu6ja58kdc1rt\">预先编译（AOT）</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"enilh4hv7jqqqy4oqa0gmo9qu\">在构建时编译您的应用和库。这是 Angular 9 开始的默认设置。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2n038s31mwt3jch2aw48kbd3y\">当运行 CLI 命令 <a href=\"cli/build\"><code>ng build</code></a> （只构建）或 <a href=\"cli/serve\"><code>ng serve</code></a>（构建并启动本地服务器）时，编译类型（JIT 或 AOT）取决于你在 <code>angular.json</code> 中的构建配置所指定的 <code>aot</code> 属性。默认情况下，对于新的 CLI 应用，其 <code>aot</code> 为 <code>true</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3ccs9cdadj48rospz18x3idi\">要了解更多，参阅<a href=\"cli\">CLI 文档</a>，和 <a href=\"guide/build\">构建与运行 Angular 应用</a>。</p>\n<h2 id=\"how-aot-works\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bq8bjvfxhrq96dcf9fhcg9uh3\">AOT 工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#how-aot-works\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4zjhvn93uxue4t5le3rgbjqle\">Angular AOT 编译器会提取<strong>元数据</strong>来解释应由 Angular 管理的应用程序部分。你可以在<strong>装饰器</strong>（比如 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 和 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>）中显式指定元数据，也可以在<strong>被装饰的类</strong>的构造函数声明中隐式指定元数据。元数据告诉 Angular 要如何构造应用程序类的实例并在运行时与它们进行交互。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5egctqhwd0u5p9hrxjmetbpqt\">在下列范例中，<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 元数据对象和类的构造函数会告诉 Angular 如何创建和显示 <code>TypicalComponent</code> 的实例。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-typical',\n  template: '&lt;div&gt;A typical component for {{data.name}}&lt;/div&gt;'\n})\nexport class TypicalComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() data: TypicalData;\n  constructor(private someService: SomeService) { … }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8o0cggrvcqgkzhifhq10c32kk\">Angular 编译器只提取<strong>一次</strong>元数据，并且为 <code>TypicalComponent</code> 生成一个<strong>工厂</strong>。当它需要创建 <code>TypicalComponent</code> 的实例时，Angular 调用这个工厂，工厂会生成一个新的可视元素，并且把它（及其依赖）绑定到组件类的一个新实例上。</p>\n<h3 id=\"compilation-phases\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cors6napom1dxn5jfs01ubk4m\">编译的各个阶段<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#compilation-phases\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9fxscotkotcrxy7u00ykuc0fa\">AOT 编译分为三个阶段。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ksevlnrwwntaghvm9gkh5nf7\">阶段</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6q1qn323vovc12zfwjt1n90ci\">代码分析</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cgw42cd3ifpejlu1opgpp1orz\">在此阶段，TypeScript 编译器和 AOT 收集器创建源代码的表示。收集器不会尝试解释它收集的元数据。它会尽可能地表示元数据，并在检测到元数据语法违规时记录错误。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bfw4hs0j1ocbbpmni129cch9k\">代码生成</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bwwrb6syoqoidaszsxw1nmtpb\">在此阶段，编译器的\n<code>StaticReflector</code>解析在第一阶段收集的元数据，对元数据进行额外验证，并在检测到元数据限制违规时引发错误。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ljn0mt4c3ds1hs1h0yxb4qf7\">模板类型检查</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"47yhvtn5lhde3ujzbkhi6qgl5\">在这个可选阶段，Angular\n<em>模板编译器</em>使用 TypeScript 编译器来验证模板中的绑定表达式。您可以通过设置\n<code>strictTemplates</code>配置选项显式启用此阶段；请参阅\n<a href=\"guide/angular-compiler-options\">Angular 编译器选项</a>。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"metadata-restrictions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e706ncbspohkemcmgs4ogupag\">元数据的限制<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-restrictions\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aan2l7eqmpe37mn1b7ti2upf0\">你只能使用 TypeScript 的一个<strong>子集</strong>书写元数据，它必须满足下列限制：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cznvutexx7edw32rfh8ze718p\"><a href=\"guide/aot-compiler#expression-syntax\">表达式语法</a>只支持 JavaScript 的一个有限的子集</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rotxryhzmenglatg33254ubr\">只能引用<a href=\"guide/aot-compiler#code-folding\">代码收缩</a>后导出的符号</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ssda5am0fzjjhpyzoj5t68m1\">只能调用编译器<a href=\"guide/aot-compiler#supported-functions\">支持的函数</a></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wp7syzn7lv9kktv1jbmpu3rj\">输入属性、输出属性和用于数据绑定的类成员必须是公共（public）的或受保护的（protected）。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ypmzyskc6fcvl912jy81d1qt\">关于准备 AOT 编译应用程序的其它准则和说明，参阅 <a href=\"https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f\">Angular：编写 AOT 友好的应用程序</a>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1edp97ni7i2d8q7ckoshjqvhe\">AOT 编译中的错误通常是由于元数据不符合编译器的要求而发生的（下面将更全面地介绍）。为了帮助你理解和解决这些问题，参阅 <a href=\"guide/aot-metadata-errors\">AOT 元数据错误</a>。</p>\n</div>\n<h3 id=\"configuring-aot-compilation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6bxnkr03spg91rhxv2g1pq018\">配置 AOT 编译<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#configuring-aot-compilation\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29gl7r5n9cqwaf3tzjomcdnay\">你可以在 <a href=\"guide/typescript-configuration\">TypeScript 配置文件</a>中提供控制编译过程的选项。关于可用选项的完整列表，参阅 <a href=\"guide/angular-compiler-options\">Angular 编译器</a>选项。</p>\n<h2 id=\"phase-1-code-analysis\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"exnp0whhuvtgumnvdc07avdxj\">阶段 1：分析<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-1-code-analysis\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91dc6s084zmazzi32xtfr76or\">TypeScript 编译器会做一些初步的分析工作，它会生成<strong>类型定义文件</strong><code>.d.ts</code>，其中带有类型信息，Angular 编译器需要借助它们来生成代码。\n同时，AOT <strong>收集器（collector）</strong> 会记录 Angular 装饰器中的元数据，并把它们输出到<strong><code>.metadata.json</code></strong>文件中，和每个 <code>.d.ts</code> 文件相对应。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1o3lgq9ylbxbnas7dl9miwveg\">你可以把 <code>.metadata.json</code> 文件看做一个包括全部装饰器的元数据的全景图，就像<a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">抽象语法树（AST）</a>一样。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"898861iqa2fryvh24wtgrrqo\">Angular 的 <a href=\"https://github.com/angular/angular/blob/main/packages/compiler-cli/src/metadata/schema.ts\">schema.ts</a> 会将 JSON 格式描述为 TypeScript 接口的集合。</p>\n</div>\n<p><a id=\"expression-syntax\"></a></p>\n<h3 id=\"expression-syntax-limitations\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54fm54djtjvm5rz7kquds3h9v\">表达式语法限制<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#expression-syntax-limitations\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"al5js0pespniqoehgw0qzyudb\">AOT 收集器只能理解 JavaScript 的一个子集。定义元数据对象时要遵循下列语法限制：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8p44mx807exjp3s0k9dwbuxla\">语法</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"lzz2v4ucg07faxnpe2bu1wa1\">范例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"pawdo4v1ftsqb7hgncivrrtr\">字面对象</td>\n<td align=\"left\"><code>{cherry: true, apple: true, mincemeat: false}</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"celil1s9fvdj5h001ggxww2wg\">字面数组</td>\n<td align=\"left\"><code>['cherries', 'flour', 'sugar']</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9jcubru2hcec6y1xoseq584lw\">字面数组中的扩展</td>\n<td align=\"left\"><code>['apples', 'flour', ...]</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ajlqvrq9or76b4immqohnkbvt\">调用</td>\n<td align=\"left\"><code>bake(ingredients)</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80lep37b3pz9v0caoqb21dem\">新建</td>\n<td align=\"left\"><code>new Oven()</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8hlklpuzu6n50x3rnyjh8ica5\">属性访问</td>\n<td align=\"left\"><code>pie.slice</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8nkjm5j5wf05rwfytv4oe8oi\">数组索引</td>\n<td align=\"left\"><code>ingredients[0]</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9j92obtwtq0usp87w7hnqugc7\">身份引用</td>\n<td align=\"left\"><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dg3oxut0wds57hvogtnhfyr6\">模板字符串</td>\n<td align=\"left\"><code>`pie is ${multiplier} times better than cake`</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6km60trrfnc4j65n50ltmrz6\">字面字符串</td>\n<td align=\"left\"><code>'pi'</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9whhr0otfdhciw4ompg2p3y28\">字面数字</td>\n<td align=\"left\"><code>3.14153265</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3n8z4687qnsdmn5y6xmbmnnxi\">字面布尔</td>\n<td align=\"left\"><code>true</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3915mfsp6yfqt6ltma1w5m19h\">字面空</td>\n<td align=\"left\"><code>null</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9qfkr5r9jpuemmic1t6z59ubs\">支持的前缀运算符</td>\n<td align=\"left\"><code>!cake</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"do39fzcuk0e5ooxm62kmz4lhm\">支持的二元运算符</td>\n<td align=\"left\"><code>a+b</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yferwjkhuahg79erz4z23rnm\">条件运算符</td>\n<td align=\"left\"><code>a ? b : c</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99vy3rp3vy14fnojqf6hj1uc7\">括号</td>\n<td align=\"left\"><code>(a+b)</code></td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bj5uscaq5fulnhykzwepeao6r\">如果表达式使用了不支持的语法，收集器就会往 <code>.metadata.json</code> 文件中写入一个错误节点。稍后，如果编译器用到元数据中的这部分内容来生成应用代码，它就会报告这个错误。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6p9x0jw8k7zis7q5ehz0w3ouz\">如果你希望 <code>ngc</code> 立即汇报这些语法错误，而不要生成带有错误信息的 <code>.metadata.json</code> 文件，可以到 TypeScript 的配置文件中设置 <code>strictMetadataEmit</code> 选项。</p>\n<code-example format=\"json\" language=\"json\">\n\n\"angularCompilerOptions\": {\n  …\n  \"strictMetadataEmit\" : true\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ac5sprw2ka9jfacn5388cxqb\">Angular 库通过这个选项来确保所有的 Angular <code>.metadata.json</code> 文件都是干净的。当你要构建自己的代码库时，这也同样是一项最佳实践。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"42bla7x8wcua44wlulj71bdcw\"><a id=\"function-expression\"></a>\n<a id=\"arrow-functions\"></a></p>\n<h3 id=\"no-arrow-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cmk4vwqqg3ck95hzsdiojv725\">不要有箭头函数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#no-arrow-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7k5hgg6f38daxu4pbahmitdn4\">AOT 编译器不支持<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/function\">函数表达式</a>和<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">箭头函数</a>，也叫 <em>lambda</em> 函数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"v429s9ycivh9f3gg5fph1ota\">考虑如下组件装饰器：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  …\n  providers: [{provide: server, useFactory: () =&gt; new Server()}]\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9vw3t8qqqnq9r4z6s8pmnjeo6\">AOT 的收集器不支持在元数据表达式中出现箭头函数 <code>() =&gt; new Server()</code>。它会在该函数中就地生成一个错误节点。稍后，当编译器解释该节点时，它就会报告一个错误，让你把这个箭头函数转换成一个<em>导出的函数</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1sadqhpcharplmexeezc3ksd\">你可以把它改写成这样来修复这个错误：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport function serverFactory() {\n  return new Server();\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  …\n  providers: [{provide: server, useFactory: serverFactory}]\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"biau97ainnq98atfc1yvr7gmg\">在版本 5 和更高版本中，编译器会在发出 <code>.js</code> 文件时自动执行此重写。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9e0nt04ute9359jzu5pnuamde\"><a id=\"exported-symbols\"></a>\n<a id=\"code-folding\"></a></p>\n<h3 id=\"code-folding\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1pg98cu5iosl3v77xe0tzmtu0\">代码折叠<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#code-folding\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"499me36ueowsvf86mviu4b5\">编译器只会解析到<strong><em>已导出</em></strong>符号的引用。收集器可以在收集期间执行表达式，并用其结果记录到 <code>.metadata.json</code> 中（而不是原始表达式中）。这样可以让你把非导出符号的使用限制在表达式中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2mfuygqhlwzzu0lx31fmy8t8\">比如，收集器可以估算表达式 <code>1 + 2 + 3 + 4</code> 并将其替换为结果 <code>10</code>。这个过程称为<em>折叠</em>。可以用这种方式简化的表达式是<em>可折叠的</em>。</p>\n<p><a id=\"var-declaration\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3ig6siqo2ttwfn3pdihcorc7\">收集器可以计算对模块局部变量的 <code>const</code> 声明和初始化过的 <code>var</code> 和 <code>let</code> 声明，并从 <code>.metadata.json</code> 文件中移除它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bmvammydlsjz5rief6bf16fep\">考虑下列组件定义：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst template = '&lt;div&gt;{{hero.name}}&lt;/div&gt;';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dusg1unylhi4sh85hp7ef5wci\">编译器不能引用 <code>template</code> 常量，因为它是未导出的。但是收集器可以通过内联 <code>template</code> 常量的方式把它<em>折叠</em>进元数据定义中。最终的结果和你以前的写法是一样的：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: '&lt;div&gt;{{hero.name}}&lt;/div&gt;'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekrp7dvp100dbq8yjxs1msfle\">这里没有对 <code>template</code> 的引用，因此，当编译器稍后对位于 <code>.metadata.json</code> 中的收集器输出进行解释时，不会再出问题。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"245sbav4ip29byr0ft4ji202p\">你还可以通过把 <code>template</code> 常量包含在其它表达式中来让这个例子深入一点：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst template = '&lt;div&gt;{{hero.name}}&lt;/div&gt;';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template + '&lt;div&gt;{{hero.title}}&lt;/div&gt;'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"apahzps8bqqeol46nyll46g58\">收集器把该表达式缩减成其等价的<em>已折叠</em>字符串：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n'&lt;div&gt;{{hero.name}}&lt;/div&gt;&lt;div&gt;{{hero.title}}&lt;/div&gt;'\n\n</code-example>\n<h4 id=\"foldable-syntax\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66w5yow6rvxff09rca2895ux1\">可折叠的语法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#foldable-syntax\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9t12vm44r0v7d3okadism3nvs\">下表中描述了收集器可以折叠以及不能折叠哪些表达式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8p44mx807exjp3s0k9dwbuxla\">语法</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8js8rcvbhx832x0aa5btafxm0\">可折叠的</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"pawdo4v1ftsqb7hgncivrrtr\">字面对象</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"celil1s9fvdj5h001ggxww2wg\">字面数组</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9jcubru2hcec6y1xoseq584lw\">字面数组中的扩展</td>\n<td align=\"left\">no</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ajlqvrq9or76b4immqohnkbvt\">调用</td>\n<td align=\"left\">no</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80lep37b3pz9v0caoqb21dem\">新建</td>\n<td align=\"left\">no</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8hlklpuzu6n50x3rnyjh8ica5\">属性访问</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eu2xtjafpdelexixad8s29kiu\">是的，如果目标可折叠</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8nkjm5j5wf05rwfytv4oe8oi\">数组索引</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"606o23hk8xjq0aqug6gp3ysxk\">是的，如果目标和索引都可折叠</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9j92obtwtq0usp87w7hnqugc7\">身份引用</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a621jxv32k4getbglk8v5t158\">是的，如果它是对本地引用的引用</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2x8b3uzq2e1c9x6pxn2h0f0k\">一个没有替换的模板</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vm7wzo9yufzneso1bvy92rd2\">一个带有替换的模板</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4426iokopml0k64ar8cz4tklj\">是的，如果替换内容可折叠</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6km60trrfnc4j65n50ltmrz6\">字面字符串</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9whhr0otfdhciw4ompg2p3y28\">字面数字</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3n8z4687qnsdmn5y6xmbmnnxi\">字面布尔</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3915mfsp6yfqt6ltma1w5m19h\">字面空</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9qfkr5r9jpuemmic1t6z59ubs\">支持的前缀运算符</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8w7u9s5tktg84igoky5nmk1x8\">是的，如果操作数可折叠</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"do39fzcuk0e5ooxm62kmz4lhm\">支持的二元运算符</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ffs9xizd3pr7cdvr2rbehme2\">是的，如果左右两边都可折叠</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yferwjkhuahg79erz4z23rnm\">条件运算符</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amjha0tbhse041jeyjuvedlp5\">是的，如果条件可折叠</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99vy3rp3vy14fnojqf6hj1uc7\">括号</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9nk3eg924z3m839az0x2w9x9\">是的，如果表达式可折叠</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bpn5y4vss818yxb9qdwhz7kt\">如果表达式是不可折叠的，那么收集器就会把它作为一个 <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">AST</a>（抽象语法树）写入 <code>.metadata.json</code> 中，留给编译器去解析。</p>\n<h2 id=\"phase-2-code-generation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dkuta9n5b71mcf4ecwtx9flg\">阶段 2：代码生成<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-2-code-generation\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"60ejxlav8x2y28idv9kliher4\">收集器不会试图理解它收集并输出到 <code>.metadata.json</code> 中的元数据，它所能做的只是尽可能准确的表述这些元数据，并在检测到元数据中的语法违规时记录这些错误。解释这些 <code>.metadata.json</code> 是编译器在代码生成阶段要承担的工作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2f8docifkobp53tsjdx25i9qh\">编译器理解收集器支持的所有语法形式，但是它也可能拒绝那些虽然<em>语法正确</em>但<em>语义</em>违反了编译器规则的元数据。</p>\n<h3 id=\"public-or-protected-symbols\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cg167by3cxj7ek6kntucm3ro3\">公共的或受保护的符号<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#public-or-protected-symbols\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"23227kuy1ppw38thjxd1egtg0\">编译器只能引用<em>已导出的符号</em>。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ectj4xhcje8namkj3e53x6onx\">带有装饰器的类成员必须是公开的（public）或保护的（protected）。你不可能把一个私有属性做成 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5cjv9svl72qwtv6qyrt09fcej\">数据绑定的属性同样必须是公开的（public）或保护的（protected）</p>\n</li>\n</ul>\n<p><a id=\"supported-functions\"></a></p>\n<h3 id=\"supported-classes-and-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bh95gvr0vg7zp74kebyqamdzq\">支持的类和函数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#supported-classes-and-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9szpynoy3gh2xhw17kk5ruig8\">只要语法有效，收集器就可以用 <code>new</code> 来表示函数调用或对象创建。但是，编译器在后面可以拒绝生成对<em>特定</em>函数的调用或对<em>特定</em>对象的创建。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"al0lyauwz8ypvxccnrcwvocg1\">编译器只能创建某些类的实例，仅支持核心装饰器，并且仅支持对返回表达式的宏（函数或静态方法）的调用。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c421y5ac8mh41l3n9kalw03wx\">编译器操作</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"70c03lcwyg7vctfl5zpgdkgx\">新实例</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d8m27q5u62wppyr8dwa09ndc9\">编译器仅允许创建来自\n<code>@angular/core</code>模块的\n<code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code>类的实例的元数据。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"fj9i8h7cp6axo40lwtzez45e\">支持的装饰器</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"49b0x3ll9qh9nwgmmm47l1zi0\">编译器仅支持\n<a href=\"api/core#decorators\">在<code>@angular/core</code>模块中的Angular装饰器的元数据</a>。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4vve9ogkkcpalb2xdkuucyzay\">函数调用</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qbo4qn9dscajhj4jrnzom39y\">工厂函数必须是导出的、具名函数。AOT编译器不支持用于工厂函数的lambda表达式（\"箭头函数\"）。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"function-calls\"></a></p>\n<h3 id=\"functions-and-static-method-calls\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6kbb4ju0or5yzbjzjm6pcgni4\">函数和静态方法调用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#functions-and-static-method-calls\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2xuv4vfa74y9ct2uqhj2v4up0\">收集器接受任何只包含一个 <code>return</code> 语句的函数或静态方法。编译器也支持在返回表达式的函数或静态函数中使用<em>宏</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"88mt6000uk9b639d21izbyc9x\">考虑下面的函数：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport function wrapInArray&lt;T&gt;(value: T): T[] {\n  return [value];\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"chtium6n6l36ulxrwux8ux4wy\">你可以在元数据定义中调用 <code>wrapInArray</code>，因为它所返回的表达式的值满足编译器支持的 JavaScript 受限子集。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"avtcedibccqkly4kkpyllg8uq\">你还可以这样使用 <code>wrapInArray()</code>：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: wrapInArray(TypicalComponent)\n})\nexport class TypicalModule {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cxe1c38pqqvbbjyri66x67hjg\">编译器会把这种用法处理成你以前的写法：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [TypicalComponent]\n})\nexport class TypicalModule {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58o43e3qkv0xk36qh6by5ozms\">Angular 的 <a href=\"api/router/RouterModule\"><code>RouterModule</code></a> 导出了两个静态宏函数 <code>forRoot</code> 和 <code>forChild</code>，以帮助声明根路由和子路由。\n查看这些方法的<a href=\"https://github.com/angular/angular/blob/main/packages/router/src/router_module.ts#L139\" title=\"RouterModule.forRoot source code\">源码</a>，以了解宏函数是如何简化复杂的 <a href=\"guide/ngmodules\">NgModule</a> 配置的。</p>\n<p><a id=\"metadata-rewriting\"></a></p>\n<h3 id=\"metadata-rewriting\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80apurgqc66e7jogku2jtp62a\">元数据重写<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-rewriting\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f1jczh8zyouu84dnshb9jnvw9\">编译器会对含有 <code>useClass</code>、<code>useValue</code>、<code>useFactory</code> 和 <code>data</code> 的对象字面量进行特殊处理，把用这些字段之一初始化的表达式转换成一个导出的变量，并用它替换该表达式。这个重写表达式的过程，会消除它们受到的所有限制，因为编译器并不需要知道该表达式的值，它只要能生成对该值的引用就行了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dn54lv55obipr2bwr6zanx61m\">你可以这样写：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass TypicalServer {\n\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: () =&gt; TypicalServer}]\n})\nexport class TypicalModule {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5sz4uv9eyalxrj9qd4cnufab2\">如果不重写，这就是无效的，因为这里不支持 Lambda 表达式，而且 <code>TypicalServer</code> 也没有被导出。为了支持这种写法，编译器自动把它重写成了这样：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass TypicalServer {\n\n}\n\nexport const θ0 = () =&gt; new TypicalServer();\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: θ0}]\n})\nexport class TypicalModule {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bcbx8kkzgetiwka0zqsa2lhou\">这就让编译器能在工厂中生成一个对 <code>θ0</code> 的引用，而不用知道 <code>θ0</code> 中包含的值到底是什么。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7i6v5c3mlwht17l2y7f7jgatn\">编译器会在生成 <code>.js</code> 文件期间进行这种重写。它不会重写 <code>.d.ts</code> 文件，所以 TypeScript 也不会把这个变量当做一项导出，因此也就不会污染 ES 模块中导出的 API。</p>\n<p><a id=\"binding-expression-validation\"></a></p>\n<h2 id=\"phase-3-template-type-checking\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"421aw65g3h43m9n601iadlihr\">阶段 3：模板类型检查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-3-template-type-checking\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66ae80nv8g6m98lqpdovxk283\">Angular 编译器最有用的功能之一就是能够对模板中的表达式进行类型检查，在由于出错而导致运行时崩溃之前就捕获任何错误。在模板类型检查阶段，Angular 模板编译器会使用 TypeScript 编译器来验证模板中的绑定表达式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ethdnbxoho7w4x8vex75k9n8v\">通过在该项目的 TypeScript 配置文件中的 <code>\"angularCompilerOptions\"</code> 中添加编译器选项 <code>\"fullTemplateTypeCheck\"</code>，可以显式启用本阶段（见<a href=\"guide/angular-compiler-options\">Angular 编译器选项</a>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ecodry9om0ny7r8oyefq19ipz\">当模板绑定表达式中检测到类型错误时，进行模板验证时就会生成错误。这和 TypeScript 编译器在处理 <code>.ts</code> 文件中的代码时报告错误很相似。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xntrej05bqyh32ejze8h2o6r\">比如，考虑下列组件：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '{{person.addresss.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"116qjq5dp583r9ocwz73n1wtm\">这会生成如下错误：</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nmy.component.ts.MyComponent.html(1,1): : Property 'addresss' does not exist on type 'Person'. Did you mean 'address'?\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a1h627rdv1b4qte3vycusuo5q\">错误信息中汇报的文件名 <code>my.component.ts.MyComponent.html</code> 是一个由模板编译器生成出的合成文件，用于保存 <code>MyComponent</code> 类的模板内容。编译器永远不会把这个文件写入磁盘。这个例子中，这里的行号和列号都是相对于 <code>MyComponent</code> 的 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 注解中的模板字符串的。如果组件使用 <code>templateUrl</code> 来代替 <code>template</code>，这些错误就会在 <code>templateUrl</code> 引用的 HTML 文件中汇报，而不是这个合成文件中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ahop50gfkylhwgxyq3054ns2x\">错误的位置是从包含出错的插值表达式的那个文本节点开始的。如果错误是一个属性绑定，比如 <code>[value]=\"person.address.street\"</code>，错误的位置就是那个包含错误的属性的位置。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"adbsjx9at7gcd2xlc8wirq5cd\">验证使用 TypeScript 类型检查器和提供给 TypeScript 编译器的选项来控制类型验证的详细程度。比如，如果指定了 <code>strictTypeChecks</code>，则会报告</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nmy.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2mh1xueei491gxm5xyz98xb7v\">错误以及上述错误消息。</p>\n<h3 id=\"type-narrowing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"62jrtenq1nrag23qeufytd223\">类型窄化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#type-narrowing\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ev8i5xk7ay73nq430j9zcu0ah\">在 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 指令中使用的表达式用来在 Angular 模板编译器中窄化联合类型，就像 TypeScript 中的 <code>if</code> 表达式一样。比如，要在上述模板中消除 <code>Object is possibly 'undefined'</code> 错误，可以把它改成只在 <code>person</code> 的值初始化过的时候才生成这个插值。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '<span *ngif=\"person\"> {{person.address.street}} </span>'\n})\nclass MyComponent {\n  person?: Person;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"doefyifrmnmpxdgmrjuouycvs\">使用 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 能让 TypeScript 编译器推断出这个绑定表达式中使用的 <code>person</code> 永远不会是 <code>undefined</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1kb9ozy2kf8iymukqccgjg8w0\">关于输入类型窄化的更多信息，参阅<a href=\"guide/structural-directives#directive-type-checks\">为自定义指令强化模板类型检查</a>。</p>\n<h3 id=\"non-null-type-assertion-operator\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aeavaaxa4o1gdak39uwwggmvg\">非空类型断言操作符<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#non-null-type-assertion-operator\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6a9ipen47cvtbo80bhrs1sjds\">使用 <a href=\"guide/template-expression-operators#non-null-assertion-operator\">非空类型断言操作符</a>可以在不方便使用 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 当组件中的某些约束可以确保这个绑定表达式在求值时永远不会为空时，防止出现 <code>Object is possibly 'undefined'</code> 错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6v1fs74g3wfz5nofl79joywtj\">在下面的例子中，<code>person</code> 和 <code>address</code> 属性总是一起出现的，如果 <code>person</code> 非空，则 <code>address</code> 也一定非空。没有一种简便的写法可以向 TypeScript 和模板编译器描述这种约束。但是这个例子中使用 <code>address!.street</code> 避免了报错。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&lt;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"&gt; {{person.name}} lives on {{address!.street}} &lt;/span&gt;'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"hs41q49v5supuw793fc5ptdg\">应该保守点使用非空断言操作符，因为将来对组件的重构可能会破坏这个约束。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ncjfshe6y2zo2n85s1f8nve8\">这个例子中，更建议在 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 中包含对 <code>address</code> 的检查，代码如下：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&lt;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person &amp;&amp; address\"&gt; {{person.name}} lives on {{address.street}} &lt;/span&gt;'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/upgrade\n - api/upgrade/UpgradeAdapter\n - api/upgrade/UpgradeAdapterRef\n - guide/angular-compiler-options\n - guide/aot-metadata-errors\n - guide/architecture-next-steps\n - guide/creating-libraries\n - guide/deployment\n - guide/deprecations\n - guide/file-structure\n - guide/npm-packages\n - guide/template-expression-operators\n - guide/upgrade\n - guide/upgrade-performance\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/common/NgIf\n - api/core#decorators\n - api/core/Component\n - api/core/InjectionToken\n - api/core/Input\n - api/core/NgModule\n - api/router/RouterModule\n - cli\n - cli/build\n - cli/serve\n - guide/angular-compiler-options\n - guide/aot-compiler#ahead-of-time-aot-compilation\n - guide/aot-compiler#choosing-a-compiler\n - guide/aot-compiler#code-folding\n - guide/aot-compiler#compilation-phases\n - guide/aot-compiler#configuring-aot-compilation\n - guide/aot-compiler#expression-syntax\n - guide/aot-compiler#expression-syntax-limitations\n - guide/aot-compiler#foldable-syntax\n - guide/aot-compiler#functions-and-static-method-calls\n - guide/aot-compiler#how-aot-works\n - guide/aot-compiler#metadata-restrictions\n - guide/aot-compiler#metadata-rewriting\n - guide/aot-compiler#no-arrow-functions\n - guide/aot-compiler#non-null-type-assertion-operator\n - guide/aot-compiler#phase-1-code-analysis\n - guide/aot-compiler#phase-2-code-generation\n - guide/aot-compiler#phase-3-template-type-checking\n - guide/aot-compiler#public-or-protected-symbols\n - guide/aot-compiler#supported-classes-and-functions\n - guide/aot-compiler#supported-functions\n - guide/aot-compiler#type-narrowing\n - guide/aot-metadata-errors\n - guide/build\n - guide/glossary#aot\n - guide/ngmodules\n - guide/structural-directives#directive-type-checks\n - guide/template-expression-operators#non-null-assertion-operator\n - guide/typescript-configuration\n - https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n - https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/function\n - https://en.wikipedia.org/wiki/Abstract*syntax*tree\n - https://en.wikipedia.org/wiki/Abstract_syntax_tree\n - https://github.com/angular/angular/blob/main/packages/compiler-cli/src/metadata/schema.ts\n - https://github.com/angular/angular/blob/main/packages/router/src/router_module.ts#L139\n - https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f\n - https://www.youtube.com/watch?v=anphffaCZrQ\n-->"}