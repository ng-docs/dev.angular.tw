{"id":"guide/aot-compiler","title":"預先（AOT）編譯器","contents":"<div class=\"content\">\n  <h1 id=\"ahead-of-time-aot-compilation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"86a6leao0pq5hk3gqyd7aemk7\">預先（AOT）編譯器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#ahead-of-time-aot-compilation\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ew39i3g4c1327vynuuu5docu3\">Angular 應用主要由元件及其 HTML 樣板組成。由於瀏覽器無法直接理解 Angular 所提供的元件和樣板，因此 Angular 應用程式需要先進行編譯才能在瀏覽器中執行。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bv5jbdhelpg2basa5uz6bpixh\">在瀏覽器下載和執行程式碼<em>之前</em>的編譯階段，Angular 預先（AOT）編譯器會先把你的 Angular HTML 和 TypeScript 程式碼轉換成高效的 JavaScript 程式碼。在建立期間編譯應用可以讓瀏覽器中的渲染更快速。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amwx61474ikc96wiuenj9cupx\">本指南中解釋瞭如何指定元資料，並使用一些編譯器選項以藉助 AOT 編譯器來更有效的編譯應用。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8edqrmynaedl1mr0jquiebk4\"><a href=\"https://www.youtube.com/watch?v=anphffaCZrQ\">觀看 Alex Rickabaugh 在 AngularConnect 2019 解釋 Angular 編譯器的演講</a>。</p>\n</div>\n<p><a id=\"why-aot\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dbzg1yw2h82txs5p595aat4oa\">下面是你可能要使用 AOT 的部分原因。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"betfffemq5l58dq8mv5vosvwh\">原因</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"50yas5hchrolvftacmen7qcip\">更快的渲染</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"czhuaqdcx6wxhk3ib0b8rdxnw\">使用 AOT，瀏覽器會下載應用的預編譯版本。瀏覽器載入可執行程式碼，因此可以立即渲染應用，無需等待首先編譯應用。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"qw9t9851prcg2xm3dx5fdjwp\">較少的非同步請求</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5wjg0ggevaqvvylw5fowuaxc4\">編譯器會行內應用JavaScript中的外部HTML樣板和CSS樣式表，消除了為這些源檔案進行單獨ajax請求的需要。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3fdxpt550vicfbbcri4m76afc\">更小的 Angular 框架下載大小</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccnuck7dn9ua3ragnrq7hon36\">如果應用已經編譯，就不需要下載 Angular 編譯器了。編譯器大約佔 Angular 本身的一半，因此省略它會顯著減少應用的負載。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4lqtwpylqmhgjuvpdbq9aq9hc\">更早地檢測樣板錯誤</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5o8jkfxvm9k2kekwhv438cxto\">AOT 編譯器在建立階段檢測和報告樣板繫結錯誤，使用戶在看到這些錯誤之前就能知曉。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29jgs05nbj8s9dyo4ys70vpfx\">更好的安全性</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e5xs1i6kax02oxa0itaex5n82\">AOT 將HTML樣板和元件提前編譯成JavaScript檔案，遠在它們提供給用戶端之前。由於沒有樣板可讀取，也沒有危險的用戶端HTML或JavaScript評估，因此注入攻擊的機會更少。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"overview\"></a></p>\n<h2 id=\"choosing-a-compiler\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2o3e9qme7pht4k6kdg9i6dldk\">選擇編譯器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#choosing-a-compiler\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7tmjeukt2ijvkq5fzld60dksf\">Angular 提供了兩種方式來編譯你的應用：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5c1v5byb3pogxaf6r8uyffq2\">Angular 編譯</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"30tlatjxu4iem3fjqgus1a6sr\">即時編譯（JIT）</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d14pasefti0hkzmn4acic9poo\">在執行時在瀏覽器中編譯您的應用。這是 Angular 8 之前的預設設定。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c376oxdtbp8nfu6ja58kdc1rt\">預先編譯（AOT）</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"enilh4hv7jqqqy4oqa0gmo9qu\">在建立時編譯您的應用和函式庫。這是 Angular 9 開始的預設設定。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2n038s31mwt3jch2aw48kbd3y\">當執行 CLI 指令 <a href=\"cli/build\"><code>ng build</code></a> （只建立）或 <a href=\"cli/serve\"><code>ng serve</code></a>（建立並啟動本地伺服器）時，編譯型別（JIT 或 AOT）取決於你在 <code>angular.json</code> 中的建立設定所指定的 <code>aot</code> 屬性。預設情況下，對於新的 CLI 應用，其 <code>aot</code> 為 <code>true</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3ccs9cdadj48rospz18x3idi\">要了解更多，參閱<a href=\"cli\">CLI 文件</a>，和 <a href=\"guide/build\">建立與執行 Angular 應用</a>。</p>\n<h2 id=\"how-aot-works\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bq8bjvfxhrq96dcf9fhcg9uh3\">AOT 工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#how-aot-works\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4zjhvn93uxue4t5le3rgbjqle\">Angular AOT 編譯器會提取<strong>元資料</strong>來解釋應由 Angular 管理的應用程式部分。你可以在<strong>裝飾器</strong>（比如 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 和 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>）中顯式指定元資料，也可以在<strong>被裝飾的類</strong>的建構式函式宣告中隱式指定元資料。元資料告訴 Angular 要如何構造應用程式類別的實例並在執行時與它們進行互動。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5egctqhwd0u5p9hrxjmetbpqt\">在下列範例中，<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 元資料物件和類別的建構式函式會告訴 Angular 如何建立和顯示 <code>TypicalComponent</code> 的實例。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-typical',\n  template: '&lt;div&gt;A typical component for {{data.name}}&lt;/div&gt;'\n})\nexport class TypicalComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() data: TypicalData;\n  constructor(private someService: SomeService) { … }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8o0cggrvcqgkzhifhq10c32kk\">Angular 編譯器只提取<strong>一次</strong>元資料，並且為 <code>TypicalComponent</code> 生成一個<strong>工廠</strong>。當它需要建立 <code>TypicalComponent</code> 的實例時，Angular 呼叫這個工廠，工廠會生成一個新的可視元素，並且把它（及其依賴）繫結到元件類別的一個新實例上。</p>\n<h3 id=\"compilation-phases\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cors6napom1dxn5jfs01ubk4m\">編譯的各個階段<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#compilation-phases\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9fxscotkotcrxy7u00ykuc0fa\">AOT 編譯分為三個階段。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ksevlnrwwntaghvm9gkh5nf7\">階段</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6q1qn323vovc12zfwjt1n90ci\">程式碼分析</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cgw42cd3ifpejlu1opgpp1orz\">在此階段，TypeScript 編譯器和 AOT 收集器建立原始碼的表示。收集器不會嘗試解釋它收集的元資料。它會盡可能地表示元資料，並在檢測到元資料語法違規時記錄錯誤。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bfw4hs0j1ocbbpmni129cch9k\">程式碼生成</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bwwrb6syoqoidaszsxw1nmtpb\">在此階段，編譯器的\n<code>StaticReflector</code>解析在第一階段收集的元資料，對元資料進行額外驗證，並在檢測到元資料限制違規時引發錯誤。</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ljn0mt4c3ds1hs1h0yxb4qf7\">樣板型別檢查</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"47yhvtn5lhde3ujzbkhi6qgl5\">在這個可選階段，Angular\n<em>樣板編譯器</em>使用 TypeScript 編譯器來驗證樣板中的繫結表示式。您可以透過設定\n<code>strictTemplates</code>設定選項顯式啟用此階段；請參閱\n<a href=\"guide/angular-compiler-options\">Angular 編譯器選項</a>。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"metadata-restrictions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e706ncbspohkemcmgs4ogupag\">元資料的限制<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-restrictions\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aan2l7eqmpe37mn1b7ti2upf0\">你只能使用 TypeScript 的一個<strong>子集</strong>書寫元資料，它必須滿足下列限制：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cznvutexx7edw32rfh8ze718p\"><a href=\"guide/aot-compiler#expression-syntax\">表示式語法</a>只支援 JavaScript 的一個有限的子集</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rotxryhzmenglatg33254ubr\">只能引用<a href=\"guide/aot-compiler#code-folding\">程式碼收縮</a>後匯出的符號</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ssda5am0fzjjhpyzoj5t68m1\">只能呼叫編譯器<a href=\"guide/aot-compiler#supported-functions\">支援的函式</a></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wp7syzn7lv9kktv1jbmpu3rj\">輸入屬性、輸出屬性和用於資料繫結的類別成員必須是公共（public）的或受保護的（protected）。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ypmzyskc6fcvl912jy81d1qt\">關於準備 AOT 編譯應用程式的其它準則和說明，參閱 <a href=\"https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f\">Angular：編寫 AOT 友好的應用程式</a>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1edp97ni7i2d8q7ckoshjqvhe\">AOT 編譯中的錯誤通常是由於元資料不符合編譯器的要求而發生的（下面將更全面地介紹）。為了幫助你理解和解決這些問題，參閱 <a href=\"guide/aot-metadata-errors\">AOT 元資料錯誤</a>。</p>\n</div>\n<h3 id=\"configuring-aot-compilation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6bxnkr03spg91rhxv2g1pq018\">設定 AOT 編譯<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#configuring-aot-compilation\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29gl7r5n9cqwaf3tzjomcdnay\">你可以在 <a href=\"guide/typescript-configuration\">TypeScript 設定檔案</a>中提供控制編譯過程的選項。關於可用選項的完整清單，參閱 <a href=\"guide/angular-compiler-options\">Angular 編譯器</a>選項。</p>\n<h2 id=\"phase-1-code-analysis\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"exnp0whhuvtgumnvdc07avdxj\">階段 1：分析<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-1-code-analysis\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91dc6s084zmazzi32xtfr76or\">TypeScript 編譯器會做一些初步的分析工作，它會生成<strong>型別定義檔案</strong><code>.d.ts</code>，其中帶有型別訊息，Angular 編譯器需要藉助它們來生成程式碼。\n同時，AOT <strong>收集器（collector）</strong> 會記錄 Angular 裝飾器中的元資料，並把它們輸出到<strong><code>.metadata.json</code></strong>檔案中，和每個 <code>.d.ts</code> 檔案相對應。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1o3lgq9ylbxbnas7dl9miwveg\">你可以把 <code>.metadata.json</code> 檔案看做一個包括全部裝飾器的元資料的全景圖，就像<a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">抽象語法樹（AST）</a>一樣。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"898861iqa2fryvh24wtgrrqo\">Angular 的 <a href=\"https://github.com/angular/angular/blob/main/packages/compiler-cli/src/metadata/schema.ts\">schema.ts</a> 會將 JSON 格式描述為 TypeScript 介面的集合。</p>\n</div>\n<p><a id=\"expression-syntax\"></a></p>\n<h3 id=\"expression-syntax-limitations\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54fm54djtjvm5rz7kquds3h9v\">表示式語法限制<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#expression-syntax-limitations\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"al5js0pespniqoehgw0qzyudb\">AOT 收集器只能理解 JavaScript 的一個子集。定義元資料物件時要遵循下列語法限制：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8p44mx807exjp3s0k9dwbuxla\">語法</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"lzz2v4ucg07faxnpe2bu1wa1\">範例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"pawdo4v1ftsqb7hgncivrrtr\">字面物件</td>\n<td align=\"left\"><code>{cherry: true, apple: true, mincemeat: false}</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"celil1s9fvdj5h001ggxww2wg\">字面陣列</td>\n<td align=\"left\"><code>['cherries', 'flour', 'sugar']</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9jcubru2hcec6y1xoseq584lw\">字面陣列中的擴充套件</td>\n<td align=\"left\"><code>['apples', 'flour', ...]</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ajlqvrq9or76b4immqohnkbvt\">呼叫</td>\n<td align=\"left\"><code>bake(ingredients)</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80lep37b3pz9v0caoqb21dem\">新建</td>\n<td align=\"left\"><code>new Oven()</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8hlklpuzu6n50x3rnyjh8ica5\">屬性訪問</td>\n<td align=\"left\"><code>pie.slice</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8nkjm5j5wf05rwfytv4oe8oi\">陣列索引</td>\n<td align=\"left\"><code>ingredients[0]</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9j92obtwtq0usp87w7hnqugc7\">身份引用</td>\n<td align=\"left\"><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dg3oxut0wds57hvogtnhfyr6\">樣板字串</td>\n<td align=\"left\"><code>`pie is ${multiplier} times better than cake`</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6km60trrfnc4j65n50ltmrz6\">字面字串</td>\n<td align=\"left\"><code>'pi'</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9whhr0otfdhciw4ompg2p3y28\">字面數字</td>\n<td align=\"left\"><code>3.14153265</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3n8z4687qnsdmn5y6xmbmnnxi\">字面布林</td>\n<td align=\"left\"><code>true</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3915mfsp6yfqt6ltma1w5m19h\">字面空</td>\n<td align=\"left\"><code>null</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9qfkr5r9jpuemmic1t6z59ubs\">支援的字首運算符</td>\n<td align=\"left\"><code>!cake</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"do39fzcuk0e5ooxm62kmz4lhm\">支援的二元運算符</td>\n<td align=\"left\"><code>a+b</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yferwjkhuahg79erz4z23rnm\">條件運算符</td>\n<td align=\"left\"><code>a ? b : c</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99vy3rp3vy14fnojqf6hj1uc7\">括號</td>\n<td align=\"left\"><code>(a+b)</code></td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bj5uscaq5fulnhykzwepeao6r\">如果表示式使用了不支援的語法，收集器就會往 <code>.metadata.json</code> 檔案中寫入一個錯誤節點。稍後，如果編譯器用到元資料中的這部分內容來生成應用程式碼，它就會報告這個錯誤。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6p9x0jw8k7zis7q5ehz0w3ouz\">如果你希望 <code>ngc</code> 立即彙報這些語法錯誤，而不要生成帶有錯誤訊息的 <code>.metadata.json</code> 檔案，可以到 TypeScript 的設定檔案中設定 <code>strictMetadataEmit</code> 選項。</p>\n<code-example format=\"json\" language=\"json\">\n\n\"angularCompilerOptions\": {\n  …\n  \"strictMetadataEmit\" : true\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ac5sprw2ka9jfacn5388cxqb\">Angular 函式庫透過這個選項來確保所有的 Angular <code>.metadata.json</code> 檔案都是乾淨的。當你要建立自己的程式碼庫時，這也同樣是一項最佳實踐。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"42bla7x8wcua44wlulj71bdcw\"><a id=\"function-expression\"></a>\n<a id=\"arrow-functions\"></a></p>\n<h3 id=\"no-arrow-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cmk4vwqqg3ck95hzsdiojv725\">不要有箭頭函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#no-arrow-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7k5hgg6f38daxu4pbahmitdn4\">AOT 編譯器不支援<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/function\">函式表示式</a>和<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">箭頭函式</a>，也叫 <em>lambda</em> 函式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"v429s9ycivh9f3gg5fph1ota\">考慮如下元件裝飾器：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  …\n  providers: [{provide: server, useFactory: () =&gt; new Server()}]\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9vw3t8qqqnq9r4z6s8pmnjeo6\">AOT 的收集器不支援在元資料表示式中出現箭頭函式 <code>() =&gt; new Server()</code>。它會在該函式中就地生成一個錯誤節點。稍後，當編譯器解釋該節點時，它就會報告一個錯誤，讓你把這個箭頭函式轉換成一個<em>匯出的函式</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1sadqhpcharplmexeezc3ksd\">你可以把它改寫成這樣來修復這個錯誤：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport function serverFactory() {\n  return new Server();\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  …\n  providers: [{provide: server, useFactory: serverFactory}]\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"biau97ainnq98atfc1yvr7gmg\">在版本 5 和更高版本中，編譯器會在發出 <code>.js</code> 檔案時自動執行此重寫。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9e0nt04ute9359jzu5pnuamde\"><a id=\"exported-symbols\"></a>\n<a id=\"code-folding\"></a></p>\n<h3 id=\"code-folding\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1pg98cu5iosl3v77xe0tzmtu0\">程式碼摺疊<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#code-folding\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"499me36ueowsvf86mviu4b5\">編譯器只會解析到<strong><em>已匯出</em></strong>符號的引用。收集器可以在收集期間執行表示式，並用其結果記錄到 <code>.metadata.json</code> 中（而不是原始表示式中）。這樣可以讓你把非匯出符號的使用限制在表示式中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2mfuygqhlwzzu0lx31fmy8t8\">比如，收集器可以估算表示式 <code>1 + 2 + 3 + 4</code> 並將其替換為結果 <code>10</code>。這個過程稱為<em>摺疊</em>。可以用這種方式簡化的表示式是<em>可摺疊的</em>。</p>\n<p><a id=\"var-declaration\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3ig6siqo2ttwfn3pdihcorc7\">收集器可以計算對模組區域性變數的 <code>const</code> 宣告和初始化過的 <code>var</code> 和 <code>let</code> 宣告，並從 <code>.metadata.json</code> 檔案中移除它們。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bmvammydlsjz5rief6bf16fep\">考慮下列元件定義：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst template = '&lt;div&gt;{{hero.name}}&lt;/div&gt;';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dusg1unylhi4sh85hp7ef5wci\">編譯器不能引用 <code>template</code> 常數，因為它是未匯出的。但是收集器可以透過行內 <code>template</code> 常數的方式把它<em>摺疊</em>進元資料定義中。最終的結果和你以前的寫法是一樣的：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: '&lt;div&gt;{{hero.name}}&lt;/div&gt;'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekrp7dvp100dbq8yjxs1msfle\">這裡沒有對 <code>template</code> 的引用，因此，當編譯器稍後對位於 <code>.metadata.json</code> 中的收集器輸出進行解釋時，不會再出問題。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"245sbav4ip29byr0ft4ji202p\">你還可以透過把 <code>template</code> 常數包含在其它表示式中來讓這個例子深入一點：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst template = '&lt;div&gt;{{hero.name}}&lt;/div&gt;';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template + '&lt;div&gt;{{hero.title}}&lt;/div&gt;'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"apahzps8bqqeol46nyll46g58\">收集器把該表示式縮減成其等價的<em>已摺疊</em>字串：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n'&lt;div&gt;{{hero.name}}&lt;/div&gt;&lt;div&gt;{{hero.title}}&lt;/div&gt;'\n\n</code-example>\n<h4 id=\"foldable-syntax\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66w5yow6rvxff09rca2895ux1\">可摺疊的語法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#foldable-syntax\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9t12vm44r0v7d3okadism3nvs\">下表中描述了收集器可以摺疊以及不能摺疊哪些表示式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8p44mx807exjp3s0k9dwbuxla\">語法</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8js8rcvbhx832x0aa5btafxm0\">可摺疊的</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"pawdo4v1ftsqb7hgncivrrtr\">字面物件</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"celil1s9fvdj5h001ggxww2wg\">字面陣列</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9jcubru2hcec6y1xoseq584lw\">字面陣列中的擴充套件</td>\n<td align=\"left\">no</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ajlqvrq9or76b4immqohnkbvt\">呼叫</td>\n<td align=\"left\">no</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80lep37b3pz9v0caoqb21dem\">新建</td>\n<td align=\"left\">no</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8hlklpuzu6n50x3rnyjh8ica5\">屬性訪問</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eu2xtjafpdelexixad8s29kiu\">是的，如果目標可摺疊</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8nkjm5j5wf05rwfytv4oe8oi\">陣列索引</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"606o23hk8xjq0aqug6gp3ysxk\">是的，如果目標和索引都可摺疊</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9j92obtwtq0usp87w7hnqugc7\">身份引用</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a621jxv32k4getbglk8v5t158\">是的，如果它是對本地引用的引用</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2x8b3uzq2e1c9x6pxn2h0f0k\">一個沒有替換的樣板</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vm7wzo9yufzneso1bvy92rd2\">一個帶有替換的樣板</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4426iokopml0k64ar8cz4tklj\">是的，如果替換內容可摺疊</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6km60trrfnc4j65n50ltmrz6\">字面字串</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9whhr0otfdhciw4ompg2p3y28\">字面數字</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3n8z4687qnsdmn5y6xmbmnnxi\">字面布林</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3915mfsp6yfqt6ltma1w5m19h\">字面空</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9qfkr5r9jpuemmic1t6z59ubs\">支援的字首運算符</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8w7u9s5tktg84igoky5nmk1x8\">是的，如果操作數可摺疊</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"do39fzcuk0e5ooxm62kmz4lhm\">支援的二元運算符</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ffs9xizd3pr7cdvr2rbehme2\">是的，如果左右兩邊都可摺疊</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yferwjkhuahg79erz4z23rnm\">條件運算符</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amjha0tbhse041jeyjuvedlp5\">是的，如果條件可摺疊</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99vy3rp3vy14fnojqf6hj1uc7\">括號</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9nk3eg924z3m839az0x2w9x9\">是的，如果表示式可摺疊</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bpn5y4vss818yxb9qdwhz7kt\">如果表示式是不可摺疊的，那麼收集器就會把它作為一個 <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">AST</a>（抽象語法樹）寫入 <code>.metadata.json</code> 中，留給編譯器去解析。</p>\n<h2 id=\"phase-2-code-generation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dkuta9n5b71mcf4ecwtx9flg\">階段 2：程式碼生成<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-2-code-generation\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"60ejxlav8x2y28idv9kliher4\">收集器不會試圖理解它收集並輸出到 <code>.metadata.json</code> 中的元資料，它所能做的只是儘可能準確的表述這些元資料，並在檢測到元資料中的語法違規時記錄這些錯誤。解釋這些 <code>.metadata.json</code> 是編譯器在程式碼生成階段要承擔的工作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2f8docifkobp53tsjdx25i9qh\">編譯器理解收集器支援的所有語法形式，但是它也可能拒絕那些雖然<em>語法正確</em>但<em>語義</em>違反了編譯器規則的元資料。</p>\n<h3 id=\"public-or-protected-symbols\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cg167by3cxj7ek6kntucm3ro3\">公共的或受保護的符號<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#public-or-protected-symbols\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"23227kuy1ppw38thjxd1egtg0\">編譯器只能引用<em>已匯出的符號</em>。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ectj4xhcje8namkj3e53x6onx\">帶有裝飾器的類別成員必須是公開的（public）或保護的（protected）。你不可能把一個私有屬性做成 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5cjv9svl72qwtv6qyrt09fcej\">資料繫結的屬性同樣必須是公開的（public）或保護的（protected）</p>\n</li>\n</ul>\n<p><a id=\"supported-functions\"></a></p>\n<h3 id=\"supported-classes-and-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bh95gvr0vg7zp74kebyqamdzq\">支援的類別和函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#supported-classes-and-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9szpynoy3gh2xhw17kk5ruig8\">只要語法有效，收集器就可以用 <code>new</code> 來表示函式呼叫或物件建立。但是，編譯器在後面可以拒絕生成對<em>特定</em>函式的呼叫或對<em>特定</em>物件的建立。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"al0lyauwz8ypvxccnrcwvocg1\">編譯器只能建立某些類別的實例，僅支援核心裝飾器，並且僅支援對回傳表示式的宏（函式或靜態方法）的呼叫。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c421y5ac8mh41l3n9kalw03wx\">編譯器操作</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"70c03lcwyg7vctfl5zpgdkgx\">新實例</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d8m27q5u62wppyr8dwa09ndc9\">編譯器僅允許建立來自\n<code>@angular/core</code>模組的\n<code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code>類別的實例的元資料。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"fj9i8h7cp6axo40lwtzez45e\">支援的裝飾器</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"49b0x3ll9qh9nwgmmm47l1zi0\">編譯器僅支援\n<a href=\"api/core#decorators\">在<code>@angular/core</code>模組中的Angular裝飾器的元資料</a>。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4vve9ogkkcpalb2xdkuucyzay\">函式呼叫</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qbo4qn9dscajhj4jrnzom39y\">工廠函式必須是匯出的、具名函式。AOT編譯器不支援用於工廠函式的lambda表示式（\"箭頭函式\"）。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"function-calls\"></a></p>\n<h3 id=\"functions-and-static-method-calls\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6kbb4ju0or5yzbjzjm6pcgni4\">函式和靜態方法呼叫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#functions-and-static-method-calls\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2xuv4vfa74y9ct2uqhj2v4up0\">收集器接受任何只包含一個 <code>return</code> 語句的函式或靜態方法。編譯器也支援在回傳表示式的函式或靜態函式中使用<em>宏</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"88mt6000uk9b639d21izbyc9x\">考慮下面的函式：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport function wrapInArray&lt;T&gt;(value: T): T[] {\n  return [value];\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"chtium6n6l36ulxrwux8ux4wy\">你可以在元資料定義中呼叫 <code>wrapInArray</code>，因為它所回傳的表示式的值滿足編譯器支援的 JavaScript 受限子集。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"avtcedibccqkly4kkpyllg8uq\">你還可以這樣使用 <code>wrapInArray()</code>：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: wrapInArray(TypicalComponent)\n})\nexport class TypicalModule {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cxe1c38pqqvbbjyri66x67hjg\">編譯器會把這種用法處理成你以前的寫法：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [TypicalComponent]\n})\nexport class TypicalModule {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58o43e3qkv0xk36qh6by5ozms\">Angular 的 <a href=\"api/router/RouterModule\"><code>RouterModule</code></a> 匯出了兩個靜態巨集函式 <code>forRoot</code> 和 <code>forChild</code>，以幫助宣告根路由和子路由。\n檢視這些方法的<a href=\"https://github.com/angular/angular/blob/main/packages/router/src/router_module.ts#L139\" title=\"RouterModule.forRoot source code\">原始碼</a>，以瞭解巨集函式是如何簡化複雜的 <a href=\"guide/ngmodules\">NgModule</a> 設定的。</p>\n<p><a id=\"metadata-rewriting\"></a></p>\n<h3 id=\"metadata-rewriting\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80apurgqc66e7jogku2jtp62a\">元資料重寫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-rewriting\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f1jczh8zyouu84dnshb9jnvw9\">編譯器會對含有 <code>useClass</code>、<code>useValue</code>、<code>useFactory</code> 和 <code>data</code> 的物件字面量進行特殊處理，把用這些欄位之一初始化的表示式轉換成一個匯出的變數，並用它替換該表示式。這個重寫表示式的過程，會消除它們受到的所有限制，因為編譯器並不需要知道該表示式的值，它只要能生成對該值的引用就行了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dn54lv55obipr2bwr6zanx61m\">你可以這樣寫：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass TypicalServer {\n\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: () =&gt; TypicalServer}]\n})\nexport class TypicalModule {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5sz4uv9eyalxrj9qd4cnufab2\">如果不重寫，這就是無效的，因為這裡不支援 Lambda 表示式，而且 <code>TypicalServer</code> 也沒有被匯出。為了支援這種寫法，編譯器自動把它重寫成了這樣：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass TypicalServer {\n\n}\n\nexport const θ0 = () =&gt; new TypicalServer();\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: θ0}]\n})\nexport class TypicalModule {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bcbx8kkzgetiwka0zqsa2lhou\">這就讓編譯器能在工廠中生成一個對 <code>θ0</code> 的引用，而不用知道 <code>θ0</code> 中包含的值到底是什麼。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7i6v5c3mlwht17l2y7f7jgatn\">編譯器會在生成 <code>.js</code> 檔案期間進行這種重寫。它不會重寫 <code>.d.ts</code> 檔案，所以 TypeScript 也不會把這個變數當做一項匯出，因此也就不會汙染 ES 模組中匯出的 API。</p>\n<p><a id=\"binding-expression-validation\"></a></p>\n<h2 id=\"phase-3-template-type-checking\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"421aw65g3h43m9n601iadlihr\">階段 3：樣板型別檢查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-3-template-type-checking\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66ae80nv8g6m98lqpdovxk283\">Angular 編譯器最有用的功能之一就是能夠對樣板中的表示式進行型別檢查，在由於出錯而導致執行時崩潰之前就捕獲任何錯誤。在樣板型別檢查階段，Angular 樣板編譯器會使用 TypeScript 編譯器來驗證樣板中的繫結表示式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ethdnbxoho7w4x8vex75k9n8v\">透過在該專案的 TypeScript 設定檔案中的 <code>\"angularCompilerOptions\"</code> 中新增編譯器選項 <code>\"fullTemplateTypeCheck\"</code>，可以顯式啟用本階段（見<a href=\"guide/angular-compiler-options\">Angular 編譯器選項</a>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ecodry9om0ny7r8oyefq19ipz\">當樣板繫結表示式中檢測到型別錯誤時，進行樣板驗證時就會生成錯誤。這和 TypeScript 編譯器在處理 <code>.ts</code> 檔案中的程式碼時報告錯誤很相似。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xntrej05bqyh32ejze8h2o6r\">比如，考慮下列元件：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '{{person.addresss.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"116qjq5dp583r9ocwz73n1wtm\">這會生成如下錯誤：</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nmy.component.ts.MyComponent.html(1,1): : Property 'addresss' does not exist on type 'Person'. Did you mean 'address'?\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a1h627rdv1b4qte3vycusuo5q\">錯誤訊息中彙報的檔案名 <code>my.component.ts.MyComponent.html</code> 是一個由樣板編譯器生成出的合成檔案，用於儲存 <code>MyComponent</code> 類別的樣板內容。編譯器永遠不會把這個檔案寫入磁碟。這個例子中，這裡的行號和列號都是相對於 <code>MyComponent</code> 的 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 註解中的樣板字串的。如果元件使用 <code>templateUrl</code> 來代替 <code>template</code>，這些錯誤就會在 <code>templateUrl</code> 引用的 HTML 檔案中彙報，而不是這個合成檔案中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ahop50gfkylhwgxyq3054ns2x\">錯誤的位置是從包含出錯的內嵌表示式的那個文字節點開始的。如果錯誤是一個屬性繫結，比如 <code>[value]=\"person.address.street\"</code>，錯誤的位置就是那個包含錯誤的屬性的位置。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"adbsjx9at7gcd2xlc8wirq5cd\">驗證使用 TypeScript 型別檢查器和提供給 TypeScript 編譯器的選項來控制型別驗證的詳細程度。比如，如果指定了 <code>strictTypeChecks</code>，則會報告</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nmy.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2mh1xueei491gxm5xyz98xb7v\">錯誤以及上述錯誤訊息。</p>\n<h3 id=\"type-narrowing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"62jrtenq1nrag23qeufytd223\">型別窄化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#type-narrowing\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ev8i5xk7ay73nq430j9zcu0ah\">在 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 指令中使用的表示式用來在 Angular 樣板編譯器中窄化聯合型別，就像 TypeScript 中的 <code>if</code> 表示式一樣。比如，要在上述樣板中消除 <code>Object is possibly 'undefined'</code> 錯誤，可以把它改成只在 <code>person</code> 的值初始化過的時候才生成這個內嵌。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '<span *ngif=\"person\"> {{person.address.street}} </span>'\n})\nclass MyComponent {\n  person?: Person;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"doefyifrmnmpxdgmrjuouycvs\">使用 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 能讓 TypeScript 編譯器推斷出這個繫結表示式中使用的 <code>person</code> 永遠不會是 <code>undefined</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1kb9ozy2kf8iymukqccgjg8w0\">關於輸入型別窄化的更多訊息，參閱<a href=\"guide/structural-directives#directive-type-checks\">為自定義指令強化樣板型別檢查</a>。</p>\n<h3 id=\"non-null-type-assertion-operator\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aeavaaxa4o1gdak39uwwggmvg\">非空型別斷言運算子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#non-null-type-assertion-operator\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6a9ipen47cvtbo80bhrs1sjds\">使用 <a href=\"guide/template-expression-operators#non-null-assertion-operator\">非空型別斷言運算子</a>可以在不方便使用 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 當元件中的某些約束可以確保這個繫結表示式在求值時永遠不會為空時，防止出現 <code>Object is possibly 'undefined'</code> 錯誤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6v1fs74g3wfz5nofl79joywtj\">在下面的例子中，<code>person</code> 和 <code>address</code> 屬性總是一起出現的，如果 <code>person</code> 非空，則 <code>address</code> 也一定非空。沒有一種簡便的寫法可以向 TypeScript 和樣板編譯器描述這種約束。但是這個例子中使用 <code>address!.street</code> 避免了報錯。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&lt;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"&gt; {{person.name}} lives on {{address!.street}} &lt;/span&gt;'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"hs41q49v5supuw793fc5ptdg\">應該保守點使用非空斷言運算子，因為將來對元件的重構可能會破壞這個約束。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ncjfshe6y2zo2n85s1f8nve8\">這個例子中，更建議在 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 中包含對 <code>address</code> 的檢查，程式碼如下：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&lt;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person &amp;&amp; address\"&gt; {{person.name}} lives on {{address.street}} &lt;/span&gt;'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/upgrade\n - api/upgrade/UpgradeAdapter\n - api/upgrade/UpgradeAdapterRef\n - guide/angular-compiler-options\n - guide/aot-metadata-errors\n - guide/architecture-next-steps\n - guide/creating-libraries\n - guide/deployment\n - guide/deprecations\n - guide/file-structure\n - guide/npm-packages\n - guide/template-expression-operators\n - guide/upgrade\n - guide/upgrade-performance\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/common/NgIf\n - api/core#decorators\n - api/core/Component\n - api/core/InjectionToken\n - api/core/Input\n - api/core/NgModule\n - api/router/RouterModule\n - cli\n - cli/build\n - cli/serve\n - guide/angular-compiler-options\n - guide/aot-compiler#ahead-of-time-aot-compilation\n - guide/aot-compiler#choosing-a-compiler\n - guide/aot-compiler#code-folding\n - guide/aot-compiler#compilation-phases\n - guide/aot-compiler#configuring-aot-compilation\n - guide/aot-compiler#expression-syntax\n - guide/aot-compiler#expression-syntax-limitations\n - guide/aot-compiler#foldable-syntax\n - guide/aot-compiler#functions-and-static-method-calls\n - guide/aot-compiler#how-aot-works\n - guide/aot-compiler#metadata-restrictions\n - guide/aot-compiler#metadata-rewriting\n - guide/aot-compiler#no-arrow-functions\n - guide/aot-compiler#non-null-type-assertion-operator\n - guide/aot-compiler#phase-1-code-analysis\n - guide/aot-compiler#phase-2-code-generation\n - guide/aot-compiler#phase-3-template-type-checking\n - guide/aot-compiler#public-or-protected-symbols\n - guide/aot-compiler#supported-classes-and-functions\n - guide/aot-compiler#supported-functions\n - guide/aot-compiler#type-narrowing\n - guide/aot-metadata-errors\n - guide/build\n - guide/glossary#aot\n - guide/ngmodules\n - guide/structural-directives#directive-type-checks\n - guide/template-expression-operators#non-null-assertion-operator\n - guide/typescript-configuration\n - https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n - https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/function\n - https://en.wikipedia.org/wiki/Abstract*syntax*tree\n - https://en.wikipedia.org/wiki/Abstract_syntax_tree\n - https://github.com/angular/angular/blob/main/packages/compiler-cli/src/metadata/schema.ts\n - https://github.com/angular/angular/blob/main/packages/router/src/router_module.ts#L139\n - https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f\n - https://www.youtube.com/watch?v=anphffaCZrQ\n-->"}