{"id":"guide/dependency-injection-providers","title":"配置依赖提供者","contents":"<div class=\"content\">\n  <h1 id=\"configuring-dependency-providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brqvn9jic743ozm0p4c2zldqg\">配置依赖提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#configuring-dependency-providers\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2n0jbovl9pcl8fuhokyopgh1y\">“创建与注入服务”这个主题介绍的是如何使用类作为依赖项。除了类之外，你还可以用其他值作为依赖项，例如 Boolean、字符串、日期和对象。Angular DI 提供了一些必要的 API 来让依赖的配置方式更加灵活，以便你可以把这些值在 DI 中可用。</p>\n<h2 id=\"specifying-a-provider-token\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4byb2yctdq0owdf2h89nohro1\">指定提供者令牌<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#specifying-a-provider-token\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f3u1p70olzxdi0fm4zzu3hvgr\">如果你用服务类作为提供者令牌，则其默认行为是注入器使用 <code>new</code> 运算符实例化该类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5lz9ldpaw83mdyov1uo7vk42m\">在下面这个例子中，<code>Logger</code> 类提供了 <code>Logger</code> 的实例。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\nproviders: [Logger],\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebsr2o6b6mj89bnll019dll5g\">但是，你可以将 DI 配置为使用不同的类或任何其他不同的值来与 <code>Logger</code> 类关联。因此，当注入 <code>Logger</code> 时，会改为使用这个新值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3ggof50eby6dk9i4gwrihvh7\">实际上，类提供者语法是一个简写表达式，可以扩展为由 <code><a href=\"api/core/Provider\" class=\"code-anchor\">Provider</a></code> 接口定义的提供者配置信息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"611mf0tbs1vkvlr4ihtl7oqca\">在这种情况下，Angular 将 <code>providers</code> 值展开为完整的提供者对象，如下所示：</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-3\">\n[{ provide: Logger, useClass: Logger }]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b7ge1xu391a92kwpy15ntg86l\">展开后的提供者配置是一个具有两个属性的对象字面量：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brtew7yykcvd2oty0xati7pgc\"><code>provide</code> 属性包含一个令牌，该令牌会作为定位依赖值和配置注入器时的键。</li>\n<li>The second property is a provider definition object, which tells the injector how to create the dependency value. The provider-definition key can be one of the following:\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"325dlpe4h4p8dtlo28vxfsfrs\">useClass - 此选项告诉 Angular DI 在注入依赖项时要实例化这里提供的类</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bs15mt90kp831vsobw2ni99se\">useExisting - 允许你为令牌起一个别名，并引用任意一个现有令牌。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a0ygfth8fo7vlqdy8scfmnd7k\">useFactory - 允许你定义一个用来构造依赖项的函数。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3gte22hhqh4f3ululgrvhenr0\">useValue - 提供了一个应该作为依赖项使用的静态值。</li>\n</ul>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e54u6uvt4gbzcb0dvx1xvhrc0\">下面的部分介绍如何使用这里所说的“提供者定义”键。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26ikqhyhviwplkvzjcsl9vg66\"><a id=\"token\"></a>\n<a id=\"injection-token\"></a></p>\n<h3 id=\"class-providers-useclass\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4m21pdw8oxjp6mnjfl2a1v52o\">类提供者：useClass<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#class-providers-useclass\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4wp6g1qghcacizwujixochu7h\"><code>useClass</code> 这个提供者键名能让你创建并返回指定类的新实例。你可以用这种类型的提供者来作为通用类或默认类的替代实现。例如，替代实现可以实现不同的策略、扩展默认类或模拟测试用例中真实类的行为。在以下示例中，当在组件或任何其他类中请求 <code>Logger</code> 依赖项时，将转而实例化 <code>BetterLogger</code> 类。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-4\">\n[{ provide: Logger, useClass: BetterLogger }]\n\n</code-example>\n<p><a id=\"class-provider-dependencies\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"284eu3j00xfrgucx0pak77hok\">如果替代类提供者有自己的依赖项，请在父模块或组件的 <code>providers</code> 元数据属性中指定这两个提供者。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-5\">\n[ UserService,\n  { provide: Logger, useClass: EvenBetterLogger }]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a2pg27d9ng1ago6uzhr4ip8gz\">在这个例子中，<code>EvenBetterLogger</code> 会在日志信息里显示用户名。这个 logger 要从注入的 <code>UserService</code> 实例中来获取该用户。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"EvenBetterLogger\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class EvenBetterLogger extends Logger {\n  constructor(private userService: UserService) { super(); }\n\n  override log(message: string) {\n    const name = this.userService.user.name;\n    super.log(`Message to ${name}: ${message}`);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66iwvg4zu5tuxl8v0m9p8prk6\">Angular DI 知道如何构建 <code>UserService</code> 依赖项，因为它已经在上面进行配置并且在注入器中可用。</p>\n<h3 id=\"alias-providers-useexisting\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eqgy2wslmhjn5x4gskowi1ph8\">别名提供者：useExisting<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#alias-providers-useexisting\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4mbj4al0zns2scwbm4w67a1xq\"><code>useExisting</code> 提供者键允许你将一个令牌映射到另一个。实际上，第一个令牌是与第二个令牌关联的服务的别名，创建了两种访问同一个服务对象的方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3tmj0mq84hlbwl90aisyllg9d\">在下面的例子中，当组件请求新的或旧的记录器时，注入器都会注入一个 <code>NewLogger</code> 的实例。通过这种方式，<code>OldLogger</code> 就成了 <code>NewLogger</code> 的别名。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6b\">\n[ NewLogger,\n  // Alias OldLogger w/ reference to NewLogger\n  { provide: OldLogger, useExisting: NewLogger}]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"arjqw5ny9ikwg0ebpcm3nzppn\">确保你没有使用 <code>OldLogger</code> 将 <code>NewLogger</code> 别名为 <code>useClass</code>，因为这会创建两个不同 <code>NewLogger</code> 实例。</p>\n<h3 id=\"factory-providers-usefactory\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dtvee05y9eicg556iou6cdt1u\">工厂提供者：useFactory<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#factory-providers-usefactory\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"as4hisfwlqw7txbxfpfy5fuo6\"><code>useFactory</code> 提供者键允许你通过调用工厂函数来创建依赖对象。使用这种方法，你可以根据 DI 和应用程序中其他地方的可用信息创建动态值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99n5f649ikgo695nypi006gis\">在下面的例子中，只有授权用户才能看到 <code>HeroService</code> 中的秘密英雄。授权可能在单个应用会话期间发生变化，比如改用其他用户登录。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7l8gnececk6q0u0n13yokkti9\">要想在 <code>UserService</code> 和 <code>HeroService</code> 中保存敏感信息，就要给 <code>HeroService</code> 的构造函数传一个逻辑标志来控制秘密英雄的显示。</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.ts\" region=\"internals\" header=\"src/app/heroes/hero.service.ts (excerpt)\">\nconstructor(\n  private logger: Logger,\n  private isAuthorized: boolean) { }\n\ngetHeroes() {\n  const auth = this.isAuthorized ? 'authorized ' : 'unauthorized';\n  this.logger.log(`Getting heroes for ${auth} user.`);\n  return HEROES.filter(hero =&gt; this.isAuthorized || !hero.isSecret);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9pbkexofqt14s5snvieeb9q5y\">要实现 <code>isAuthorized</code> 标志，可以用工厂提供者来为 <code>HeroService</code> 创建一个新的 logger 实例。</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"factory\" header=\"src/app/heroes/hero.service.provider.ts (excerpt)\">\nconst heroServiceFactory = (logger: Logger, userService: UserService) =&gt;\n  new HeroService(logger, userService.user.isAuthorized);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2kylw5z70ylw546br9c8jlhj3\">这个工厂函数可以访问 <code>UserService</code>。你可以同时把 <code>Logger</code> 和 <code>UserService</code> 注入到工厂提供者中，这样注入器就可以把它们传给工厂函数了。</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"provider\" header=\"src/app/heroes/hero.service.provider.ts (excerpt)\">\nexport const heroServiceProvider =\n  { provide: HeroService,\n    useFactory: heroServiceFactory,\n    deps: [Logger, UserService]\n  };\n\n</code-example>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7xo4a9mpcclmgz5nbg0xude37\"><code>useFactory</code> 字段指定该提供者是一个工厂函数，其实现代码是 <code>heroServiceFactory</code>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8uvdyjiw1n0tqvblkoqk0ncbw\"><code>deps</code> 属性是一个提供者令牌的数组。<code>Logger</code> 和 <code>UserService</code> 类作为它们自己的类提供者的令牌。注入器会解析这些令牌，并将相应的服务注入到匹配的 <code>heroServiceFactory</code> 工厂函数参数中。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"acgeqlllc11kckubtx783mioc\">通过把工厂提供者导出为变量 <code>heroServiceProvider</code>，就能让工厂提供者变得可复用。</p>\n<h3 id=\"value-providers-usevalue\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6u7t3lkiapd2gjvqule3zvs15\">值提供者：useValue<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#value-providers-usevalue\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"oprif6cn9wqsilyt52i8g2we\"><code>useValue</code> 键允许你将固定值与某个 DI 令牌相关联。可以用此技术提供运行时配置常量，例如网站基址和特性标志。你还可以在单元测试中使用值提供者来提供模拟数据以代替生产级数据服务。下一节提供有关 <code>useValue</code> 键的更多信息。</p>\n<h2 id=\"using-an-injectiontoken-object\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ajsb1nhcb8qd0c0qo23ir1ec\">使用 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#using-an-injectiontoken-object\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3qe0ee6i4g34mvjeoo8xa8by\">可以定义和使用一个 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 对象来为非类的依赖选择一个提供者令牌。下列例子定义了一个类型为 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 的 <code>APP_CONFIG</code>。</p>\n<code-example path=\"dependency-injection/src/app/injection.config.ts\" region=\"token\" header=\"src/app/app.config.ts\">\nimport { <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const APP_CONFIG = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&lt;AppConfig&gt;('app.config');\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cnzvtb7niy199nawjutbp6f5a\">可选的参数 <code>&lt;AppConfig&gt;</code> 和令牌描述 <code>app.config</code> 指明了此令牌的用途。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8hk0uchs7cig7lgdrclenkuq7\">接着，用 <code>APP_CONFIG</code> 这个 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 对象在组件中注册依赖提供者。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" header=\"src/app/providers.component.ts\" region=\"providers-9\">\nproviders: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvu3u4myos78jk6wadf0urhfs\">现在，借助参数装饰器 <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>()</code>，你可以把这个配置对象注入到构造函数中。</p>\n<code-example path=\"dependency-injection/src/app/app.component.2.ts\" region=\"ctor\" header=\"src/app/app.component.ts\">\nconstructor(@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(APP_CONFIG) config: AppConfig) {\n  this.title = config.title;\n}\n\n</code-example>\n<h3 id=\"interfaces-and-di\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aun1byrtfca0ptg7q0d3ad2s5\">接口和 DI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#interfaces-and-di\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"75hnexmtenkb0exhgdr73sfs0\">尽管 TypeScript 的 <code>AppConfig</code> 接口可以充当类的类型，但 <code>AppConfig</code> 接口在 DI 中无法使用。在 TypeScript 中，接口是设计时工件，它没有可供 DI 框架使用的运行时表示或令牌。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1gte29xc26cdjnwbdj528hy9\">当转译器把 TypeScript 转换成 JavaScript 时，接口就会消失，因为 JavaScript 没有接口。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xk2ijkt1cqr52yflr1dku1ko\">由于 Angular 在运行期没有接口，所以该接口不能作为令牌，也不能注入它。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9-interface\">\n// Can't use interface as provider token\n[{ provide: AppConfig, useValue: HERO_DI_CONFIG })]\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-9-ctor-interface\">\n// Can't inject using the interface as the parameter type\nconstructor(private config: AppConfig){ }\n\n</code-example>\n<h2 id=\"whats-next\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"407r2fj2mi5kvg7imj9zdcpe\">下一步呢？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#whats-next\"><i class=\"material-icons\">link</i></a></h2>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1gv65k67y6jmm88mzefenhg2y\"><a href=\"guide/dependency-injection-in-action\">依赖注入实战</a></li>\n</ul>\n\n  <div class=\"reviewed\">最后复查时间：Wed Sep 06 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core\n - api/core/Injector\n - api/core/StaticProvider\n - guide/creating-injectable-service\n - guide/dependency-injection\n - guide/dependency-injection-in-action\n - guide/dependency-injection-overview\n - guide/hierarchical-dependency-injection\n - guide/providers\n - guide/router\n-->\n<!-- links from this doc:\n - api/core/Inject\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/Provider\n - guide/dependency-injection-in-action\n - guide/dependency-injection-providers#alias-providers-useexisting\n - guide/dependency-injection-providers#class-providers-useclass\n - guide/dependency-injection-providers#configuring-dependency-providers\n - guide/dependency-injection-providers#factory-providers-usefactory\n - guide/dependency-injection-providers#interfaces-and-di\n - guide/dependency-injection-providers#specifying-a-provider-token\n - guide/dependency-injection-providers#using-an-injectiontoken-object\n - guide/dependency-injection-providers#value-providers-usevalue\n - guide/dependency-injection-providers#whats-next\n-->"}