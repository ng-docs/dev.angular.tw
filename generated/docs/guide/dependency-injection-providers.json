{"id":"guide/dependency-injection-providers","title":"設定依賴提供者","contents":"<div class=\"content\">\n  <h1 id=\"configuring-dependency-providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brqvn9jic743ozm0p4c2zldqg\">設定依賴提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#configuring-dependency-providers\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2n0jbovl9pcl8fuhokyopgh1y\">『建立與注入服務』這個主題介紹的是如何使用類作為依賴項。除了類之外，你還可以用其他值作為依賴項，例如 Boolean、字串、日期和物件。Angular DI 提供了一些必要的 API 來讓依賴的設定方式更加靈活，以便你可以把這些值在 DI 中可用。</p>\n<h2 id=\"specifying-a-provider-token\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4byb2yctdq0owdf2h89nohro1\">指定提供者令牌<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#specifying-a-provider-token\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f3u1p70olzxdi0fm4zzu3hvgr\">如果你用服務類別作為提供者令牌，則其預設行為是注入器使用 <code>new</code> 運算符實例化該類別。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5lz9ldpaw83mdyov1uo7vk42m\">在下面這個例子中，<code>Logger</code> 類提供了 <code>Logger</code> 的實例。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\nproviders: [Logger],\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebsr2o6b6mj89bnll019dll5g\">但是，你可以將 DI 設定為使用不同的類或任何其他不同的值來與 <code>Logger</code> 類關聯。因此，當注入 <code>Logger</code> 時，會改為使用這個新值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3ggof50eby6dk9i4gwrihvh7\">實際上，類提供者語法是一個簡寫表示式，可以擴充套件為由 <code><a href=\"api/core/Provider\" class=\"code-anchor\">Provider</a></code> 介面定義的提供者設定訊息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"611mf0tbs1vkvlr4ihtl7oqca\">在這種情況下，Angular 將 <code>providers</code> 值展開為完整的提供者物件，如下所示：</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-3\">\n[{ provide: Logger, useClass: Logger }]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b7ge1xu391a92kwpy15ntg86l\">展開後的提供者設定是一個具有兩個屬性的物件字面量：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brtew7yykcvd2oty0xati7pgc\"><code>provide</code> 屬性包含一個令牌，該令牌會作為定位依賴值和設定注入器時的鍵。</li>\n<li>The second property is a provider definition object, which tells the injector how to create the dependency value. The provider-definition key can be one of the following:\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"325dlpe4h4p8dtlo28vxfsfrs\">useClass - 此選項告訴 Angular DI 在注入依賴項時要實例化這裡提供的類</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bs15mt90kp831vsobw2ni99se\">useExisting - 允許你為令牌起一個別名，並引用任意一個現有令牌。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a0ygfth8fo7vlqdy8scfmnd7k\">useFactory - 允許你定義一個用來構造依賴項的函式。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3gte22hhqh4f3ululgrvhenr0\">useValue - 提供了一個應該作為依賴項使用的靜態值。</li>\n</ul>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e54u6uvt4gbzcb0dvx1xvhrc0\">下面的部分介紹如何使用這裡所說的『提供者定義』鍵。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26ikqhyhviwplkvzjcsl9vg66\"><a id=\"token\"></a>\n<a id=\"injection-token\"></a></p>\n<h3 id=\"class-providers-useclass\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4m21pdw8oxjp6mnjfl2a1v52o\">類提供者：useClass<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#class-providers-useclass\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4wp6g1qghcacizwujixochu7h\"><code>useClass</code> 這個提供者鍵名能讓你建立並回傳指定類別的新實例。你可以用這種型別的提供者來作為通用類或預設類的替代實現。例如，替代實現可以實現不同的策略、擴充套件預設類或模擬測試用例中真實類的行為。在以下範例中，當在元件或任何其他類別中請求 <code>Logger</code> 依賴項時，將轉而實例化 <code>BetterLogger</code> 類。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-4\">\n[{ provide: Logger, useClass: BetterLogger }]\n\n</code-example>\n<p><a id=\"class-provider-dependencies\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"284eu3j00xfrgucx0pak77hok\">如果替代類提供者有自己的依賴項，請在父模組或元件的 <code>providers</code> 元資料屬性中指定這兩個提供者。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-5\">\n[ UserService,\n  { provide: Logger, useClass: EvenBetterLogger }]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a2pg27d9ng1ago6uzhr4ip8gz\">在這個例子中，<code>EvenBetterLogger</code> 會在日誌訊息裡顯示使用者名。這個 logger 要從注入的 <code>UserService</code> 實例中來獲取該使用者。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"EvenBetterLogger\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class EvenBetterLogger extends Logger {\n  constructor(private userService: UserService) { super(); }\n\n  override log(message: string) {\n    const name = this.userService.user.name;\n    super.log(`Message to ${name}: ${message}`);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66iwvg4zu5tuxl8v0m9p8prk6\">Angular DI 知道如何建立 <code>UserService</code> 依賴項，因為它已經在上面進行設定並且在注入器中可用。</p>\n<h3 id=\"alias-providers-useexisting\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eqgy2wslmhjn5x4gskowi1ph8\">別名提供者：useExisting<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#alias-providers-useexisting\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4mbj4al0zns2scwbm4w67a1xq\"><code>useExisting</code> 提供者鍵允許你將一個令牌對映到另一個。實際上，第一個令牌是與第二個令牌關聯的服務的別名，建立了兩種訪問同一個服務物件的方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3tmj0mq84hlbwl90aisyllg9d\">在下面的例子中，當元件請求新的或舊的記錄器時，注入器都會注入一個 <code>NewLogger</code> 的實例。透過這種方式，<code>OldLogger</code> 就成了 <code>NewLogger</code> 的別名。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6b\">\n[ NewLogger,\n  // Alias OldLogger w/ reference to NewLogger\n  { provide: OldLogger, useExisting: NewLogger}]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"arjqw5ny9ikwg0ebpcm3nzppn\">確保你沒有使用 <code>OldLogger</code> 將 <code>NewLogger</code> 別名為 <code>useClass</code>，因為這會建立兩個不同 <code>NewLogger</code> 實例。</p>\n<h3 id=\"factory-providers-usefactory\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dtvee05y9eicg556iou6cdt1u\">工廠提供者：useFactory<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#factory-providers-usefactory\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"as4hisfwlqw7txbxfpfy5fuo6\"><code>useFactory</code> 提供者鍵允許你透過呼叫工廠函式來建立依賴物件。使用這種方法，你可以根據 DI 和應用程式中其他地方的可用訊息建立動態值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99n5f649ikgo695nypi006gis\">在下面的例子中，只有授權使用者才能看到 <code>HeroService</code> 中的秘密英雄。授權可能在單個應用會話期間發生變化，比如改用其他使用者登入。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7l8gnececk6q0u0n13yokkti9\">要想在 <code>UserService</code> 和 <code>HeroService</code> 中保存敏感訊息，就要給 <code>HeroService</code> 的建構式函式傳一個邏輯標誌來控制秘密英雄的顯示。</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.ts\" region=\"internals\" header=\"src/app/heroes/hero.service.ts (excerpt)\">\nconstructor(\n  private logger: Logger,\n  private isAuthorized: boolean) { }\n\ngetHeroes() {\n  const auth = this.isAuthorized ? 'authorized ' : 'unauthorized';\n  this.logger.log(`Getting heroes for ${auth} user.`);\n  return HEROES.filter(hero =&gt; this.isAuthorized || !hero.isSecret);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9pbkexofqt14s5snvieeb9q5y\">要實現 <code>isAuthorized</code> 標誌，可以用工廠提供者來為 <code>HeroService</code> 建立一個新的 logger 實例。</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"factory\" header=\"src/app/heroes/hero.service.provider.ts (excerpt)\">\nconst heroServiceFactory = (logger: Logger, userService: UserService) =&gt;\n  new HeroService(logger, userService.user.isAuthorized);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2kylw5z70ylw546br9c8jlhj3\">這個工廠函式可以訪問 <code>UserService</code>。你可以同時把 <code>Logger</code> 和 <code>UserService</code> 注入到工廠提供者中，這樣注入器就可以把它們傳給工廠函式了。</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"provider\" header=\"src/app/heroes/hero.service.provider.ts (excerpt)\">\nexport const heroServiceProvider =\n  { provide: HeroService,\n    useFactory: heroServiceFactory,\n    deps: [Logger, UserService]\n  };\n\n</code-example>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7xo4a9mpcclmgz5nbg0xude37\"><code>useFactory</code> 欄位指定該提供者是一個工廠函式，其實現代碼是 <code>heroServiceFactory</code>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8uvdyjiw1n0tqvblkoqk0ncbw\"><code>deps</code> 屬性是一個提供者令牌的陣列。<code>Logger</code> 和 <code>UserService</code> 類作為它們自己的類提供者的令牌。注入器會解析這些令牌，並將相應的服務注入到對應的 <code>heroServiceFactory</code> 工廠函式引數中。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"acgeqlllc11kckubtx783mioc\">透過把工廠提供者匯出為變數 <code>heroServiceProvider</code>，就能讓工廠提供者變得可複用。</p>\n<h3 id=\"value-providers-usevalue\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6u7t3lkiapd2gjvqule3zvs15\">值提供者：useValue<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#value-providers-usevalue\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"oprif6cn9wqsilyt52i8g2we\"><code>useValue</code> 鍵允許你將固定值與某個 DI 令牌相關聯。可以用此技術提供執行時設定常數，例如網站基址和屬性標誌。你還可以在單元測試中使用值提供者來提供模擬資料以代替生產級數據服務。下一節提供有關 <code>useValue</code> 鍵的更多訊息。</p>\n<h2 id=\"using-an-injectiontoken-object\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ajsb1nhcb8qd0c0qo23ir1ec\">使用 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#using-an-injectiontoken-object\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3qe0ee6i4g34mvjeoo8xa8by\">可以定義和使用一個 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 物件來為非類的依賴選擇一個提供者令牌。下列例子定義了一個型別為 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 的 <code>APP_CONFIG</code>。</p>\n<code-example path=\"dependency-injection/src/app/injection.config.ts\" region=\"token\" header=\"src/app/app.config.ts\">\nimport { <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const APP_CONFIG = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&lt;AppConfig&gt;('app.config');\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cnzvtb7niy199nawjutbp6f5a\">可選的引數 <code>&lt;AppConfig&gt;</code> 和令牌描述 <code>app.config</code> 指明了此令牌的用途。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8hk0uchs7cig7lgdrclenkuq7\">接著，用 <code>APP_CONFIG</code> 這個 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 物件在元件中註冊依賴提供者。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" header=\"src/app/providers.component.ts\" region=\"providers-9\">\nproviders: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvu3u4myos78jk6wadf0urhfs\">現在，藉助引數裝飾器 <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>()</code>，你可以把這個設定物件注入到建構式函式中。</p>\n<code-example path=\"dependency-injection/src/app/app.component.2.ts\" region=\"ctor\" header=\"src/app/app.component.ts\">\nconstructor(@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(APP_CONFIG) config: AppConfig) {\n  this.title = config.title;\n}\n\n</code-example>\n<h3 id=\"interfaces-and-di\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aun1byrtfca0ptg7q0d3ad2s5\">介面和 DI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#interfaces-and-di\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"75hnexmtenkb0exhgdr73sfs0\">儘管 TypeScript 的 <code>AppConfig</code> 介面可以充當類別的型別，但 <code>AppConfig</code> 介面在 DI 中無法使用。在 TypeScript 中，介面是設計時工件，它沒有可供 DI 框架使用的執行時表示或令牌。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1gte29xc26cdjnwbdj528hy9\">當轉譯器把 TypeScript 轉換成 JavaScript 時，介面就會消失，因為 JavaScript 沒有介面。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xk2ijkt1cqr52yflr1dku1ko\">由於 Angular 在執行期沒有介面，所以該介面不能作為令牌，也不能注入它。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9-interface\">\n// Can't use interface as provider token\n[{ provide: AppConfig, useValue: HERO_DI_CONFIG })]\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-9-ctor-interface\">\n// Can't inject using the interface as the parameter type\nconstructor(private config: AppConfig){ }\n\n</code-example>\n<h2 id=\"whats-next\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"407r2fj2mi5kvg7imj9zdcpe\">下一步呢？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#whats-next\"><i class=\"material-icons\">link</i></a></h2>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1gv65k67y6jmm88mzefenhg2y\"><a href=\"guide/dependency-injection-in-action\">依賴注入實戰</a></li>\n</ul>\n\n  <div class=\"reviewed\">最後複查時間：Wed Sep 06 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core\n - api/core/Injector\n - api/core/StaticProvider\n - guide/creating-injectable-service\n - guide/dependency-injection\n - guide/dependency-injection-in-action\n - guide/dependency-injection-overview\n - guide/hierarchical-dependency-injection\n - guide/providers\n - guide/router\n-->\n<!-- links from this doc:\n - api/core/Inject\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/Provider\n - guide/dependency-injection-in-action\n - guide/dependency-injection-providers#alias-providers-useexisting\n - guide/dependency-injection-providers#class-providers-useclass\n - guide/dependency-injection-providers#configuring-dependency-providers\n - guide/dependency-injection-providers#factory-providers-usefactory\n - guide/dependency-injection-providers#interfaces-and-di\n - guide/dependency-injection-providers#specifying-a-provider-token\n - guide/dependency-injection-providers#using-an-injectiontoken-object\n - guide/dependency-injection-providers#value-providers-usevalue\n - guide/dependency-injection-providers#whats-next\n-->"}