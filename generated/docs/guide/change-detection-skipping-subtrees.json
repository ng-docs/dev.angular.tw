{"id":"guide/change-detection-skipping-subtrees","title":"跳过组件子树","contents":"<div class=\"content\">\n  <h1 id=\"skipping-component-subtrees\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3uq0yztu63f0ohd2ohrtt0ww5\">跳过组件子树<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#skipping-component-subtrees\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ywjb2jn13s2ec0iq4ujpyzq6\">默认情况下，JavaScript 会使用你可以从多个不同组件引用的可变数据结构。Angular 会在你的整个组件树上运行变更检测，以确保数据结构的最新状态反映在 DOM 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3nax4imr6f1zqgqdlcz6p19ub\">对于大多数应用程序，变更检测都足够快。但是，当应用程序有特别大的组件树时，在整个应用程序中运行变更检测可能会导致性能问题。你可以通过将变更检测配置为仅在组件树的子集上运行来解决这个问题。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7r384y64hmhvc84v96htksh0y\">如果你确信应用程序的一部分不受状态更改的影响，可以用 <a href=\"/api/core/ChangeDetectionStrategy\">OnPush</a> 跳过整个组件子树中的变更检测。</p>\n<h2 id=\"using-onpush\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6nr1bi2gmyg9zbhiw81qed56p\">使用 <code>OnPush</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#using-onpush\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"akjoaw6v5osmcxkt8fk68pxrt\">OnPush 变更检测会指示 Angular 仅在以下情况下为组件子树运行变更检测：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44syhwo6vohftjkzvy9grswb3\">子树的根组件接收到作为模板绑定的结果的新输入。Angular 将输入的当前值和过去值使用 <code>==</code> 进行比较</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aui114yj0nvvsgy7ic137s55u\">Angular 在本子树的根组件或它的任何子组件（而不管其是否使用 OnPush 变更检测方式）中处理使用 OnPush 变更检测策略的组件中的事件（比如事件绑定、输出绑定或 <code>@<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a></code>）时</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ex4e06dgtk8zkhu8h753hwku\">你可以在 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 装饰器中将组件的变更检测策略设置为 <code>OnPush</code>：</p>\n<code-example language=\"ts\">\nimport { <a href=\"api/core/ChangeDetectionStrategy\" class=\"code-anchor\">ChangeDetectionStrategy</a>, <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  changeDetection: <a href=\"api/core/ChangeDetectionStrategy#OnPush\" class=\"code-anchor\">ChangeDetectionStrategy.OnPush</a>,\n})\nexport class MyComponent {}\n</code-example>\n<h2 id=\"common-change-detection-scenarios\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4oe782s6ivueauikxxx9sbnxy\">常见的变更检测场景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#common-change-detection-scenarios\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6r9j0yakde4pf08qv7wunhow5\">本节展示了几种常见的变更检测场景，以说明 Angular 的行为。</p>\n<h2 id=\"an-event-is-handled-by-a-component-with-default-change-detection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ghj93tk8uxkwppcisana9582\">事件由具有默认变更检测的组件处理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-component-with-default-change-detection\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1w89ycdmcc1n5gq2onwgp8g84\">如果 Angular 在没有 <code>OnPush</code> 策略的情况下处理组件中的事件，则框架会在整个组件树上执行变更检测。Angular 将跳过具有 <code>OnPush</code> 策略的组件的后代组件子树，如果该组件没有收到新输入的话。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehfar5vvuhbu4m1s9sp1ktvk5\">比如，如果我们将 <code>MainComponent</code> 的变更检测策略设置为 <code>OnPush</code>，并且用户与具有根 <code>MainComponent</code> 的子树外的组件交互，Angular 将检查下图中的所有绿色组件（<code>AppComponent</code> 、 <code>HeaderComponent</code> 、 <code>SearchComponent</code> 、 <code>ButtonComponent</code>），除非 <code>MainComponent</code> 接收到了新的输入：</p>\n<div class=\"lightbox\">\n  <img alt=\"Change detection propagation from non-OnPush component\" src=\"generated/images/guide/change-detection/event-trigger.svg\" width=\"741\" height=\"261\">\n</div>\n<h2 id=\"an-event-is-handled-by-a-component-with-onpush\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6003qxxe228h20zsj5zok4vjw\">事件由具有 OnPush 的组件处理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-component-with-onpush\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6kocvioffk71828yw4wpf1r0a\">如果 Angular 使用 OnPush 策略处理组件中的事件，则框架将在整个组件树中执行变更检测。Angular 将忽略以具有 OnPush 策略的组件为根的组件子树（如果这个根组件尚未接收到新输入并且在处理此事件的组件外部）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5dgooqihtlci19mniyk0lhzbl\">比如，如果 Angular 处理 <code>MainComponent</code> 中的事件，则框架将在整个组件树中运行变更检测。Angular 将忽略具有根 <code>LoginComponent</code> 的子树，因为该组件具有 <code>OnPush</code> 策略并且此事件发生在其范围之外。</p>\n<div class=\"lightbox\">\n  <img alt=\"Change detection propagation from OnPush component\" src=\"generated/images/guide/change-detection/on-push-trigger.svg\" width=\"611\" height=\"261\">\n</div>\n<h2 id=\"an-event-is-handled-by-a-descendant-of-a-component-with-onpush\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aisrvla4ceznfjxci61n0l4s0\">事件由具有 OnPush 的组件的后代处理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-descendant-of-a-component-with-onpush\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cl2cw4uyxhyzq056hmd5ixpbg\">如果 Angular 使用 OnPush 处理组件中的事件，则框架将在整个组件树中执行变更检测，包括组件的祖先。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ak65zdrvldbvw4vdcvtuhfa8u\">比如，在下图中，Angular 会处理使用 OnPush 的 <code>LoginComponent</code> 中的事件。Angular 将在整个组件子树中调用变更检测，包括 <code>MainComponent</code>（<code>LoginComponent</code> 的父级），尽管 <code>MainComponent</code> 也有 <code>OnPush</code>。Angular 也会检查 <code>MainComponent</code>，因为 <code>LoginComponent</code> 是其视图的一部分。</p>\n<div class=\"lightbox\">\n  <img alt=\"Change detection propagation from nested OnPush component\" src=\"generated/images/guide/change-detection/leaf-trigger.svg\" width=\"611\" height=\"381\">\n</div>\n<h2 id=\"new-inputs-to-component-with-onpush\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7lz89el7rs7bc2a2i9n41v2a2\">具有 OnPush 策略的组件的新输入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#new-inputs-to-component-with-onpush\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wq3yleghirbbok7e3g3bov81\">Angular 将在具有 <code>OnPush</code> 策略的子组件中运行变更检测，将 input 属性设置为模板绑定的结果。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5mf5rf0y5d4any1ctonsud74q\">比如，在下图中，<code>AppComponent</code> 会将新输入传递给 <code>MainComponent</code>，它具有 <code>OnPush</code> 策略。Angular 将在 <code>MainComponent</code> 中运行变更检测，但不会在同样具有 <code>OnPush</code> 策略的 <code>LoginComponent</code> 中运行变更检测，除非它也接收到新的输入。</p>\n<div class=\"lightbox\">\n  <img alt=\"Change detection propagation with OnPush component that receives new inputs\" src=\"generated/images/guide/change-detection/on-push-input.svg\" width=\"611\" height=\"261\">\n</div>\n<h2 id=\"edge-cases\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4zhtix64sq35rjzufnhxdxybp\">边缘情况<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#edge-cases\"><i class=\"material-icons\">link</i></a></h2>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"79ehbnu8f0vl6d8py09ztntf4\"><strong>修改 TypeScript 代码中的输入属性</strong>。当你使用 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 或 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 等 API 来获取对 TypeScript 中组件的引用并手动修改 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 属性时，Angular 将不会自动为 OnPush 组件运行变更检测。如果你需要 Angular 运行变更检测，你可以在你的组件中注入 <code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code> 并调用 <code>changeDetectorRef.markForCheck()</code> 来告诉 Angular 为其安排一次变更检测。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dc0n2jzldulbqi3e40yjevd1x\"><strong>修改对象引用</strong>。如果输入接收到可变对象作为值，并且你修改了对象内容但引用没变，则 Angular 将不会调用变更检测。这是预期的行为，因为输入的前一个值和当前值都指向了同一个引用。</li>\n</ul>\n\n  <div class=\"reviewed\">最后复查时间：Wed May 04 2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/core/ChangeDetectionStrategy\n - api/core/ChangeDetectionStrategy\n - api/core/ChangeDetectionStrategy#OnPush\n - api/core/ChangeDetectorRef\n - api/core/Component\n - api/core/ContentChild\n - api/core/HostListener\n - api/core/Input\n - api/core/ViewChild\n - guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-component-with-default-change-detection\n - guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-component-with-onpush\n - guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-descendant-of-a-component-with-onpush\n - guide/change-detection-skipping-subtrees#common-change-detection-scenarios\n - guide/change-detection-skipping-subtrees#edge-cases\n - guide/change-detection-skipping-subtrees#new-inputs-to-component-with-onpush\n - guide/change-detection-skipping-subtrees#skipping-component-subtrees\n - guide/change-detection-skipping-subtrees#using-onpush\n-->"}