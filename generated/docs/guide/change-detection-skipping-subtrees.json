{"id":"guide/change-detection-skipping-subtrees","title":"跳過元件子樹","contents":"<div class=\"content\">\n  <h1 id=\"skipping-component-subtrees\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3uq0yztu63f0ohd2ohrtt0ww5\">跳過元件子樹<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#skipping-component-subtrees\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ywjb2jn13s2ec0iq4ujpyzq6\">預設情況下，JavaScript 會使用你可以從多個不同元件引用的可變資料結構。Angular 會在你的整個元件樹上執行變更檢測，以確保資料結構的最新狀態反映在 DOM 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3nax4imr6f1zqgqdlcz6p19ub\">對於大多數應用程式，變更檢測都足夠快。但是，當應用程式有特別大的元件樹時，在整個應用程式中執行變更檢測可能會導致效能問題。你可以透過將變更檢測設定為僅在元件樹的子集上執行來解決這個問題。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7r384y64hmhvc84v96htksh0y\">如果你確信應用程式的一部分不受狀態更改的影響，可以用 <a href=\"/api/core/ChangeDetectionStrategy\">OnPush</a> 跳過整個元件子樹中的變更檢測。</p>\n<h2 id=\"using-onpush\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6nr1bi2gmyg9zbhiw81qed56p\">使用 <code>OnPush</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#using-onpush\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"akjoaw6v5osmcxkt8fk68pxrt\">OnPush 變更檢測會指示 Angular 僅在以下情況下為元件子樹執行變更檢測：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44syhwo6vohftjkzvy9grswb3\">子樹的根元件接收到作為樣板繫結的結果的新輸入。Angular 將輸入的當前值和過去值使用 <code>==</code> 進行比較</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aui114yj0nvvsgy7ic137s55u\">Angular 在本子樹的根元件或它的任何子元件（而不管其是否使用 OnPush 變更檢測方式）中處理使用 OnPush 變更檢測策略的元件中的事件（比如事件繫結、輸出繫結或 <code>@<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a></code>）時</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ex4e06dgtk8zkhu8h753hwku\">你可以在 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 裝飾器中將元件的變更檢測策略設定為 <code>OnPush</code>：</p>\n<code-example language=\"ts\">\nimport { <a href=\"api/core/ChangeDetectionStrategy\" class=\"code-anchor\">ChangeDetectionStrategy</a>, <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  changeDetection: <a href=\"api/core/ChangeDetectionStrategy#OnPush\" class=\"code-anchor\">ChangeDetectionStrategy.OnPush</a>,\n})\nexport class MyComponent {}\n</code-example>\n<h2 id=\"common-change-detection-scenarios\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4oe782s6ivueauikxxx9sbnxy\">常見的變更檢測場景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#common-change-detection-scenarios\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6r9j0yakde4pf08qv7wunhow5\">本節展示了幾種常見的變更檢測場景，以說明 Angular 的行為。</p>\n<h2 id=\"an-event-is-handled-by-a-component-with-default-change-detection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ghj93tk8uxkwppcisana9582\">事件由具有預設變更檢測的元件處理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-component-with-default-change-detection\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1w89ycdmcc1n5gq2onwgp8g84\">如果 Angular 在沒有 <code>OnPush</code> 策略的情況下處理元件中的事件，則框架會在整個元件樹上執行變更檢測。Angular 將跳過具有 <code>OnPush</code> 策略的元件的後代元件子樹，如果該組件沒有收到新輸入的話。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehfar5vvuhbu4m1s9sp1ktvk5\">比如，如果我們將 <code>MainComponent</code> 的變更檢測策略設定為 <code>OnPush</code>，並且使用者與具有根 <code>MainComponent</code> 的子樹外的元件互動，Angular 將檢查下圖中的所有綠色元件（<code>AppComponent</code> 、 <code>HeaderComponent</code> 、 <code>SearchComponent</code> 、 <code>ButtonComponent</code>），除非 <code>MainComponent</code> 接收到了新的輸入：</p>\n<div class=\"lightbox\">\n  <img alt=\"Change detection propagation from non-OnPush component\" src=\"generated/images/guide/change-detection/event-trigger.svg\" width=\"741\" height=\"261\">\n</div>\n<h2 id=\"an-event-is-handled-by-a-component-with-onpush\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6003qxxe228h20zsj5zok4vjw\">事件由具有 OnPush 的元件處理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-component-with-onpush\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6kocvioffk71828yw4wpf1r0a\">如果 Angular 使用 OnPush 策略處理元件中的事件，則框架將在整個元件樹中執行變更檢測。Angular 將忽略以具有 OnPush 策略的元件為根的元件子樹（如果這個根元件尚未接收到新輸入並且在處理此事件的元件外部）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5dgooqihtlci19mniyk0lhzbl\">比如，如果 Angular 處理 <code>MainComponent</code> 中的事件，則框架將在整個元件樹中執行變更檢測。Angular 將忽略具有根 <code>LoginComponent</code> 的子樹，因為該組件具有 <code>OnPush</code> 策略並且此事件發生在其範圍之外。</p>\n<div class=\"lightbox\">\n  <img alt=\"Change detection propagation from OnPush component\" src=\"generated/images/guide/change-detection/on-push-trigger.svg\" width=\"611\" height=\"261\">\n</div>\n<h2 id=\"an-event-is-handled-by-a-descendant-of-a-component-with-onpush\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aisrvla4ceznfjxci61n0l4s0\">事件由具有 OnPush 的元件的後代處理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-descendant-of-a-component-with-onpush\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cl2cw4uyxhyzq056hmd5ixpbg\">如果 Angular 使用 OnPush 處理元件中的事件，則框架將在整個元件樹中執行變更檢測，包括元件的祖先。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ak65zdrvldbvw4vdcvtuhfa8u\">比如，在下圖中，Angular 會處理使用 OnPush 的 <code>LoginComponent</code> 中的事件。Angular 將在整個元件子樹中呼叫變更檢測，包括 <code>MainComponent</code>（<code>LoginComponent</code> 的父級），儘管 <code>MainComponent</code> 也有 <code>OnPush</code>。Angular 也會檢查 <code>MainComponent</code>，因為 <code>LoginComponent</code> 是其檢視的一部分。</p>\n<div class=\"lightbox\">\n  <img alt=\"Change detection propagation from nested OnPush component\" src=\"generated/images/guide/change-detection/leaf-trigger.svg\" width=\"611\" height=\"381\">\n</div>\n<h2 id=\"new-inputs-to-component-with-onpush\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7lz89el7rs7bc2a2i9n41v2a2\">具有 OnPush 策略的元件的新輸入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#new-inputs-to-component-with-onpush\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wq3yleghirbbok7e3g3bov81\">Angular 將在具有 <code>OnPush</code> 策略的子元件中執行變更檢測，將 input 屬性設定為樣板繫結的結果。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5mf5rf0y5d4any1ctonsud74q\">比如，在下圖中，<code>AppComponent</code> 會將新輸入傳遞給 <code>MainComponent</code>，它具有 <code>OnPush</code> 策略。Angular 將在 <code>MainComponent</code> 中執行變更檢測，但不會在同樣具有 <code>OnPush</code> 策略的 <code>LoginComponent</code> 中執行變更檢測，除非它也接收到新的輸入。</p>\n<div class=\"lightbox\">\n  <img alt=\"Change detection propagation with OnPush component that receives new inputs\" src=\"generated/images/guide/change-detection/on-push-input.svg\" width=\"611\" height=\"261\">\n</div>\n<h2 id=\"edge-cases\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4zhtix64sq35rjzufnhxdxybp\">邊緣情況<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#edge-cases\"><i class=\"material-icons\">link</i></a></h2>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"79ehbnu8f0vl6d8py09ztntf4\"><strong>修改 TypeScript 程式碼中的輸入屬性</strong>。當你使用 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 或 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 等 API 來獲取對 TypeScript 中元件的引用並手動修改 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 屬性時，Angular 將不會自動為 OnPush 元件執行變更檢測。如果你需要 Angular 執行變更檢測，你可以在你的元件中注入 <code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code> 並呼叫 <code>changeDetectorRef.markForCheck()</code> 來告訴 Angular 為其安排一次變更檢測。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dc0n2jzldulbqi3e40yjevd1x\"><strong>修改物件引用</strong>。如果輸入接收到可變物件作為值，並且你修改了物件內容但引用沒變，則 Angular 將不會呼叫變更檢測。這是預期的行為，因為輸入的前一個值和當前值都指向了同一個引用。</li>\n</ul>\n\n  <div class=\"reviewed\">最後複查時間：Wed May 04 2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/core/ChangeDetectionStrategy\n - api/core/ChangeDetectionStrategy\n - api/core/ChangeDetectionStrategy#OnPush\n - api/core/ChangeDetectorRef\n - api/core/Component\n - api/core/ContentChild\n - api/core/HostListener\n - api/core/Input\n - api/core/ViewChild\n - guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-component-with-default-change-detection\n - guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-component-with-onpush\n - guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-descendant-of-a-component-with-onpush\n - guide/change-detection-skipping-subtrees#common-change-detection-scenarios\n - guide/change-detection-skipping-subtrees#edge-cases\n - guide/change-detection-skipping-subtrees#new-inputs-to-component-with-onpush\n - guide/change-detection-skipping-subtrees#skipping-component-subtrees\n - guide/change-detection-skipping-subtrees#using-onpush\n-->"}