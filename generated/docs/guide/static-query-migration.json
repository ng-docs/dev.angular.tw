{"id":"guide/static-query-migration","title":"静态查询（Static Query）迁移指南","contents":"<div class=\"content\">\n  <h1 id=\"static-query-migration-guide\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7gqx36os1u6pjxjpxg98haqlf\">静态查询（Static Query）迁移指南<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#static-query-migration-guide\"><i class=\"material-icons\">link</i></a></h1>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4j2eu2c1dbq7q0y15vcb8z4rx\"><strong>重要</strong>：<br>\n库的作者注意：\n这份迁移指南非常重要，可以方便他们的用户升级到（Angular 的）版本 9（大约在 2019 年 10 月发布）。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5opt5ckspqzd9opnkwq75qfie\">在版本 9 中，<code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 这两个查询的默认设置会改变，以修复查询中的 BUG 和意外行为（详情参阅<a href=\"guide/static-query-migration#what-does-this-flag-mean\">此处</a>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vkh75no8h44cg463hktzgljr\">为了应对这个变化，我们从版本 8 开始就要开始迁移所有应用和库，显式指定 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查询的解析策略。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bdkhngx1dq5sp5xiw24knhldt\">具体来说，这次迁移会添加一个显式的 “static” 标志，用来指出应该何时对该查询的结果进行赋值。等升级到版本 9 的时候，这个标志可以确保这些代码的工作方式都是一样的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"avbj53jo8a6qvi7ldp6ge3r5\">之前：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> results sometimes available in `ngOnInit`, sometimes in `ngAfterViewInit` (based on template)\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('foo') foo: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f0strjmc2u3ezgi4ylp84oekx\">之后：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> results available in ngOnInit\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('foo', {<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}) foo: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\nOR\n\n// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> results available in ngAfterViewInit\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('foo', {<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}) foo: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dmuw3aw9e74fipybmj7f0gjnm\">从版本 9 开始，<code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 标志将默认为 <code>false</code>。那时候，可以安全地删除所有 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code> 标志，而且我们还会提供一个能帮你更新代码的原理图（schematic）。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jlzgajnuznsed3rpbxhvdicm\"><strong>注意</strong>：<br>\n这个标志只适用于 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 这两个查询，这是因为 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查询都没有静态和动态的概念（它们总是“动态”解析）。</p>\n</div>\n<h2 id=\"faq\">FAQ<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#faq\"><i class=\"material-icons\">link</i></a></h2>\n<p><a id=\"what-to-do-with-todo\"></a></p>\n<h3 id=\"what-should-i-do-if-i-see-a--todo-add-static-flag--comment-printed-by-the-schematic\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4dsl1dfezg5y0mt4aauq2of16\">当看到由原理图添加的 <code>/* TODO: add <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> flag */</code> 注释时，我该怎么办？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#what-should-i-do-if-i-see-a--todo-add-static-flag--comment-printed-by-the-schematic\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cel3yn0rc4h929qe47t4pvddd\">如果你看到这个注释，就意味着原理图无法自己找到恰当的标志。在这种情况下，你必须根据应用的行为添加正确的标志。要了解如何进行选择，请参阅<a href=\"guide/static-query-migration#how-do-i-choose\">下一个问题</a>。</p>\n<p><a id=\"how-do-i-choose\"></a></p>\n<h3 id=\"how-do-i-choose-which-static-flag-value-to-use-true-or-false\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dmmnhtod1spa6jqmg5evrmlpi\">如何选择 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 标志：<code>true</code> 还是 <code>false</code>？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#how-do-i-choose-which-static-flag-value-to-use-true-or-false\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqdo9mjcqeunpxe8gm1i28bf0\">在官方 API 文档中，我们建议对于<a href=\"api/core/ViewChild#description\">视图查询</a> 总是在 <code>ngAfterViewInit</code> 中获取查询结果，对于<a href=\"api/core/ContentChild#description\">内容查询</a> 总是在 <code>ngAfterContentInit</code> 中获取查询结果。这是因为当这些生命周期钩子运行时，相关节点的变更检测已完成，我们可以确信收集到了所有可能的查询结果。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3a96jwz2e5yd9ee6l403f7dxr\">由于这个原因，大多数应用都应该使用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>。这个设置可以确保找出那些依赖于绑定解析的查询结果（比如 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 内的查询）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"268alg9wew37fko9z3lt18y7b\">在某些很少见的情况下，必须使用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code> 标志（参阅<a href=\"guide/static-query-migration#should-i-use-static-true\">这里的回答</a>）。</p>\n<p><a id=\"should-i-use-static-true\"></a></p>\n<h3 id=\"is-there-a-case-where-i-should-use-static-true\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aggkqn3c4j9z15z8u5ir2mza0\">什么情况下我应该用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code>？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#is-there-a-case-where-i-should-use-static-true\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"abo8hm58u411qapf2o73lpp5i\">这个选项的引入是为了支持动态创建嵌入式视图。如果你要查询一个 <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code> 以便动态创建一个视图，将无法在 <code>ngAfterViewInit</code> 中这样做。这是因为变量检测已在该视图上运行过，所以这时候使用该模板创建一个新视图就会抛出 <code>ExpressionHasChangedAfterChecked</code> 错误。在这种情况下，你要把 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 标志设置为 <code>true</code>，并在 <code>ngOnInit</code> 中创建你的视图。在其它大多数情况下，最好的做法是使用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cptu0qtr1psudt8g22orcvuje\">为了便于迁移到版本 8 中，如果你的组件代码期望这些查询的结果在 <code>ngAfterViewInit</code>（对于视图查询）或 <code>ngAfterContentInit</code>（对于内容查询）<strong>之前</strong>的某个时刻就已经可用，可能也要把 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 标志设置为 <code>true</code>。比如，如果你的组件期望在 <code>ngOnInit</code> 钩子或 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 的 setter 中这些查询结果已经就绪，就要把该标志设置为 <code>true</code> 或者改写你的组件以推迟它的执行时间。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"789rc672lft7ad9yg4b12ifvb\"><strong>注意</strong>：<br>\n把 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 设置为 <code>true</code> 意味着此查询将不会发现嵌在 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 中的查询结果。只有在运行过变更检测之后才能取得这些结果。</p>\n</div>\n<p><a id=\"what-does-this-flag-mean\"></a></p>\n<h3 id=\"what-does-this-flag-mean-and-why-is-it-necessary\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cox6q7iygigspcnfwk9qzxfuk\">这个标志是什么意思，它有什么必要？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#what-does-this-flag-mean-and-why-is-it-necessary\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ci96xo3ldqme6uvvw7co03fap\">以前，默认的查询行为一直没有文档记载，这会令人困惑，而且也常导致难以调试的问题。在版本 9 中，我们希望这种查询行为更加一致，也更容易理解。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d023u154htuhs4ydczbqg0n15\">为了解释其原由，首先要弄清楚到目前为止这些查询是如何工作的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rqtxjxqlk9u3iiwfgo8urwzr\">当没有 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 标志时，编译器会自行决定每个查询该如何解析。所有的 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> / <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查询在编译时都会被归类为两种方式之一：“static” 或 “dynamic”。当查询结果可供用户使用时，就会决定该使用何种方式。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c9qgdxgq2felc6594coxgnnzo\">查询</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9vq1u53wsficu2h7kl7gax3bc\">静态查询</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bbpmq262c9hzhy8qjk8jud86e\">由于结果不依赖于运行时值（如绑定），因此结果可以静态确定。在该视图的变更检测运行之前，静态查询的结果就可用（可在 \n<code>ngOnInit</code> 中访问）。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"87x0bkis85pp5wzk6q956plvf\">动态查询</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9lweyujr8mqg04ri0vyox2y2w\">由于结果依赖于运行时值（绑定），因此结果无法静态确定。动态查询的结果直到该视图的变更检测运行后才可用（在内容查询的 \n<code>ngAfterContentInit</code> 或视图查询的 \n<code>ngAfterViewInit</code> 中可访问）。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"db1ahr14w09s7lvjcuvmi3mep\">比如，假设我们有一个组件 <code>Comp</code>。在其中，我们有这样一个查询：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>(Foo) foo: Foo;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"erxdxrsyvmgellpa7p8j6x9jo\">和这样的模板：</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;div foo&gt;&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3slhd62updp5oyhkqij8k1l0h\">这个 <code>Foo</code> 查询会被归类为静态查询，这是因为在编译时，就已经知道 <code>&lt;div&gt;</code> 上的 <code>Foo</code> 实例是正确的查询结果了。由于查询结果并不依赖于运行时的值，所以在解析此查询之前，我们不必等待模板上的变更检测。因此，在 <code>ngOnInit</code> 中这些结果就已经可用了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6viy3j2ucu7lvh0tlf67h4rea\">假设查询不变，但组件模板改成了这样：</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;div foo *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"showing\"&gt;&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehsrunpx0wpe4p4vc2nu19m5a\">对于该模板，该查询将被归类为动态查询。我们需要知道 <code>showing</code> 在运行期间的值以确定该查询的正确结果应该是什么。因此，必须首先运行变更检测，其结果只能在 <code>ngAfterViewInit</code> 或该查询属性的 setter 中才能使用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"adsadx7m437ez9qyvi8dgq92u\">这种实现方式的效果是，在查询匹配的任何父级节点添加 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 会导致：当查询结果可用之后，其匹配结果也会发生变化。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crwwpauee5d7g5j9oeu3nvs8q\">请记住，这些类别只能用于 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 这两种查询。而 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查询都没有静态和动态的概念，它们总是“动态”解析。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2nxkug15r278q5vijsecoaqk1\">这种策略会根据查询所在的位置，在不同的时机进行解析，这引起了很大的困惑。即：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"anpcj288kinmmneho7ovctjro\">其查询结果在 <code>ngOnInit</code> 中有时可用有时不可用，而且还不清楚为什么（参阅 <a href=\"https://github.com/angular/angular/issues/21800\">21800</a> 或 <a href=\"https://github.com/angular/angular/issues/19872\">19872</a>）。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b6yjlbryo8udgccwirbv7b0w9\"><code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 查询和 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 查询的解析时机不一样，而 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查询和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查询的解析时机也不一样。如果用户把 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 查询换成 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 查询，那么他们的代码就会突然崩溃，因为其解析时机已经变化了。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"619w27t66umxxwyrr9lhosrsk\">一旦往模板中添加了 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>，依赖于查询结果的代码就会突然停止工作</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"n4fdrq0bkrhoz6rqqjm3yfps\">当每次使用该组件时，针对同一个组件的 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查询却会在生命周期的不同时机进行解析。这导致了一些错误的行为，即：带 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 的组件会以一种对组件作者来说很隐晦的、微妙的方式被破坏。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7emrgy1eojbqr88d7b2g4zt7k\">在版本 9 中，我们准备简化这种行为：默认情况下，每当运行变更检测之后，都会解析所有查询。模板中查询的位置不会再影响查询结果何时可用，也不会突然破坏你的代码，其默认行为总是一样的。这样，这种逻辑对于用户来说就更加一致、更加可预测。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wdq70ounf4blvcsqtwb9966z\">也就是说，如果一个应用程序确实需要更早拿到查询结果（比如，在创建嵌入式视图时需要这种查询结果），就可以添加 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code> 标志来明确要求静态解析。有了这个标志，用户就可以表明他们只关心那些静态可用的结果，并且在 <code>ngOnInit</code> 之前就会填上查询结果。</p>\n<p><a id=\"view-children-and-content-children\"></a></p>\n<h3 id=\"does-this-change-affect-viewchildren-or-contentchildren-queries\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5uy6pfft6ij3rhhgc5d8q0n5e\">这项变化是否会影响 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 或 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查询？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#does-this-change-affect-viewchildren-or-contentchildren-queries\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"162kcppsu70mhhhnyyafxtvop\">不，这项变化只会影响 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查询。默认情况下，<code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查询已经是“动态”的，并且不支持静态解析。</p>\n<p><a id=\"why-specify-static-false\"></a></p>\n<h3 id=\"why-do-i-have-to-specify-static-false-isnt-that-the-default\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"84cqcveolimym9qcixo36dkah\">为什么我还要指定 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>？它不是默认值吗？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#why-do-i-have-to-specify-static-false-isnt-that-the-default\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3j92g86cw5jqqx4yis57kn45f\">本次迁移的目的是把现在的版本 9 之前的应用转换为与版本 9 兼容的查询模式。然而，大多数应用都会用到库，而其中某些库可能还无法升级到版本 8（因而可能没有指定合适的标志值）。由于应用程序编译时会用到当前的 Angular 版本，所以如果我们修改了默认值，库里组件的查询行为就会变成版本 8 的这个默认值，这可能导致重大变更。而现在这种方式，应用程序的依赖项在转换过程中的行为就和之前的版本是一样的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8dd76xigybvt9h137406phr3h\">在 Angular 9 及更高版本中，任意删除 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code> 标志都是安全的，届时，我们会在原理图中为你完成这个清理工作。</p>\n<p><a id=\"libraries\"></a></p>\n<h3 id=\"can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"75rtso6vopnazpvtdu0q93ji5\">我还可以继续使用尚未更新到版本 8 的 Angular 库吗？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ub1zv43g5oxrubuw3nu2gzo5\">绝对没问题！\n因为我们没有改变版本 8 中的默认查询行为（比如编译器在没有设置任何标志的情况下仍然会自己选择一个合适的时机），所以当你的应用运行时，如果你的库没有更新到版本 8，该库的运行方式就和版本 7 中是一样的。这样就可以保证你的应用在版本 8 中仍然可以工作，不过这些库的开发者就需要花费更长的时间来修改代码了。</p>\n<p><a id=\"update-library-to-use-static-flag\"></a></p>\n<h3 id=\"can-i-update-my-library-to-version-8-by-adding-the-static-flag-to-view-queries-while-still-being-compatible-with-angular-version-7-apps\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1nfcbq4luaep8q1g7wlgqh5bf\">我可以通过为视图查询添加 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 标志来把我的库更新到版本 8，那它还能同时和 Angular 7 应用兼容吗？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#can-i-update-my-library-to-version-8-by-adding-the-static-flag-to-view-queries-while-still-being-compatible-with-angular-version-7-apps\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bia5kx4d6was13p0e3duzalmw\">是的，Angular 团队对库的建议是更新到版本 8 并添加 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 标志。Angular 7 的应用可以继续使用那些带有此标志的库。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2deavlyyi2qd2x1lyckfumj9d\">但是，如果你把你的库更新到 Angular 8，并希望利用新的第 8 版 API，或者你想要新版依赖项（比如 Typescript 或 RxJS），你的库就会变得与 Angular 7 的应用不兼容。如果你的目标是同时与 Angular 7 和 8 兼容，那你就不应该更新你的库，只有 <code>package.json</code> 中的 <code>peerDependencies</code> 除外。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9y0jqqsr3y0e49h4ocr2agt5s\">一般来说，最有效的计划是让库采用 6 个月的主版本计划，并在每次 Angular 升级之后适配主版本。这样，库就可以和 Angular 保持同样的发布节奏了。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/deprecations\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/NgFor\n - api/common/NgIf\n - api/core/ContentChild\n - api/core/ContentChild#description\n - api/core/ContentChildren\n - api/core/ElementRef\n - api/core/Input\n - api/core/TemplateRef\n - api/core/ViewChild\n - api/core/ViewChild#description\n - api/core/ViewChildren\n - api/upgrade/static\n - guide/static-query-migration#can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet\n - guide/static-query-migration#can-i-update-my-library-to-version-8-by-adding-the-static-flag-to-view-queries-while-still-being-compatible-with-angular-version-7-apps\n - guide/static-query-migration#does-this-change-affect-viewchildren-or-contentchildren-queries\n - guide/static-query-migration#faq\n - guide/static-query-migration#how-do-i-choose\n - guide/static-query-migration#how-do-i-choose-which-static-flag-value-to-use-true-or-false\n - guide/static-query-migration#is-there-a-case-where-i-should-use-static-true\n - guide/static-query-migration#should-i-use-static-true\n - guide/static-query-migration#static-query-migration-guide\n - guide/static-query-migration#what-does-this-flag-mean\n - guide/static-query-migration#what-does-this-flag-mean-and-why-is-it-necessary\n - guide/static-query-migration#what-should-i-do-if-i-see-a--todo-add-static-flag--comment-printed-by-the-schematic\n - guide/static-query-migration#why-do-i-have-to-specify-static-false-isnt-that-the-default\n - https://github.com/angular/angular/issues/19872\n - https://github.com/angular/angular/issues/21800\n-->"}