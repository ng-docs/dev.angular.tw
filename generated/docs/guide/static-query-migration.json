{"id":"guide/static-query-migration","title":"靜態查詢（Static Query）遷移指南","contents":"<div class=\"content\">\n  <h1 id=\"static-query-migration-guide\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7gqx36os1u6pjxjpxg98haqlf\">靜態查詢（Static Query）遷移指南<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#static-query-migration-guide\"><i class=\"material-icons\">link</i></a></h1>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4j2eu2c1dbq7q0y15vcb8z4rx\"><strong>重要</strong>：<br>\n函式庫的作者注意：\n這份遷移指南非常重要，可以方便他們的使用者升級到（Angular 的）版本 9（大約在 2019 年 10 月發布）。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5opt5ckspqzd9opnkwq75qfie\">在版本 9 中，<code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 這兩個查詢的預設設定會改變，以修復查詢中的 BUG 和意外行為（詳情參閱<a href=\"guide/static-query-migration#what-does-this-flag-mean\">此處</a>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vkh75no8h44cg463hktzgljr\">為了應對這個變化，我們從版本 8 開始就要開始遷移所有應用和函式庫，顯式指定 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查詢的解析策略。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bdkhngx1dq5sp5xiw24knhldt\">具體來說，這次遷移會新增一個顯式的 『static』 標誌，用來指出應該何時對該查詢的結果進行賦值。等升級到版本 9 的時候，這個標誌可以確保這些程式碼的工作方式都是一樣的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"avbj53jo8a6qvi7ldp6ge3r5\">之前：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> results sometimes available in `ngOnInit`, sometimes in `ngAfterViewInit` (based on template)\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('foo') foo: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f0strjmc2u3ezgi4ylp84oekx\">之後：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> results available in ngOnInit\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('foo', {<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}) foo: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\nOR\n\n// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> results available in ngAfterViewInit\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('foo', {<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}) foo: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dmuw3aw9e74fipybmj7f0gjnm\">從版本 9 開始，<code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 標誌將預設為 <code>false</code>。那時候，可以安全地刪除所有 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code> 標誌，而且我們還會提供一個能幫你更新程式碼的原理圖（schematic）。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jlzgajnuznsed3rpbxhvdicm\"><strong>注意</strong>：<br>\n這個標誌只適用於 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 這兩個查詢，這是因為 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查詢都沒有靜態和動態的概念（它們總是『動態』解析）。</p>\n</div>\n<h2 id=\"faq\">FAQ<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#faq\"><i class=\"material-icons\">link</i></a></h2>\n<p><a id=\"what-to-do-with-todo\"></a></p>\n<h3 id=\"what-should-i-do-if-i-see-a--todo-add-static-flag--comment-printed-by-the-schematic\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4dsl1dfezg5y0mt4aauq2of16\">當看到由原理圖新增的 <code>/* TODO: add <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> flag */</code> 註解時，我該怎麼辦？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#what-should-i-do-if-i-see-a--todo-add-static-flag--comment-printed-by-the-schematic\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cel3yn0rc4h929qe47t4pvddd\">如果你看到這個註解，就意味著原理圖無法自己找到恰當的標誌。在這種情況下，你必須根據應用的行為新增正確的標誌。要了解如何進行選擇，請參閱<a href=\"guide/static-query-migration#how-do-i-choose\">下一個問題</a>。</p>\n<p><a id=\"how-do-i-choose\"></a></p>\n<h3 id=\"how-do-i-choose-which-static-flag-value-to-use-true-or-false\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dmmnhtod1spa6jqmg5evrmlpi\">如何選擇 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 標誌：<code>true</code> 還是 <code>false</code>？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#how-do-i-choose-which-static-flag-value-to-use-true-or-false\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqdo9mjcqeunpxe8gm1i28bf0\">在官方 API 文件中，我們建議對於<a href=\"api/core/ViewChild#description\">檢視查詢</a> 總是在 <code>ngAfterViewInit</code> 中獲取查詢結果，對於<a href=\"api/core/ContentChild#description\">內容查詢</a> 總是在 <code>ngAfterContentInit</code> 中獲取查詢結果。這是因為當這些生命週期鉤子執行時，相關節點的變更檢測已完成，我們可以確信收集到了所有可能的查詢結果。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3a96jwz2e5yd9ee6l403f7dxr\">由於這個原因，大多數應用都應該使用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>。這個設定可以確保找出那些依賴於繫結解析的查詢結果（比如 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 內的查詢）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"268alg9wew37fko9z3lt18y7b\">在某些很少見的情況下，必須使用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code> 標誌（參閱<a href=\"guide/static-query-migration#should-i-use-static-true\">這裡的回答</a>）。</p>\n<p><a id=\"should-i-use-static-true\"></a></p>\n<h3 id=\"is-there-a-case-where-i-should-use-static-true\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aggkqn3c4j9z15z8u5ir2mza0\">什麼情況下我應該用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code>？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#is-there-a-case-where-i-should-use-static-true\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"abo8hm58u411qapf2o73lpp5i\">這個選項的引入是為了支援動態建立嵌入式檢視。如果你要查詢一個 <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code> 以便動態建立一個檢視，將無法在 <code>ngAfterViewInit</code> 中這樣做。這是因為變數檢測已在該檢視上執行過，所以這時候使用該範本建立一個新檢視就會丟擲 <code>ExpressionHasChangedAfterChecked</code> 錯誤。在這種情況下，你要把 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 標誌設定為 <code>true</code>，並在 <code>ngOnInit</code> 中建立你的檢視。在其它大多數情況下，最好的做法是使用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cptu0qtr1psudt8g22orcvuje\">為了便於遷移到版本 8 中，如果你的元件程式碼期望這些查詢的結果在 <code>ngAfterViewInit</code>（對於檢視查詢）或 <code>ngAfterContentInit</code>（對於內容查詢）<strong>之前</strong>的某個時刻就已經可用，可能也要把 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 標誌設定為 <code>true</code>。比如，如果你的元件期望在 <code>ngOnInit</code> 鉤子或 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 的 setter 中這些查詢結果已經就緒，就要把該標誌設定為 <code>true</code> 或者改寫你的元件以推遲它的執行時間。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"789rc672lft7ad9yg4b12ifvb\"><strong>注意</strong>：<br>\n把 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 設定為 <code>true</code> 意味著此查詢將不會發現嵌在 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 中的查詢結果。只有在執行過變更檢測之後才能取得這些結果。</p>\n</div>\n<p><a id=\"what-does-this-flag-mean\"></a></p>\n<h3 id=\"what-does-this-flag-mean-and-why-is-it-necessary\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cox6q7iygigspcnfwk9qzxfuk\">這個標誌是什麼意思，它有什麼必要？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#what-does-this-flag-mean-and-why-is-it-necessary\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ci96xo3ldqme6uvvw7co03fap\">以前，預設的查詢行為一直沒有文件記載，這會令人困惑，而且也常導致難以除錯的問題。在版本 9 中，我們希望這種查詢行為更加一致，也更容易理解。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d023u154htuhs4ydczbqg0n15\">為了解釋其原由，首先要弄清楚到目前為止這些查詢是如何工作的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rqtxjxqlk9u3iiwfgo8urwzr\">當沒有 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 標誌時，編譯器會自行決定每個查詢該如何解析。所有的 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> / <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查詢在編譯時都會被歸類別為兩種方式之一：『static』 或 『dynamic』。當查詢結果可供使用者使用時，就會決定該使用何種方式。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c9qgdxgq2felc6594coxgnnzo\">查詢</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9vq1u53wsficu2h7kl7gax3bc\">靜態查詢</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bbpmq262c9hzhy8qjk8jud86e\">由於結果不依賴於執行時值（如繫結），因此結果可以靜態確定。在該檢視的變更檢測執行之前，靜態查詢的結果就可用（可在 \n<code>ngOnInit</code> 中訪問）。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"87x0bkis85pp5wzk6q956plvf\">動態查詢</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9lweyujr8mqg04ri0vyox2y2w\">由於結果依賴於執行時值（繫結），因此結果無法靜態確定。動態查詢的結果直到該檢視的變更檢測執行後才可用（在內容查詢的 \n<code>ngAfterContentInit</code> 或檢視查詢的 \n<code>ngAfterViewInit</code> 中可訪問）。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"db1ahr14w09s7lvjcuvmi3mep\">比如，假設我們有一個元件 <code>Comp</code>。在其中，我們有這樣一個查詢：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>(Foo) foo: Foo;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"erxdxrsyvmgellpa7p8j6x9jo\">和這樣的範本：</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;div foo&gt;&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3slhd62updp5oyhkqij8k1l0h\">這個 <code>Foo</code> 查詢會被歸類別為靜態查詢，這是因為在編譯時，就已經知道 <code>&lt;div&gt;</code> 上的 <code>Foo</code> 實例是正確的查詢結果了。由於查詢結果並不依賴於執行時的值，所以在解析此查詢之前，我們不必等待範本上的變更檢測。因此，在 <code>ngOnInit</code> 中這些結果就已經可用了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6viy3j2ucu7lvh0tlf67h4rea\">假設查詢不變，但元件範本改成了這樣：</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;div foo *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"showing\"&gt;&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehsrunpx0wpe4p4vc2nu19m5a\">對於該範本，該查詢將被歸類別為動態查詢。我們需要知道 <code>showing</code> 在執行期間的值以確定該查詢的正確結果應該是什麼。因此，必須首先執行變更檢測，其結果只能在 <code>ngAfterViewInit</code> 或該查詢屬性的 setter 中才能使用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"adsadx7m437ez9qyvi8dgq92u\">這種實現方式的效果是，在查詢對應的任何父級節點新增 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 會導致：當查詢結果可用之後，其對應結果也會發生變化。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crwwpauee5d7g5j9oeu3nvs8q\">請記住，這些類別只能用於 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 這兩種查詢。而 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查詢都沒有靜態和動態的概念，它們總是『動態』解析。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2nxkug15r278q5vijsecoaqk1\">這種策略會根據查詢所在的位置，在不同的時機進行解析，這引起了很大的困惑。即：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"anpcj288kinmmneho7ovctjro\">其查詢結果在 <code>ngOnInit</code> 中有時可用有時不可用，而且還不清楚為什麼（參閱 <a href=\"https://github.com/angular/angular/issues/21800\">21800</a> 或 <a href=\"https://github.com/angular/angular/issues/19872\">19872</a>）。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b6yjlbryo8udgccwirbv7b0w9\"><code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 查詢和 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 查詢的解析時機不一樣，而 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查詢和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查詢的解析時機也不一樣。如果使用者把 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 查詢換成 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 查詢，那麼他們的程式碼就會突然崩潰，因為其解析時機已經變化了。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"619w27t66umxxwyrr9lhosrsk\">一旦往範本中新增了 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>，依賴於查詢結果的程式碼就會突然停止工作</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"n4fdrq0bkrhoz6rqqjm3yfps\">當每次使用該組件時，針對同一個元件的 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查詢卻會在生命週期的不同時機進行解析。這導致了一些錯誤的行為，即：帶 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 的元件會以一種對元件作者來說很隱晦的、微妙的方式被破壞。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7emrgy1eojbqr88d7b2g4zt7k\">在版本 9 中，我們準備簡化這種行為：預設情況下，每當執行變更檢測之後，都會解析所有查詢。範本中查詢的位置不會再影響查詢結果何時可用，也不會突然破壞你的程式碼，其預設行為總是一樣的。這樣，這種邏輯對於使用者來說就更加一致、更加可預測。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wdq70ounf4blvcsqtwb9966z\">也就是說，如果一個應用程式確實需要更早拿到查詢結果（比如，在建立嵌入式檢視時需要這種查詢結果），就可以新增 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code> 標誌來明確要求靜態解析。有了這個標誌，使用者就可以表明他們只關心那些靜態可用的結果，並且在 <code>ngOnInit</code> 之前就會填上查詢結果。</p>\n<p><a id=\"view-children-and-content-children\"></a></p>\n<h3 id=\"does-this-change-affect-viewchildren-or-contentchildren-queries\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5uy6pfft6ij3rhhgc5d8q0n5e\">這項變化是否會影響 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 或 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查詢？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#does-this-change-affect-viewchildren-or-contentchildren-queries\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"162kcppsu70mhhhnyyafxtvop\">不，這項變化只會影響 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查詢。預設情況下，<code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查詢已經是『動態』的，並且不支援靜態解析。</p>\n<p><a id=\"why-specify-static-false\"></a></p>\n<h3 id=\"why-do-i-have-to-specify-static-false-isnt-that-the-default\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"84cqcveolimym9qcixo36dkah\">為什麼我還要指定 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>？它不是預設值嗎？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#why-do-i-have-to-specify-static-false-isnt-that-the-default\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3j92g86cw5jqqx4yis57kn45f\">本次遷移的目的是把現在的版本 9 之前的應用轉換為與版本 9 相容的查詢模式。然而，大多數應用都會用到函式庫，而其中某些函式庫可能還無法升級到版本 8（因而可能沒有指定合適的標誌值）。由於應用程式編譯時會用到當前的 Angular 版本，所以如果我們修改了預設值，函式庫裡元件的查詢行為就會變成版本 8 的這個預設值，這可能導致重大變更。而現在這種方式，應用程式的依賴項在轉換過程中的行為就和之前的版本是一樣的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8dd76xigybvt9h137406phr3h\">在 Angular 9 及更高版本中，任意刪除 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code> 標誌都是安全的，屆時，我們會在原理圖中為你完成這個清理工作。</p>\n<p><a id=\"libraries\"></a></p>\n<h3 id=\"can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"75rtso6vopnazpvtdu0q93ji5\">我還可以繼續使用尚未更新到版本 8 的 Angular 函式庫嗎？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ub1zv43g5oxrubuw3nu2gzo5\">絕對沒問題！\n因為我們沒有改變版本 8 中的預設查詢行為（比如編譯器在沒有設定任何標誌的情況下仍然會自己選擇一個合適的時機），所以當你的應用執行時，如果你的函式庫沒有更新到版本 8，該函式庫的執行方式就和版本 7 中是一樣的。這樣就可以保證你的應用在版本 8 中仍然可以工作，不過這些函式庫的開發者就需要花費更長的時間來修改程式碼了。</p>\n<p><a id=\"update-library-to-use-static-flag\"></a></p>\n<h3 id=\"can-i-update-my-library-to-version-8-by-adding-the-static-flag-to-view-queries-while-still-being-compatible-with-angular-version-7-apps\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1nfcbq4luaep8q1g7wlgqh5bf\">我可以透過為檢視查詢新增 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 標誌來把我的函式庫更新到版本 8，那它還能同時和 Angular 7 應用相容嗎？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#can-i-update-my-library-to-version-8-by-adding-the-static-flag-to-view-queries-while-still-being-compatible-with-angular-version-7-apps\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bia5kx4d6was13p0e3duzalmw\">是的，Angular 團隊對函式庫的建議是更新到版本 8 並新增 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 標誌。Angular 7 的應用可以繼續使用那些帶有此標誌的函式庫。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2deavlyyi2qd2x1lyckfumj9d\">但是，如果你把你的函式庫更新到 Angular 8，並希望利用新的第 8 版 API，或者你想要新版依賴項（比如 Typescript 或 RxJS），你的函式庫就會變得與 Angular 7 的應用不相容。如果你的目標是同時與 Angular 7 和 8 相容，那你就不應該更新你的函式庫，只有 <code>package.json</code> 中的 <code>peerDependencies</code> 除外。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9y0jqqsr3y0e49h4ocr2agt5s\">一般來說，最有效的計劃是讓函式庫採用 6 個月的主版本計劃，並在每次 Angular 升級之後適配主版本。這樣，函式庫就可以和 Angular 保持同樣的發布節奏了。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/deprecations\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/NgFor\n - api/common/NgIf\n - api/core/ContentChild\n - api/core/ContentChild#description\n - api/core/ContentChildren\n - api/core/ElementRef\n - api/core/Input\n - api/core/TemplateRef\n - api/core/ViewChild\n - api/core/ViewChild#description\n - api/core/ViewChildren\n - api/upgrade/static\n - guide/static-query-migration#can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet\n - guide/static-query-migration#can-i-update-my-library-to-version-8-by-adding-the-static-flag-to-view-queries-while-still-being-compatible-with-angular-version-7-apps\n - guide/static-query-migration#does-this-change-affect-viewchildren-or-contentchildren-queries\n - guide/static-query-migration#faq\n - guide/static-query-migration#how-do-i-choose\n - guide/static-query-migration#how-do-i-choose-which-static-flag-value-to-use-true-or-false\n - guide/static-query-migration#is-there-a-case-where-i-should-use-static-true\n - guide/static-query-migration#should-i-use-static-true\n - guide/static-query-migration#static-query-migration-guide\n - guide/static-query-migration#what-does-this-flag-mean\n - guide/static-query-migration#what-does-this-flag-mean-and-why-is-it-necessary\n - guide/static-query-migration#what-should-i-do-if-i-see-a--todo-add-static-flag--comment-printed-by-the-schematic\n - guide/static-query-migration#why-do-i-have-to-specify-static-false-isnt-that-the-default\n - https://github.com/angular/angular/issues/19872\n - https://github.com/angular/angular/issues/21800\n-->"}