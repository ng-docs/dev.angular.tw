{"id":"guide/migration-module-with-providers","title":"ModuleWithProviders 遷移","contents":"<div class=\"content\">\n  <h1 id=\"modulewithproviders-migration\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7kcwmdzrkgkqg05y17kj533g\"><code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 遷移<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-module-with-providers#modulewithproviders-migration\"><i class=\"material-icons\">link</i></a></h1>\n<h2 id=\"what-does-this-schematic-do\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"658j6i5bcolbjplq8i1gn2i5j\">這個原理圖做了什麼？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-module-with-providers#what-does-this-schematic-do\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehjgxacc9anhfu5w6nl4wxam5\">一些 Angular 函式庫，比如 <code>@angular/router</code> 和 <code>@ngrx/store</code>，實現了某些回傳 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 型別的 API（通常是一個名叫 <code>forRoot()</code> 的方法）。這種型別代表了一個 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 以及其提供者。Angular 9 不推薦使用不帶泛型的 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code>，泛型型別就是 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的型別。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7rny1vjzdvo1hbhpxllgj63cc\">這個原理圖會給那些缺少泛型的 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 用法新增泛型型別。在下面的例子中，<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的型別是 <code>SomeModule</code>，所以原理圖就把型別修改為 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>&lt;SomeModule&gt;</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ofalxrsiul8xaypkc7mxsldx\"><strong>之前</strong></p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({…})\nexport class MyModule {\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(config: SomeConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a> {\n    return {\n      ngModule: SomeModule,\n      providers: [\n        {provide: SomeConfig, useValue: config}\n      ]\n    };\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"smcnebhffa1ezxha35vogpdo\"><strong>之後</strong></p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({…})\nexport class MyModule {\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(config: SomeConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>&lt;SomeModule&gt; {\n    return {\n      ngModule: SomeModule,\n      providers: [\n        {provide: SomeConfig, useValue: config }\n      ]\n    };\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ary9c89qtvgm5wbp31r2fljur\">在極少數情況下，原理圖無法確定 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 的型別，你可能會看到原理圖列印出一條 TODO 註解來讓你手動更新程式碼。</p>\n<h2 id=\"why-is-this-migration-necessary\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"beeyw6htdnv7zrizs0aw385nk\">為何這次遷移必不可少？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-module-with-providers#why-is-this-migration-necessary\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uq7y6rydchj6vy1a3636los7\">自 Angular 7 開始，<code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 就有了泛型型別，但它是可選的。即使缺了也可以正常編譯，因為 <code>metadata.json</code> 檔案中包含了所有的元資料。在 Ivy 中，不再需要 <code>metadata.json</code> 檔案了，所以框架不能再假定已經有了所有必要的型別。相反，Ivy 要依賴 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 的泛型型別來獲取正確的型別訊息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92gxozawxn8gduwowv5uf1zgk\">出於這個原因，Angular 9 版本不推薦使用不帶泛型型別的 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code>。Angular 的未來版本會刪除預設的泛型型別，並且要求一個明確的型別。</p>\n<h2 id=\"should-i-add-the-generic-type-when-i-add-new-modulewithproviders-types-to-my-application\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94fjmhiu6ocgg90yb30hjmcf3\">當我把新的 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 型別新增到應用中時，是否應該新增泛型？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-module-with-providers#should-i-add-the-generic-type-when-i-add-new-modulewithproviders-types-to-my-application\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ac43qh3bm05dsyb7a83fphfg\">是的，任何時候，當你的程式碼引用了 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 型別，都要有一個與其回傳的實際 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 相對應的泛型型別（比如，<code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>&lt;MyModule&gt;</code>）。</p>\n<h2 id=\"what-should-i-do-if-the-schematic-prints-a-todo-comment\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cuemlzkesleivudh9zusiicrv\">如果此原理圖列印出了 TODO 註解，我該怎麼辦？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-module-with-providers#what-should-i-do-if-the-schematic-prints-a-todo-comment\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlzppdx9k1vx27d9dveuee5fy\">此原理圖會在它無法檢測出 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 型別的正確泛型型別的情況下列印 TODO 註解。在這種情況下，你需要手動為 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 新增正確的泛型。它應該對應 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 物件中回傳的那個 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>。</p>\n<h2 id=\"what-does-this-mean-for-libraries\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ynl2b77rv218pdiz4sao6p1g\">這對函式庫來說意味著什麼？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-module-with-providers#what-does-this-mean-for-libraries\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1kzs1l794310ak0o800v4d4a4\">函式庫應該把泛型型別新增到 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 型別的任何一次使用中。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Thu Feb 16 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/deprecations\n-->\n<!-- links from this doc:\n - api/core/ModuleWithProviders\n - api/core/NgModule\n - api/upgrade/static\n - guide/migration-module-with-providers#modulewithproviders-migration\n - guide/migration-module-with-providers#should-i-add-the-generic-type-when-i-add-new-modulewithproviders-types-to-my-application\n - guide/migration-module-with-providers#what-does-this-mean-for-libraries\n - guide/migration-module-with-providers#what-does-this-schematic-do\n - guide/migration-module-with-providers#what-should-i-do-if-the-schematic-prints-a-todo-comment\n - guide/migration-module-with-providers#why-is-this-migration-necessary\n-->"}