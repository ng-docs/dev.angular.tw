{"id":"guide/migration-module-with-providers","title":"ModuleWithProviders 迁移","contents":"<div class=\"content\">\n  <h1 id=\"modulewithproviders-migration\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7kcwmdzrkgkqg05y17kj533g\"><code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 迁移<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-module-with-providers#modulewithproviders-migration\"><i class=\"material-icons\">link</i></a></h1>\n<h2 id=\"what-does-this-schematic-do\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"658j6i5bcolbjplq8i1gn2i5j\">这个原理图做了什么？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-module-with-providers#what-does-this-schematic-do\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehjgxacc9anhfu5w6nl4wxam5\">一些 Angular 库，比如 <code>@angular/router</code> 和 <code>@ngrx/store</code>，实现了某些返回 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 类型的 API（通常是一个名叫 <code>forRoot()</code> 的方法）。这种类型代表了一个 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 以及其提供者。Angular 9 不推荐使用不带泛型的 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code>，泛型类型就是 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的类型。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7rny1vjzdvo1hbhpxllgj63cc\">这个原理图会给那些缺少泛型的 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 用法添加泛型类型。在下面的例子中，<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的类型是 <code>SomeModule</code>，所以原理图就把类型修改为 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>&lt;SomeModule&gt;</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ofalxrsiul8xaypkc7mxsldx\"><strong>之前</strong></p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({…})\nexport class MyModule {\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(config: SomeConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a> {\n    return {\n      ngModule: SomeModule,\n      providers: [\n        {provide: SomeConfig, useValue: config}\n      ]\n    };\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"smcnebhffa1ezxha35vogpdo\"><strong>之后</strong></p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({…})\nexport class MyModule {\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(config: SomeConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>&lt;SomeModule&gt; {\n    return {\n      ngModule: SomeModule,\n      providers: [\n        {provide: SomeConfig, useValue: config }\n      ]\n    };\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ary9c89qtvgm5wbp31r2fljur\">在极少数情况下，原理图无法确定 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 的类型，你可能会看到原理图打印出一条 TODO 注释来让你手动更新代码。</p>\n<h2 id=\"why-is-this-migration-necessary\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"beeyw6htdnv7zrizs0aw385nk\">为何这次迁移必不可少？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-module-with-providers#why-is-this-migration-necessary\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uq7y6rydchj6vy1a3636los7\">自 Angular 7 开始，<code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 就有了泛型类型，但它是可选的。即使缺了也可以正常编译，因为 <code>metadata.json</code> 文件中包含了所有的元数据。在 Ivy 中，不再需要 <code>metadata.json</code> 文件了，所以框架不能再假定已经有了所有必要的类型。相反，Ivy 要依赖 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 的泛型类型来获取正确的类型信息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92gxozawxn8gduwowv5uf1zgk\">出于这个原因，Angular 9 版本不推荐使用不带泛型类型的 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code>。Angular 的未来版本会删除默认的泛型类型，并且要求一个明确的类型。</p>\n<h2 id=\"should-i-add-the-generic-type-when-i-add-new-modulewithproviders-types-to-my-application\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94fjmhiu6ocgg90yb30hjmcf3\">当我把新的 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 类型添加到应用中时，是否应该添加泛型？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-module-with-providers#should-i-add-the-generic-type-when-i-add-new-modulewithproviders-types-to-my-application\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ac43qh3bm05dsyb7a83fphfg\">是的，任何时候，当你的代码引用了 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 类型，都要有一个与其返回的实际 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 相匹配的泛型类型（比如，<code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>&lt;MyModule&gt;</code>）。</p>\n<h2 id=\"what-should-i-do-if-the-schematic-prints-a-todo-comment\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cuemlzkesleivudh9zusiicrv\">如果此原理图打印出了 TODO 注释，我该怎么办？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-module-with-providers#what-should-i-do-if-the-schematic-prints-a-todo-comment\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlzppdx9k1vx27d9dveuee5fy\">此原理图会在它无法检测出 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 类型的正确泛型类型的情况下打印 TODO 注释。在这种情况下，你需要手动为 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 添加正确的泛型。它应该匹配 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 对象中返回的那个 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>。</p>\n<h2 id=\"what-does-this-mean-for-libraries\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ynl2b77rv218pdiz4sao6p1g\">这对库来说意味着什么？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-module-with-providers#what-does-this-mean-for-libraries\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1kzs1l794310ak0o800v4d4a4\">库应该把泛型类型添加到 <code><a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a></code> 类型的任何一次使用中。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Thu Feb 16 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/deprecations\n-->\n<!-- links from this doc:\n - api/core/ModuleWithProviders\n - api/core/NgModule\n - api/upgrade/static\n - guide/migration-module-with-providers#modulewithproviders-migration\n - guide/migration-module-with-providers#should-i-add-the-generic-type-when-i-add-new-modulewithproviders-types-to-my-application\n - guide/migration-module-with-providers#what-does-this-mean-for-libraries\n - guide/migration-module-with-providers#what-does-this-schematic-do\n - guide/migration-module-with-providers#what-should-i-do-if-the-schematic-prints-a-todo-comment\n - guide/migration-module-with-providers#why-is-this-migration-necessary\n-->"}