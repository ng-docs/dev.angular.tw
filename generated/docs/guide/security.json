{"id":"guide/security","title":"安全","contents":"<div class=\"content\">\n  <h1 id=\"security\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tmchdk1ct294f2gw8klyefyd\">安全<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#security\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9mrwrcafecguxdtsts5fw0erd\">本主題會講述 Angular 為防範 Web 應用常見的安全漏洞和攻擊（比如跨站指令碼攻擊）內建的保護措施，但不會涉及應用級安全，比如使用者認證（<em>這個使用者是誰？</em>）和授權（<em>這個使用者能做什麼？</em>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1bl23pvc92z5e5hqr9uvhvxd7\">要了解更多攻防訊息，參閱<a href=\"https://www.owasp.org/index.php/Category:OWASP_Guide_Project\">開放式 Web 應用程式安全專案（OWASP）</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1fliytthw8ajl1jed0jtyvesz\">你可以執行<live-example></live-example>，在 Stackblitz 中試用並下載本頁的程式碼。</p>\n<p><a id=\"report-issues\"></a></p>\n<div class=\"callout is-important\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wvo0nk9ciayfr0clbe1i4x13\">舉報漏洞</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"31rvqvnpjqz0vyd35f0rs39ln\">Angular是Google的一部分 \n<a href=\"https://bughunters.google.com/about/rules/6521337925468160/google-open-source-software-vulnerability-reward-program-rules\">開源軟體漏洞獎勵計劃</a>的一部分。 \n<a href=\"https://bughunters.google.com/report\">有關Angular的漏洞，請在 https://bughunters.google.com 送出報告</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4pheox6rw1iltrjr0f8wcs9u9\">要了解關於『谷歌如何處理安全問題』的更多訊息，參閱<a href=\"https://www.google.com/about/appsecurity/\">谷歌的安全哲學</a>。</p>\n</div>\n<p><a id=\"best-practices\"></a></p>\n<div class=\"callout is-helpful\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bjllji5sr3q5uwcd3o4optfxh\">最佳實踐</header>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ek8e4x2w81qq5uycuuqaae0n\">實踐</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c35vmjp6jisaojypr03o3qlvk\">始終保持最新的Angular函式庫發布</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"afit235ud49zuxvb6dx1i517v\">Angular函式庫會定期更新，這些更新可能修復先前版本中發現的安全缺陷。檢視Angular的\n<a href=\"https://github.com/angular/angular/blob/main/CHANGELOG.md\">變更日誌</a>以獲取與安全相關的更新。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2hztu4wvtytsfxktfi7v65xtn\">不要更改Angular的副本</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"q1j2sn52lpnldhwjozvd7oli\">私有的、定製版本的Angular往往落後於當前版本，並可能不包含重要的安全修復和增強功能。相反，與社群分享你的Angular改進並送出拉取請求。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ril7bmiak9odbyoizeminvry\">避免使用文件中標記為\"\n<em>安全風險</em>\"的Angular API</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"akkx2t19dgr70e0789n7kiim7\">有關更多訊息，請參閱本頁面的\n<a href=\"guide/security#bypass-security-apis\">信任安全值</a>部分。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"preventing-cross-site-scripting-xss\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b0yuw9jlyuidv1j9hn122f0s2\">防範跨站指令碼（XSS）攻擊<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#preventing-cross-site-scripting-xss\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ww6t4ql6ocpuo6tfghu0vcoo\"><a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">跨站指令碼（XSS）</a>允許攻擊者將惡意程式碼注入到頁面中。這些程式碼可以偷取用戶及其登入資料資料，還可以冒充使用者執行操作。它是 Web 上最常見的攻擊方式之一。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ethhqqayj1hgptjkhsyf8w6z\">為了防範 XSS 攻擊，你必須阻止惡意程式碼進入 DOM。比如，如果某個攻擊者能騙你把 <code>&lt;script&gt;</code> 標籤插入到 DOM，就可以在你的網站上執行任何程式碼。除了 <code>&lt;script&gt;</code>，攻擊者還可以使用很多 DOM 元素和屬性來執行程式碼，比如 <code>&lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> alt=\"\" onerror=\"...\"&gt;</code>、<code>&lt;a href=\"javascript:...\"&gt;</code>。如果攻擊者所控制的資料混進了 DOM，就會導致安全漏洞。</p>\n<h3 id=\"angulars-cross-site-scripting-security-model\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3r5tviniurmflj66uw239f5no\">Angular 的『跨站指令碼安全模型』<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#angulars-cross-site-scripting-security-model\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97xohtadcqiw7xyk1g04d02by\">為了系統性的防範 XSS 問題，Angular 預設把所有值都當做不可信任的。\n當值從樣板中以屬性（Property）、DOM 元素屬性（Attribte）、CSS 類別繫結或內嵌等途徑插入到 DOM 中的時候，\nAngular 將對這些值進行無害化處理（Sanitize），對不可信的值進行編碼。如果某個值已經在 Angular 之外進行過無害化處理，可以確信是安全的，可以<a href=\"guide/security#bypass-security-apis\">把這個值標記為安全的</a>來把這一點通知 Angular。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dsiz3ikxq2gj5x1bcirtxm0j3\">與用於渲染的值不同，預設情況下，Angular 樣板被認為是受信任的，應被視為可執行程式碼。切勿透過串聯使用者輸入和樣板語法來生成樣板。這樣做會使攻擊者能夠<a href=\"https://en.wikipedia.org/wiki/Code_injection\">將任意程式碼注入</a>你的應用程式。為避免這些漏洞，請始終在生產部署中<a href=\"guide/security#offline-template-compiler\">使用預設的 AOT 樣板編譯器。</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5r3dygto994nd4oqsy3vln6xe\">藉助內容安全策略和可信型別，可以提供額外的保護層。這些 Web 平台屬性會在 DOM 級別執行，這是用來防範 XSS 問題的最有效位置，因為即使使用其它低階 API 也無法繞過它們。出於這個原因，我們強烈建議開發人員透過為其應用程式設定<a href=\"guide/security#content-security-policy\">內容安全策略</a>並啟用<a href=\"guide/security#trusted-types\">強制可信型別</a>來利用這些屬性。</p>\n<h3 id=\"sanitization-and-security-contexts\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7xlut81nemd9ym9zi0vi9pub9\">無害化處理與安全環境<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#sanitization-and-security-contexts\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jxp468r53cng8i1s00lfhzua\">無害化處理會審查不可信的值，並將它們轉換成可以安全插入到 DOM 的形式。多數情況下，這些值並不會在處理過程中發生任何變化。無害化處理的方式取決於所在的環境：一個在 CSS 裡面無害的值，可能在 URL 裡很危險。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ls64ghadjsvvmujq56vt3wsq\">Angular 定義了四個安全環境：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7nqo06dkmqthsrcpvth4nj8oq\">安全上下文</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">HTML</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97jlcn11j6epihbophjin0z10\">在將值解釋為HTML時使用，例如，當繫結到\n<code>innerHtml</code>時。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ab6gpm47ggoqvg5dy42ycwx7f\">樣式</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"22w9efwesvb04j10jbwnhr5ae\">用於將CSS繫結到\n<code><a href=\"api/animations/style\" class=\"code-anchor\">style</a></code>屬性中。</td>\n</tr>\n<tr>\n<td align=\"left\">URL</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"grdd8o9bt9fmqxid48juxn5v\">用於URL屬性，例如\n<code>&lt;a href&gt;</code>。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eem8q4in3t1qrsxl06xymx95y\">資源URL</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5hz5s82igj87k28lqrqbs7f3o\">作為程式碼載入和執行的URL，例如，在\n<code>&lt;script src&gt;</code>中。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"edktxoojrqb20uacjp4n584b7\">Angular 會對前三項中種不可信的值進行無害化處理，但不能對第四種資源 URL 進行無害化，因為它們可能包含任何程式碼。在開發模式下，如果在進行無害化處理時需要被迫改變一個值，Angular 就會在控制台上輸出一個警告。</p>\n<h3 id=\"sanitization-example\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"365xxywjscduuegy2qfv6pr0d\">無害化範例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#sanitization-example\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cqiv9f14o3z7q4m55mbdkxunm\">下面的例子繫結了 <code>htmlSnippet</code> 的值。一次把它放進內嵌裡，另一次把它繫結到元素的 <code>innerHTML</code> 屬性上。</p>\n<code-example header=\"src/app/inner-html-binding.component.html\" path=\"security/src/app/inner-html-binding.component.html\">\n&lt;h3&gt;Binding innerHTML&lt;/h3&gt;\n&lt;p&gt;Bound value:&lt;/p&gt;\n&lt;p class=\"e2e-inner-html-interpolated\"&gt;{{htmlSnippet}}&lt;/p&gt;\n&lt;p&gt;Result of binding to innerHTML:&lt;/p&gt;\n&lt;p class=\"e2e-inner-html-bound\" [innerHTML]=\"htmlSnippet\"&gt;&lt;/p&gt;\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dl080d5r77cgzl6tfdyj3biy2\">內嵌的內容總會被編碼 - 其中的 HTML 不會被解釋，所以瀏覽器會在元素的文字內容中顯示尖括號。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ijrsaqsggg9iib43d0mpkp3e\">如果希望這段 HTML 被正常解釋，就必須繫結到一個 HTML 屬性上，比如 <code>innerHTML</code>。但要小心如果把一個可能被攻擊者控制的值繫結到 <code>innerHTML</code> 就會導致 XSS 漏洞。比如，某些人可以用這種方式來執行惡意程式碼：</p>\n<code-example header=\"src/app/inner-html-binding.component.ts (class)\" path=\"security/src/app/inner-html-binding.component.ts\" region=\"class\">\nexport class InnerHtmlBindingComponent {\n  // For example, a user/attacker-controlled value from a URL.\n  htmlSnippet = 'Template &lt;script&gt;alert(\"0wned\")&lt;/script&gt; &lt;b&gt;Syntax&lt;/b&gt;';\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"egq196mowt244uijiw6ggpklj\">Angular 認為這些值是不安全的，並自動進行無害化處理。它會移除 <code>script</code> 元素，但保留安全的內容，比如該片段中的 <code>&lt;b&gt;</code> 元素。</p>\n<div class=\"lightbox\">\n<img alt=\"A screenshot showing interpolated and bound HTML values\" src=\"generated/images/guide/security/binding-inner-html.png\" width=\"400\" height=\"114\">\n</div>\n<h3 id=\"direct-use-of-the-dom-apis-and-explicit-sanitization-calls\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qaw7j6zm95z8549eysgyt27l\">避免直接使用 DOM API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#direct-use-of-the-dom-apis-and-explicit-sanitization-calls\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1gsypvrmrbhee91m20nt96mc8\">除非你強制使用可信型別（Trusted Types），否則瀏覽器內建的 DOM API 不會自動保護你免受安全漏洞的侵害。比如 <code>document</code>、透過 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code> 拿到的節點和很多第三方 API，都可能包含不安全的方法。如果你使用能操縱 DOM 的其它函式庫，也同樣無法藉助像 Angular 內嵌那樣的自動清理功能。所以，要避免直接和 DOM 打交道，而是儘可能使用 Angular 樣板。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"65mu3dje6lothqaafdaet28rt\">在無法避免的情況下，使用內建的 Angular 無害化處理函式。使用 <a href=\"api/platform-browser/DomSanitizer#sanitize\">DomSanitizer.sanitize</a> 方法以及適當的 <code><a href=\"api/core/SecurityContext\" class=\"code-anchor\">SecurityContext</a></code> 來對不可信的值進行無害化處理。此函式也可以接受使用 <code>bypassSecurityTrust</code> 函式標為可信的值，而且不會對它們進行無害化處理，就像<a href=\"guide/security#bypass-security-apis\">稍後講的那樣</a>。</p>\n<p><a id=\"bypass-security-apis\"></a></p>\n<h3 id=\"trusting-safe-values\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b35wkxoxu523e184hzupgjazf\">信任安全值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#trusting-safe-values\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qd92bujky5gs9jhtmnf8sa75\">有時候，應用程式確實需要包含可執行的程式碼，比如使用 URL 顯示 <code>&lt;iframe&gt;</code>，或者構造出有潛在危險的 URL。為了防止在這種情況下被自動無害化，可以告訴 Angular，你已經審查了這個值，檢查了它是怎麼生成的，並確信它總是安全的。但是<strong>千萬要小心</strong>！如果你信任了一個可能是惡意的值，就會在應用中引入一個安全漏洞。如果你有疑問，請找一個安全專家複查下。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"70o5hvc6kx5ood9mnu1p47jo4\">注入 <code><a href=\"api/platform-browser/DomSanitizer\" class=\"code-anchor\">DomSanitizer</a></code> 服務，然後呼叫下面的方法之一，你就可以把一個值標記為可信任的。</p>\n<ul>\n<li><code>bypassSecurityTrustHtml</code></li>\n<li><code>bypassSecurityTrustScript</code></li>\n<li><code>bypassSecurityTrustStyle</code></li>\n<li><code>bypassSecurityTrustUrl</code></li>\n<li><code>bypassSecurityTrustResourceUrl</code></li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bdg1g7jbv7xar6nb5app2h78e\">記住，一個值是否安全取決於它所在的環境，所以你要為這個值按預定的用法選擇正確的環境。假設下面的樣板需要把 <code>javascript.alert(...)</code> 方法繫結到 URL。</p>\n<code-example header=\"src/app/bypass-security.component.html (URL)\" path=\"security/src/app/bypass-security.component.html\" region=\"URL\">\n&lt;h4&gt;An untrusted URL:&lt;/h4&gt;\n&lt;p&gt;&lt;a class=\"e2e-dangerous-url\" [href]=\"dangerousUrl\"&gt;Click me&lt;/a&gt;&lt;/p&gt;\n&lt;h4&gt;A trusted URL:&lt;/h4&gt;\n&lt;p&gt;&lt;a class=\"e2e-trusted-url\" [href]=\"trustedUrl\"&gt;Click me&lt;/a&gt;&lt;/p&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a79hazri5klxaozentv622s0e\">通常，Angular 會自動無害化這個 URL 並禁止危險的程式碼。為了防止這種行為，可以呼叫 <code>bypassSecurityTrustUrl</code> 把這個 URL 值標記為一個可信任的 URL：</p>\n<code-example header=\"src/app/bypass-security.component.ts (trust-url)\" path=\"security/src/app/bypass-security.component.ts\" region=\"trust-url\">\nconstructor(private sanitizer: <a href=\"api/platform-browser/DomSanitizer\" class=\"code-anchor\">DomSanitizer</a>) {\n  // javascript: URLs are dangerous if attacker controlled.\n  // Angular sanitizes them in data binding, but you can\n  // explicitly tell Angular to trust this value:\n  this.dangerousUrl = 'javascript:alert(\"Hi there\")';\n  this.trustedUrl = sanitizer.bypassSecurityTrustUrl(this.dangerousUrl);\n\n</code-example>\n<div class=\"lightbox\">\n<img alt=\"A screenshot showing an alert box created from a trusted URL\" src=\"generated/images/guide/security/bypass-security-component.png\" width=\"454\" height=\"175\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bb2xnc7c5wvlp9qriky5jimic\">如果需要把使用者輸入轉換為一個可信任的值，可以在元件方法中處理。下面的樣板允許使用者輸入一個 YouTube 影片的 ID，然後把相應的影片載入到 <code>&lt;iframe&gt;</code> 中。<code>&lt;iframe src&gt;</code> 是一個『資源 URL』的安全環境，因為不可信的原始碼可能作為檔案下載到本地，被毫無防備的使用者執行。所以要呼叫一個元件方法來構造一個新的、可信任的影片 URL，這樣 Angular 就會允許把它繫結到 <code>&lt;iframe src&gt;</code>。</p>\n<code-example header=\"src/app/bypass-security.component.html (iframe)\" path=\"security/src/app/bypass-security.component.html\" region=\"iframe\">\n&lt;h4&gt;Resource URL:&lt;/h4&gt;\n&lt;p&gt;Showing: {{dangerousVideoUrl}}&lt;/p&gt;\n&lt;p&gt;Trusted:&lt;/p&gt;\n&lt;iframe class=\"e2e-iframe-trusted-src\" width=\"640\" height=\"390\" [src]=\"videoUrl\" title=\"trusted video url\"&gt;&lt;/iframe&gt;\n&lt;p&gt;Untrusted:&lt;/p&gt;\n&lt;iframe class=\"e2e-iframe-untrusted-src\" width=\"640\" height=\"390\" [src]=\"dangerousVideoUrl\" title=\"unTrusted video url\"&gt;&lt;/iframe&gt;\n\n\n</code-example>\n<code-example header=\"src/app/bypass-security.component.ts (trust-video-url)\" path=\"security/src/app/bypass-security.component.ts\" region=\"trust-video-url\">\nupdateVideoUrl(id: string) {\n  // Appending an ID to a YouTube URL is safe.\n  // Always make sure to construct <a href=\"api/platform-browser/SafeValue\" class=\"code-anchor\">SafeValue</a> objects as\n  // close as possible to the input data so\n  // that it's easier to check if the value is safe.\n  this.dangerousVideoUrl = 'https://www.youtube.com/embed/' + id;\n  this.videoUrl = this.sanitizer.bypassSecurityTrustResourceUrl(this.dangerousVideoUrl);\n}\n\n</code-example>\n<p><a id=\"content-security-policy\"></a></p>\n<h3 id=\"content-security-policy\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1eltfz13cnddsz51bg1ybj0gh\">內容安全政策<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#content-security-policy\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3yha3a0e0yp41ssyn2r2dqrwg\">內容安全策略（CSP）是防止 XSS 的深度防禦技術。要啟用 CSP，請將你的 Web 伺服器設定為回傳適當的 <code>Content-Security-Policy</code> HTTP 請求頭。在 Google Developers 網站上的<a href=\"https://developers.google.com/web/fundamentals/security/csp\">《網路基礎知識》指南</a>中瞭解有關內容安全政策的更多訊息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bslsxf2yzhg8wgzrop0lc8ikc\">新版 Angular 所需的最小化策略是：</p>\n<code-example format=\"none\" language=\"none\">\n\ndefault-src 'self'; style-src 'self' 'nonce-randomNonceGoesHere'; script-src 'self' 'nonce-randomNonceGoesHere';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dzg70bbvgx0j974g97nic5ish\">在為 Angular 應用程式提供服務時，伺服器應在每個請求的 HTTP 標頭中包含一個隨機生成的隨機數。你必須向 Angular 提供此一次性隨機數（Nonce），以便框架可以渲染 <code>&lt;<a href=\"api/animations/style\" class=\"code-anchor\">style</a>&gt;</code> 元素。你可以透過以下兩種方式之一為 Angular 設定隨機數：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"afsckxdpsku2kr99mzk53pfta\">將根應用程式元素上的 <code>ngCspNonce</code> 屬性設定為 <code>&lt;app ngCspNonce=\"randomNonceGoesHere\"&gt;&lt;/app&gt;</code>。如果你可以訪問伺服器端樣板，並且可以在建立回應時將隨機數新增到標頭和 <code>index.html</code>，請使用此方法。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"do1d6c8f75q0quebsfdcko691\">使用 <code><a href=\"api/core/CSP_NONCE\" class=\"code-anchor\">CSP_NONCE</a></code> 注入令牌提供隨機數。如果你可以在執行時訪問 nonce 並且希望快取 <code>index.html</code>，請使用此方法。</li>\n</ol>\n<code-example format=\"typescript\" language=\"typescript\">\n\nimport {<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>, <a href=\"api/core/CSP_NONCE\" class=\"code-anchor\">CSP_NONCE</a>} from '@angular/core';\nimport {AppComponent} from './app/app.component';\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(AppComponent, {\n  providers: [{\n    provide: <a href=\"api/core/CSP_NONCE\" class=\"code-anchor\">CSP_NONCE</a>,\n    useValue: globalThis.myRandomNonceValue\n  }]\n});\n\n</code-example>\n<div class=\"callout is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"49di9ixdx7d2dog6ovcexc1mi\">始終確保你提供的nonce是每個請求中唯一的，並且不可預測或猜測。 如果攻擊者可以預測未來的nonce，他們可以規避CSP提供的保護措施。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"892hlnnkf9uc5w8zki3xsowvr\">如果你無法在專案中生成隨機數，則可以透過將 <code>'unsafe-inline'</code> 新增到 CSP 標頭的 <code>style-src</code> 部分來允許行內樣式。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7w88zr2vle94hg5329lphobbh\">部分</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>default-src 'self';</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8z4stnw1dzqi6uwrshh52te9p\">允許頁面從同一源載入所有必需資源。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>style-src 'self' 'nonce-randomNonceGoesHere';</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9h0jkbn7trs18pqc9a6ky7zrg\">允許頁面從同一源（\n<code>'self'</code>）載入全域樣式和由 Angular 插入的樣式，樣式中包含\n<code>nonce-randomNonceGoesHere</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>script-src 'self' 'nonce-randomNonceGoesHere';</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"mlh8ftqzl3rjs7gf2p1aimiq\">允許頁面從同一源（\n<code>'self'</code>）載入 JavaScript 和由 Angular CLI 插入的指令碼，僅在使用關鍵 CSS 行內時才需要。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ohj2vh7ow1fbfnng0nm5tpm3\">Angular 本身只需要這些設定即可正常執行。隨著專案的增長，你可能需要將 CSP 設定擴充套件出應用特有的一些額外屬性。</p>\n<p><a id=\"trusted-types\"></a></p>\n<!-- vale Angular.Google_Headings = NO -->\n<h3 id=\"enforcing-trusted-types\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24qpccceijqiefel42l3muyuj\">強制執行可信型別<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#enforcing-trusted-types\"><i class=\"material-icons\">link</i></a></h3>\n<!-- vale Angular.Google_Headings = YES -->\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gv57kivnav18jyl755i4tdg4\">建議使用<a href=\"https://w3c.github.io/webappsec-trusted-types/dist/spec\">可信型別</a>來幫助保護你的應用程式免受跨站指令碼攻擊。可信型別是一項 <a href=\"https://en.wikipedia.org/wiki/Web_platform\">Web 平台</a>功能，可透過實施更安全的編碼實踐來幫助你防範跨站指令碼攻擊。可信型別還可以幫助簡化應用程式程式碼的審計。</p>\n<div class=\"callout is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eydtsl788bxzy1ax1sj3nmced\">可信型別可能尚未在你的應用程式目標的所有瀏覽器中可用。如果啟用了可信型別的應用程式在不支援可信型別的瀏覽器中執行，應用程式的功能將被保留，並且你的應用程式將透過 Angular 的 DomSanitizer 防範 XSS。有關當前瀏覽器支援，請參閱 <a href=\"https://caniuse.com/trusted-types\">caniuse.com/trusted-types</a>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6blmcd0kc8kophbp1mez9bqgt\">要為你的應用程式強制實施可信型別，你必須將應用程式的 Web 伺服器設定為使用以下 Angular 策略之一發出 HTTP 請求頭：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dc5ntx6nv873oalnjesk83gs\">策略</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9lz2ilbl74njwyw23mw9u1v39\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>angular</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1lbrp4ch23gy0wcg42xixpvx7\">此策略用於內部 Angular 安全審查程式碼，並在強制執行受信任型別時 Angular 需要使用此策略才能正常工作。 Angular 消毒的任何行內樣板值或內容都會被此策略視為安全。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>angular#unsafe-bypass</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"860wy4630nro9oflti30b0x4o\">此策略用於使用 Angular 的任何繞過安全性的方法，如\n<code>bypassSecurityTrustHtml</code>的應用程式。 使用這些方法的任何應用程式必須啟用此策略。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>angular#unsafe-jit</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dp4qtnwtxe2nffxrcs1k05gv9\">此策略由 \n<a href=\"api/core/Compiler\">即時（JIT）編譯器</a>使用。 如果您的應用程式直接與 JIT 編譯器互動或使用\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\">平台瀏覽器動態</a>執行 JIT 模式，則必須啟用此策略。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>angular#bundler</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99sgsxxtenbjca4c9gwx0i3fa\">在建立延遲載入塊檔案時，Angular CLI 捆綁器使用此策略。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f1l9lqvtl7fc4nldszvhfxgf\">你應該在以下位置為可信型別設定 HTTP 請求頭：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cjn6e417zzmqrktunervl93v8\">生產環境基礎設施伺服器</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8t8qdgum7pcwm0p4whlmo0hor\">Angular CLI （ <code>ng serve</code> ），使用 <code>angular.json</code> 檔案中的 <code>headers</code> 屬性，用於本地開發和端到端測試</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gfe91rcupzaij53kyikz3nb8\">Karma （ <code>ng test</code> ），使用 <code>karma.config.js</code> 檔案中的 <code>customHeaders</code> 屬性，進行單元測試</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2ur8bi80ajau10fuho6maa4c\">以下是為可信型別和 Angular 設定的請求頭範例：</p>\n<code-example format=\"html\" language=\"html\">\n\nContent-Security-Policy: trusted-types angular; require-trusted-types-for 'script';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xzf39x9yob5yl342j43idm71\">以下是為可信型別和 Angular 應用程式專門設定的請求頭範例，這些應用程式使用了 Angular <a href=\"api/platform-browser/DomSanitizer\">DomSanitizer</a> 中那些可以繞過安全性的方法。</p>\n<code-example format=\"html\" language=\"html\">\n\nContent-Security-Policy: trusted-types angular angular#unsafe-bypass; require-trusted-types-for 'script';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bostv3cow9jzp7hzku3wkp6xo\">以下是使用 JIT，且專門為可信型別和 Angular 應用程式設定的請求頭範例：</p>\n<code-example format=\"html\" language=\"html\">\n\nContent-Security-Policy: trusted-types angular angular#unsafe-jit; require-trusted-types-for 'script';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2hawmv9qf7fwso9fm60erkcw5\">以下是專門為使用延遲載入模組的受信任型別和 Angular 應用程式設定的標頭範例：</p>\n<code-example language=\"html\">\n\nContent-Security-Policy: trusted-types angular angular#bundler; require-trusted-types-for 'script';\n\n</code-example>\n<div class=\"callout is-helpful\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b1q2cq0wwmtcekjucgxtiki0d\">社群貢獻</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8dhm6rm5n8ppflnajwp7jtz0j\">要了解關於如何對可信型別設定進行故障排除的更多訊息，以下資源可能會有所幫助：</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4tpjszgj9ubr5eriyu4lxkcnw\"><a href=\"https://web.dev/trusted-types/#how-to-use-trusted-types\">使用可信型別防範基於 DOM 的跨站指令碼漏洞</a></p>\n</div>\n<p><a id=\"offline-template-compiler\"></a></p>\n<h3 id=\"use-the-aot-template-compiler\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"at1xgqrrxwkmlexmulum0tbzo\">使用 AOT 樣板編譯器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#use-the-aot-template-compiler\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d9fydwzp6awt7f1p7ml3io6zb\">AOT 樣板編譯器可防止稱為樣板注入的一整類漏洞，並大大提高了應用程式效能。AOT 樣板編譯器是 Angular CLI 應用程式使用的預設編譯器，你應該在所有生產部署中使用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ezionf6omrnh4ia3oaolosw2d\">AOT 編譯器的替代方法是 JIT 編譯器，它可以在執行時將樣板編譯為瀏覽器中的可執行樣板程式碼。Angular 信任這些樣板程式碼，因此動態生成樣板並進行編譯（尤其是包含使用者資料的樣板）可以規避 Angular 的內建保護就。這是一種安全性方面的反模式。要了解如何以安全方式動態建立表單，請參見<a href=\"guide/dynamic-form\">《動態表單》</a>指南。</p>\n<p><a id=\"server-side-xss\"></a></p>\n<h3 id=\"server-side-xss-protection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvlz4wdz4hqceh72uob76jm40\">伺服器端 XSS 保護<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#server-side-xss-protection\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cjn1niod8wmhnwuxpqbnexa0\">在服務器上構造的 HTML 容易受到注入攻擊。將樣板程式碼注入到 Angular 應用程式中與注入可執行程式碼是一樣的：它使攻擊者可以完全控制該應用程式。為避免這種情況，請使用一種樣板語言來自動轉義值以防止伺服器上的 XSS 漏洞。不要在服務端使用樣板語言生成 Angular 樣板。這樣做會帶來引入樣板注入漏洞的高風險。</p>\n<p><a id=\"http\"></a></p>\n<!-- vale Angular.Google_Acronyms = NO -->\n<h2 id=\"http-level-vulnerabilities\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gwgw47mccaasw2dsst36i1sm\">HTTP 級漏洞<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#http-level-vulnerabilities\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"nsfssmrqur2grc0ksjsblqnf\">Angular 內建了一些支援來防範兩個常見的 HTTP 漏洞：跨站請求偽造（XSRF）和跨站指令碼套件含（XSSI）。這兩個漏洞主要在服務端防範，但是 Angular 也自帶了一些輔助屬性，可以讓用戶端的整合變得更容易。</p>\n<p><a id=\"xsrf\"></a></p>\n<h3 id=\"cross-site-request-forgery\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cy8edwifr6rjs8hcwx1mnxl51\">跨站請求偽造<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#cross-site-request-forgery\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4q2672rw8n9xgk0z7abceaxnn\">在跨站請求偽造（XSRF 或 CSRF）中，攻擊者欺騙使用者，讓他們訪問一個假冒頁面（比如 <code>evil.com</code>）。該頁面帶有惡意程式碼，秘密的向你的應用程式伺服器傳送惡意請求（比如 <code>example-bank.com</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1fm8l7ohox31w3mjsn2ojbvx6\">假設使用者已經在 <code>example-bank.com</code> 登入。使用者開啟一個郵件，點選裡面的連結，在新頁面中開啟 <code>evil.com</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7zknfj9jpo55jmq5q0lmzorpf\">該 <code>evil.com</code> 頁面立刻傳送惡意請求到 <code>example-bank.com</code>。這個請求可能是從使用者賬戶轉賬到攻擊者的賬戶。與該請求一起，瀏覽器自動發出 <code>example-bank.com</code> 的 cookie。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wxy92lzorbs5f85qxecoi9rr\">如果 <code>example-bank.com</code> 伺服器缺乏 XSRF 保護，就無法辨識請求是從應用程式發來的合法請求還是從 <code>evil.com</code> 來的假請求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1dml66qb0kouyok1u25e85ksh\">為了防止這種情況，你必須確保每個使用者的請求都是從你自己的應用中發出的，而不是從另一個網站發出的。用戶端和伺服器必須合作來抵擋這種攻擊。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29myblvsmbm1w5wnchp92ql62\">常見的反 XSRF 技術是伺服器隨機生成一個使用者認證令牌到 cookie 中。用戶端程式碼獲取這個 cookie，並用它為接下來所有的請求新增自定義請求頁頭。伺服器比較收到的 cookie 值與請求頁頭的值，如果它們不對應，便拒絕請求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dnf6futg5b5ur79f8d1p57hp\">這個技術之所以有效，是因為所有瀏覽器都實現了<em>同源策略</em>。只有設定 cookie 的網站的程式碼可以訪問該站的 cookie，併為該站的請求設定自定義頁頭。這就是說，只有你的應用程式可以獲取這個 cookie 令牌和設定自定義頁頭。<code>evil.com</code> 的惡意程式碼不能。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68l2mn9cufjmp3nidkgxmd5xo\">Angular的\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>內建支援此技術的用戶端部分。 在\n<a href=\"guide/http-security-xsrf-protection\">HttpClient指南</a>中瞭解更多訊息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vl591ed0td62k3rn81v0nw1s\">可到 \"開放式 Web 應用程式安全專案 （OWASP） \" 深入瞭解 CSRF，參閱<a href=\"https://owasp.org/www-community/attacks/csrf\">Cross-Site Request Forgery （CSRF）</a> 和<a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html\">Cross-Site Request Forgery （CSRF） Prevention Cheat Sheet</a>。這個斯坦福大學論文 <a href=\"https://seclab.stanford.edu/websec/csrf/csrf.pdf\">Robust Defenses for Cross-Site Request Forgery</a> 有詳盡的細節。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ezf4i5q6iytfhgo8w6lqxsrwc\">參閱 Dave Smith 在<a href=\"https://www.youtube.com/watch?v=9inczw6qtpY\" title=\"Cross Site Request Funkery Securing Your Angular Apps From Evil Doers\">AngularConnect 2016 關於 XSRF 的演講</a>。</p>\n<!-- vale Angular.Google_Acronyms = YES -->\n<p><a id=\"xssi\"></a></p>\n<h3 id=\"cross-site-script-inclusion-xssi\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3958pr5c4v9c4qookhtxxj5nu\">跨站指令碼套件含（XSSI）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#cross-site-script-inclusion-xssi\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ny1t957skgfrdqzi8n8c3fth\">跨站指令碼套件含，也被稱為 Json 漏洞，它可以允許一個攻擊者的網站從 JSON API 讀取資料。這種攻擊發生在老的瀏覽器上，它重寫原生 JavaScript 物件的建構式函式，然後使用 <code>&lt;script&gt;</code> 標籤包含一個 API 的 URL。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2abgqtwguscebfb13q6w06b10\">只有在回傳的 JSON 能像 JavaScript 一樣可以被執行時，這種攻擊才會生效。所以伺服器端會約定給所有 JSON 回應體加上字首 <code>\")]}',\\n\"</code>，來把它們標記為不可執行的，以防範這種攻擊。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1itp7dpmi27pdiyygk70131f2\">Angular 的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 函式庫會識別這種約定，並在進一步解析之前，自動把字串 <code>\")]}',\\n\"</code> 從所有回應中去掉。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0l9fstdd85lcelyt9zn0xz1w\">要學習更多這方面的知識，請參閱<a href=\"https://security.googleblog.com/2011/05/website-security-for-webmasters.html\">谷歌 Web 安全部落格文章</a>的 XSSI 小節。</p>\n<p><a id=\"code-review\"></a></p>\n<h2 id=\"auditing-angular-applications\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4pxaf1myl3liskzwckibidl08\">審計 Angular 應用程式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#auditing-angular-applications\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dm6yhzysvuy5jyqpg85avw5f\">Angular 應用應該遵循和常規 Web 應用一樣的安全原則並按照這些原則進行審計。Angular 中某些應該在安全評審中被審計的 API（比如<a href=\"guide/security#bypass-security-apis\"><em>bypassSecurityTrust</em></a> API）都在文件中被明確標記為安全性敏感的。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Tue May 16 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/architecture-next-steps\n - guide/example-apps-list\n - guide/template-overview\n - guide/template-syntax\n-->\n<!-- links from this doc:\n - api/animations/style\n - api/common/NgOptimizedImage\n - api/common/http/HttpClient\n - api/core/CSP_NONCE\n - api/core/Compiler\n - api/core/ElementRef\n - api/core/SecurityContext\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/DomSanitizer\n - api/platform-browser/DomSanitizer#sanitize\n - api/platform-browser/SafeValue\n - api/platform-browser/bootstrapApplication\n - guide/dynamic-form\n - guide/http-security-xsrf-protection\n - guide/security#angulars-cross-site-scripting-security-model\n - guide/security#auditing-angular-applications\n - guide/security#bypass-security-apis\n - guide/security#content-security-policy\n - guide/security#cross-site-request-forgery\n - guide/security#cross-site-script-inclusion-xssi\n - guide/security#direct-use-of-the-dom-apis-and-explicit-sanitization-calls\n - guide/security#enforcing-trusted-types\n - guide/security#http-level-vulnerabilities\n - guide/security#offline-template-compiler\n - guide/security#preventing-cross-site-scripting-xss\n - guide/security#sanitization-and-security-contexts\n - guide/security#sanitization-example\n - guide/security#security\n - guide/security#server-side-xss-protection\n - guide/security#trusted-types\n - guide/security#trusting-safe-values\n - guide/security#use-the-aot-template-compiler\n - https://bughunters.google.com/about/rules/6521337925468160/google-open-source-software-vulnerability-reward-program-rules\n - https://bughunters.google.com/report\n - https://caniuse.com/trusted-types\n - https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html\n - https://developers.google.com/web/fundamentals/security/csp\n - https://en.wikipedia.org/wiki/Code_injection\n - https://en.wikipedia.org/wiki/Cross-site_scripting\n - https://en.wikipedia.org/wiki/Web_platform\n - https://github.com/angular/angular/blob/main/CHANGELOG.md\n - https://owasp.org/www-community/attacks/csrf\n - https://seclab.stanford.edu/websec/csrf/csrf.pdf\n - https://security.googleblog.com/2011/05/website-security-for-webmasters.html\n - https://w3c.github.io/trusted-types/dist/spec/\n - https://web.dev/trusted-types/#how-to-use-trusted-types\n - https://www.google.com/about/appsecurity\n - https://www.owasp.org/index.php/Category:OWASP_Guide_Project\n - https://www.youtube.com/watch?v=9inczw6qtpY\n-->"}