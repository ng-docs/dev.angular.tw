{"id":"guide/security","title":"安全","contents":"<div class=\"content\">\n  <h1 id=\"security\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tmchdk1ct294f2gw8klyefyd\">安全<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#security\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9mrwrcafecguxdtsts5fw0erd\">本主题会讲述 Angular 为防范 Web 应用常见的安全漏洞和攻击（比如跨站脚本攻击）内置的保护措施，但不会涉及应用级安全，比如用户认证（<em>这个用户是谁？</em>）和授权（<em>这个用户能做什么？</em>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1bl23pvc92z5e5hqr9uvhvxd7\">要了解更多攻防信息，参阅<a href=\"https://www.owasp.org/index.php/Category:OWASP_Guide_Project\">开放式 Web 应用程序安全项目（OWASP）</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1fliytthw8ajl1jed0jtyvesz\">你可以运行<live-example></live-example>，在 Stackblitz 中试用并下载本页的代码。</p>\n<p><a id=\"report-issues\"></a></p>\n<div class=\"callout is-important\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wvo0nk9ciayfr0clbe1i4x13\">举报漏洞</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"31rvqvnpjqz0vyd35f0rs39ln\">Angular是Google的一部分 \n<a href=\"https://bughunters.google.com/about/rules/6521337925468160/google-open-source-software-vulnerability-reward-program-rules\">开源软件漏洞奖励计划</a>的一部分。 \n<a href=\"https://bughunters.google.com/report\">有关Angular的漏洞，请在 https://bughunters.google.com 提交报告</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4pheox6rw1iltrjr0f8wcs9u9\">要了解关于“谷歌如何处理安全问题”的更多信息，参阅<a href=\"https://www.google.com/about/appsecurity/\">谷歌的安全哲学</a>。</p>\n</div>\n<p><a id=\"best-practices\"></a></p>\n<div class=\"callout is-helpful\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bjllji5sr3q5uwcd3o4optfxh\">最佳实践</header>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ek8e4x2w81qq5uycuuqaae0n\">实践</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c35vmjp6jisaojypr03o3qlvk\">始终保持最新的Angular库发布</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"afit235ud49zuxvb6dx1i517v\">Angular库会定期更新，这些更新可能修复先前版本中发现的安全缺陷。查看Angular的\n<a href=\"https://github.com/angular/angular/blob/main/CHANGELOG.md\">变更日志</a>以获取与安全相关的更新。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2hztu4wvtytsfxktfi7v65xtn\">不要更改Angular的副本</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"q1j2sn52lpnldhwjozvd7oli\">私有的、定制版本的Angular往往落后于当前版本，并可能不包含重要的安全修复和增强功能。相反，与社区分享你的Angular改进并提交拉取请求。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ril7bmiak9odbyoizeminvry\">避免使用文档中标记为\"\n<em>安全风险</em>\"的Angular API</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"akkx2t19dgr70e0789n7kiim7\">有关更多信息，请参阅本页面的\n<a href=\"guide/security#bypass-security-apis\">信任安全值</a>部分。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"preventing-cross-site-scripting-xss\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b0yuw9jlyuidv1j9hn122f0s2\">防范跨站脚本（XSS）攻击<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#preventing-cross-site-scripting-xss\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ww6t4ql6ocpuo6tfghu0vcoo\"><a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">跨站脚本（XSS）</a>允许攻击者将恶意代码注入到页面中。这些代码可以偷取用户及其登录数据数据，还可以冒充用户执行操作。它是 Web 上最常见的攻击方式之一。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ethhqqayj1hgptjkhsyf8w6z\">为了防范 XSS 攻击，你必须阻止恶意代码进入 DOM。比如，如果某个攻击者能骗你把 <code>&lt;script&gt;</code> 标签插入到 DOM，就可以在你的网站上运行任何代码。除了 <code>&lt;script&gt;</code>，攻击者还可以使用很多 DOM 元素和属性来执行代码，比如 <code>&lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> alt=\"\" onerror=\"...\"&gt;</code>、<code>&lt;a href=\"javascript:...\"&gt;</code>。如果攻击者所控制的数据混进了 DOM，就会导致安全漏洞。</p>\n<h3 id=\"angulars-cross-site-scripting-security-model\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3r5tviniurmflj66uw239f5no\">Angular 的“跨站脚本安全模型”<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#angulars-cross-site-scripting-security-model\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97xohtadcqiw7xyk1g04d02by\">为了系统性的防范 XSS 问题，Angular 默认把所有值都当做不可信任的。\n当值从模板中以属性（Property）、DOM 元素属性（Attribte）、CSS 类绑定或插值等途径插入到 DOM 中的时候，\nAngular 将对这些值进行无害化处理（Sanitize），对不可信的值进行编码。如果某个值已经在 Angular 之外进行过无害化处理，可以确信是安全的，可以<a href=\"guide/security#bypass-security-apis\">把这个值标记为安全的</a>来把这一点通知 Angular。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dsiz3ikxq2gj5x1bcirtxm0j3\">与用于渲染的值不同，默认情况下，Angular 模板被认为是受信任的，应被视为可执行代码。切勿通过串联用户输入和模板语法来生成模板。这样做会使攻击者能够<a href=\"https://en.wikipedia.org/wiki/Code_injection\">将任意代码注入</a>你的应用程序。为避免这些漏洞，请始终在生产部署中<a href=\"guide/security#offline-template-compiler\">使用默认的 AOT 模板编译器。</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5r3dygto994nd4oqsy3vln6xe\">借助内容安全策略和可信类型，可以提供额外的保护层。这些 Web 平台特性会在 DOM 级别运行，这是用来防范 XSS 问题的最有效位置，因为即使使用其它低级 API 也无法绕过它们。出于这个原因，我们强烈建议开发人员通过为其应用程序配置<a href=\"guide/security#content-security-policy\">内容安全策略</a>并启用<a href=\"guide/security#trusted-types\">强制可信类型</a>来利用这些特性。</p>\n<h3 id=\"sanitization-and-security-contexts\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7xlut81nemd9ym9zi0vi9pub9\">无害化处理与安全环境<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#sanitization-and-security-contexts\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jxp468r53cng8i1s00lfhzua\">无害化处理会审查不可信的值，并将它们转换成可以安全插入到 DOM 的形式。多数情况下，这些值并不会在处理过程中发生任何变化。无害化处理的方式取决于所在的环境：一个在 CSS 里面无害的值，可能在 URL 里很危险。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ls64ghadjsvvmujq56vt3wsq\">Angular 定义了四个安全环境：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7nqo06dkmqthsrcpvth4nj8oq\">安全上下文</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">HTML</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97jlcn11j6epihbophjin0z10\">在将值解释为HTML时使用，例如，当绑定到\n<code>innerHtml</code>时。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ab6gpm47ggoqvg5dy42ycwx7f\">样式</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"22w9efwesvb04j10jbwnhr5ae\">用于将CSS绑定到\n<code><a href=\"api/animations/style\" class=\"code-anchor\">style</a></code>属性中。</td>\n</tr>\n<tr>\n<td align=\"left\">URL</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"grdd8o9bt9fmqxid48juxn5v\">用于URL属性，例如\n<code>&lt;a href&gt;</code>。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eem8q4in3t1qrsxl06xymx95y\">资源URL</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5hz5s82igj87k28lqrqbs7f3o\">作为代码加载和执行的URL，例如，在\n<code>&lt;script src&gt;</code>中。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"edktxoojrqb20uacjp4n584b7\">Angular 会对前三项中种不可信的值进行无害化处理，但不能对第四种资源 URL 进行无害化，因为它们可能包含任何代码。在开发模式下，如果在进行无害化处理时需要被迫改变一个值，Angular 就会在控制台上输出一个警告。</p>\n<h3 id=\"sanitization-example\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"365xxywjscduuegy2qfv6pr0d\">无害化范例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#sanitization-example\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cqiv9f14o3z7q4m55mbdkxunm\">下面的例子绑定了 <code>htmlSnippet</code> 的值。一次把它放进插值里，另一次把它绑定到元素的 <code>innerHTML</code> 属性上。</p>\n<code-example header=\"src/app/inner-html-binding.component.html\" path=\"security/src/app/inner-html-binding.component.html\">\n&lt;h3&gt;Binding innerHTML&lt;/h3&gt;\n&lt;p&gt;Bound value:&lt;/p&gt;\n&lt;p class=\"e2e-inner-html-interpolated\"&gt;{{htmlSnippet}}&lt;/p&gt;\n&lt;p&gt;Result of binding to innerHTML:&lt;/p&gt;\n&lt;p class=\"e2e-inner-html-bound\" [innerHTML]=\"htmlSnippet\"&gt;&lt;/p&gt;\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dl080d5r77cgzl6tfdyj3biy2\">插值的内容总会被编码 - 其中的 HTML 不会被解释，所以浏览器会在元素的文本内容中显示尖括号。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ijrsaqsggg9iib43d0mpkp3e\">如果希望这段 HTML 被正常解释，就必须绑定到一个 HTML 属性上，比如 <code>innerHTML</code>。但要小心如果把一个可能被攻击者控制的值绑定到 <code>innerHTML</code> 就会导致 XSS 漏洞。比如，某些人可以用这种方式来执行恶意代码：</p>\n<code-example header=\"src/app/inner-html-binding.component.ts (class)\" path=\"security/src/app/inner-html-binding.component.ts\" region=\"class\">\nexport class InnerHtmlBindingComponent {\n  // For example, a user/attacker-controlled value from a URL.\n  htmlSnippet = 'Template &lt;script&gt;alert(\"0wned\")&lt;/script&gt; &lt;b&gt;Syntax&lt;/b&gt;';\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"egq196mowt244uijiw6ggpklj\">Angular 认为这些值是不安全的，并自动进行无害化处理。它会移除 <code>script</code> 元素，但保留安全的内容，比如该片段中的 <code>&lt;b&gt;</code> 元素。</p>\n<div class=\"lightbox\">\n<img alt=\"A screenshot showing interpolated and bound HTML values\" src=\"generated/images/guide/security/binding-inner-html.png\" width=\"400\" height=\"114\">\n</div>\n<h3 id=\"direct-use-of-the-dom-apis-and-explicit-sanitization-calls\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qaw7j6zm95z8549eysgyt27l\">避免直接使用 DOM API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#direct-use-of-the-dom-apis-and-explicit-sanitization-calls\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1gsypvrmrbhee91m20nt96mc8\">除非你强制使用可信类型（Trusted Types），否则浏览器内置的 DOM API 不会自动保护你免受安全漏洞的侵害。比如 <code>document</code>、通过 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code> 拿到的节点和很多第三方 API，都可能包含不安全的方法。如果你使用能操纵 DOM 的其它库，也同样无法借助像 Angular 插值那样的自动清理功能。所以，要避免直接和 DOM 打交道，而是尽可能使用 Angular 模板。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"65mu3dje6lothqaafdaet28rt\">在无法避免的情况下，使用内置的 Angular 无害化处理函数。使用 <a href=\"api/platform-browser/DomSanitizer#sanitize\">DomSanitizer.sanitize</a> 方法以及适当的 <code><a href=\"api/core/SecurityContext\" class=\"code-anchor\">SecurityContext</a></code> 来对不可信的值进行无害化处理。此函数也可以接受使用 <code>bypassSecurityTrust</code> 函数标为可信的值，而且不会对它们进行无害化处理，就像<a href=\"guide/security#bypass-security-apis\">稍后讲的那样</a>。</p>\n<p><a id=\"bypass-security-apis\"></a></p>\n<h3 id=\"trusting-safe-values\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b35wkxoxu523e184hzupgjazf\">信任安全值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#trusting-safe-values\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qd92bujky5gs9jhtmnf8sa75\">有时候，应用程序确实需要包含可执行的代码，比如使用 URL 显示 <code>&lt;iframe&gt;</code>，或者构造出有潜在危险的 URL。为了防止在这种情况下被自动无害化，可以告诉 Angular，你已经审查了这个值，检查了它是怎么生成的，并确信它总是安全的。但是<strong>千万要小心</strong>！如果你信任了一个可能是恶意的值，就会在应用中引入一个安全漏洞。如果你有疑问，请找一个安全专家复查下。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"70o5hvc6kx5ood9mnu1p47jo4\">注入 <code><a href=\"api/platform-browser/DomSanitizer\" class=\"code-anchor\">DomSanitizer</a></code> 服务，然后调用下面的方法之一，你就可以把一个值标记为可信任的。</p>\n<ul>\n<li><code>bypassSecurityTrustHtml</code></li>\n<li><code>bypassSecurityTrustScript</code></li>\n<li><code>bypassSecurityTrustStyle</code></li>\n<li><code>bypassSecurityTrustUrl</code></li>\n<li><code>bypassSecurityTrustResourceUrl</code></li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bdg1g7jbv7xar6nb5app2h78e\">记住，一个值是否安全取决于它所在的环境，所以你要为这个值按预定的用法选择正确的环境。假设下面的模板需要把 <code>javascript.alert(...)</code> 方法绑定到 URL。</p>\n<code-example header=\"src/app/bypass-security.component.html (URL)\" path=\"security/src/app/bypass-security.component.html\" region=\"URL\">\n&lt;h4&gt;An untrusted URL:&lt;/h4&gt;\n&lt;p&gt;&lt;a class=\"e2e-dangerous-url\" [href]=\"dangerousUrl\"&gt;Click me&lt;/a&gt;&lt;/p&gt;\n&lt;h4&gt;A trusted URL:&lt;/h4&gt;\n&lt;p&gt;&lt;a class=\"e2e-trusted-url\" [href]=\"trustedUrl\"&gt;Click me&lt;/a&gt;&lt;/p&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a79hazri5klxaozentv622s0e\">通常，Angular 会自动无害化这个 URL 并禁止危险的代码。为了防止这种行为，可以调用 <code>bypassSecurityTrustUrl</code> 把这个 URL 值标记为一个可信任的 URL：</p>\n<code-example header=\"src/app/bypass-security.component.ts (trust-url)\" path=\"security/src/app/bypass-security.component.ts\" region=\"trust-url\">\nconstructor(private sanitizer: <a href=\"api/platform-browser/DomSanitizer\" class=\"code-anchor\">DomSanitizer</a>) {\n  // javascript: URLs are dangerous if attacker controlled.\n  // Angular sanitizes them in data binding, but you can\n  // explicitly tell Angular to trust this value:\n  this.dangerousUrl = 'javascript:alert(\"Hi there\")';\n  this.trustedUrl = sanitizer.bypassSecurityTrustUrl(this.dangerousUrl);\n\n</code-example>\n<div class=\"lightbox\">\n<img alt=\"A screenshot showing an alert box created from a trusted URL\" src=\"generated/images/guide/security/bypass-security-component.png\" width=\"454\" height=\"175\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bb2xnc7c5wvlp9qriky5jimic\">如果需要把用户输入转换为一个可信任的值，可以在组件方法中处理。下面的模板允许用户输入一个 YouTube 视频的 ID，然后把相应的视频加载到 <code>&lt;iframe&gt;</code> 中。<code>&lt;iframe src&gt;</code> 是一个“资源 URL”的安全环境，因为不可信的源码可能作为文件下载到本地，被毫无防备的用户执行。所以要调用一个组件方法来构造一个新的、可信任的视频 URL，这样 Angular 就会允许把它绑定到 <code>&lt;iframe src&gt;</code>。</p>\n<code-example header=\"src/app/bypass-security.component.html (iframe)\" path=\"security/src/app/bypass-security.component.html\" region=\"iframe\">\n&lt;h4&gt;Resource URL:&lt;/h4&gt;\n&lt;p&gt;Showing: {{dangerousVideoUrl}}&lt;/p&gt;\n&lt;p&gt;Trusted:&lt;/p&gt;\n&lt;iframe class=\"e2e-iframe-trusted-src\" width=\"640\" height=\"390\" [src]=\"videoUrl\" title=\"trusted video url\"&gt;&lt;/iframe&gt;\n&lt;p&gt;Untrusted:&lt;/p&gt;\n&lt;iframe class=\"e2e-iframe-untrusted-src\" width=\"640\" height=\"390\" [src]=\"dangerousVideoUrl\" title=\"unTrusted video url\"&gt;&lt;/iframe&gt;\n\n\n</code-example>\n<code-example header=\"src/app/bypass-security.component.ts (trust-video-url)\" path=\"security/src/app/bypass-security.component.ts\" region=\"trust-video-url\">\nupdateVideoUrl(id: string) {\n  // Appending an ID to a YouTube URL is safe.\n  // Always make sure to construct <a href=\"api/platform-browser/SafeValue\" class=\"code-anchor\">SafeValue</a> objects as\n  // close as possible to the input data so\n  // that it's easier to check if the value is safe.\n  this.dangerousVideoUrl = 'https://www.youtube.com/embed/' + id;\n  this.videoUrl = this.sanitizer.bypassSecurityTrustResourceUrl(this.dangerousVideoUrl);\n}\n\n</code-example>\n<p><a id=\"content-security-policy\"></a></p>\n<h3 id=\"content-security-policy\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1eltfz13cnddsz51bg1ybj0gh\">内容安全政策<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#content-security-policy\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3yha3a0e0yp41ssyn2r2dqrwg\">内容安全策略（CSP）是防止 XSS 的深度防御技术。要启用 CSP，请将你的 Web 服务器配置为返回适当的 <code>Content-Security-Policy</code> HTTP 请求头。在 Google Developers 网站上的<a href=\"https://developers.google.com/web/fundamentals/security/csp\">《网络基础知识》指南</a>中了解有关内容安全政策的更多信息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bslsxf2yzhg8wgzrop0lc8ikc\">新版 Angular 所需的最小化策略是：</p>\n<code-example format=\"none\" language=\"none\">\n\ndefault-src 'self'; style-src 'self' 'nonce-randomNonceGoesHere'; script-src 'self' 'nonce-randomNonceGoesHere';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dzg70bbvgx0j974g97nic5ish\">在为 Angular 应用程序提供服务时，服务器应在每个请求的 HTTP 标头中包含一个随机生成的随机数。你必须向 Angular 提供此一次性随机数（Nonce），以便框架可以渲染 <code>&lt;<a href=\"api/animations/style\" class=\"code-anchor\">style</a>&gt;</code> 元素。你可以通过以下两种方式之一为 Angular 设置随机数：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"afsckxdpsku2kr99mzk53pfta\">将根应用程序元素上的 <code>ngCspNonce</code> 属性设置为 <code>&lt;app ngCspNonce=\"randomNonceGoesHere\"&gt;&lt;/app&gt;</code>。如果你可以访问服务端模板，并且可以在构建响应时将随机数添加到标头和 <code>index.html</code>，请使用此方法。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"do1d6c8f75q0quebsfdcko691\">使用 <code><a href=\"api/core/CSP_NONCE\" class=\"code-anchor\">CSP_NONCE</a></code> 注入令牌提供随机数。如果你可以在运行时访问 nonce 并且希望缓存 <code>index.html</code>，请使用此方法。</li>\n</ol>\n<code-example format=\"typescript\" language=\"typescript\">\n\nimport {<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>, <a href=\"api/core/CSP_NONCE\" class=\"code-anchor\">CSP_NONCE</a>} from '@angular/core';\nimport {AppComponent} from './app/app.component';\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(AppComponent, {\n  providers: [{\n    provide: <a href=\"api/core/CSP_NONCE\" class=\"code-anchor\">CSP_NONCE</a>,\n    useValue: globalThis.myRandomNonceValue\n  }]\n});\n\n</code-example>\n<div class=\"callout is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"49di9ixdx7d2dog6ovcexc1mi\">始终确保你提供的nonce是每个请求中唯一的，并且不可预测或猜测。 如果攻击者可以预测未来的nonce，他们可以规避CSP提供的保护措施。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"892hlnnkf9uc5w8zki3xsowvr\">如果你无法在项目中生成随机数，则可以通过将 <code>'unsafe-inline'</code> 添加到 CSP 标头的 <code>style-src</code> 部分来允许内联样式。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7w88zr2vle94hg5329lphobbh\">部分</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>default-src 'self';</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8z4stnw1dzqi6uwrshh52te9p\">允许页面从同一源加载所有必需资源。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>style-src 'self' 'nonce-randomNonceGoesHere';</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9h0jkbn7trs18pqc9a6ky7zrg\">允许页面从同一源（\n<code>'self'</code>）加载全局样式和由 Angular 插入的样式，样式中包含\n<code>nonce-randomNonceGoesHere</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>script-src 'self' 'nonce-randomNonceGoesHere';</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"mlh8ftqzl3rjs7gf2p1aimiq\">允许页面从同一源（\n<code>'self'</code>）加载 JavaScript 和由 Angular CLI 插入的脚本，仅在使用关键 CSS 内联时才需要。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ohj2vh7ow1fbfnng0nm5tpm3\">Angular 本身只需要这些设置即可正常运行。随着项目的增长，你可能需要将 CSP 设置扩展出应用特有的一些额外特性。</p>\n<p><a id=\"trusted-types\"></a></p>\n<!-- vale Angular.Google_Headings = NO -->\n<h3 id=\"enforcing-trusted-types\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24qpccceijqiefel42l3muyuj\">强制执行可信类型<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#enforcing-trusted-types\"><i class=\"material-icons\">link</i></a></h3>\n<!-- vale Angular.Google_Headings = YES -->\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gv57kivnav18jyl755i4tdg4\">建议使用<a href=\"https://w3c.github.io/webappsec-trusted-types/dist/spec\">可信类型</a>来帮助保护你的应用程序免受跨站脚本攻击。可信类型是一项 <a href=\"https://en.wikipedia.org/wiki/Web_platform\">Web 平台</a>功能，可通过实施更安全的编码实践来帮助你防范跨站脚本攻击。可信类型还可以帮助简化应用程序代码的审计。</p>\n<div class=\"callout is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eydtsl788bxzy1ax1sj3nmced\">可信类型可能尚未在你的应用程序目标的所有浏览器中可用。如果启用了可信类型的应用程序在不支持可信类型的浏览器中运行，应用程序的功能将被保留，并且你的应用程序将通过 Angular 的 DomSanitizer 防范 XSS。有关当前浏览器支持，请参阅 <a href=\"https://caniuse.com/trusted-types\">caniuse.com/trusted-types</a>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6blmcd0kc8kophbp1mez9bqgt\">要为你的应用程序强制实施可信类型，你必须将应用程序的 Web 服务器配置为使用以下 Angular 策略之一发出 HTTP 请求头：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dc5ntx6nv873oalnjesk83gs\">策略</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9lz2ilbl74njwyw23mw9u1v39\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>angular</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1lbrp4ch23gy0wcg42xixpvx7\">此策略用于内部 Angular 安全审查代码，并在强制执行受信任类型时 Angular 需要使用此策略才能正常工作。 Angular 消毒的任何内联模板值或内容都会被此策略视为安全。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>angular#unsafe-bypass</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"860wy4630nro9oflti30b0x4o\">此策略用于使用 Angular 的任何绕过安全性的方法，如\n<code>bypassSecurityTrustHtml</code>的应用程序。 使用这些方法的任何应用程序必须启用此策略。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>angular#unsafe-jit</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dp4qtnwtxe2nffxrcs1k05gv9\">此策略由 \n<a href=\"api/core/Compiler\">即时（JIT）编译器</a>使用。 如果您的应用程序直接与 JIT 编译器交互或使用\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\">平台浏览器动态</a>运行 JIT 模式，则必须启用此策略。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>angular#bundler</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99sgsxxtenbjca4c9gwx0i3fa\">在创建延迟加载块文件时，Angular CLI 捆绑器使用此策略。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f1l9lqvtl7fc4nldszvhfxgf\">你应该在以下位置为可信类型配置 HTTP 请求头：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cjn6e417zzmqrktunervl93v8\">生产环境基础设施服务器</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8t8qdgum7pcwm0p4whlmo0hor\">Angular CLI （ <code>ng serve</code> ），使用 <code>angular.json</code> 文件中的 <code>headers</code> 属性，用于本地开发和端到端测试</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gfe91rcupzaij53kyikz3nb8\">Karma （ <code>ng test</code> ），使用 <code>karma.config.js</code> 文件中的 <code>customHeaders</code> 属性，进行单元测试</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2ur8bi80ajau10fuho6maa4c\">以下是为可信类型和 Angular 配置的请求头示例：</p>\n<code-example format=\"html\" language=\"html\">\n\nContent-Security-Policy: trusted-types angular; require-trusted-types-for 'script';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xzf39x9yob5yl342j43idm71\">以下是为可信类型和 Angular 应用程序专门配置的请求头示例，这些应用程序使用了 Angular <a href=\"api/platform-browser/DomSanitizer\">DomSanitizer</a> 中那些可以绕过安全性的方法。</p>\n<code-example format=\"html\" language=\"html\">\n\nContent-Security-Policy: trusted-types angular angular#unsafe-bypass; require-trusted-types-for 'script';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bostv3cow9jzp7hzku3wkp6xo\">以下是使用 JIT，且专门为可信类型和 Angular 应用程序配置的请求头示例：</p>\n<code-example format=\"html\" language=\"html\">\n\nContent-Security-Policy: trusted-types angular angular#unsafe-jit; require-trusted-types-for 'script';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2hawmv9qf7fwso9fm60erkcw5\">以下是专门为使用惰性加载模块的受信任类型和 Angular 应用程序配置的标头示例：</p>\n<code-example language=\"html\">\n\nContent-Security-Policy: trusted-types angular angular#bundler; require-trusted-types-for 'script';\n\n</code-example>\n<div class=\"callout is-helpful\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b1q2cq0wwmtcekjucgxtiki0d\">社区贡献</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8dhm6rm5n8ppflnajwp7jtz0j\">要了解关于如何对可信类型配置进行故障排除的更多信息，以下资源可能会有所帮助：</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4tpjszgj9ubr5eriyu4lxkcnw\"><a href=\"https://web.dev/trusted-types/#how-to-use-trusted-types\">使用可信类型防范基于 DOM 的跨站脚本漏洞</a></p>\n</div>\n<p><a id=\"offline-template-compiler\"></a></p>\n<h3 id=\"use-the-aot-template-compiler\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"at1xgqrrxwkmlexmulum0tbzo\">使用 AOT 模板编译器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#use-the-aot-template-compiler\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d9fydwzp6awt7f1p7ml3io6zb\">AOT 模板编译器可防止称为模板注入的一整类漏洞，并大大提高了应用程序性能。AOT 模板编译器是 Angular CLI 应用程序使用的默认编译器，你应该在所有生产部署中使用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ezionf6omrnh4ia3oaolosw2d\">AOT 编译器的替代方法是 JIT 编译器，它可以在运行时将模板编译为浏览器中的可执行模板代码。Angular 信任这些模板代码，因此动态生成模板并进行编译（尤其是包含用户数据的模板）可以规避 Angular 的内置保护就。这是一种安全性方面的反模式。要了解如何以安全方式动态构建表单，请参见<a href=\"guide/dynamic-form\">《动态表单》</a>指南。</p>\n<p><a id=\"server-side-xss\"></a></p>\n<h3 id=\"server-side-xss-protection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvlz4wdz4hqceh72uob76jm40\">服务端 XSS 保护<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#server-side-xss-protection\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cjn1niod8wmhnwuxpqbnexa0\">在服务器上构造的 HTML 容易受到注入攻击。将模板代码注入到 Angular 应用程序中与注入可执行代码是一样的：它使攻击者可以完全控制该应用程序。为避免这种情况，请使用一种模板语言来自动转义值以防止服务器上的 XSS 漏洞。不要在服务端使用模板语言生成 Angular 模板。这样做会带来引入模板注入漏洞的高风险。</p>\n<p><a id=\"http\"></a></p>\n<!-- vale Angular.Google_Acronyms = NO -->\n<h2 id=\"http-level-vulnerabilities\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gwgw47mccaasw2dsst36i1sm\">HTTP 级漏洞<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#http-level-vulnerabilities\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"nsfssmrqur2grc0ksjsblqnf\">Angular 内置了一些支持来防范两个常见的 HTTP 漏洞：跨站请求伪造（XSRF）和跨站脚本包含（XSSI）。这两个漏洞主要在服务端防范，但是 Angular 也自带了一些辅助特性，可以让客户端的集成变得更容易。</p>\n<p><a id=\"xsrf\"></a></p>\n<h3 id=\"cross-site-request-forgery\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cy8edwifr6rjs8hcwx1mnxl51\">跨站请求伪造<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#cross-site-request-forgery\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4q2672rw8n9xgk0z7abceaxnn\">在跨站请求伪造（XSRF 或 CSRF）中，攻击者欺骗用户，让他们访问一个假冒页面（比如 <code>evil.com</code>）。该页面带有恶意代码，秘密的向你的应用程序服务器发送恶意请求（比如 <code>example-bank.com</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1fm8l7ohox31w3mjsn2ojbvx6\">假设用户已经在 <code>example-bank.com</code> 登录。用户打开一个邮件，点击里面的链接，在新页面中打开 <code>evil.com</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7zknfj9jpo55jmq5q0lmzorpf\">该 <code>evil.com</code> 页面立刻发送恶意请求到 <code>example-bank.com</code>。这个请求可能是从用户账户转账到攻击者的账户。与该请求一起，浏览器自动发出 <code>example-bank.com</code> 的 cookie。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wxy92lzorbs5f85qxecoi9rr\">如果 <code>example-bank.com</code> 服务器缺乏 XSRF 保护，就无法辨识请求是从应用程序发来的合法请求还是从 <code>evil.com</code> 来的假请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1dml66qb0kouyok1u25e85ksh\">为了防止这种情况，你必须确保每个用户的请求都是从你自己的应用中发出的，而不是从另一个网站发出的。客户端和服务器必须合作来抵挡这种攻击。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29myblvsmbm1w5wnchp92ql62\">常见的反 XSRF 技术是服务器随机生成一个用户认证令牌到 cookie 中。客户端代码获取这个 cookie，并用它为接下来所有的请求添加自定义请求页头。服务器比较收到的 cookie 值与请求页头的值，如果它们不匹配，便拒绝请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dnf6futg5b5ur79f8d1p57hp\">这个技术之所以有效，是因为所有浏览器都实现了<em>同源策略</em>。只有设置 cookie 的网站的代码可以访问该站的 cookie，并为该站的请求设置自定义页头。这就是说，只有你的应用程序可以获取这个 cookie 令牌和设置自定义页头。<code>evil.com</code> 的恶意代码不能。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68l2mn9cufjmp3nidkgxmd5xo\">Angular的\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>内置支持此技术的客户端部分。 在\n<a href=\"guide/http-security-xsrf-protection\">HttpClient指南</a>中了解更多信息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vl591ed0td62k3rn81v0nw1s\">可到 \"开放式 Web 应用程序安全项目 （OWASP） \" 深入了解 CSRF，参阅<a href=\"https://owasp.org/www-community/attacks/csrf\">Cross-Site Request Forgery （CSRF）</a> 和<a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html\">Cross-Site Request Forgery （CSRF） Prevention Cheat Sheet</a>。这个斯坦福大学论文 <a href=\"https://seclab.stanford.edu/websec/csrf/csrf.pdf\">Robust Defenses for Cross-Site Request Forgery</a> 有详尽的细节。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ezf4i5q6iytfhgo8w6lqxsrwc\">参阅 Dave Smith 在<a href=\"https://www.youtube.com/watch?v=9inczw6qtpY\" title=\"Cross Site Request Funkery Securing Your Angular Apps From Evil Doers\">AngularConnect 2016 关于 XSRF 的演讲</a>。</p>\n<!-- vale Angular.Google_Acronyms = YES -->\n<p><a id=\"xssi\"></a></p>\n<h3 id=\"cross-site-script-inclusion-xssi\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3958pr5c4v9c4qookhtxxj5nu\">跨站脚本包含（XSSI）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#cross-site-script-inclusion-xssi\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ny1t957skgfrdqzi8n8c3fth\">跨站脚本包含，也被称为 Json 漏洞，它可以允许一个攻击者的网站从 JSON API 读取数据。这种攻击发生在老的浏览器上，它重写原生 JavaScript 对象的构造函数，然后使用 <code>&lt;script&gt;</code> 标签包含一个 API 的 URL。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2abgqtwguscebfb13q6w06b10\">只有在返回的 JSON 能像 JavaScript 一样可以被执行时，这种攻击才会生效。所以服务端会约定给所有 JSON 响应体加上前缀 <code>\")]}',\\n\"</code>，来把它们标记为不可执行的，以防范这种攻击。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1itp7dpmi27pdiyygk70131f2\">Angular 的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 库会识别这种约定，并在进一步解析之前，自动把字符串 <code>\")]}',\\n\"</code> 从所有响应中去掉。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0l9fstdd85lcelyt9zn0xz1w\">要学习更多这方面的知识，请参阅<a href=\"https://security.googleblog.com/2011/05/website-security-for-webmasters.html\">谷歌 Web 安全博客文章</a>的 XSSI 小节。</p>\n<p><a id=\"code-review\"></a></p>\n<h2 id=\"auditing-angular-applications\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4pxaf1myl3liskzwckibidl08\">审计 Angular 应用程序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#auditing-angular-applications\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dm6yhzysvuy5jyqpg85avw5f\">Angular 应用应该遵循和常规 Web 应用一样的安全原则并按照这些原则进行审计。Angular 中某些应该在安全评审中被审计的 API（比如<a href=\"guide/security#bypass-security-apis\"><em>bypassSecurityTrust</em></a> API）都在文档中被明确标记为安全性敏感的。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Tue May 16 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/architecture-next-steps\n - guide/example-apps-list\n - guide/template-overview\n - guide/template-syntax\n-->\n<!-- links from this doc:\n - api/animations/style\n - api/common/NgOptimizedImage\n - api/common/http/HttpClient\n - api/core/CSP_NONCE\n - api/core/Compiler\n - api/core/ElementRef\n - api/core/SecurityContext\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/DomSanitizer\n - api/platform-browser/DomSanitizer#sanitize\n - api/platform-browser/SafeValue\n - api/platform-browser/bootstrapApplication\n - guide/dynamic-form\n - guide/http-security-xsrf-protection\n - guide/security#angulars-cross-site-scripting-security-model\n - guide/security#auditing-angular-applications\n - guide/security#bypass-security-apis\n - guide/security#content-security-policy\n - guide/security#cross-site-request-forgery\n - guide/security#cross-site-script-inclusion-xssi\n - guide/security#direct-use-of-the-dom-apis-and-explicit-sanitization-calls\n - guide/security#enforcing-trusted-types\n - guide/security#http-level-vulnerabilities\n - guide/security#offline-template-compiler\n - guide/security#preventing-cross-site-scripting-xss\n - guide/security#sanitization-and-security-contexts\n - guide/security#sanitization-example\n - guide/security#security\n - guide/security#server-side-xss-protection\n - guide/security#trusted-types\n - guide/security#trusting-safe-values\n - guide/security#use-the-aot-template-compiler\n - https://bughunters.google.com/about/rules/6521337925468160/google-open-source-software-vulnerability-reward-program-rules\n - https://bughunters.google.com/report\n - https://caniuse.com/trusted-types\n - https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html\n - https://developers.google.com/web/fundamentals/security/csp\n - https://en.wikipedia.org/wiki/Code_injection\n - https://en.wikipedia.org/wiki/Cross-site_scripting\n - https://en.wikipedia.org/wiki/Web_platform\n - https://github.com/angular/angular/blob/main/CHANGELOG.md\n - https://owasp.org/www-community/attacks/csrf\n - https://seclab.stanford.edu/websec/csrf/csrf.pdf\n - https://security.googleblog.com/2011/05/website-security-for-webmasters.html\n - https://w3c.github.io/trusted-types/dist/spec/\n - https://web.dev/trusted-types/#how-to-use-trusted-types\n - https://www.google.com/about/appsecurity\n - https://www.owasp.org/index.php/Category:OWASP_Guide_Project\n - https://www.youtube.com/watch?v=9inczw6qtpY\n-->"}