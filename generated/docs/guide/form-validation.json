{"id":"guide/form-validation","title":"驗證表單輸入","contents":"<div class=\"content\">\n  <h1 id=\"validating-form-input\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bj26fyjitoxu8l9ytnse5nhrn\">驗證表單輸入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validating-form-input\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51ppuvd6dlw056yznt9nijcid\">透過驗證使用者輸入的準確性和完整性，可以提高整體的資料質量。該頁面顯示瞭如何從 UI 驗證使用者輸入，以及如何在回應式表單和樣板驅動表單中顯示有用的驗證訊息。</p>\n<h2 id=\"prerequisites\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e44b21uig1fakj5vcfuvz1bdu\">前提條件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#prerequisites\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"60p4gzxfubhq39l87u4itz9q2\">在閱讀表單驗證之前，你應該對這些內容有一個基本的瞭解。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bzu3w3qb66mmgbf3434pkh9sn\"><a href=\"https://www.typescriptlang.org/\" title=\"TypeScript 語言\">TypeScript</a>和 HTML5 程式設計</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b5xhj95pp4wr4e63fjqwvv5jb\"><a href=\"guide/architecture\" title=\"Angular 應用設計概念簡介\">Angular 應用設計</a>的基本概念</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bsvscaik413b3cfrbvqmzax5u\"><a href=\"guide/forms-overview\" title=\"Angular 表單簡介\">Angular 支援的兩類表單</a></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayc7bc0nluilb6wfghzu1dq73\"><a href=\"guide/forms\" title=\"樣板驅動表單指南\">樣板驅動表單</a>或<a href=\"guide/reactive-forms\" title=\"回應式表單指南\">回應式表單</a>的基礎知識</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58rakd2ypcrbkqk9sxwbblpk1\">要獲取這裡用講解表單驗證的回應式表單和樣板驅動表單的完整範例程式碼。請執行<live-example></live-example>。</p>\n</div>\n<p><a id=\"template-driven-validation\"></a></p>\n<h2 id=\"validating-input-in-template-driven-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dbkihv4jjzmuwck4huui2dk46\">在樣板驅動表單中驗證輸入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validating-input-in-template-driven-forms\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2cui13b0us5up0do8ux8ejz5g\">為了往樣板驅動表單中新增驗證機制，你要新增一些驗證屬性，就像<a href=\"https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation\">原生的 HTML 表單驗證器</a>一樣。\nAngular 會用指令來對應這些具有驗證功能的指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5magj4jokuo6qldet5fc8zc4y\">每當表單控制元件中的值發生變化時，Angular 就會進行驗證，並生成一個驗證錯誤的清單（對應著 <code>INVALID</code> 狀態）或者 null（對應著 VALID 狀態）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"23iym1j7axg1x9hy31gnr8es4\">你可以透過把 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 匯出成區域性樣板變數來檢視該控制元件的狀態。\n比如下面這個例子就把 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 匯出成了一個名叫 <code>name</code> 的變數：</p>\n<code-example header=\"template/hero-form-template.component.html (name)\" path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"name-with-error-msg\">\n&lt;input\n  type=\"text\"\n  id=\"name\"\n  name=\"name\"\n  class=\"form-control\"\n  required\n  <a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>=\"4\"\n  appForbiddenName=\"bob\"\n  [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\"\n  #name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"\n/&gt;\n\n&lt;div\n  *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.invalid &amp;&amp; (name.dirty || name.touched)\"\n  class=\"alert\"\n&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['required']\"&gt;Name is required.&lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['<a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>']\"&gt;\n    Name must be at least 4 characters long.\n  &lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['forbiddenName']\"&gt;\n    Name cannot be Bob.\n  &lt;/div&gt;\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94l08uixa1k9s9zevdi3k04kz\">注意這個例子講解的如下屬性。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78ixou4qg90qh2rgvm4ep4s0i\"><code>&lt;input&gt;</code> 元素帶有一些 HTML 驗證屬性：<code>required</code> 和 <code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>。它還帶有一個自定義的驗證器指令 <code>forbiddenName</code>。欲知詳情，參閱<a href=\"guide/form-validation#custom-validators\">自定義驗證器</a>一節。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b83dufuyz4ve5q7y5mxkrm2d5\"><code>#name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"</code> 把 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 匯出成了一個名叫 <code>name</code> 的區域性變數。<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 把自己控制的 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例的屬性對映出去，讓你能在樣板中檢查控制元件的狀態，比如 <code>valid</code> 和 <code>dirty</code>。要了解完整的控制元件屬性，參閱 API 參考手冊中的<a href=\"api/forms/AbstractControl\">AbstractControl</a>。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8i92nxpgp8imtarxjfu4n6iw6\"><code>&lt;div&gt;</code> 元素的 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 展示了一組巢狀的訊息 <code>div</code>，但是只在有『name』錯誤和控制器為 <code>dirty</code> 或者 <code>touched</code> 時才出現。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"62ae0ichxaes90wsufw9mwzxz\">每個巢狀的 <code>&lt;div&gt;</code> 為其中一個可能出現的驗證錯誤顯示一條自定義訊息。比如 <code>required</code>、<code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code> 和 <code>forbiddenName</code>。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><a id=\"dirty-or-touched\"></a></p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4y0a4ns7d9q7wsmsh860bto2k\">為防止驗證程式在使用者有機會編輯表單之前就顯示錯誤，你應該檢查控制元件的 <code>dirty</code> 狀態或 <code>touched</code> 狀態。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26wc1ws2d6feqar5hci39idbd\">當用戶在被監視的欄位中修改該值時，控制元件就會被標記為 <code>dirty</code>（髒）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jkh7bj1v9skeyq9ofod5arf4\">當用戶的表單控制元件失去焦點時，該控制元件就會被標記為 <code>touched</code>（已接觸）</li>\n</ul>\n</div>\n<p><a id=\"reactive-form-validation\"></a></p>\n<h2 id=\"validating-input-in-reactive-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"du18fhr2olw0m3u6uqtp5sx71\">在回應式表單中驗證輸入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validating-input-in-reactive-forms\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"duq6cyr85xttgw86wwomwooea\">在回應式表單中，事實之源是其元件類別。不應該透過樣板上的屬性來新增驗證器，而應該在元件類別中直接把驗證器函式新增到表單控制元件模型上（<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code>）。然後，一旦控制元件發生了變化，Angular 就會呼叫這些函式。</p>\n<h3 id=\"validator-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amf6d696khzdbvd2xpvhh26ly\">驗證器（Validator）函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validator-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"34hgwf1yk4ec4ywdycujf02c2\">驗證器函式可以是同步函式，也可以是非同步函式。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"82i7dvenvfj5p8di6db66t0kz\">驗證器型別</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e7wuhqwfs6pereev4zssztnpe\">同步驗證器</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"47ef9l9xo2aa3yd830gatyvg7\">立即接受一個控制元件實例並回傳一組驗證錯誤或\n<code>null</code>的同步函式。在實例化\n<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code>時將其作為第二個引數傳入。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6nzklv7afq05vys55yuubb34c\">非同步驗證器</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43pbp224loheuez8qaueqsy53\">接受一個控制元件實例並回傳一個後來會發出一組驗證錯誤或\n<code>null</code>的 Promise 或 Observable 的非同步函式。在實例化\n<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code>時將其作為第三個引數傳入。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2uudkg3ldpu84yrbwnyf2zj4c\">出於效能方面的考慮，只有在所有同步驗證器都透過之後，Angular 才會執行非同步驗證器。當每一個非同步驗證器都執行完之後，才會設定這些驗證錯誤。</p>\n<h3 id=\"built-in-validator-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bims18gn3avu2ay176kkt0q0w\">內建驗證器函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#built-in-validator-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"52zq2k4a58xjka04ip62m1631\">你可以選擇<a href=\"guide/form-validation#custom-validators\">編寫自己的驗證器函式</a>，也可以使用 Angular 的一些內建驗證器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jp615m3zfdily49bggdx9m5y\">在樣板驅動表單中用作屬性的那些內建驗證器，比如 <code>required</code> 和 <code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>，也都可以作為 <code><a href=\"api/forms/Validators\" class=\"code-anchor\">Validators</a></code> 類別中的函式使用。關於內建驗證器的完整清單，參閱 API 參考手冊中的<a href=\"api/forms/Validators\">驗證器</a>部分。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9a9oq9rrkk4matevlhwzilyvm\">要想把這個英雄表單改造成一個回應式表單，還是要用那些內建驗證器，但這次改為用它們的函式形態。參閱下面的例子。</p>\n<p><a id=\"reactive-component-class\"></a></p>\n<code-example header=\"reactive/hero-form-reactive.component.ts (validator functions)\" path=\"form-validation/src/app/reactive/hero-form-reactive.component.1.ts\" region=\"form-group\">\nngOnInit(): void {\n  this.heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n    name: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.name, [\n      Validators.required,\n      Validators.minLength(4),\n      forbiddenNameValidator(/bob/i), // &lt;-- Here's how you pass in the custom validator.\n    ]),\n    alterEgo: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.alterEgo),\n    power: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.power, Validators.required),\n  });\n}\n\nget name() {\n  return this.heroForm.get('name');\n}\n\nget power() {\n  return this.heroForm.get('power');\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ci9z4xeplv4a69mrmv61xnvm3\">在這個例子中，<code>name</code> 控制元件設定了兩個內建驗證器 - <code>Validators.required</code> 和 <code>Validators.minLength(4)</code> 以及一個自定義驗證器 <code>forbiddenNameValidator</code>。（欲知詳情，參閱下面的<a href=\"guide/form-validation#custom-validators\">自定義驗證器</a>部分。）</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dcb6il8ls9h0qqn7izygeavgl\">所有這些驗證器都是同步的，所以它們作為第二個引數傳遞。注意，你可以透過把這些函式放到一個陣列中傳入來支援多個驗證器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1349joww93wq568y1doo60sm1\">這個例子還新增了一些 getter 方法。在回應式表單中，你通常會通過它所屬的控制元件群組（FormGroup）的 <code>get</code> 方法來訪問表單控制元件，但有時候為樣板定義一些 getter 作為簡短形式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bpm3fq0bqpsy5kzdang8fjfrd\">如果你到樣板中找到 <code>name</code> 輸入框，就會發現它和樣板驅動的例子很相似。</p>\n<code-example header=\"reactive/hero-form-reactive.component.html (name with error msg)\" path=\"form-validation/src/app/reactive/hero-form-reactive.component.html\" region=\"name-with-error-msg\">\n&lt;input\n  type=\"text\"\n  id=\"name\"\n  class=\"form-control\"\n  <a href=\"api/forms/FormControlName\" class=\"code-anchor\">formControlName</a>=\"name\"\n  required\n/&gt;\n\n&lt;div\n  *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.invalid &amp;&amp; (name.dirty || name.touched)\"\n  class=\"alert alert-danger\"\n&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['required']\"&gt;Name is required.&lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['<a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>']\"&gt;\n    Name must be at least 4 characters long.\n  &lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['forbiddenName']\"&gt;\n    Name cannot be Bob.\n  &lt;/div&gt;\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91p2gbyo663ur58xr0ssd6g\">這個表單與樣板驅動的版本不同，它不再匯出任何指令。相反，它使用元件類別中定義的 <code>name</code> 讀取器（getter）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91sa78qntwggw9waho53u2ixl\">請注意，\n<code>required</code>屬性仍然存在於樣板中。雖然它對於驗證不是必需的，但應為無障礙目的保留它。</p>\n<p><a id=\"custom-validators\"></a></p>\n<h2 id=\"defining-custom-validators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3t2lod2adzkf2j35tv9vkpxxo\">定義自定義驗證器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#defining-custom-validators\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a9a1an41xm2g5inzx26e3ri4e\">內建的驗證器並不是總能精確對應應用中的用例，因此有時你需要建立一個自定義驗證器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cyas5gek4grn4bqq85gkl2d5\">考慮前面的<a href=\"guide/form-validation#reactive-component-class\">回應式式表單中</a>的 <code>forbiddenNameValidator</code> 函式。該函式的定義如下。</p>\n<code-example header=\"shared/forbidden-name.directive.ts (forbiddenNameValidator)\" path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"custom-validator\">\n/** A hero's name can't match the given regular expression */\nexport function forbiddenNameValidator(nameRe: RegExp): <a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a> {\n  return (control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): <a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null =&gt; {\n    const forbidden = nameRe.test(control.value);\n    return forbidden ? { forbiddenName: { value: control.value } } : null;\n  };\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bi28130d3ui3ql1x13gypsapa\">這個函式是一個工廠，它接受一個用來檢測指定名字是否已被停用的正則表示式，並回傳一個驗證器函式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xrmkjrjf3jluwzuoao5sqzbo\">在本例中，禁止的名字是『bob』；\n驗證器會拒絕任何帶有『bob』的英雄名字。\n在其它地方，只要設定的正則表示式可以對應上，它可能拒絕『alice』或者任何其它名字。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5kztweoain277b3rgnug66x8r\"><code>forbiddenNameValidator</code> 工廠函式回傳設定好的驗證器函式。\n該函式接受一個 Angular 控制元件物件，並在控制元件值有效時回傳 null，或無效時回傳驗證錯誤物件。\n驗證錯誤物件通常有一個屬性，其屬性名（<code>'forbiddenName'</code>）是驗證的鍵名，其值為一個任意值字典，你可以用來插入錯誤訊息（<code>{name}</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ltloli20i6wr3xhtf2a2ulw7\">自定義非同步驗證器和同步驗證器很像，只是它們必須回傳一個稍後會輸出 null 或『驗證錯誤物件』的承諾（Promise）或可觀察物件，如果是可觀察物件，那麼它必須在某個時間點被完成（complete），那時候這個表單就會使用它輸出的最後一個值作為驗證結果。（譯註：HTTP 服務是自動完成的，但是某些自定義的可觀察物件可能需要手動呼叫 complete 方法）</p>\n<p><a id=\"adding-to-reactive-forms\"></a></p>\n<h3 id=\"adding-custom-validators-to-reactive-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"87mg3i59lghrl409j005lr6rx\">把自定義驗證器新增到回應式表單中<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-custom-validators-to-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1x35hhfwzkz6jvq3ejzexw6yl\">在回應式表單中，透過直接把該函式傳給 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 來新增自定義驗證器。</p>\n<code-example header=\"reactive/hero-form-reactive.component.ts (validator functions)\" path=\"form-validation/src/app/reactive/hero-form-reactive.component.1.ts\" region=\"custom-validator\">\nthis.heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n  name: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.name, [\n    Validators.required,\n    Validators.minLength(4),\n    forbiddenNameValidator(/bob/i), // &lt;-- Here's how you pass in the custom validator.\n  ]),\n  alterEgo: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.alterEgo),\n  power: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.power, Validators.required),\n});\n\n</code-example>\n<p><a id=\"adding-to-template-driven-forms\"></a></p>\n<h3 id=\"adding-custom-validators-to-template-driven-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayx63any6vp2jdglbgisl5sqc\">為樣板驅動表單中新增自定義驗證器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-custom-validators-to-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4zap7cjedwav6mg9qfi1dxdpl\">在樣板驅動表單中，要為樣板新增一個指令，該指令包含了 validator 函式。比如，對應的 <code>ForbiddenValidatorDirective</code> 用作 <code>forbiddenNameValidator</code> 的套件裝器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9z93zl8hvcln8lznih5lnzmsy\">Angular 在驗證過程中會識別出該指令的作用，因為該指令把自己註冊成了 <code><a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a></code> 提供者，如下例所示。<code><a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a></code> 是一個帶有可擴充套件驗證器集合的預定義提供者。</p>\n<code-example header=\"shared/forbidden-name.directive.ts (providers)\" path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"directive-providers\">\nproviders: [\n  {\n    provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>,\n    useExisting: ForbiddenValidatorDirective,\n    multi: true,\n  },\n],\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"386n9u0l799z7p49c5qd15b7t\">然後該指令類實現了 <code><a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a></code> 介面，以便它能簡單的與 Angular 表單整合在一起。這個指令的其餘部分有助於你理解它們是如何協作的：</p>\n<code-example header=\"shared/forbidden-name.directive.ts (directive)\" path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"directive\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appForbiddenName]',\n  providers: [\n    {\n      provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>,\n      useExisting: ForbiddenValidatorDirective,\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class ForbiddenValidatorDirective implements <a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appForbiddenName') forbiddenName = '';\n\n  validate(control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): <a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null {\n    return this.forbiddenName\n      ? forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control)\n      : null;\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhquk7538vcvgngkk9r9m5he1\">一旦 <code>ForbiddenValidatorDirective</code> 寫好了，你只要把 <code>forbiddenName</code> 選擇器新增到輸入框上就可以啟用這個驗證器了。比如：</p>\n<code-example header=\"template/hero-form-template.component.html (forbidden-name-input)\" path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"name-input\">\n&lt;input\n  type=\"text\"\n  id=\"name\"\n  name=\"name\"\n  class=\"form-control\"\n  required\n  <a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>=\"4\"\n  appForbiddenName=\"bob\"\n  [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\"\n  #name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"\n/&gt;\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amqtbqqph0pj63b6rnf9ruo2\">注意，自定義驗證指令是用 <code>useExisting</code> 而不是 <code>useClass</code> 來實例化的。註冊的驗證程式必須是 <code>ForbiddenValidatorDirective</code> <em>實例本身</em> - 表單中的實例，也就是表單中 <code>forbiddenName</code> 屬性被繫結到了\"bob\"的那個。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f3kbuz9h1icarmak3k49xw4dg\">如果用 <code>useClass</code> 來代替 <code>useExisting</code>，就會註冊一個新的類別實例，而它是沒有 <code>forbiddenName</code> 的。</p>\n</div>\n<h2 id=\"control-status-css-classes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a22sgpj699qql2r1ygca7zu05\">表示控制元件狀態的 CSS 類<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#control-status-css-classes\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6gwuz687fz490vx6kyo2b8884\">Angular 會自動把很多控制元件屬性作為 CSS 類對映到控制元件所在的元素上。你可以使用這些類來根據表單狀態給表單控制元件元素新增樣式。目前支援下列類：</p>\n<ul>\n<li><code>.ng-valid</code></li>\n<li><code>.ng-invalid</code></li>\n<li><code>.ng-pending</code></li>\n<li><code>.ng-pristine</code></li>\n<li><code>.ng-dirty</code></li>\n<li><code>.ng-untouched</code></li>\n<li><code>.ng-touched</code></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"22c97js42v789ykdpvpwn0qd3\"><code>.ng-submitted</code>（只對 form 元素新增）</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ffyhm1dshqmlla53enozdy01\">在下面的例子中，這個英雄表單使用 <code>.ng-valid</code> 和 <code>.ng-invalid</code> 來設定每個表單控制元件的邊框顏色。</p>\n<code-example header=\"forms.css (status classes)\" path=\"form-validation/src/assets/forms.css\">\n\n.ng-valid[required], .ng-valid.required  {\n  border-left: 5px solid #42A948; /* green */\n}\n\n.ng-invalid:not(form)  {\n  border-left: 5px solid #a94442; /* red */\n}\n\n.alert div {\n  background-color: #fed3d3;\n  color: #820000;\n  padding: 1rem;\n  margin-bottom: 1rem;\n}\n\n.form-group {\n  margin-bottom: 1rem;\n}\n\nlabel {\n  display: block;\n  margin-bottom: .5rem;\n}\n\nselect {\n  width: 100%;\n  padding: .5rem;\n}\n\n\n</code-example>\n<h2 id=\"cross-field-validation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9q8bc1s6dc4lp6njff6wl5mvy\">跨欄位交叉驗證<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#cross-field-validation\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crjbaxjktxni568ipgrhtmfby\">跨欄位交叉驗證器是一種<a href=\"guide/form-validation#custom-validators\" title=\"閱讀自定義驗證器\">自定義驗證器</a>，可以對錶單中不同欄位的值進行比較，並針對它們的組合進行接受或拒絕。比如，你可能有一個提供互不相容選項的表單，以便讓使用者選擇 A 或 B，而不能兩者都選。某些欄位值也可能依賴於其它值；使用者可能只有當選擇了 A 之後才能選擇 B。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ktokn5pujzeav7zhqlx3yoao\">下列交叉驗證的例子說明了如何進行如下操作：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aohhs6rp79tuq1v7fhg193epa\">根據兩個兄弟控制元件的值驗證回應式表單或樣板驅動表單的輸入，</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qld11rh7x2gya1ywkz3fn2yy\">當用戶與表單互動過，且驗證失敗後，就會顯示描述性的錯誤訊息。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8l489bjir6sflj3pm411ksk22\">這些例子使用了交叉驗證，以確保英雄們不會透過填寫 Hero 表單來暴露自己的真實身份。驗證器會通過檢查英雄的名字和第二人格是否對應來做到這一點。</p>\n<h3 id=\"adding-cross-validation-to-reactive-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f8p2e0p8pyoo3egrzuy4ca15\">為回應式表單新增交叉驗證<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-cross-validation-to-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dfl51r12ritfc5yaz8ts817wd\">該表單具有以下結構：</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n  'name': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'alterEgo': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'power': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>()\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4lrhpxk7ell7i66ht7nm7s3lf\">注意，<code>name</code> 和 <code>alterEgo</code> 是兄弟控制元件。要想在單個自定義驗證器中計算這兩個控制元件，你就必須在它們共同的祖先控制元件中執行驗證：<code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code>。你可以在 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 中查詢它的子控制元件，從而讓你能比較它們的值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"br4bfa42eurzl2fb8tak01kg0\">要想給 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 新增驗證器，就要在建立時把一個新的驗證器傳給它的第二個引數。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n  'name': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'alterEgo': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'power': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>()\n}, { validators: identityRevealedValidator });\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"60a4vq9w9dfr6rzet9nx2exxe\">驗證器的程式碼如下。</p>\n<code-example header=\"shared/identity-revealed.directive.ts\" path=\"form-validation/src/app/shared/identity-revealed.directive.ts\" region=\"cross-validation-validator\">\n/** A hero's name can't match the hero's alter ego */\nexport const identityRevealedValidator: <a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a> = (\n  control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>,\n): <a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null =&gt; {\n  const name = control.get('name');\n  const alterEgo = control.get('alterEgo');\n\n  return name &amp;&amp; alterEgo &amp;&amp; name.value === alterEgo.value\n    ? { identityRevealed: true }\n    : null;\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1w70nnkilvvrqy4s9nvhviw8e\">這個 <code>identity</code> 驗證器實現了 <code><a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a></code> 介面。它接收一個 Angular 表單控制元件物件作為引數，當表單有效時，它回傳一個 null，否則回傳 <code><a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a></code> 物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ijaf8zpdohah7mltza7nswkv\">該驗證器透過呼叫 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 的 <a href=\"api/forms/AbstractControl#get\">get</a> 方法來檢索這些子控制元件，然後比較 <code>name</code> 和 <code>alterEgo</code> 控制元件的值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4h6nffdpck2stzcphhoyjw04q\">如果值不對應，則 hero 的身份保持秘密，兩者都有效，且 validator 回傳 null。如果對應，就說明英雄的身份已經暴露了，驗證器必須透過回傳一個錯誤物件來把這個表單標記為無效的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4j36i4svvistox1xi04lrgke4\">為了提供更好的使用者體驗，當表單無效時，樣板還會顯示一條恰當的錯誤訊息。</p>\n<code-example header=\"reactive/hero-form-template.component.html\" path=\"form-validation/src/app/reactive/hero-form-reactive.component.html\" region=\"cross-validation-error-message\">\n&lt;div\n  *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"\n    heroForm.errors?.['identityRevealed'] &amp;&amp;\n    (heroForm.touched || heroForm.dirty)\n  \"\n  class=\"cross-validation-error-message alert alert-danger\"\n&gt;\n  Name cannot match alter ego.\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9n5k3chs2zjal3vf7202iy1vq\">如果 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 中有一個由 <code>identityRevealed</code> 驗證器回傳的交叉驗證錯誤，<code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 就會顯示錯誤，但只有當該使用者已經<a href=\"guide/form-validation#dirty-or-touched\">與表單進行過互動</a>的時候才顯示。</p>\n<h3 id=\"adding-cross-validation-to-template-driven-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"befoa6xj926n609b9ihppm0hp\">為樣板驅動表單新增交叉驗證<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-cross-validation-to-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cbhafi245bh4xzxxugbxxo4dp\">對於樣板驅動表單，你必須建立一個指令來包裝驗證器函式。你可以使用<a href=\"guide/form-validation#adding-to-template-driven-forms\" title=\"瞭解如何提供驗證器\"><code>NG_VALIDATORS</code> 令牌</a>來把該指令提供為驗證器，如下例所示。</p>\n<code-example header=\"shared/identity-revealed.directive.ts\" path=\"form-validation/src/app/shared/identity-revealed.directive.ts\" region=\"cross-validation-directive\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appIdentityRevealed]',\n  providers: [\n    {\n      provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>,\n      useExisting: IdentityRevealedValidatorDirective,\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class IdentityRevealedValidatorDirective implements <a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a> {\n  validate(control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): <a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null {\n    return identityRevealedValidator(control);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91evp1jl23mbsg0vnubaoumle\">你必須把這個新指令新增到 HTML 樣板中。由於驗證器必須註冊在表單的最高層，因此下列樣板會把該指令放在 <code>form</code> 標籤上。</p>\n<code-example header=\"template/hero-form-template.component.html\" path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"cross-validation-register-validator\">\n&lt;form #heroForm=\"<a href=\"api/forms/NgForm\" class=\"code-anchor\">ngForm</a>\" appIdentityRevealed&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5087lmja6dkip06nqjvsmxg54\">為了提供更好的使用者體驗，當表單無效時，我們要顯示一個恰當的錯誤訊息。</p>\n<code-example header=\"template/hero-form-template.component.html\" path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"cross-validation-error-message\">\n&lt;div\n  *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"\n    heroForm.errors?.['identityRevealed'] &amp;&amp;\n    (heroForm.touched || heroForm.dirty)\n  \"\n  class=\"cross-validation-error-message alert\"\n&gt;\n  Name cannot match alter ego.\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1uckgqpdzo61c0amns3msb668\">這在樣板驅動表單和回應式表單中都是一樣的。</p>\n<h2 id=\"creating-asynchronous-validators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ab360yrsxcqh7wvgxltku3obb\">建立非同步驗證器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#creating-asynchronous-validators\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"23pr6vyqfr3f1kk8hruajuk2f\">非同步驗證器實現了 <code><a href=\"api/forms/AsyncValidatorFn\" class=\"code-anchor\">AsyncValidatorFn</a></code> 和 <code><a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a></code> 介面。它們與其同步版本非常相似，但有以下不同之處。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ftz9vjrnff3ebgdby4720mm6\"><code>validate()</code> 函式必須回傳一個 Promise 或可觀察物件，</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b74vrzrnq0t7jfgg4szraxqy\">回傳的可觀察物件必須是有盡的，這意味著它必須在某個時刻完成（complete）。要把無盡的可觀察物件轉換成有盡的，可以在通道中加入過濾運算子，比如 <code>first</code>、<code>last</code>、<code>take</code> 或 <code>takeUntil</code>。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jun0frqvwdnfpf4bhv531ypz\">非同步驗證在同步驗證完成後才會發生，並且只有在同步驗證成功時才會執行。如果更基本的驗證方法已經發現了無效輸入，那麼這種檢查順序就可以讓表單避免使用昂貴的非同步驗證流程（比如 HTTP 請求）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3peq983pp18xyzuiowvngqcz4\">非同步驗證開始之後，表單控制元件就會進入 <code>pending</code> 狀態。可以檢查控制元件的 <code>pending</code> 屬性，並用它來給出對驗證中的視覺反饋。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4o3u25dd0vxfoalvtyht6n0vf\">一種常見的 UI 模式是在執行非同步驗證時顯示 Spinner（轉輪）。下面的例子展示了如何在樣板驅動表單中實現這一點。</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"name\" #<a href=\"api/core/model\" class=\"code-anchor\">model</a>=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\" appSomeAsyncValidator&gt;\n&lt;app-spinner *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"model.pending\"&gt;&lt;/app-spinner&gt;\n\n</code-example>\n<h3 id=\"implementing-a-custom-async-validator\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43u236xu5itxwr6kvoyjpvapr\">實現自定義非同步驗證器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#implementing-a-custom-async-validator\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccs9pb1jldw9jkm11opqq8ics\">在下面的例子中，非同步驗證器可以確保英雄們選擇了一個尚未採用的第二人格。新英雄不斷湧現，老英雄也會離開，所以無法提前找到可用的人格清單。為了驗證潛在的第二人格條目，驗證器必須啟動一個非同步操作來查詢包含所有在編英雄的中央資料庫。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wvtbjyity30tpj6ee5x3mw40\">下面的程式碼建立了一個驗證器類 <code>UniqueAlterEgoValidator</code>，它實現了 <code><a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a></code> 介面。</p>\n<code-example path=\"form-validation/src/app/shared/alter-ego.directive.ts\" region=\"async-validator\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({ providedIn: 'root' })\nexport class UniqueAlterEgoValidator implements <a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a> {\n  constructor(private heroesService: HeroesService) {}\n\n  validate(control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): Observable&lt;<a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null&gt; {\n    return this.heroesService.isAlterEgoTaken(control.value).pipe(\n      map((isTaken) =&gt; (isTaken ? { uniqueAlterEgo: true } : null)),\n      catchError(() =&gt; of(null)),\n    );\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"apygo24rl1mufes9z24aqr8vc\">建構式函式中注入了 <code>HeroesService</code>，它定義了如下介面。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\ninterface HeroesService {\n  isAlterEgoTaken: (alterEgo: string) =&gt; Observable&lt;boolean&gt;;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dk6g897yyuzu4dh0pmp6qhz5r\">在真實的應用中，<code>HeroesService</code> 會負責向英雄資料函式庫發起一個 HTTP 請求，以檢查該第二人格是否可用。\n從該驗證器的視角看，此服務的具體實現無關緊要，所以這個例子僅僅針對 <code>HeroesService</code> 介面來寫實現代碼。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3oorawcofadz72k25frg5rnij\">當驗證開始的時候，<code>UniqueAlterEgoValidator</code> 把任務委託給 <code>HeroesService</code> 的 <code>isAlterEgoTaken()</code> 方法，並傳入當前控制元件的值。這時候，該控制元件會被標記為 <code>pending</code> 狀態，直到 <code>validate()</code> 方法所回傳的可觀察物件完成（complete）了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aa7ksqpdux181bpo6e2c85eny\"><code>isAlterEgoTaken()</code> 方法會排程一個 HTTP 請求來檢查第二人格是否可用，並回傳 <code>Observable&lt;boolean&gt;</code> 作為結果。<code>validate()</code> 方法透過 <code>map</code> 運算子來對回應物件進行通道化處理，並把它轉換成驗證結果。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"djw5rjsq56ha2b34b84i3h8oy\">與任何驗證器一樣，如果表單有效，該方法回傳 <code>null</code>，如果無效，則回傳 <code><a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a></code>。這個驗證器使用 <code>catchError</code> 運算子來處理任何潛在的錯誤。在這個例子中，驗證器將 <code>isAlterEgoTaken()</code> 錯誤視為成功的驗證，因為未能發出驗證請求並不一定意味著這個第二人格無效。你也可以用不同的方式處理這種錯誤，比如回傳 <code>ValidationError</code> 物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9djywv3wtg6bnwezi8hd0auuo\">一段時間過後，這條可觀察物件鏈完成，非同步驗證也就完成了。<code>pending</code> 標誌位也設定為 <code>false</code>，該表單的有效性也已更新。</p>\n<h3 id=\"adding-async-validators-to-reactive-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cdo4hz1rwj9fkis2lh110nucl\">將非同步驗證器新增到回應式表單<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-async-validators-to-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66wmkr0y8vof68v67dym7nd4n\">要以回應式表單使用非同步驗證器，請首先將驗證器注入元件類別的建構式函式。</p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.2.ts\" region=\"async-validator-inject\">\nconstructor(private alterEgoValidator: UniqueAlterEgoValidator) {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ag6gr9wkkwv70jzm4qs0f2u8h\">然後，將驗證器函式直接傳遞給 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 以應用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4vs8t54hy64gq7oqt7et35hnu\">在以下範例中，<code>UniqueAlterEgoValidator</code> 的 <code>validate</code> 函式將其傳遞給控制元件的 <code>asyncValidators</code> 選項並將其繫結到注入到 <code>HeroFormReactiveComponent</code> 中的 <code>UniqueAlterEgoValidator</code> 實例，最終將其應用於 <code>alterEgoControl</code>。<code>asyncValidators</code> 的值可以是單個非同步驗證器函式，也可以是函式陣列。要了解有關 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 選項的更多訊息，參閱<a href=\"api/forms/AbstractControlOptions\">AbstractControlOptions</a> API 參考。</p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.2.ts\" region=\"async-validator-usage\">\nconst alterEgoControl = new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('', {\n  asyncValidators: [\n    this.alterEgoValidator.validate.bind(this.alterEgoValidator),\n  ],\n  updateOn: 'blur',\n});\n\n</code-example>\n<h3 id=\"adding-async-validators-to-template-driven-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7x6cdftbus1shbq2sd7gj02qy\">將非同步驗證器新增到樣板驅動表單<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-async-validators-to-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9l79i8oni5ctf4mrusm7fwn8j\">要在樣板驅動表單中使用非同步驗證器，請建立一個新指令並在其上註冊 <code><a href=\"api/forms/NG_ASYNC_VALIDATORS\" class=\"code-anchor\">NG_ASYNC_VALIDATORS</a></code> 提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amjyw5lx8pl8go43anloj7tuo\">在下面的範例中，該指令注入包含實際驗證邏輯的 <code>UniqueAlterEgoValidator</code> 類，並在應該進行驗證時由 Angular 觸發的 <code>validate</code> 函式中呼叫它。</p>\n<code-example path=\"form-validation/src/app/shared/alter-ego.directive.ts\" region=\"async-validator-directive\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appUniqueAlterEgo]',\n  providers: [\n    {\n      provide: <a href=\"api/forms/NG_ASYNC_VALIDATORS\" class=\"code-anchor\">NG_ASYNC_VALIDATORS</a>,\n      useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; UniqueAlterEgoValidatorDirective),\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class UniqueAlterEgoValidatorDirective implements <a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a> {\n  constructor(private validator: UniqueAlterEgoValidator) {}\n\n  validate(control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): Observable&lt;<a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null&gt; {\n    return this.validator.validate(control);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66wd5dgdz0xtmeua4csg4ujp5\">然後，與使用同步驗證器一樣，將指令的選擇器新增到輸入以啟用它。</p>\n<code-example header=\"template/hero-form-template.component.html (unique-alter-ego-input)\" path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"alterEgo-input\">\n&lt;input\n  type=\"text\"\n  id=\"alterEgo\"\n  name=\"alterEgo\"\n  #alterEgo=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"\n  [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.alterEgo\"\n  [ngModelOptions]=\"{ updateOn: 'blur' }\"\n  appUniqueAlterEgo\n/&gt;\n\n</code-example>\n<h3 id=\"optimizing-performance-of-async-validators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gj9ccjmjj25izq58bzsqxsej\">最佳化非同步驗證器的效能<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#optimizing-performance-of-async-validators\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bvj9tyk4rcpl1rr5f10zt9avw\">預設情況下，所有驗證程式在每次表單值更改後都會執行。對於同步驗證器，這通常不會對應用效能產生明顯的影響。但是，非同步驗證器通常會執行某種 HTTP 請求來驗證控制元件。每次按鍵後排程一次 HTTP 請求都會給後端 API 帶來壓力，應該儘可能避免。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"btfh38009s8ww1b56in132hh6\">你可以把 <code>updateOn</code> 屬性從 <code>change</code>（預設值）改成 <code>submit</code> 或 <code>blur</code> 來推遲表單驗證的更新時機。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4cz1gu9jz2tzatsiijygcbz0j\">使用樣板驅動表單時，可以在樣板中設定該屬性。</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"name\" [ngModelOptions]=\"{updateOn: 'blur'}\"&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5obb5dqbfdy339stqfn8y27dj\">使用回應式表單時，可以在 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 實例中設定該屬性。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nnew <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('', {updateOn: 'blur'});\n\n</code-example>\n<h2 id=\"interaction-with-native-html-form-validation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cb8jvh5r2sjl3l5n1nk0bgxs3\">與原生 HTML 表單驗證器互動<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#interaction-with-native-html-form-validation\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ajpiqdr2rjnet1prn7bwau8i7\">預設情況下，Angular 透過在 <code>&lt;form&gt;</code> 元素上新增 <code>novalidate</code> 屬性來停用<a href=\"https://developer.mozilla.org/docs/Web/Guide/HTML/Constraint_validation\">原生 HTML 表單驗證</a>，並使用指令將這些屬性與框架中的驗證器函式相對應。如果你想將原生驗證與基於 Angular 的驗證<strong>結合</strong>使用，你可以使用 <code>ngNativeValidate</code> 指令來重新啟用它。欲知詳情，參閱<a href=\"api/forms/NgForm#native-dom-validation-ui\"> API 文件</a>。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Tue Sep 12 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/forms/CheckboxRequiredValidator\n - api/forms/EmailValidator\n - api/forms/MaxLengthValidator\n - api/forms/MaxValidator\n - api/forms/MinLengthValidator\n - api/forms/MinValidator\n - api/forms/PatternValidator\n - api/forms/RequiredValidator\n - guide/dynamic-form\n - guide/example-apps-list\n - guide/forms-overview\n - guide/glossary\n - guide/reactive-forms\n-->\n<!-- links from this doc:\n - api/common/NgIf\n - api/core/Directive\n - api/core/Injectable\n - api/core/Input\n - api/core/forwardRef\n - api/core/model\n - api/forms/AbstractControl\n - api/forms/AbstractControl#get\n - api/forms/AbstractControlOptions\n - api/forms/AsyncValidator\n - api/forms/AsyncValidatorFn\n - api/forms/FormControl\n - api/forms/FormControlName\n - api/forms/FormGroup\n - api/forms/MinLengthValidator\n - api/forms/NG_ASYNC_VALIDATORS\n - api/forms/NG_VALIDATORS\n - api/forms/NgForm\n - api/forms/NgForm#native-dom-validation-ui\n - api/forms/NgModel\n - api/forms/ValidationErrors\n - api/forms/Validator\n - api/forms/ValidatorFn\n - api/forms/Validators\n - guide/architecture\n - guide/form-validation#adding-async-validators-to-reactive-forms\n - guide/form-validation#adding-async-validators-to-template-driven-forms\n - guide/form-validation#adding-cross-validation-to-reactive-forms\n - guide/form-validation#adding-cross-validation-to-template-driven-forms\n - guide/form-validation#adding-custom-validators-to-reactive-forms\n - guide/form-validation#adding-custom-validators-to-template-driven-forms\n - guide/form-validation#adding-to-template-driven-forms\n - guide/form-validation#built-in-validator-functions\n - guide/form-validation#control-status-css-classes\n - guide/form-validation#creating-asynchronous-validators\n - guide/form-validation#cross-field-validation\n - guide/form-validation#custom-validators\n - guide/form-validation#defining-custom-validators\n - guide/form-validation#dirty-or-touched\n - guide/form-validation#implementing-a-custom-async-validator\n - guide/form-validation#interaction-with-native-html-form-validation\n - guide/form-validation#optimizing-performance-of-async-validators\n - guide/form-validation#prerequisites\n - guide/form-validation#reactive-component-class\n - guide/form-validation#validating-form-input\n - guide/form-validation#validating-input-in-reactive-forms\n - guide/form-validation#validating-input-in-template-driven-forms\n - guide/form-validation#validator-functions\n - guide/forms\n - guide/forms-overview\n - guide/reactive-forms\n - https://developer.mozilla.org/docs/Web/Guide/HTML/Constraint_validation\n - https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation\n - https://www.typescriptlang.org/\n-->"}