{"id":"guide/form-validation","title":"验证表单输入","contents":"<div class=\"content\">\n  <h1 id=\"validating-form-input\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bj26fyjitoxu8l9ytnse5nhrn\">验证表单输入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validating-form-input\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51ppuvd6dlw056yznt9nijcid\">通过验证用户输入的准确性和完整性，可以提高整体的数据质量。该页面显示了如何从 UI 验证用户输入，以及如何在响应式表单和模板驱动表单中显示有用的验证消息。</p>\n<h2 id=\"prerequisites\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e44b21uig1fakj5vcfuvz1bdu\">前提条件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#prerequisites\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"60p4gzxfubhq39l87u4itz9q2\">在阅读表单验证之前，你应该对这些内容有一个基本的了解。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bzu3w3qb66mmgbf3434pkh9sn\"><a href=\"https://www.typescriptlang.org/\" title=\"TypeScript 语言\">TypeScript</a>和 HTML5 编程</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b5xhj95pp4wr4e63fjqwvv5jb\"><a href=\"guide/architecture\" title=\"Angular 应用设计概念简介\">Angular 应用设计</a>的基本概念</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bsvscaik413b3cfrbvqmzax5u\"><a href=\"guide/forms-overview\" title=\"Angular 表单简介\">Angular 支持的两类表单</a></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayc7bc0nluilb6wfghzu1dq73\"><a href=\"guide/forms\" title=\"模板驱动表单指南\">模板驱动表单</a>或<a href=\"guide/reactive-forms\" title=\"响应式表单指南\">响应式表单</a>的基础知识</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58rakd2ypcrbkqk9sxwbblpk1\">要获取这里用讲解表单验证的响应式表单和模板驱动表单的完整范例代码。请运行<live-example></live-example>。</p>\n</div>\n<p><a id=\"template-driven-validation\"></a></p>\n<h2 id=\"validating-input-in-template-driven-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dbkihv4jjzmuwck4huui2dk46\">在模板驱动表单中验证输入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validating-input-in-template-driven-forms\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2cui13b0us5up0do8ux8ejz5g\">为了往模板驱动表单中添加验证机制，你要添加一些验证属性，就像<a href=\"https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation\">原生的 HTML 表单验证器</a>一样。\nAngular 会用指令来匹配这些具有验证功能的指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5magj4jokuo6qldet5fc8zc4y\">每当表单控件中的值发生变化时，Angular 就会进行验证，并生成一个验证错误的列表（对应着 <code>INVALID</code> 状态）或者 null（对应着 VALID 状态）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"23iym1j7axg1x9hy31gnr8es4\">你可以通过把 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 导出成局部模板变量来查看该控件的状态。\n比如下面这个例子就把 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 导出成了一个名叫 <code>name</code> 的变量：</p>\n<code-example header=\"template/hero-form-template.component.html (name)\" path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"name-with-error-msg\">\n&lt;input\n  type=\"text\"\n  id=\"name\"\n  name=\"name\"\n  class=\"form-control\"\n  required\n  <a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>=\"4\"\n  appForbiddenName=\"bob\"\n  [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\"\n  #name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"\n/&gt;\n\n&lt;div\n  *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.invalid &amp;&amp; (name.dirty || name.touched)\"\n  class=\"alert\"\n&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['required']\"&gt;Name is required.&lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['<a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>']\"&gt;\n    Name must be at least 4 characters long.\n  &lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['forbiddenName']\"&gt;\n    Name cannot be Bob.\n  &lt;/div&gt;\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94l08uixa1k9s9zevdi3k04kz\">注意这个例子讲解的如下特性。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78ixou4qg90qh2rgvm4ep4s0i\"><code>&lt;input&gt;</code> 元素带有一些 HTML 验证属性：<code>required</code> 和 <code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>。它还带有一个自定义的验证器指令 <code>forbiddenName</code>。欲知详情，参阅<a href=\"guide/form-validation#custom-validators\">自定义验证器</a>一节。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b83dufuyz4ve5q7y5mxkrm2d5\"><code>#name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"</code> 把 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 导出成了一个名叫 <code>name</code> 的局部变量。<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 把自己控制的 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例的属性映射出去，让你能在模板中检查控件的状态，比如 <code>valid</code> 和 <code>dirty</code>。要了解完整的控件属性，参阅 API 参考手册中的<a href=\"api/forms/AbstractControl\">AbstractControl</a>。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8i92nxpgp8imtarxjfu4n6iw6\"><code>&lt;div&gt;</code> 元素的 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 展示了一组嵌套的消息 <code>div</code>，但是只在有“name”错误和控制器为 <code>dirty</code> 或者 <code>touched</code> 时才出现。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"62ae0ichxaes90wsufw9mwzxz\">每个嵌套的 <code>&lt;div&gt;</code> 为其中一个可能出现的验证错误显示一条自定义消息。比如 <code>required</code>、<code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code> 和 <code>forbiddenName</code>。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><a id=\"dirty-or-touched\"></a></p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4y0a4ns7d9q7wsmsh860bto2k\">为防止验证程序在用户有机会编辑表单之前就显示错误，你应该检查控件的 <code>dirty</code> 状态或 <code>touched</code> 状态。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26wc1ws2d6feqar5hci39idbd\">当用户在被监视的字段中修改该值时，控件就会被标记为 <code>dirty</code>（脏）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jkh7bj1v9skeyq9ofod5arf4\">当用户的表单控件失去焦点时，该控件就会被标记为 <code>touched</code>（已接触）</li>\n</ul>\n</div>\n<p><a id=\"reactive-form-validation\"></a></p>\n<h2 id=\"validating-input-in-reactive-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"du18fhr2olw0m3u6uqtp5sx71\">在响应式表单中验证输入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validating-input-in-reactive-forms\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"duq6cyr85xttgw86wwomwooea\">在响应式表单中，事实之源是其组件类。不应该通过模板上的属性来添加验证器，而应该在组件类中直接把验证器函数添加到表单控件模型上（<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code>）。然后，一旦控件发生了变化，Angular 就会调用这些函数。</p>\n<h3 id=\"validator-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amf6d696khzdbvd2xpvhh26ly\">验证器（Validator）函数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validator-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"34hgwf1yk4ec4ywdycujf02c2\">验证器函数可以是同步函数，也可以是异步函数。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"82i7dvenvfj5p8di6db66t0kz\">验证器类型</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e7wuhqwfs6pereev4zssztnpe\">同步验证器</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"47ef9l9xo2aa3yd830gatyvg7\">立即接受一个控件实例并返回一组验证错误或\n<code>null</code>的同步函数。在实例化\n<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code>时将其作为第二个参数传入。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6nzklv7afq05vys55yuubb34c\">异步验证器</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43pbp224loheuez8qaueqsy53\">接受一个控件实例并返回一个后来会发出一组验证错误或\n<code>null</code>的 Promise 或 Observable 的异步函数。在实例化\n<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code>时将其作为第三个参数传入。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2uudkg3ldpu84yrbwnyf2zj4c\">出于性能方面的考虑，只有在所有同步验证器都通过之后，Angular 才会运行异步验证器。当每一个异步验证器都执行完之后，才会设置这些验证错误。</p>\n<h3 id=\"built-in-validator-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bims18gn3avu2ay176kkt0q0w\">内置验证器函数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#built-in-validator-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"52zq2k4a58xjka04ip62m1631\">你可以选择<a href=\"guide/form-validation#custom-validators\">编写自己的验证器函数</a>，也可以使用 Angular 的一些内置验证器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jp615m3zfdily49bggdx9m5y\">在模板驱动表单中用作属性的那些内置验证器，比如 <code>required</code> 和 <code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>，也都可以作为 <code><a href=\"api/forms/Validators\" class=\"code-anchor\">Validators</a></code> 类中的函数使用。关于内置验证器的完整列表，参阅 API 参考手册中的<a href=\"api/forms/Validators\">验证器</a>部分。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9a9oq9rrkk4matevlhwzilyvm\">要想把这个英雄表单改造成一个响应式表单，还是要用那些内置验证器，但这次改为用它们的函数形态。参阅下面的例子。</p>\n<p><a id=\"reactive-component-class\"></a></p>\n<code-example header=\"reactive/hero-form-reactive.component.ts (validator functions)\" path=\"form-validation/src/app/reactive/hero-form-reactive.component.1.ts\" region=\"form-group\">\nngOnInit(): void {\n  this.heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n    name: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.name, [\n      Validators.required,\n      Validators.minLength(4),\n      forbiddenNameValidator(/bob/i), // &lt;-- Here's how you pass in the custom validator.\n    ]),\n    alterEgo: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.alterEgo),\n    power: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.power, Validators.required),\n  });\n}\n\nget name() {\n  return this.heroForm.get('name');\n}\n\nget power() {\n  return this.heroForm.get('power');\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ci9z4xeplv4a69mrmv61xnvm3\">在这个例子中，<code>name</code> 控件设置了两个内置验证器 - <code>Validators.required</code> 和 <code>Validators.minLength(4)</code> 以及一个自定义验证器 <code>forbiddenNameValidator</code>。（欲知详情，参阅下面的<a href=\"guide/form-validation#custom-validators\">自定义验证器</a>部分。）</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dcb6il8ls9h0qqn7izygeavgl\">所有这些验证器都是同步的，所以它们作为第二个参数传递。注意，你可以通过把这些函数放到一个数组中传入来支持多个验证器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1349joww93wq568y1doo60sm1\">这个例子还添加了一些 getter 方法。在响应式表单中，你通常会通过它所属的控件组（FormGroup）的 <code>get</code> 方法来访问表单控件，但有时候为模板定义一些 getter 作为简短形式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bpm3fq0bqpsy5kzdang8fjfrd\">如果你到模板中找到 <code>name</code> 输入框，就会发现它和模板驱动的例子很相似。</p>\n<code-example header=\"reactive/hero-form-reactive.component.html (name with error msg)\" path=\"form-validation/src/app/reactive/hero-form-reactive.component.html\" region=\"name-with-error-msg\">\n&lt;input\n  type=\"text\"\n  id=\"name\"\n  class=\"form-control\"\n  <a href=\"api/forms/FormControlName\" class=\"code-anchor\">formControlName</a>=\"name\"\n  required\n/&gt;\n\n&lt;div\n  *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.invalid &amp;&amp; (name.dirty || name.touched)\"\n  class=\"alert alert-danger\"\n&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['required']\"&gt;Name is required.&lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['<a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>']\"&gt;\n    Name must be at least 4 characters long.\n  &lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['forbiddenName']\"&gt;\n    Name cannot be Bob.\n  &lt;/div&gt;\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91p2gbyo663ur58xr0ssd6g\">这个表单与模板驱动的版本不同，它不再导出任何指令。相反，它使用组件类中定义的 <code>name</code> 读取器（getter）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91sa78qntwggw9waho53u2ixl\">请注意，\n<code>required</code>属性仍然存在于模板中。虽然它对于验证不是必需的，但应为无障碍目的保留它。</p>\n<p><a id=\"custom-validators\"></a></p>\n<h2 id=\"defining-custom-validators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3t2lod2adzkf2j35tv9vkpxxo\">定义自定义验证器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#defining-custom-validators\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a9a1an41xm2g5inzx26e3ri4e\">内置的验证器并不是总能精确匹配应用中的用例，因此有时你需要创建一个自定义验证器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cyas5gek4grn4bqq85gkl2d5\">考虑前面的<a href=\"guide/form-validation#reactive-component-class\">响应式式表单中</a>的 <code>forbiddenNameValidator</code> 函数。该函数的定义如下。</p>\n<code-example header=\"shared/forbidden-name.directive.ts (forbiddenNameValidator)\" path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"custom-validator\">\n/** A hero's name can't match the given regular expression */\nexport function forbiddenNameValidator(nameRe: RegExp): <a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a> {\n  return (control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): <a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null =&gt; {\n    const forbidden = nameRe.test(control.value);\n    return forbidden ? { forbiddenName: { value: control.value } } : null;\n  };\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bi28130d3ui3ql1x13gypsapa\">这个函数是一个工厂，它接受一个用来检测指定名字是否已被禁用的正则表达式，并返回一个验证器函数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xrmkjrjf3jluwzuoao5sqzbo\">在本例中，禁止的名字是“bob”；\n验证器会拒绝任何带有“bob”的英雄名字。\n在其它地方，只要配置的正则表达式可以匹配上，它可能拒绝“alice”或者任何其它名字。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5kztweoain277b3rgnug66x8r\"><code>forbiddenNameValidator</code> 工厂函数返回配置好的验证器函数。\n该函数接受一个 Angular 控件对象，并在控件值有效时返回 null，或无效时返回验证错误对象。\n验证错误对象通常有一个属性，其属性名（<code>'forbiddenName'</code>）是验证的键名，其值为一个任意值字典，你可以用来插入错误信息（<code>{name}</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ltloli20i6wr3xhtf2a2ulw7\">自定义异步验证器和同步验证器很像，只是它们必须返回一个稍后会输出 null 或“验证错误对象”的承诺（Promise）或可观察对象，如果是可观察对象，那么它必须在某个时间点被完成（complete），那时候这个表单就会使用它输出的最后一个值作为验证结果。（译注：HTTP 服务是自动完成的，但是某些自定义的可观察对象可能需要手动调用 complete 方法）</p>\n<p><a id=\"adding-to-reactive-forms\"></a></p>\n<h3 id=\"adding-custom-validators-to-reactive-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"87mg3i59lghrl409j005lr6rx\">把自定义验证器添加到响应式表单中<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-custom-validators-to-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1x35hhfwzkz6jvq3ejzexw6yl\">在响应式表单中，通过直接把该函数传给 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 来添加自定义验证器。</p>\n<code-example header=\"reactive/hero-form-reactive.component.ts (validator functions)\" path=\"form-validation/src/app/reactive/hero-form-reactive.component.1.ts\" region=\"custom-validator\">\nthis.heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n  name: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.name, [\n    Validators.required,\n    Validators.minLength(4),\n    forbiddenNameValidator(/bob/i), // &lt;-- Here's how you pass in the custom validator.\n  ]),\n  alterEgo: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.alterEgo),\n  power: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.power, Validators.required),\n});\n\n</code-example>\n<p><a id=\"adding-to-template-driven-forms\"></a></p>\n<h3 id=\"adding-custom-validators-to-template-driven-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayx63any6vp2jdglbgisl5sqc\">为模板驱动表单中添加自定义验证器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-custom-validators-to-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4zap7cjedwav6mg9qfi1dxdpl\">在模板驱动表单中，要为模板添加一个指令，该指令包含了 validator 函数。比如，对应的 <code>ForbiddenValidatorDirective</code> 用作 <code>forbiddenNameValidator</code> 的包装器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9z93zl8hvcln8lznih5lnzmsy\">Angular 在验证过程中会识别出该指令的作用，因为该指令把自己注册成了 <code><a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a></code> 提供者，如下例所示。<code><a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a></code> 是一个带有可扩展验证器集合的预定义提供者。</p>\n<code-example header=\"shared/forbidden-name.directive.ts (providers)\" path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"directive-providers\">\nproviders: [\n  {\n    provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>,\n    useExisting: ForbiddenValidatorDirective,\n    multi: true,\n  },\n],\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"386n9u0l799z7p49c5qd15b7t\">然后该指令类实现了 <code><a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a></code> 接口，以便它能简单的与 Angular 表单集成在一起。这个指令的其余部分有助于你理解它们是如何协作的：</p>\n<code-example header=\"shared/forbidden-name.directive.ts (directive)\" path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"directive\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appForbiddenName]',\n  providers: [\n    {\n      provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>,\n      useExisting: ForbiddenValidatorDirective,\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class ForbiddenValidatorDirective implements <a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appForbiddenName') forbiddenName = '';\n\n  validate(control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): <a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null {\n    return this.forbiddenName\n      ? forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control)\n      : null;\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhquk7538vcvgngkk9r9m5he1\">一旦 <code>ForbiddenValidatorDirective</code> 写好了，你只要把 <code>forbiddenName</code> 选择器添加到输入框上就可以激活这个验证器了。比如：</p>\n<code-example header=\"template/hero-form-template.component.html (forbidden-name-input)\" path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"name-input\">\n&lt;input\n  type=\"text\"\n  id=\"name\"\n  name=\"name\"\n  class=\"form-control\"\n  required\n  <a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>=\"4\"\n  appForbiddenName=\"bob\"\n  [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\"\n  #name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"\n/&gt;\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amqtbqqph0pj63b6rnf9ruo2\">注意，自定义验证指令是用 <code>useExisting</code> 而不是 <code>useClass</code> 来实例化的。注册的验证程序必须是 <code>ForbiddenValidatorDirective</code> <em>实例本身</em> - 表单中的实例，也就是表单中 <code>forbiddenName</code> 属性被绑定到了\"bob\"的那个。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f3kbuz9h1icarmak3k49xw4dg\">如果用 <code>useClass</code> 来代替 <code>useExisting</code>，就会注册一个新的类实例，而它是没有 <code>forbiddenName</code> 的。</p>\n</div>\n<h2 id=\"control-status-css-classes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a22sgpj699qql2r1ygca7zu05\">表示控件状态的 CSS 类<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#control-status-css-classes\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6gwuz687fz490vx6kyo2b8884\">Angular 会自动把很多控件属性作为 CSS 类映射到控件所在的元素上。你可以使用这些类来根据表单状态给表单控件元素添加样式。目前支持下列类：</p>\n<ul>\n<li><code>.ng-valid</code></li>\n<li><code>.ng-invalid</code></li>\n<li><code>.ng-pending</code></li>\n<li><code>.ng-pristine</code></li>\n<li><code>.ng-dirty</code></li>\n<li><code>.ng-untouched</code></li>\n<li><code>.ng-touched</code></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"22c97js42v789ykdpvpwn0qd3\"><code>.ng-submitted</code>（只对 form 元素添加）</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ffyhm1dshqmlla53enozdy01\">在下面的例子中，这个英雄表单使用 <code>.ng-valid</code> 和 <code>.ng-invalid</code> 来设置每个表单控件的边框颜色。</p>\n<code-example header=\"forms.css (status classes)\" path=\"form-validation/src/assets/forms.css\">\n\n.ng-valid[required], .ng-valid.required  {\n  border-left: 5px solid #42A948; /* green */\n}\n\n.ng-invalid:not(form)  {\n  border-left: 5px solid #a94442; /* red */\n}\n\n.alert div {\n  background-color: #fed3d3;\n  color: #820000;\n  padding: 1rem;\n  margin-bottom: 1rem;\n}\n\n.form-group {\n  margin-bottom: 1rem;\n}\n\nlabel {\n  display: block;\n  margin-bottom: .5rem;\n}\n\nselect {\n  width: 100%;\n  padding: .5rem;\n}\n\n\n</code-example>\n<h2 id=\"cross-field-validation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9q8bc1s6dc4lp6njff6wl5mvy\">跨字段交叉验证<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#cross-field-validation\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crjbaxjktxni568ipgrhtmfby\">跨字段交叉验证器是一种<a href=\"guide/form-validation#custom-validators\" title=\"阅读自定义验证器\">自定义验证器</a>，可以对表单中不同字段的值进行比较，并针对它们的组合进行接受或拒绝。比如，你可能有一个提供互不兼容选项的表单，以便让用户选择 A 或 B，而不能两者都选。某些字段值也可能依赖于其它值；用户可能只有当选择了 A 之后才能选择 B。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ktokn5pujzeav7zhqlx3yoao\">下列交叉验证的例子说明了如何进行如下操作：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aohhs6rp79tuq1v7fhg193epa\">根据两个兄弟控件的值验证响应式表单或模板驱动表单的输入，</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qld11rh7x2gya1ywkz3fn2yy\">当用户与表单交互过，且验证失败后，就会显示描述性的错误信息。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8l489bjir6sflj3pm411ksk22\">这些例子使用了交叉验证，以确保英雄们不会通过填写 Hero 表单来暴露自己的真实身份。验证器会通过检查英雄的名字和第二人格是否匹配来做到这一点。</p>\n<h3 id=\"adding-cross-validation-to-reactive-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f8p2e0p8pyoo3egrzuy4ca15\">为响应式表单添加交叉验证<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-cross-validation-to-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dfl51r12ritfc5yaz8ts817wd\">该表单具有以下结构：</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n  'name': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'alterEgo': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'power': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>()\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4lrhpxk7ell7i66ht7nm7s3lf\">注意，<code>name</code> 和 <code>alterEgo</code> 是兄弟控件。要想在单个自定义验证器中计算这两个控件，你就必须在它们共同的祖先控件中执行验证：<code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code>。你可以在 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 中查询它的子控件，从而让你能比较它们的值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"br4bfa42eurzl2fb8tak01kg0\">要想给 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 添加验证器，就要在创建时把一个新的验证器传给它的第二个参数。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n  'name': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'alterEgo': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'power': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>()\n}, { validators: identityRevealedValidator });\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"60a4vq9w9dfr6rzet9nx2exxe\">验证器的代码如下。</p>\n<code-example header=\"shared/identity-revealed.directive.ts\" path=\"form-validation/src/app/shared/identity-revealed.directive.ts\" region=\"cross-validation-validator\">\n/** A hero's name can't match the hero's alter ego */\nexport const identityRevealedValidator: <a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a> = (\n  control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>,\n): <a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null =&gt; {\n  const name = control.get('name');\n  const alterEgo = control.get('alterEgo');\n\n  return name &amp;&amp; alterEgo &amp;&amp; name.value === alterEgo.value\n    ? { identityRevealed: true }\n    : null;\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1w70nnkilvvrqy4s9nvhviw8e\">这个 <code>identity</code> 验证器实现了 <code><a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a></code> 接口。它接收一个 Angular 表单控件对象作为参数，当表单有效时，它返回一个 null，否则返回 <code><a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a></code> 对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ijaf8zpdohah7mltza7nswkv\">该验证器通过调用 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 的 <a href=\"api/forms/AbstractControl#get\">get</a> 方法来检索这些子控件，然后比较 <code>name</code> 和 <code>alterEgo</code> 控件的值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4h6nffdpck2stzcphhoyjw04q\">如果值不匹配，则 hero 的身份保持秘密，两者都有效，且 validator 返回 null。如果匹配，就说明英雄的身份已经暴露了，验证器必须通过返回一个错误对象来把这个表单标记为无效的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4j36i4svvistox1xi04lrgke4\">为了提供更好的用户体验，当表单无效时，模板还会显示一条恰当的错误信息。</p>\n<code-example header=\"reactive/hero-form-template.component.html\" path=\"form-validation/src/app/reactive/hero-form-reactive.component.html\" region=\"cross-validation-error-message\">\n&lt;div\n  *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"\n    heroForm.errors?.['identityRevealed'] &amp;&amp;\n    (heroForm.touched || heroForm.dirty)\n  \"\n  class=\"cross-validation-error-message alert alert-danger\"\n&gt;\n  Name cannot match alter ego.\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9n5k3chs2zjal3vf7202iy1vq\">如果 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 中有一个由 <code>identityRevealed</code> 验证器返回的交叉验证错误，<code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 就会显示错误，但只有当该用户已经<a href=\"guide/form-validation#dirty-or-touched\">与表单进行过交互</a>的时候才显示。</p>\n<h3 id=\"adding-cross-validation-to-template-driven-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"befoa6xj926n609b9ihppm0hp\">为模板驱动表单添加交叉验证<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-cross-validation-to-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cbhafi245bh4xzxxugbxxo4dp\">对于模板驱动表单，你必须创建一个指令来包装验证器函数。你可以使用<a href=\"guide/form-validation#adding-to-template-driven-forms\" title=\"了解如何提供验证器\"><code>NG_VALIDATORS</code> 令牌</a>来把该指令提供为验证器，如下例所示。</p>\n<code-example header=\"shared/identity-revealed.directive.ts\" path=\"form-validation/src/app/shared/identity-revealed.directive.ts\" region=\"cross-validation-directive\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appIdentityRevealed]',\n  providers: [\n    {\n      provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>,\n      useExisting: IdentityRevealedValidatorDirective,\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class IdentityRevealedValidatorDirective implements <a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a> {\n  validate(control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): <a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null {\n    return identityRevealedValidator(control);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91evp1jl23mbsg0vnubaoumle\">你必须把这个新指令添加到 HTML 模板中。由于验证器必须注册在表单的最高层，因此下列模板会把该指令放在 <code>form</code> 标签上。</p>\n<code-example header=\"template/hero-form-template.component.html\" path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"cross-validation-register-validator\">\n&lt;form #heroForm=\"<a href=\"api/forms/NgForm\" class=\"code-anchor\">ngForm</a>\" appIdentityRevealed&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5087lmja6dkip06nqjvsmxg54\">为了提供更好的用户体验，当表单无效时，我们要显示一个恰当的错误信息。</p>\n<code-example header=\"template/hero-form-template.component.html\" path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"cross-validation-error-message\">\n&lt;div\n  *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"\n    heroForm.errors?.['identityRevealed'] &amp;&amp;\n    (heroForm.touched || heroForm.dirty)\n  \"\n  class=\"cross-validation-error-message alert\"\n&gt;\n  Name cannot match alter ego.\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1uckgqpdzo61c0amns3msb668\">这在模板驱动表单和响应式表单中都是一样的。</p>\n<h2 id=\"creating-asynchronous-validators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ab360yrsxcqh7wvgxltku3obb\">创建异步验证器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#creating-asynchronous-validators\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"23pr6vyqfr3f1kk8hruajuk2f\">异步验证器实现了 <code><a href=\"api/forms/AsyncValidatorFn\" class=\"code-anchor\">AsyncValidatorFn</a></code> 和 <code><a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a></code> 接口。它们与其同步版本非常相似，但有以下不同之处。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ftz9vjrnff3ebgdby4720mm6\"><code>validate()</code> 函数必须返回一个 Promise 或可观察对象，</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b74vrzrnq0t7jfgg4szraxqy\">返回的可观察对象必须是有尽的，这意味着它必须在某个时刻完成（complete）。要把无尽的可观察对象转换成有尽的，可以在管道中加入过滤操作符，比如 <code>first</code>、<code>last</code>、<code>take</code> 或 <code>takeUntil</code>。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jun0frqvwdnfpf4bhv531ypz\">异步验证在同步验证完成后才会发生，并且只有在同步验证成功时才会执行。如果更基本的验证方法已经发现了无效输入，那么这种检查顺序就可以让表单避免使用昂贵的异步验证流程（比如 HTTP 请求）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3peq983pp18xyzuiowvngqcz4\">异步验证开始之后，表单控件就会进入 <code>pending</code> 状态。可以检查控件的 <code>pending</code> 属性，并用它来给出对验证中的视觉反馈。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4o3u25dd0vxfoalvtyht6n0vf\">一种常见的 UI 模式是在执行异步验证时显示 Spinner（转轮）。下面的例子展示了如何在模板驱动表单中实现这一点。</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"name\" #<a href=\"api/core/model\" class=\"code-anchor\">model</a>=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\" appSomeAsyncValidator&gt;\n&lt;app-spinner *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"model.pending\"&gt;&lt;/app-spinner&gt;\n\n</code-example>\n<h3 id=\"implementing-a-custom-async-validator\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43u236xu5itxwr6kvoyjpvapr\">实现自定义异步验证器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#implementing-a-custom-async-validator\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccs9pb1jldw9jkm11opqq8ics\">在下面的例子中，异步验证器可以确保英雄们选择了一个尚未采用的第二人格。新英雄不断涌现，老英雄也会离开，所以无法提前找到可用的人格列表。为了验证潜在的第二人格条目，验证器必须启动一个异步操作来查询包含所有在编英雄的中央数据库。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wvtbjyity30tpj6ee5x3mw40\">下面的代码创建了一个验证器类 <code>UniqueAlterEgoValidator</code>，它实现了 <code><a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a></code> 接口。</p>\n<code-example path=\"form-validation/src/app/shared/alter-ego.directive.ts\" region=\"async-validator\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({ providedIn: 'root' })\nexport class UniqueAlterEgoValidator implements <a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a> {\n  constructor(private heroesService: HeroesService) {}\n\n  validate(control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): Observable&lt;<a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null&gt; {\n    return this.heroesService.isAlterEgoTaken(control.value).pipe(\n      map((isTaken) =&gt; (isTaken ? { uniqueAlterEgo: true } : null)),\n      catchError(() =&gt; of(null)),\n    );\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"apygo24rl1mufes9z24aqr8vc\">构造函数中注入了 <code>HeroesService</code>，它定义了如下接口。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\ninterface HeroesService {\n  isAlterEgoTaken: (alterEgo: string) =&gt; Observable&lt;boolean&gt;;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dk6g897yyuzu4dh0pmp6qhz5r\">在真实的应用中，<code>HeroesService</code> 会负责向英雄数据库发起一个 HTTP 请求，以检查该第二人格是否可用。\n从该验证器的视角看，此服务的具体实现无关紧要，所以这个例子仅仅针对 <code>HeroesService</code> 接口来写实现代码。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3oorawcofadz72k25frg5rnij\">当验证开始的时候，<code>UniqueAlterEgoValidator</code> 把任务委托给 <code>HeroesService</code> 的 <code>isAlterEgoTaken()</code> 方法，并传入当前控件的值。这时候，该控件会被标记为 <code>pending</code> 状态，直到 <code>validate()</code> 方法所返回的可观察对象完成（complete）了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aa7ksqpdux181bpo6e2c85eny\"><code>isAlterEgoTaken()</code> 方法会调度一个 HTTP 请求来检查第二人格是否可用，并返回 <code>Observable&lt;boolean&gt;</code> 作为结果。<code>validate()</code> 方法通过 <code>map</code> 操作符来对响应对象进行管道化处理，并把它转换成验证结果。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"djw5rjsq56ha2b34b84i3h8oy\">与任何验证器一样，如果表单有效，该方法返回 <code>null</code>，如果无效，则返回 <code><a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a></code>。这个验证器使用 <code>catchError</code> 操作符来处理任何潜在的错误。在这个例子中，验证器将 <code>isAlterEgoTaken()</code> 错误视为成功的验证，因为未能发出验证请求并不一定意味着这个第二人格无效。你也可以用不同的方式处理这种错误，比如返回 <code>ValidationError</code> 对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9djywv3wtg6bnwezi8hd0auuo\">一段时间过后，这条可观察对象链完成，异步验证也就完成了。<code>pending</code> 标志位也设置为 <code>false</code>，该表单的有效性也已更新。</p>\n<h3 id=\"adding-async-validators-to-reactive-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cdo4hz1rwj9fkis2lh110nucl\">将异步验证器添加到响应式表单<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-async-validators-to-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66wmkr0y8vof68v67dym7nd4n\">要以响应式表单使用异步验证器，请首先将验证器注入组件类的构造函数。</p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.2.ts\" region=\"async-validator-inject\">\nconstructor(private alterEgoValidator: UniqueAlterEgoValidator) {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ag6gr9wkkwv70jzm4qs0f2u8h\">然后，将验证器函数直接传递给 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 以应用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4vs8t54hy64gq7oqt7et35hnu\">在以下示例中，<code>UniqueAlterEgoValidator</code> 的 <code>validate</code> 函数将其传递给控件的 <code>asyncValidators</code> 选项并将其绑定到注入到 <code>HeroFormReactiveComponent</code> 中的 <code>UniqueAlterEgoValidator</code> 实例，最终将其应用于 <code>alterEgoControl</code>。<code>asyncValidators</code> 的值可以是单个异步验证器函数，也可以是函数数组。要了解有关 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 选项的更多信息，参阅<a href=\"api/forms/AbstractControlOptions\">AbstractControlOptions</a> API 参考。</p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.2.ts\" region=\"async-validator-usage\">\nconst alterEgoControl = new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('', {\n  asyncValidators: [\n    this.alterEgoValidator.validate.bind(this.alterEgoValidator),\n  ],\n  updateOn: 'blur',\n});\n\n</code-example>\n<h3 id=\"adding-async-validators-to-template-driven-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7x6cdftbus1shbq2sd7gj02qy\">将异步验证器添加到模板驱动表单<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-async-validators-to-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9l79i8oni5ctf4mrusm7fwn8j\">要在模板驱动表单中使用异步验证器，请创建一个新指令并在其上注册 <code><a href=\"api/forms/NG_ASYNC_VALIDATORS\" class=\"code-anchor\">NG_ASYNC_VALIDATORS</a></code> 提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amjyw5lx8pl8go43anloj7tuo\">在下面的示例中，该指令注入包含实际验证逻辑的 <code>UniqueAlterEgoValidator</code> 类，并在应该进行验证时由 Angular 触发的 <code>validate</code> 函数中调用它。</p>\n<code-example path=\"form-validation/src/app/shared/alter-ego.directive.ts\" region=\"async-validator-directive\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appUniqueAlterEgo]',\n  providers: [\n    {\n      provide: <a href=\"api/forms/NG_ASYNC_VALIDATORS\" class=\"code-anchor\">NG_ASYNC_VALIDATORS</a>,\n      useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; UniqueAlterEgoValidatorDirective),\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class UniqueAlterEgoValidatorDirective implements <a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a> {\n  constructor(private validator: UniqueAlterEgoValidator) {}\n\n  validate(control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): Observable&lt;<a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null&gt; {\n    return this.validator.validate(control);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66wd5dgdz0xtmeua4csg4ujp5\">然后，与使用同步验证器一样，将指令的选择器添加到输入以激活它。</p>\n<code-example header=\"template/hero-form-template.component.html (unique-alter-ego-input)\" path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"alterEgo-input\">\n&lt;input\n  type=\"text\"\n  id=\"alterEgo\"\n  name=\"alterEgo\"\n  #alterEgo=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"\n  [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.alterEgo\"\n  [ngModelOptions]=\"{ updateOn: 'blur' }\"\n  appUniqueAlterEgo\n/&gt;\n\n</code-example>\n<h3 id=\"optimizing-performance-of-async-validators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gj9ccjmjj25izq58bzsqxsej\">优化异步验证器的性能<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#optimizing-performance-of-async-validators\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bvj9tyk4rcpl1rr5f10zt9avw\">默认情况下，所有验证程序在每次表单值更改后都会运行。对于同步验证器，这通常不会对应用性能产生明显的影响。但是，异步验证器通常会执行某种 HTTP 请求来验证控件。每次按键后调度一次 HTTP 请求都会给后端 API 带来压力，应该尽可能避免。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"btfh38009s8ww1b56in132hh6\">你可以把 <code>updateOn</code> 属性从 <code>change</code>（默认值）改成 <code>submit</code> 或 <code>blur</code> 来推迟表单验证的更新时机。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4cz1gu9jz2tzatsiijygcbz0j\">使用模板驱动表单时，可以在模板中设置该属性。</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"name\" [ngModelOptions]=\"{updateOn: 'blur'}\"&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5obb5dqbfdy339stqfn8y27dj\">使用响应式表单时，可以在 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例中设置该属性。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nnew <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('', {updateOn: 'blur'});\n\n</code-example>\n<h2 id=\"interaction-with-native-html-form-validation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cb8jvh5r2sjl3l5n1nk0bgxs3\">与原生 HTML 表单验证器交互<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#interaction-with-native-html-form-validation\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ajpiqdr2rjnet1prn7bwau8i7\">默认情况下，Angular 通过在 <code>&lt;form&gt;</code> 元素上添加 <code>novalidate</code> 属性来禁用<a href=\"https://developer.mozilla.org/docs/Web/Guide/HTML/Constraint_validation\">原生 HTML 表单验证</a>，并使用指令将这些属性与框架中的验证器函数相匹配。如果你想将原生验证与基于 Angular 的验证<strong>结合</strong>使用，你可以使用 <code>ngNativeValidate</code> 指令来重新启用它。欲知详情，参阅<a href=\"api/forms/NgForm#native-dom-validation-ui\"> API 文档</a>。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Tue Sep 12 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/forms/CheckboxRequiredValidator\n - api/forms/EmailValidator\n - api/forms/MaxLengthValidator\n - api/forms/MaxValidator\n - api/forms/MinLengthValidator\n - api/forms/MinValidator\n - api/forms/PatternValidator\n - api/forms/RequiredValidator\n - guide/dynamic-form\n - guide/example-apps-list\n - guide/forms-overview\n - guide/glossary\n - guide/reactive-forms\n-->\n<!-- links from this doc:\n - api/common/NgIf\n - api/core/Directive\n - api/core/Injectable\n - api/core/Input\n - api/core/forwardRef\n - api/core/model\n - api/forms/AbstractControl\n - api/forms/AbstractControl#get\n - api/forms/AbstractControlOptions\n - api/forms/AsyncValidator\n - api/forms/AsyncValidatorFn\n - api/forms/FormControl\n - api/forms/FormControlName\n - api/forms/FormGroup\n - api/forms/MinLengthValidator\n - api/forms/NG_ASYNC_VALIDATORS\n - api/forms/NG_VALIDATORS\n - api/forms/NgForm\n - api/forms/NgForm#native-dom-validation-ui\n - api/forms/NgModel\n - api/forms/ValidationErrors\n - api/forms/Validator\n - api/forms/ValidatorFn\n - api/forms/Validators\n - guide/architecture\n - guide/form-validation#adding-async-validators-to-reactive-forms\n - guide/form-validation#adding-async-validators-to-template-driven-forms\n - guide/form-validation#adding-cross-validation-to-reactive-forms\n - guide/form-validation#adding-cross-validation-to-template-driven-forms\n - guide/form-validation#adding-custom-validators-to-reactive-forms\n - guide/form-validation#adding-custom-validators-to-template-driven-forms\n - guide/form-validation#adding-to-template-driven-forms\n - guide/form-validation#built-in-validator-functions\n - guide/form-validation#control-status-css-classes\n - guide/form-validation#creating-asynchronous-validators\n - guide/form-validation#cross-field-validation\n - guide/form-validation#custom-validators\n - guide/form-validation#defining-custom-validators\n - guide/form-validation#dirty-or-touched\n - guide/form-validation#implementing-a-custom-async-validator\n - guide/form-validation#interaction-with-native-html-form-validation\n - guide/form-validation#optimizing-performance-of-async-validators\n - guide/form-validation#prerequisites\n - guide/form-validation#reactive-component-class\n - guide/form-validation#validating-form-input\n - guide/form-validation#validating-input-in-reactive-forms\n - guide/form-validation#validating-input-in-template-driven-forms\n - guide/form-validation#validator-functions\n - guide/forms\n - guide/forms-overview\n - guide/reactive-forms\n - https://developer.mozilla.org/docs/Web/Guide/HTML/Constraint_validation\n - https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation\n - https://www.typescriptlang.org/\n-->"}