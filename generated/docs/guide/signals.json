{"id":"guide/signals","title":"Angular 訊號（Signal）","contents":"<div class=\"content\">\n  <h1 id=\"angular-signals\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4v4ycngrts2vgsrm920jvsyon\">Angular 訊號（Signal）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#angular-signals\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ljcmkooo3lywtegp5cke96fx\"><strong>Angular 訊號（Signal）</strong>是一個體系，可以精細地跟蹤你的狀態在整個應用程式中的使用方式和位置，從而允許框架最佳化渲染更新。</p>\n<h2 id=\"what-are-signals\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e5nteqfnhhs39uz271fvirz3v\">什麼是訊號？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#what-are-signals\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8itl1xhr23sqxpr30ctm5ld3\"><strong>訊號</strong>是一個值的套件裝器，可以在該值發生變化時通知感興趣的消費者。訊號可以包含任何值，從簡單的原語到複雜的資料結構。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"36he8ypskdrpzn96zes9n29uv\">訊號的值總會透過 getter 函式讀取，這使得 Angular 可以跟蹤訊號的使用位置。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqiqriefulyi8615d7qn8gl05\">訊號可以是<strong>可寫的</strong>或<strong>只讀的</strong>。</p>\n<h3 id=\"writable-signals\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7oz6k6xa7khhyl4bgazsgeuth\">可寫訊號<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#writable-signals\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"caessoxn4rttvxgj3nzccft7r\">可寫訊號提供了一個 API 來直接更新它們的值。你可以透過使用訊號的初始值呼叫 <code><a href=\"api/core/signal\" class=\"code-anchor\">signal</a></code> 函式來建立可寫訊號：</p>\n<code-example language=\"ts\">\nconst count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n\n// Signals are getter functions - calling them reads their value.\nconsole.log('The count is: ' + count());\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1v4k4ygr72to5v4279i4zmots\">要更改可寫訊號的值，你可以直接 <code>.set()</code>：</p>\n<code-example language=\"ts\">\ncount.set(3);\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3cxlgxd2mbbiqhf1ci0aygzf6\">或者使用 <code>.update()</code> 操作從前一個值計算出一個新值：</p>\n<code-example language=\"ts\">\n// Increment the count by 1.\ncount.update(value =&gt; value + 1);\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cam4dba3h2mvmy0cqo7373rep\">可寫訊號的型別為 <code><a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a></code>。</p>\n<h3 id=\"computed-signals\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2x0royoakh9ax2x3iakyk1sy9\">計算（computed）訊號<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8w0npe988ng37kdes1koxmsip\"><strong>計算訊號</strong>是從其他訊號中派生出來的。可以使用 <code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code> 並指定推導函式來定義一個：</p>\n<code-example language=\"typescript\">\nconst count: <a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a>&lt;number&gt; = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\nconst doubleCount: <a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>&lt;number&gt; = <a href=\"api/core/computed\" class=\"code-anchor\">computed</a>(() =&gt; count() * 2);\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9bf8xkg7j7tnc6sfmj3wftb5r\"><code>doubleCount</code> 訊號取決於 <code>count</code>。每當 <code>count</code> 更新時，Angular 知道任何依賴於 <code>count</code> 或 <code>doubleCount</code> 東西也需要更新。</p>\n<h4 id=\"computed-signals-are-both-lazily-evaluated-and-memoized\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6lnytfwkx1nisqzp55t2nutev\">計算訊號既是惰性評估的，也是記憶的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals-are-both-lazily-evaluated-and-memoized\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7neh7a5v658e2opr4h456nzwr\">在第一次讀取 <code>doubleCount</code> 之前，不會執行 <code>doubleCount</code> 的派生函式以計算其值。一旦計算出來，這個值就會被快取起來，以後讀取 <code>doubleCount</code> 將回傳快取的值而不用重新計算。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1oocn28z1ww97u6pd2wsik37y\">當 <code>count</code> 發生變化時，它會告訴 <code>doubleCount</code> 它的快取值不再有效，並且該值只會在下一次讀取 <code>doubleCount</code> 時重新計算。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"206e50zan7jt0jq4xfq246urz\">因此，在計算訊號中執行計算量大的推導（例如過濾陣列）是相當安全的。</p>\n<h4 id=\"computed-signals-are-not-writable-signals\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7023c5wb1klek3333mskp4uhs\">計算訊號不是可寫訊號<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals-are-not-writable-signals\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9mq4yndvns5xj7y53q6onls2x\">你不能直接為計算訊號賦值。比如，</p>\n<code-example language=\"ts\">\ndoubleCount.set(3);\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63j7f5takuwddecykhdzcrkgo\">會產生編譯錯誤，因為 <code>doubleCount</code> 不是 <code><a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a></code>。</p>\n<h4 id=\"computed-signal-dependencies-are-dynamic\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99c7be7ouf3tfqqccqcfvmkx3\">計算訊號的依賴性是動態的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signal-dependencies-are-dynamic\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d4aakndrq89opq8aluq60alm\">只能跟蹤推導期間實際讀取過的訊號。例如，在此計算中，只會有條件地讀取 <code>count</code> 訊號：</p>\n<code-example language=\"ts\">\nconst showCount = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(false);\nconst count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\nconst conditionalCount = <a href=\"api/core/computed\" class=\"code-anchor\">computed</a>(() =&gt; {\n  if (showCount()) {\n    return `The count is ${count()}.`;\n  } else {\n    return 'Nothing to see here!';\n  }\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xbhds043y0u1fz7g6k7s7glg\">讀取 <code>conditionalCount</code> 時，如果 <code>showCount</code> 為 <code>false</code>，則<strong>沒有</strong>讀取 <code>count</code> 訊號就回傳了訊息 『Nothing to see here!』。這意味著對 <code>count</code> 的更新不會導致重新計算。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2fa6epfpsuqy9zsn3tm0dfl1r\">如果稍後將 <code>showCount</code> 設定為 <code>true</code> 並再次讀取 <code>conditionalCount</code>，則將重新執行派生並採用 <code>showCount</code> 為 <code>true</code> 的分支，回傳顯示 <code>count</code> 值的訊息。對 <code>count</code> 的更改將使 <code>conditionalCount</code> 的快取值無效。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ejzlkrxiv3itmo3npbkrtmkpe\">請注意，可以刪除和新增依賴項。如果 <code>showCount</code> 稍後再次設定為 <code>false</code>，則 <code>count</code> 將不再被視為 <code>conditionalCount</code> 的依賴項。</p>\n<h2 id=\"reading-signals-in-onpush-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3g2aug3bh97eabpi43w74dzo9\">在 <code>OnPush</code> 型元件中讀取訊號<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#reading-signals-in-onpush-components\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c107wlwfzoax9pzjygft6t2b5\">當 <code>OnPush</code> 元件在其範本中使用訊號值時，Angular 會將訊號作為該組件的依賴項進行跟蹤。當該訊號更新時，Angular 會自動<a href=\"/api/core/ChangeDetectorRef#markforcheck\">標記</a>元件以確保它在下次執行變更檢測時得到更新。有關 <code>OnPush</code> 元件的更多訊息，請參閱<a href=\"/guide/change-detection-skipping-subtrees\">跳過元件子樹</a>指南。</p>\n<h2 id=\"effects\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4vten9v01mjrmj5lt1b39xamu\">副作用（effect）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#effects\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1w87ddlhgkab4z22evlfwcydg\">訊號很有用，因為它們可以在變化時通知感興趣的消費者。<strong>副作用</strong>是一種操作，只要一個或多個訊號值發生變化就會執行。你可以使用 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 函式建立副作用：</p>\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  console.log(`The current count is: ${count()}`);\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aqus4ly6lsiu6eu1901a2ifys\">副作用<strong>至少會執行一次。</strong> 當副作用執行時，它會跟蹤任何訊號值讀取。只要這些訊號值中的任何一個發生變化，副作用就會再次執行。與計算訊號類似，副作用會動態跟蹤它們的依賴關係，並且僅跟蹤在最近一次執行中讀取的訊號。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b4is5z7ytw3pl5lpj3ix871p2\">在變化檢測過程中，副作用始終<strong>非同步</strong>執行。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vz51g7gki1if6jhi4k5otjc7\">注意： \n<code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a>()</code> API 仍處於 \n<a href=\"/guide/releases#developer-preview\">開發者預覽</a> 階段，因為我們正在努力將基於訊號的回應性整合到核心框架中。</p>\n<h3 id=\"use-cases-for-effects\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b0hy6ub26u53qqw8x9k7ssv9e\">效果的使用案例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#use-cases-for-effects\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aojm4a2cia5wyfh6kexsaj193\">在大多數應用程式程式碼中很少需要副作用，但在特定情況下可能會有用。下面是一些需要以 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 作為解決方案的例子：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aqvurz2gevtem82essz2ynmwn\">記錄正在顯示的資料及其更改時間，用於分析或作為除錯工具</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1otykpyf4kwt54pum1g6gjsie\">在資料與 <code>window.localStorage</code> 之間保持同步</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7s2rzjmsa3vyzeftfmeb8z9w2\">新增無法用範本語法表達的自定義 DOM 行為</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ccw4129o1q0i6h0n6eua54ot\">對 <code>&lt;canvas&gt;</code>、圖表函式庫或其他第三方 UI 函式庫執行自定義渲染</li>\n</ul>\n<h4 id=\"when-not-to-use-effects\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b61w6swcjr5m72cx6fk3fck56\">何時不使用副作用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#when-not-to-use-effects\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71aog4nkhi17ekx1wyfmh3dvh\">要避免使用副作用來傳播狀態變更。這可能會導致 <code>ExpressionChangedAfterItHasBeenChecked</code> 錯誤、導致無限迴圈更新或導致不必要的變更檢測週期。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"esi4wfozl8mj5s6aw9s41cdcf\">由於存在這些風險，在副作用中預設不允許設定訊號，但在絕對必要時也可以啟用。</p>\n<h3 id=\"injection-context\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6i2331m8j8vxiqrm3m7o9qbot\">注入上下文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#injection-context\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6mkpwjlimemr0me09a1htk1sm\">預設情況下，使用 \n<code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a>()</code> 函式註冊新效果需要一個 \n<a href=\"/guide/dependency-injection-context\">注入上下文</a>（訪問 \n<code>inject</code> 函式）。提供這一點的最簡單方法是在元件、指令或服務的 \n<code>constructor</code> 中呼叫 \n<code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>：</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class EffectiveCounterCmp {\n  readonly count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n  constructor() {\n    // Register a new effect.\n    <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n      console.log(`The count is: ${this.count()})`);\n    });\n  }\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7bhr2azply4ezhi1h2m3yl5pk\">或者，可以將副作用賦值給一個欄位（這也會為其提供一個描述性名稱）。</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class EffectiveCounterCmp {\n  readonly count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n  \n  private loggingEffect = <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n    console.log(`The count is: ${this.count()})`);\n  });\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"377zp5d2bvl4je87fkduw8sg\">要在建構式函式之外建立副作用，你可以透過 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 的選項傳遞 <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> 以產生 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>：</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class EffectiveCounterCmp {\n  readonly count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n  constructor(private injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {}\n\n  initializeLogging(): void {\n    <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n      console.log(`The count is: ${this.count()})`);\n    }, {injector: this.injector});\n  }\n}\n</code-example>\n<h3 id=\"destroying-effects\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9bhshkxvby122ncer3rn84jdc\">銷燬副作用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#destroying-effects\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74e0lwmpg76kpkbhzhu03utz3\">當你建立一個副作用時，它會在其閉包上下文被銷燬時自動銷燬。這意味著當元件被銷燬時，在元件內建立的副作用也會被銷燬。指令、服務等中的副作用也是如此。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8s6xm8q4v8rux4m5xeibxu1vx\">副作用回傳一個 <code><a href=\"api/core/EffectRef\" class=\"code-anchor\">EffectRef</a></code>，可用於透過 <code>.destroy()</code> 操作手動銷燬它們。這也可以與 <code>manualCleanup</code> 選項結合使用，以建立持續到手動銷燬為止的副作用。當不再需要這些副作用時，要小心地實際清理它們。</p>\n<h2 id=\"advanced-topics\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74227uv8w0mnb9jwmm0p94era\">高階主題<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#advanced-topics\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"signal-equality-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebb4797d6e4zklfo4mardmyqh\">訊號相等性判定函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#signal-equality-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91olzgv279iaiz72mt5d9rtag\">建立訊號時，你可以選擇提供相等性判定函式，該函式將用於檢查新值是否真的與前一個值不同。</p>\n<code-example language=\"ts\">\nimport _ from 'lodash';\n\nconst data = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(['test'], {equal: _.isEqual});\n\n// Even though this is a different array instance, the deep equality\n// function will consider the values to be equal, and the <a href=\"api/core/signal\" class=\"code-anchor\">signal</a> won't\n// <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> any updates.\ndata.set(['test']);\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dooyqvr1jakjzi1jpqazderh\">可以為可寫訊號和計算訊號提供相等性判定函式。</p>\n<h3 id=\"reading-without-tracking-dependencies\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4z69vgrryxr1dp135t7wgnb98\">閱讀而不跟蹤依賴關係<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#reading-without-tracking-dependencies\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bw4f4xigkl5kjaj6d86tnuz94\">在極少數情況下，你可能希望在回應式函式（如<code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code>或<code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>）中執行可能讀取訊號的程式碼，但<strong>不希望</strong>建立一個依賴項。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"x3o6bo2srm6zwmte47d98pkl\">例如，假設當 <code>currentUser</code> 發生變化時，應該記錄 <code>counter</code> 的值。建立讀取這兩個訊號的 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>：</p>\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  console.log(`User set to `${currentUser()}` and the counter is ${counter()}`);\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4u1n0atyfye9fsqe1dh87kbw3\">此範例會在 <code>counter</code> 或 <code>currentUser</code> 發生變化時，記錄一條訊息。但是，如果副作用只應該在 <code>currentUser</code> 更改時才執行，則只會偶爾讀取 <code>counter</code>，因此對 <code>counter</code> 的更改不應記錄新訊息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bm3zdm0s5gnh11a5t31ou7zz2\">你可以透過使用 <code><a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a></code> 呼叫其 getter 來防止對訊號的讀取被跟蹤：</p>\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  console.log(`User set to `${currentUser()}` and the counter is ${<a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a>(counter)}`);\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7zpa87xn2yk4ohzf9z158xr2x\">當副作用需要呼叫一些不應被視為依賴項的外部程式碼時，<code><a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a></code> 也很有用：</p>\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  const user = currentUser();\n  <a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a>(() =&gt; {\n    // If the `loggingService` reads signals, they won't be counted as\n    // dependencies of this effect.\n    this.loggingService.log(`User set to ${user}`);\n  });\n});\n</code-example>\n<h3 id=\"effect-cleanup-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"49tbudq461hu89rnklzruv9yl\">副作用清理函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#effect-cleanup-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4u4q4t591go1mpmbq8gdcq4ni\">副作用可能會啟動長時間執行的操作，如果副作用在第一個操作完成之前就被銷燬或再次執行，則應取消該操作。建立副作用時，你的函式可以用 <code>onCleanup</code> 函式作為其第一個引數。這個 <code>onCleanup</code> 函式允許你註冊一個回呼，該回調在副作用的下一次執行開始之前或副作用被銷燬時調用。</p>\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>((onCleanup) =&gt; {\n  const user = currentUser();\n\n  const timer = setTimeout(() =&gt; {\n    console.log(`1 second ago, the user became ${user}`);\n  }, 1000);\n\n  onCleanup(() =&gt; {\n    clearTimeout(timer);\n  });\n});\n</code-example>\n\n  <div class=\"reviewed\">最後複查時間：Wed Jun 21 2023</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/core/ChangeDetectorRef#markforcheck\n - /guide/change-detection-skipping-subtrees\n - /guide/dependency-injection-context\n - /guide/releases#developer-preview\n - api/animations/trigger\n - api/core/Component\n - api/core/EffectRef\n - api/core/Injector\n - api/core/Signal\n - api/core/WritableSignal\n - api/core/computed\n - api/core/effect\n - api/core/signal\n - api/core/untracked\n - guide/signals#advanced-topics\n - guide/signals#angular-signals\n - guide/signals#computed-signal-dependencies-are-dynamic\n - guide/signals#computed-signals\n - guide/signals#computed-signals-are-both-lazily-evaluated-and-memoized\n - guide/signals#computed-signals-are-not-writable-signals\n - guide/signals#destroying-effects\n - guide/signals#effect-cleanup-functions\n - guide/signals#effects\n - guide/signals#injection-context\n - guide/signals#reading-signals-in-onpush-components\n - guide/signals#reading-without-tracking-dependencies\n - guide/signals#signal-equality-functions\n - guide/signals#use-cases-for-effects\n - guide/signals#what-are-signals\n - guide/signals#when-not-to-use-effects\n - guide/signals#writable-signals\n-->"}