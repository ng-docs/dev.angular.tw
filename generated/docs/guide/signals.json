{"id":"guide/signals","title":"Angular 信号（Signal）","contents":"<div class=\"content\">\n  <h1 id=\"angular-signals\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4v4ycngrts2vgsrm920jvsyon\">Angular 信号（Signal）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#angular-signals\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ljcmkooo3lywtegp5cke96fx\"><strong>Angular 信号（Signal）</strong>是一个体系，可以精细地跟踪你的状态在整个应用程序中的使用方式和位置，从而允许框架优化渲染更新。</p>\n<h2 id=\"what-are-signals\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e5nteqfnhhs39uz271fvirz3v\">什么是信号？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#what-are-signals\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8itl1xhr23sqxpr30ctm5ld3\"><strong>信号</strong>是一个值的包装器，可以在该值发生变化时通知感兴趣的消费者。信号可以包含任何值，从简单的原语到复杂的数据结构。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"36he8ypskdrpzn96zes9n29uv\">信号的值总会通过 getter 函数读取，这使得 Angular 可以跟踪信号的使用位置。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqiqriefulyi8615d7qn8gl05\">信号可以是<strong>可写的</strong>或<strong>只读的</strong>。</p>\n<h3 id=\"writable-signals\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7oz6k6xa7khhyl4bgazsgeuth\">可写信号<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#writable-signals\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"caessoxn4rttvxgj3nzccft7r\">可写信号提供了一个 API 来直接更新它们的值。你可以通过使用信号的初始值调用 <code><a href=\"api/core/signal\" class=\"code-anchor\">signal</a></code> 函数来创建可写信号：</p>\n<code-example language=\"ts\">\nconst count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n\n// Signals are getter functions - calling them reads their value.\nconsole.log('The count is: ' + count());\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1v4k4ygr72to5v4279i4zmots\">要更改可写信号的值，你可以直接 <code>.set()</code>：</p>\n<code-example language=\"ts\">\ncount.set(3);\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3cxlgxd2mbbiqhf1ci0aygzf6\">或者使用 <code>.update()</code> 操作从前一个值计算出一个新值：</p>\n<code-example language=\"ts\">\n// Increment the count by 1.\ncount.update(value =&gt; value + 1);\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cam4dba3h2mvmy0cqo7373rep\">可写信号的类型为 <code><a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a></code>。</p>\n<h3 id=\"computed-signals\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2x0royoakh9ax2x3iakyk1sy9\">计算（computed）信号<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8w0npe988ng37kdes1koxmsip\"><strong>计算信号</strong>是从其他信号中派生出来的。可以使用 <code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code> 并指定推导函数来定义一个：</p>\n<code-example language=\"typescript\">\nconst count: <a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a>&lt;number&gt; = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\nconst doubleCount: <a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>&lt;number&gt; = <a href=\"api/core/computed\" class=\"code-anchor\">computed</a>(() =&gt; count() * 2);\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9bf8xkg7j7tnc6sfmj3wftb5r\"><code>doubleCount</code> 信号取决于 <code>count</code>。每当 <code>count</code> 更新时，Angular 知道任何依赖于 <code>count</code> 或 <code>doubleCount</code> 东西也需要更新。</p>\n<h4 id=\"computed-signals-are-both-lazily-evaluated-and-memoized\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6lnytfwkx1nisqzp55t2nutev\">计算信号既是惰性评估的，也是记忆的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals-are-both-lazily-evaluated-and-memoized\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7neh7a5v658e2opr4h456nzwr\">在第一次读取 <code>doubleCount</code> 之前，不会运行 <code>doubleCount</code> 的派生函数以计算其值。一旦计算出来，这个值就会被缓存起来，以后读取 <code>doubleCount</code> 将返回缓存的值而不用重新计算。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1oocn28z1ww97u6pd2wsik37y\">当 <code>count</code> 发生变化时，它会告诉 <code>doubleCount</code> 它的缓存值不再有效，并且该值只会在下一次读取 <code>doubleCount</code> 时重新计算。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"206e50zan7jt0jq4xfq246urz\">因此，在计算信号中执行计算量大的推导（例如过滤数组）是相当安全的。</p>\n<h4 id=\"computed-signals-are-not-writable-signals\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7023c5wb1klek3333mskp4uhs\">计算信号不是可写信号<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals-are-not-writable-signals\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9mq4yndvns5xj7y53q6onls2x\">你不能直接为计算信号赋值。比如，</p>\n<code-example language=\"ts\">\ndoubleCount.set(3);\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63j7f5takuwddecykhdzcrkgo\">会产生编译错误，因为 <code>doubleCount</code> 不是 <code><a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a></code>。</p>\n<h4 id=\"computed-signal-dependencies-are-dynamic\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99c7be7ouf3tfqqccqcfvmkx3\">计算信号的依赖性是动态的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signal-dependencies-are-dynamic\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d4aakndrq89opq8aluq60alm\">只能跟踪推导期间实际读取过的信号。例如，在此计算中，只会有条件地读取 <code>count</code> 信号：</p>\n<code-example language=\"ts\">\nconst showCount = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(false);\nconst count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\nconst conditionalCount = <a href=\"api/core/computed\" class=\"code-anchor\">computed</a>(() =&gt; {\n  if (showCount()) {\n    return `The count is ${count()}.`;\n  } else {\n    return 'Nothing to see here!';\n  }\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xbhds043y0u1fz7g6k7s7glg\">读取 <code>conditionalCount</code> 时，如果 <code>showCount</code> 为 <code>false</code>，则<strong>没有</strong>读取 <code>count</code> 信号就返回了消息 “Nothing to see here!”。这意味着对 <code>count</code> 的更新不会导致重新计算。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2fa6epfpsuqy9zsn3tm0dfl1r\">如果稍后将 <code>showCount</code> 设置为 <code>true</code> 并再次读取 <code>conditionalCount</code>，则将重新执行派生并采用 <code>showCount</code> 为 <code>true</code> 的分支，返回显示 <code>count</code> 值的消息。对 <code>count</code> 的更改将使 <code>conditionalCount</code> 的缓存值无效。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ejzlkrxiv3itmo3npbkrtmkpe\">请注意，可以删除和添加依赖项。如果 <code>showCount</code> 稍后再次设置为 <code>false</code>，则 <code>count</code> 将不再被视为 <code>conditionalCount</code> 的依赖项。</p>\n<h2 id=\"reading-signals-in-onpush-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3g2aug3bh97eabpi43w74dzo9\">在 <code>OnPush</code> 型组件中读取信号<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#reading-signals-in-onpush-components\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c107wlwfzoax9pzjygft6t2b5\">当 <code>OnPush</code> 组件在其模板中使用信号值时，Angular 会将信号作为该组件的依赖项进行跟踪。当该信号更新时，Angular 会自动<a href=\"/api/core/ChangeDetectorRef#markforcheck\">标记</a>组件以确保它在下次运行变更检测时得到更新。有关 <code>OnPush</code> 组件的更多信息，请参阅<a href=\"/guide/change-detection-skipping-subtrees\">跳过组件子树</a>指南。</p>\n<h2 id=\"effects\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4vten9v01mjrmj5lt1b39xamu\">副作用（effect）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#effects\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1w87ddlhgkab4z22evlfwcydg\">信号很有用，因为它们可以在变化时通知感兴趣的消费者。<strong>副作用</strong>是一种操作，只要一个或多个信号值发生变化就会运行。你可以使用 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 函数创建副作用：</p>\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  console.log(`The current count is: ${count()}`);\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aqus4ly6lsiu6eu1901a2ifys\">副作用<strong>至少会运行一次。</strong> 当副作用运行时，它会跟踪任何信号值读取。只要这些信号值中的任何一个发生变化，副作用就会再次运行。与计算信号类似，副作用会动态跟踪它们的依赖关系，并且仅跟踪在最近一次执行中读取的信号。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b4is5z7ytw3pl5lpj3ix871p2\">在变化检测过程中，副作用始终<strong>异步</strong>执行。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vz51g7gki1if6jhi4k5otjc7\">注意： \n<code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a>()</code> API 仍处于 \n<a href=\"/guide/releases#developer-preview\">开发者预览</a> 阶段，因为我们正在努力将基于信号的响应性集成到核心框架中。</p>\n<h3 id=\"use-cases-for-effects\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b0hy6ub26u53qqw8x9k7ssv9e\">效果的使用案例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#use-cases-for-effects\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aojm4a2cia5wyfh6kexsaj193\">在大多数应用程序代码中很少需要副作用，但在特定情况下可能会有用。下面是一些需要以 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 作为解决方案的例子：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aqvurz2gevtem82essz2ynmwn\">记录正在显示的数据及其更改时间，用于分析或作为调试工具</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1otykpyf4kwt54pum1g6gjsie\">在数据与 <code>window.localStorage</code> 之间保持同步</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7s2rzjmsa3vyzeftfmeb8z9w2\">添加无法用模板语法表达的自定义 DOM 行为</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ccw4129o1q0i6h0n6eua54ot\">对 <code>&lt;canvas&gt;</code>、图表库或其他第三方 UI 库执行自定义渲染</li>\n</ul>\n<h4 id=\"when-not-to-use-effects\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b61w6swcjr5m72cx6fk3fck56\">何时不使用副作用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#when-not-to-use-effects\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71aog4nkhi17ekx1wyfmh3dvh\">要避免使用副作用来传播状态变更。这可能会导致 <code>ExpressionChangedAfterItHasBeenChecked</code> 错误、导致无限循环更新或导致不必要的变更检测周期。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"esi4wfozl8mj5s6aw9s41cdcf\">由于存在这些风险，在副作用中默认不允许设置信号，但在绝对必要时也可以启用。</p>\n<h3 id=\"injection-context\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6i2331m8j8vxiqrm3m7o9qbot\">注入上下文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#injection-context\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6mkpwjlimemr0me09a1htk1sm\">默认情况下，使用 \n<code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a>()</code> 函数注册新效果需要一个 \n<a href=\"/guide/dependency-injection-context\">注入上下文</a>（访问 \n<code>inject</code> 函数）。提供这一点的最简单方法是在组件、指令或服务的 \n<code>constructor</code> 中调用 \n<code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>：</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class EffectiveCounterCmp {\n  readonly count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n  constructor() {\n    // Register a new effect.\n    <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n      console.log(`The count is: ${this.count()})`);\n    });\n  }\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7bhr2azply4ezhi1h2m3yl5pk\">或者，可以将副作用赋值给一个字段（这也会为其提供一个描述性名称）。</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class EffectiveCounterCmp {\n  readonly count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n  \n  private loggingEffect = <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n    console.log(`The count is: ${this.count()})`);\n  });\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"377zp5d2bvl4je87fkduw8sg\">要在构造函数之外创建副作用，你可以通过 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 的选项传递 <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> 以产生 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>：</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class EffectiveCounterCmp {\n  readonly count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n  constructor(private injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {}\n\n  initializeLogging(): void {\n    <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n      console.log(`The count is: ${this.count()})`);\n    }, {injector: this.injector});\n  }\n}\n</code-example>\n<h3 id=\"destroying-effects\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9bhshkxvby122ncer3rn84jdc\">销毁副作用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#destroying-effects\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74e0lwmpg76kpkbhzhu03utz3\">当你创建一个副作用时，它会在其闭包上下文被销毁时自动销毁。这意味着当组件被销毁时，在组件内创建的副作用也会被销毁。指令、服务等中的副作用也是如此。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8s6xm8q4v8rux4m5xeibxu1vx\">副作用返回一个 <code><a href=\"api/core/EffectRef\" class=\"code-anchor\">EffectRef</a></code>，可用于通过 <code>.destroy()</code> 操作手动销毁它们。这也可以与 <code>manualCleanup</code> 选项结合使用，以创建持续到手动销毁为止的副作用。当不再需要这些副作用时，要小心地实际清理它们。</p>\n<h2 id=\"advanced-topics\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74227uv8w0mnb9jwmm0p94era\">高级主题<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#advanced-topics\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"signal-equality-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebb4797d6e4zklfo4mardmyqh\">信号相等性判定函数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#signal-equality-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91olzgv279iaiz72mt5d9rtag\">创建信号时，你可以选择提供相等性判定函数，该函数将用于检查新值是否真的与前一个值不同。</p>\n<code-example language=\"ts\">\nimport _ from 'lodash';\n\nconst data = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(['test'], {equal: _.isEqual});\n\n// Even though this is a different array instance, the deep equality\n// function will consider the values to be equal, and the <a href=\"api/core/signal\" class=\"code-anchor\">signal</a> won't\n// <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> any updates.\ndata.set(['test']);\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dooyqvr1jakjzi1jpqazderh\">可以为可写信号和计算信号提供相等性判定函数。</p>\n<h3 id=\"reading-without-tracking-dependencies\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4z69vgrryxr1dp135t7wgnb98\">阅读而不跟踪依赖关系<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#reading-without-tracking-dependencies\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bw4f4xigkl5kjaj6d86tnuz94\">在极少数情况下，你可能希望在响应式函数（如<code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code>或<code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>）中执行可能读取信号的代码，但<strong>不希望</strong>创建一个依赖项。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"x3o6bo2srm6zwmte47d98pkl\">例如，假设当 <code>currentUser</code> 发生变化时，应该记录 <code>counter</code> 的值。创建读取这两个信号的 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>：</p>\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  console.log(`User set to `${currentUser()}` and the counter is ${counter()}`);\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4u1n0atyfye9fsqe1dh87kbw3\">此示例会在 <code>counter</code> 或 <code>currentUser</code> 发生变化时，记录一条消息。但是，如果副作用只应该在 <code>currentUser</code> 更改时才运行，则只会偶尔读取 <code>counter</code>，因此对 <code>counter</code> 的更改不应记录新消息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bm3zdm0s5gnh11a5t31ou7zz2\">你可以通过使用 <code><a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a></code> 调用其 getter 来防止对信号的读取被跟踪：</p>\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  console.log(`User set to `${currentUser()}` and the counter is ${<a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a>(counter)}`);\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7zpa87xn2yk4ohzf9z158xr2x\">当副作用需要调用一些不应被视为依赖项的外部代码时，<code><a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a></code> 也很有用：</p>\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  const user = currentUser();\n  <a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a>(() =&gt; {\n    // If the `loggingService` reads signals, they won't be counted as\n    // dependencies of this effect.\n    this.loggingService.log(`User set to ${user}`);\n  });\n});\n</code-example>\n<h3 id=\"effect-cleanup-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"49tbudq461hu89rnklzruv9yl\">副作用清理函数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#effect-cleanup-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4u4q4t591go1mpmbq8gdcq4ni\">副作用可能会启动长时间运行的操作，如果副作用在第一个操作完成之前就被销毁或再次运行，则应取消该操作。创建副作用时，你的函数可以用 <code>onCleanup</code> 函数作为其第一个参数。这个 <code>onCleanup</code> 函数允许你注册一个回调，该回调在副作用的下一次运行开始之前或副作用被销毁时调用。</p>\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>((onCleanup) =&gt; {\n  const user = currentUser();\n\n  const timer = setTimeout(() =&gt; {\n    console.log(`1 second ago, the user became ${user}`);\n  }, 1000);\n\n  onCleanup(() =&gt; {\n    clearTimeout(timer);\n  });\n});\n</code-example>\n\n  <div class=\"reviewed\">最后复查时间：Wed Jun 21 2023</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/core/ChangeDetectorRef#markforcheck\n - /guide/change-detection-skipping-subtrees\n - /guide/dependency-injection-context\n - /guide/releases#developer-preview\n - api/animations/trigger\n - api/core/Component\n - api/core/EffectRef\n - api/core/Injector\n - api/core/Signal\n - api/core/WritableSignal\n - api/core/computed\n - api/core/effect\n - api/core/signal\n - api/core/untracked\n - guide/signals#advanced-topics\n - guide/signals#angular-signals\n - guide/signals#computed-signal-dependencies-are-dynamic\n - guide/signals#computed-signals\n - guide/signals#computed-signals-are-both-lazily-evaluated-and-memoized\n - guide/signals#computed-signals-are-not-writable-signals\n - guide/signals#destroying-effects\n - guide/signals#effect-cleanup-functions\n - guide/signals#effects\n - guide/signals#injection-context\n - guide/signals#reading-signals-in-onpush-components\n - guide/signals#reading-without-tracking-dependencies\n - guide/signals#signal-equality-functions\n - guide/signals#use-cases-for-effects\n - guide/signals#what-are-signals\n - guide/signals#when-not-to-use-effects\n - guide/signals#writable-signals\n-->"}