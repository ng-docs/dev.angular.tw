{"id":"guide/ssr","title":"服务端渲染","contents":"<div class=\"content\">\n  <h1 id=\"server-side-rendering\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63o3famemwo1dv6m2wf1liv55\">服务端渲染<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#server-side-rendering\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80bnpiy99fpg935l7dykarm2z\">服务器端渲染（SSR）是一个在服务器上呈现页面的过程，结果是包含初始页面状态的初始 HTML 内容。一旦 HTML 内容传输到浏览器，Angular 初始化应用程序并利用 HTML 中包含的数据。</p>\n<h2 id=\"why-use-ssr\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7uv6u7icrgbywhu01j8xbfhoi\">为什么要使用 SSR？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#why-use-ssr\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"nwvjgdve4yac1pbk1h93ti05\">与客户端渲染（CSR）相比，SSR 的主要优势包括：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4rbbjrpkfqaxuv4mymfowgzzd\"><strong>性能提升</strong>：通过向客户端提供完全呈现的 HTML，SSR 可以改善 Web 应用程序的性能，即使应用程序 JavaScript 尚未下载，浏览器也可以解析并显示。这对于低带宽连接或移动设备上的用户尤其有益。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"53685dyuo735cz5bi7v1hllgl\"><strong>改进的核心 Web Vitals</strong>：SSR 导致性能改进，可以使用 \n<a href=\"https://web.dev/learn-core-web-vitals/\">核心 Web Vitals（CWV）</a> 统计数据来衡量，如减少的首次内容绘制（\n<a href=\"https://developer.chrome.com/en/docs/lighthouse/performance/first-contentful-paint/\">FCP</a>）和最大内容绘制（\n<a href=\"https://web.dev/lcp/\">LCP</a>），以及累积布局变化（\n<a href=\"https://web.dev/cls/\">CLS</a>）。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ag6n8pbjogpel0b8cfoea9bxo\"><strong>更好的 SEO</strong>：SSR 可以通过使搜索引擎更容易爬取和索引应用程序的内容，从而改进 Web 应用程序的搜索引擎优化（SEO）。</li>\n</ul>\n<h2 id=\"enable-server-side-rendering\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wmy1am41dd36dw33fd4gs4rx\">启用服务器端渲染<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#enable-server-side-rendering\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5sle9wufegzdaup4f15uzhgjf\">要使用 SSR 创建一个\n<strong>新</strong>应用程序，请运行：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng new --ssr\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bdz2zbjvsx2esxf55oi6lc1ml\">要将 SSR 添加到一个\n<strong>现有</strong>项目中，请使用 Angular CLI 的 \n<code>ng add</code> 命令。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng add @angular/ssr\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5eoz8ckj80aa4f6u0z0r0f0r6\">这些命令会创建并更新应用程序代码以启用 SSR，并向项目结构添加额外的文件。</p>\n<code-example language=\"text\">\n\nmy-app\n|-- server.ts                       # application server\n└── src\n    |-- app\n    |   └── app.config.server.ts    # server application configuration\n    └── main.server.ts              # main server application bootstrapping\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eq5umjkgxj73ppzgu5hr0ik3y\">要验证应用程序是否进行了服务器端渲染，请在本地运行 \n<code>ng serve</code>。初始 HTML 请求应包含应用程序内容。</p>\n<h2 id=\"configure-server-side-rendering\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3e71mo3ljwpk0s1e0wxynkrgq\">配置服务器端渲染<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#configure-server-side-rendering\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3a9fpu6ush9eofmetganmh2c8\"><code>server.ts</code> 文件配置了一个 Node.js Express 服务器和 Angular 服务器端渲染。使用 \n<code>CommonEngine</code> 来渲染 Angular 应用程序。</p>\n<code-example path=\"ssr/server.ts\" region=\"navigation-request\">\n// All regular routes use the Angular engine\nserver.get('*', (req, res, next) =&gt; {\n  const {protocol, originalUrl, baseUrl, headers} = req;\n\n  commonEngine\n      .render({\n        bootstrap,\n        documentFilePath: indexHtml,\n        url: `${protocol}://${headers.host}${originalUrl}`,\n        publicPath: browserDistFolder,\n        providers: [{provide: <a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a>, useValue: req.baseUrl}],\n      })\n      .then((html) =&gt; res.send(html))\n      .catch((err) =&gt; next(err));\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9hxl4m9f3tw7lfogos11tgd1t\"><code>CommonEngine</code> 的 \n<code>render</code> 方法接受一个具有以下属性的对象：</p>\n<table>\n<thead>\n<tr>\n<th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ghvm54f9feewnb0zbrlubp2h\">属性</th>\n<th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n<th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6cwhe65hais9ueojrcln3vqi4\">默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>bootstrap</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2t3h3ix83ecaekog3naepqcvj\">一个返回 \n<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 或解析为 \n<code><a href=\"api/core/ApplicationRef\" class=\"code-anchor\">ApplicationRef</a></code> 的 promise 的方法。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>providers</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5v9d27s598guvmv4mc50u54t3\">当前请求的平台级提供者数组。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>url</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1p6jk8u1ncmvm44488va0rdx9\">要渲染的页面的 URL。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>inlineCriticalCss</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ep5wfos0y3f4wk2upy8ooicp\">是否通过内联关键 CSS 来减少渲染阻塞请求。</td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td><code>publicPath</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ugh6smvbp9zznq51xy2n5j7g\">浏览器文件和资产的基础路径。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>document</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51kl17k5ntctcy76otvav6l25\">用于引导服务器应用程序的初始 DOM。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>documentFilePath</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"532mtrwwto0rxe9keflvryw7v\">用于引导服务器应用程序的初始 DOM 的文件路径。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cq5l90b0tkd6a1glalipahzig\">Angular CLI 将创建一个初始的服务器实现，专注于为你的 Angular 应用程序进行服务器端渲染。此服务器可以扩展以支持其他功能，如 API 路由、重定向、静态资产等。查看\n<a href=\"https://expressjs.com/\">Express 文档</a>了解更多详情。</p>\n<h2 id=\"hydration\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f56gmhqyrur87h9p9zanu9nib\">水合（Hydration）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#hydration\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"23mseawk51gcdv9mh993zn9f\">水合是将服务器端渲染的应用程序恢复到客户端的过程。这包括重用服务器端渲染的 DOM 结构、保留应用程序状态、传输服务器已检索到的应用程序数据以及其他过程。当使用 SSR 时，默认启用水合。你可以在\n<a href=\"guide/hydration\">水合指南</a>中找到更多信息。</p>\n<h2 id=\"caching-data-when-using-httpclient\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"86j04jkj9drg1ojtcxe984irc\">在使用 HttpClient 时缓存数据<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#caching-data-when-using-httpclient\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4i0buu7bzkz845l1s2aqjqp58\">启用 SSR 后，运行在服务器上时，\n<a href=\"api/common/http/HttpClient\"><code>HttpClient</code></a> 响应会被缓存。然后，这些信息会被序列化并作为从服务器发送的初始 HTML 的一部分传输到浏览器。在浏览器中，\n<a href=\"api/common/http/HttpClient\"><code>HttpClient</code></a> 会检查缓存中是否有数据，如果有，则在初始应用程序渲染期间重用它，而不是进行新的 HTTP 请求。当应用程序在浏览器中变得\n<a href=\"api/core/ApplicationRef#isStable\">稳定</a>后，\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 将停止使用缓存。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1e044amfibiz5bw5tlzca6iqa\">默认情况下，所有 \n<code>HEAD</code> 和 \n<code>GET</code> 请求都会被缓存。你可以通过在提供水合时使用 \n<a href=\"/api/platform-browser/withHttpTransferCacheOptions\"><code>withHttpTransferCacheOptions</code></a> 来配置此缓存。</p>\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(AppComponent, {\n  providers: [\n    <a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a>(\n      <a href=\"api/platform-browser/withHttpTransferCacheOptions\" class=\"code-anchor\">withHttpTransferCacheOptions</a>({\n        includePostRequests: true,\n      }),\n    ),\n  ],\n});\n</code-example>\n<h2 id=\"authoring-server-compatible-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6uwfoot46hke04ich763n0a7v\">编写服务器兼容的组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#authoring-server-compatible-components\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9w8efg2xjf6i5iip42hlf5h6o\">一些常见的浏览器 API 和功能在服务器上可能不可用。应用程序不能使用特定于浏览器的全局对象，如 \n<code>window</code>、\n<code>document</code>、\n<code>navigator</code> 或 \n<code>location</code>，以及 \n<code>HTMLElement</code> 的某些属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59c5j3b2bp8cgwi4b2pdse8kq\">一般来说，依赖于浏览器特定符号的代码应该只在浏览器中执行，而不在服务器上执行。可以通过 \n<a href=\"api/core/afterRender\"><code>afterRender</code></a> 和 \n<a href=\"api/core/afterNextRender\"><code>afterNextRender</code></a> 生命周期钩子来实现这一点。这些钩子只在浏览器上执行，而在服务器上被跳过。</p>\n<code-example language=\"ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>, <a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-cmp',\n  template: `&lt;span #content&gt;{{ ... }}&lt;/span&gt;`,\n})\nexport class MyComponent {\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('content') contentRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n  constructor() {\n    <a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a>(() =&gt; {\n      // Safe to check `scrollHeight` because this will only run in the <a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>, not the server.\n      console.log('content height: ' + this.contentRef.nativeElement.scrollHeight);\n    });\n  }\n}\n</code-example>\n<h2 id=\"using-angular-service-worker\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8n5dwr3eb2tom8f5yiia0f153\">使用 Angular Service Worker<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#using-angular-service-worker\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dnw4aeeqef6882l36xaosyebz\">如果你在服务器上使用 Angular 与 Angular 服务工作者，行为将与正常的服务器端渲染行为有所偏离。初始服务器请求将如预期地在服务器上呈现。然而，在初始请求之后，后续请求将由服务工作者处理，并始终在客户端上呈现。</p>\n<h2 id=\"enable-performance-profiling\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rup5u228vr6bmaui4w1hn95t\">启用性能分析<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#enable-performance-profiling\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1gwthrh9i4pqu55ffdjwbswqc\"><code>CommonEngine</code> 提供了一个选项，用于启动性能分析数据的收集，并在服务器控制台中显示结果。这可以通过将 \n<code>enablePerformanceProfiler</code> 设置为 \n<code>true</code> 来实现。</p>\n<code-example language=\"ts\">\nconst commonEngine = new CommonEngine({\n  enablePerformanceProfiler: true,\n});\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Fri Nov 03 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/platform-server\n - api/router/ExtraOptions\n - api/router/InitialNavigation\n - api/router/withEnabledBlockingInitialNavigation\n - errors/NG0912\n - guide/architecture-next-steps\n - guide/developer-guide-overview\n - guide/glossary\n - guide/web-worker\n-->\n<!-- links from this doc:\n - /api/platform-browser/withHttpTransferCacheOptions\n - api/animations/browser\n - api/common/APP_BASE_HREF\n - api/common/http/HttpClient\n - api/core/ApplicationRef\n - api/core/ApplicationRef#isStable\n - api/core/Component\n - api/core/ElementRef\n - api/core/NgModule\n - api/core/ViewChild\n - api/core/afterNextRender\n - api/core/afterRender\n - api/platform-browser/bootstrapApplication\n - api/platform-browser/provideClientHydration\n - api/platform-browser/withHttpTransferCacheOptions\n - guide/hydration\n - guide/ssr#authoring-server-compatible-components\n - guide/ssr#caching-data-when-using-httpclient\n - guide/ssr#configure-server-side-rendering\n - guide/ssr#enable-performance-profiling\n - guide/ssr#enable-server-side-rendering\n - guide/ssr#hydration\n - guide/ssr#server-side-rendering\n - guide/ssr#using-angular-service-worker\n - guide/ssr#why-use-ssr\n - https://developer.chrome.com/en/docs/lighthouse/performance/first-contentful-paint/\n - https://expressjs.com/\n - https://web.dev/cls/\n - https://web.dev/lcp/\n - https://web.dev/learn-core-web-vitals/\n-->"}