{"id":"guide/ssr","title":"伺服器端渲染","contents":"<div class=\"content\">\n  <h1 id=\"server-side-rendering\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63o3famemwo1dv6m2wf1liv55\">伺服器端渲染<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#server-side-rendering\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80bnpiy99fpg935l7dykarm2z\">伺服器端渲染（SSR）是一個在服務器上呈現頁面的過程，結果是包含初始頁面狀態的初始 HTML 內容。一旦 HTML 內容傳輸到瀏覽器，Angular 初始化應用程式並利用 HTML 中包含的資料。</p>\n<h2 id=\"why-use-ssr\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7uv6u7icrgbywhu01j8xbfhoi\">為什麼要使用 SSR？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#why-use-ssr\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"nwvjgdve4yac1pbk1h93ti05\">與用戶端渲染（CSR）相比，SSR 的主要優勢包括：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4rbbjrpkfqaxuv4mymfowgzzd\"><strong>效能提升</strong>：透過向用戶端提供完全呈現的 HTML，SSR 可以改善 Web 應用程式的效能，即使應用程式 JavaScript 尚未下載，瀏覽器也可以解析並顯示。這對於低頻寬連線或行動裝置上的使用者尤其有益。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"53685dyuo735cz5bi7v1hllgl\"><strong>改進的核心 Web Vitals</strong>：SSR 導致效能改進，可以使用 \n<a href=\"https://web.dev/learn-core-web-vitals/\">核心 Web Vitals（CWV）</a> 統計資料來衡量，如減少的首次內容繪製（\n<a href=\"https://developer.chrome.com/en/docs/lighthouse/performance/first-contentful-paint/\">FCP</a>）和最大內容繪製（\n<a href=\"https://web.dev/lcp/\">LCP</a>），以及累積佈局變化（\n<a href=\"https://web.dev/cls/\">CLS</a>）。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ag6n8pbjogpel0b8cfoea9bxo\"><strong>更好的 SEO</strong>：SSR 可以透過使搜尋引擎更容易爬取和索引應用程式的內容，從而改進 Web 應用程式的搜尋引擎最佳化（SEO）。</li>\n</ul>\n<h2 id=\"enable-server-side-rendering\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wmy1am41dd36dw33fd4gs4rx\">啟用伺服器端渲染<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#enable-server-side-rendering\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5sle9wufegzdaup4f15uzhgjf\">要使用 SSR 建立一個\n<strong>新</strong>應用程式，請執行：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng new --ssr\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bdz2zbjvsx2esxf55oi6lc1ml\">要將 SSR 新增到一個\n<strong>現有</strong>專案中，請使用 Angular CLI 的 \n<code>ng add</code> 指令。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng add @angular/ssr\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5eoz8ckj80aa4f6u0z0r0f0r6\">這些指令會建立並更新應用程式程式碼以啟用 SSR，並向專案結構新增額外的檔案。</p>\n<code-example language=\"text\">\n\nmy-app\n|-- server.ts                       # application server\n└── src\n    |-- app\n    |   └── app.config.server.ts    # server application configuration\n    └── main.server.ts              # main server application bootstrapping\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eq5umjkgxj73ppzgu5hr0ik3y\">要驗證應用程式是否進行了伺服器端渲染，請在本地執行 \n<code>ng serve</code>。初始 HTML 請求應包含應用程式內容。</p>\n<h2 id=\"configure-server-side-rendering\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3e71mo3ljwpk0s1e0wxynkrgq\">設定服務器端渲染<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#configure-server-side-rendering\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3a9fpu6ush9eofmetganmh2c8\"><code>server.ts</code> 檔案設定了一個 Node.js Express 伺服器和 Angular 伺服器端渲染。使用 \n<code>CommonEngine</code> 來渲染 Angular 應用程式。</p>\n<code-example path=\"ssr/server.ts\" region=\"navigation-request\">\n// All regular routes use the Angular engine\nserver.get('*', (req, res, next) =&gt; {\n  const {protocol, originalUrl, baseUrl, headers} = req;\n\n  commonEngine\n      .render({\n        bootstrap,\n        documentFilePath: indexHtml,\n        url: `${protocol}://${headers.host}${originalUrl}`,\n        publicPath: browserDistFolder,\n        providers: [{provide: <a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a>, useValue: req.baseUrl}],\n      })\n      .then((html) =&gt; res.send(html))\n      .catch((err) =&gt; next(err));\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9hxl4m9f3tw7lfogos11tgd1t\"><code>CommonEngine</code> 的 \n<code>render</code> 方法接受一個具有以下屬性的物件：</p>\n<table>\n<thead>\n<tr>\n<th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ghvm54f9feewnb0zbrlubp2h\">屬性</th>\n<th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n<th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6cwhe65hais9ueojrcln3vqi4\">預設值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>bootstrap</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2t3h3ix83ecaekog3naepqcvj\">一個回傳 \n<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 或解析為 \n<code><a href=\"api/core/ApplicationRef\" class=\"code-anchor\">ApplicationRef</a></code> 的 promise 的方法。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>providers</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5v9d27s598guvmv4mc50u54t3\">當前請求的平台級提供者陣列。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>url</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1p6jk8u1ncmvm44488va0rdx9\">要渲染的頁面的 URL。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>inlineCriticalCss</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ep5wfos0y3f4wk2upy8ooicp\">是否透過行內關鍵 CSS 來減少渲染阻塞請求。</td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td><code>publicPath</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ugh6smvbp9zznq51xy2n5j7g\">瀏覽器檔案和資產的基礎路徑。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>document</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51kl17k5ntctcy76otvav6l25\">用於引導伺服器應用程式的初始 DOM。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>documentFilePath</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"532mtrwwto0rxe9keflvryw7v\">用於引導伺服器應用程式的初始 DOM 的檔案路徑。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cq5l90b0tkd6a1glalipahzig\">Angular CLI 將建立一個初始的伺服器實現，專注於為你的 Angular 應用程式進行伺服器端渲染。此伺服器可以擴充套件以支援其他功能，如 API 路由、重導向、靜態資產等。檢視\n<a href=\"https://expressjs.com/\">Express 文件</a>瞭解更多詳情。</p>\n<h2 id=\"hydration\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f56gmhqyrur87h9p9zanu9nib\">水合（Hydration）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#hydration\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"23mseawk51gcdv9mh993zn9f\">水合是將伺服器端渲染的應用程式恢復到用戶端的過程。這包括重用伺服器端渲染的 DOM 結構、保留應用程式狀態、傳輸伺服器已檢索到的應用程式資料以及其他過程。當使用 SSR 時，預設啟用水合。你可以在\n<a href=\"guide/hydration\">水合指南</a>中找到更多訊息。</p>\n<h2 id=\"caching-data-when-using-httpclient\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"86j04jkj9drg1ojtcxe984irc\">在使用 HttpClient 時快取資料<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#caching-data-when-using-httpclient\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4i0buu7bzkz845l1s2aqjqp58\">啟用 SSR 後，執行在服務器上時，\n<a href=\"api/common/http/HttpClient\"><code>HttpClient</code></a> 回應會被快取。然後，這些訊息會被序列化並作為從伺服器傳送的初始 HTML 的一部分傳輸到瀏覽器。在瀏覽器中，\n<a href=\"api/common/http/HttpClient\"><code>HttpClient</code></a> 會檢查快取中是否有數據，如果有，則在初始應用程式渲染期間重用它，而不是進行新的 HTTP 請求。當應用程式在瀏覽器中變得\n<a href=\"api/core/ApplicationRef#isStable\">穩定</a>後，\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 將停止使用快取。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1e044amfibiz5bw5tlzca6iqa\">預設情況下，所有 \n<code>HEAD</code> 和 \n<code>GET</code> 請求都會被快取。你可以透過在提供水合時使用 \n<a href=\"/api/platform-browser/withHttpTransferCacheOptions\"><code>withHttpTransferCacheOptions</code></a> 來設定此快取。</p>\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(AppComponent, {\n  providers: [\n    <a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a>(\n      <a href=\"api/platform-browser/withHttpTransferCacheOptions\" class=\"code-anchor\">withHttpTransferCacheOptions</a>({\n        includePostRequests: true,\n      }),\n    ),\n  ],\n});\n</code-example>\n<h2 id=\"authoring-server-compatible-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6uwfoot46hke04ich763n0a7v\">編寫伺服器相容的元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#authoring-server-compatible-components\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9w8efg2xjf6i5iip42hlf5h6o\">一些常見的瀏覽器 API 和功能在服務器上可能不可用。應用程式不能使用特定於瀏覽器的全域物件，如 \n<code>window</code>、\n<code>document</code>、\n<code>navigator</code> 或 \n<code>location</code>，以及 \n<code>HTMLElement</code> 的某些屬性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59c5j3b2bp8cgwi4b2pdse8kq\">一般來說，依賴於瀏覽器特定符號的程式碼應該只在瀏覽器中執行，而不在伺服器上執行。可以透過 \n<a href=\"api/core/afterRender\"><code>afterRender</code></a> 和 \n<a href=\"api/core/afterNextRender\"><code>afterNextRender</code></a> 生命週期鉤子來實現這一點。這些鉤子只在瀏覽器上執行，而在服務器上被跳過。</p>\n<code-example language=\"ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>, <a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-cmp',\n  template: `&lt;span #content&gt;{{ ... }}&lt;/span&gt;`,\n})\nexport class MyComponent {\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('content') contentRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n  constructor() {\n    <a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a>(() =&gt; {\n      // Safe to check `scrollHeight` because this will only run in the <a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>, not the server.\n      console.log('content height: ' + this.contentRef.nativeElement.scrollHeight);\n    });\n  }\n}\n</code-example>\n<h2 id=\"using-angular-service-worker\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8n5dwr3eb2tom8f5yiia0f153\">使用 Angular Service Worker<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#using-angular-service-worker\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dnw4aeeqef6882l36xaosyebz\">如果你在服務器上使用 Angular 與 Angular 服務工作者，行為將與正常的伺服器端渲染行為有所偏離。初始伺服器請求將如預期地在服務器上呈現。然而，在初始請求之後，後續請求將由服務工作者處理，並始終在用戶端上呈現。</p>\n<h2 id=\"enable-performance-profiling\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rup5u228vr6bmaui4w1hn95t\">啟用效能分析<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ssr#enable-performance-profiling\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1gwthrh9i4pqu55ffdjwbswqc\"><code>CommonEngine</code> 提供了一個選項，用於啟動效能分析資料的收集，並在伺服器控制台中顯示結果。這可以透過將 \n<code>enablePerformanceProfiler</code> 設定為 \n<code>true</code> 來實現。</p>\n<code-example language=\"ts\">\nconst commonEngine = new CommonEngine({\n  enablePerformanceProfiler: true,\n});\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Fri Nov 03 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/platform-server\n - api/router/ExtraOptions\n - api/router/InitialNavigation\n - api/router/withEnabledBlockingInitialNavigation\n - errors/NG0912\n - guide/architecture-next-steps\n - guide/developer-guide-overview\n - guide/glossary\n - guide/web-worker\n-->\n<!-- links from this doc:\n - /api/platform-browser/withHttpTransferCacheOptions\n - api/animations/browser\n - api/common/APP_BASE_HREF\n - api/common/http/HttpClient\n - api/core/ApplicationRef\n - api/core/ApplicationRef#isStable\n - api/core/Component\n - api/core/ElementRef\n - api/core/NgModule\n - api/core/ViewChild\n - api/core/afterNextRender\n - api/core/afterRender\n - api/platform-browser/bootstrapApplication\n - api/platform-browser/provideClientHydration\n - api/platform-browser/withHttpTransferCacheOptions\n - guide/hydration\n - guide/ssr#authoring-server-compatible-components\n - guide/ssr#caching-data-when-using-httpclient\n - guide/ssr#configure-server-side-rendering\n - guide/ssr#enable-performance-profiling\n - guide/ssr#enable-server-side-rendering\n - guide/ssr#hydration\n - guide/ssr#server-side-rendering\n - guide/ssr#using-angular-service-worker\n - guide/ssr#why-use-ssr\n - https://developer.chrome.com/en/docs/lighthouse/performance/first-contentful-paint/\n - https://expressjs.com/\n - https://web.dev/cls/\n - https://web.dev/lcp/\n - https://web.dev/learn-core-web-vitals/\n-->"}