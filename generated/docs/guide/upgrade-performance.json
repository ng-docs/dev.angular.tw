{"id":"guide/upgrade-performance","title":"更关注性能的升级方式","contents":"<div class=\"content\">\n  <h1 id=\"upgrading-for-performance\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d8ubq0eivkklkj7lo97yxv15y\">更关注性能的升级方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#upgrading-for-performance\"><i class=\"material-icons\">link</i></a></h1>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3m6ulnpzcn2y5u3f8vwoehnkh\"><em>Angular</em>是现在和未来的 Angular 名称。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uqkk63xsc5jgyb3fj0eka9ee\"><em>AngularJS</em>是所有 1.x 版本的 Angular 的名称。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1zza3plof96x22x2i9z4zcbuu\">这个指南描述了一些内置工具，用于逐步将 AngularJS 项目高效迁移到 Angular 平台。 它与从 AngularJS 迁移相关的文档非常相似，唯一的区别在于这个文档使用了 \n<a href=\"api/upgrade/static/downgradeModule\">downgradeModule()</a> 辅助函数，而不是 \n<a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a> 类。 这会影响应用程序的引导方式以及两个框架之间变化检测的传播方式。 这允许你逐步升级，同时提高混合应用程序的速度，并在升级过程的早期阶段利用 Angular 最新的功能。</p>\n<h2 id=\"preparation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"950c8mg85fl94yevwp15mppan\">准备工作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#preparation\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cnegfd07ogi8ni2tyjqzzqq0l\">在讨论你应该如何用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 来创建混合式应用之前，你可以先采取一些措施来简化升级过程，甚至在开始升级之前就可以做。无论你用哪种方式升级，这些步骤都是一样的，请参考<a href=\"guide/upgrade\">从 AngularJS 升级</a>的<a href=\"guide/upgrade#preparation\">准备工作</a>部分。</p>\n<h2 id=\"upgrading-with-ngupgrade\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"t86b1lwh4xrhvmtwo5otuzpz\">使用 <code>ngUpgrade</code> 升级<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#upgrading-with-ngupgrade\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bj7xkz1d1mol50n9tx930i6mk\">使用 Angular 中的 <code>ngUpgrade</code> 库，你可以通过构建混合式应用来逐步升级现有的 AngularJS 应用。在这些混合式应用中，你可以混用 AngularJS 和 Angular 的组件与服务，并让它们天衣无缝地进行互操作。这意味着你不用一次性完成迁移工作，因为在过渡阶段两个框架可以自然共存。</p>\n<h3 id=\"how-ngupgrade-works\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"30mbf3mud9r5ihbz5u5uldei2\"><code>ngUpgrade</code> 的工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#how-ngupgrade-works\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3usppzcegdgzlu55dn2zqcck\">无论选择 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 还是 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，升级的基本原则都是一样的：无论是混合式应用背后的心智模型，还是 <a href=\"api/upgrade/static\">upgrade/static</a> 的用法。要了解更多，参阅<a href=\"guide/upgrade\">从 AngularJS 升级</a>的 <a href=\"guide/upgrade#how-ngupgrade-works\"><code>ngUpgrade</code> 工作原理</a>部分。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"52ambp1yzw3nr9sdf14p91oa4\"><a href=\"guide/upgrade\">从 AngularJS 升级</a>中的<a href=\"guide/upgrade#change-detection\">变更检测</a>部分仅仅适用于使用 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 的应用。虽然你处理变更检测的方式和 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>（本章的重点）不同，不过读一下<a href=\"guide/upgrade#change-detection\">变更检测</a>部分还是能为后续内容提供一些有用的上下文知识。</p>\n</div>\n<h4 id=\"change-detection-with-downgrademodule\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c9zkg5hdv3w5zut42k7cgws0c\">使用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 进行变更检测<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#change-detection-with-downgrademodule\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6dhza4zzerfifdmmx0c7vw6ai\">如前所述，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 和 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 之间的一个关键区别，就是如何进行变更检测，以及检测结果如何在两个框架之间传播。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ndl0ed6lxeupuw7e7letnxz4\">使用 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，两套变更检测系统绑得更紧密一些。一旦应用中的 AngularJS 部分发生了某些变化，变更检测就会自动在 Angular 部分触发它，反之亦然。这很方便，因为它保证了任何一个框架都不会丢失重要的变更。不过，其实大多数情况下并不需要运行这些额外的变更检测。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ahs0wy40l57hzod8rkbl6mbo\">而 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 会避免显式触发变更检测，除非它确信应用的其它部分对此感兴趣。比如，如果被降级的组件定义了 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>，当那个值发生变化时，应用就可能需要知道。因此，<code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 就会自动在该组件上触发变更检测。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8nmhh25mq3hq8dwzveim95rfv\">但是，大多数情况下，应用的其它地方并不会关心某个组件中进行的局部更改。比如，如果用户点击了某个表单的提交按钮，通常会由组件自行处理这个操作的结果。话虽如此，但在某些情况下，你可能希望把这些变化传播到应用中由另一个框架控制的部分。这时候，你就有责任通过手动触发变更检测来通知相关方。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"exs7vyqkyfmrvuzp6rhdwhzxd\">如果你想让应用程序的 AngularJS 部分触发变化检测，你需要将特定代码包装在 \n<a href=\"https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply\">scope.$apply()</a> 中。 类似地，要在 Angular 中触发变化检测，你可以使用 \n<a href=\"api/core/NgZone#run\">ngZone.run()</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f2z7rffxdti70s084qdxc88za\">很多情况下，是否运行额外的变更检测可能并不重要。不过，在较大或变更检测较多的应用中，它们可能会产生显著地影响。通过让你更精细的控制变更检测的传播方式，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 可以让你的混合式应用达到更好地性能。</p>\n<h2 id=\"using-downgrademodule\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qziln42e8fmzwemi5mwr2x9k\">使用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-downgrademodule\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xu705qs3u18cfaa34gm2ivxj\">AngularJS 和 Angular 都有自己的模块概念，来帮你把应用按功能组织成内聚的代码块。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cbbpd6mwvc63o82agxw46xh6m\">它们的架构和实现方式有很大的不同。 在 AngularJS 中，你通过使用 \n<a href=\"https://docs.angularjs.org/api/ng/function/angular.module\">angular.module()</a> 指定模块的名称和依赖关系来创建一个模块。 然后你可以使用其各种方法添加资产。 在 Angular 中，你创建一个带有 \n<a href=\"api/core/NgModule\">NgModule</a> 装饰器的类，描述元数据中的资产。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6jpswo77rzv65qu7yyp0ijfpk\">在混合式应用中，你同时运行着两个框架。这意味着你至少需要一个来自 AngularJS 的模块和一个来自 Angular 的模块。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6g4siosnsje50px4u9q4oktwg\">大多数情况下，你可以使用与常规应用程序相同的方式来指定模块。然后，使用 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 辅助函数来让两个框架了解对方使用的资产。这叫做\"升级（upgrading）\"和\"降级（downgrading）\"。</p>\n<div class=\"callout is-helpful\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9kncoqehartiho1abqwo0mcu4\">定义：</header>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7yniky6cc5rmj9e2ldt82nbmq\"><em>升级</em>：让 AngularJS 中的资产，比如组件或服务，可用于应用中的 Angular 部分。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"nkcx881c46wpgwqc27seng54\"><em>降级</em>：让 Angular 中的资产，比如组件或服务，可用于应用中的 AngularJS 部分。</p>\n</li>\n</ul>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b73v4y2xekn2t54of20exg06b\">依赖互联中最重要的部分之一是把两个主模块联结在一起。这就是 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 的用武之地。使用它来创建 AngularJS 模块（你可以在 AngularJS 主模块中把这个模块用作依赖项），该模块将引导你的 Angular 主模块，并启动混合式应用中的 Angular 部分。从某种意义上说，它把 NgModule \"降级\"成了 AngularJS 模块。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dn85efczkbsetpnikuxoxdy5\">要记住如下几点：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1wcje0navt071hd2duuh719nm\">你不必把 Angular 模块直接传给 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>。<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 所需要的只是一个用来创建模块实例 \"配方\"（比如工厂函数）。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9sqwu3xmdol1pb7jl3fsdxkhm\">除非应用实际用到了，否则不会初始化这个 Angular 模块。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8v13mog2cgmloxwzpvr6aaq4x\">下面是如何使用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 来联结两个模块的例子。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n// Import `<a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()`.\nimport { <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n// Use it to downgrade the Angular module to an AngularJS module.\nconst downgradedModule = <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>(MainAngularModuleFactory);\n\n// Use the downgraded module as a dependency to the main AngularJS module.\nangular.module('mainAngularJsModule', [\n  downgradedModule\n]);\n\n</code-example>\n<h4 id=\"specifying-a-factory-for-the-angular-module\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3d2ddzjbd5a5fu8t31s1sw27n\">为 Angular 模块指定一个工厂<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#specifying-a-factory-for-the-angular-module\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eghxo5grl1dvobtmox6oil9bx\">如前所述，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 需要知道如何实例化 Angular 模块。你可以通过提供可以创建 Angular 模块实例的工厂函数来定义该配方。<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 接受两种类型的工厂函数：</p>\n<ul>\n<li><code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code></li>\n<li><code>(extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) =&gt; Promise&lt;<a href=\"api/core/NgModuleRef\" class=\"code-anchor\">NgModuleRef</a>&gt;</code></li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3b1h8n3jd1k4p84d4h640fj3\">当你传递一个 \n<code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code>，\n<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 使用它来使用 \n<a href=\"api/platform-browser/platformBrowser\">platformBrowser</a> 的 \n<a href=\"api/core/PlatformRef#bootstrapModuleFactory\">bootstrapModuleFactory()</a> 实例化模块，这与预先编译（AOT）兼容。 AOT 编译有助于使你的应用程序加载更快。 有关 AOT 以及如何创建 \n<code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code> 的更多信息，请参阅 \n<a href=\"guide/aot-compiler\">预先编译</a> 指南。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7l2gyrbr7kwokc665egjm8m0b\">另外，你还可以传入一个普通函数，它要返回一个解析为 <a href=\"api/core/NgModuleRef\">NgModuleRef</a>（比如你的 Angular 模块）的 Promise。该函数接收一个额外 <a href=\"api/core/StaticProvider\">Providers</a> 的数组，这个数组可以在所返回 <code><a href=\"api/core/NgModuleRef\" class=\"code-anchor\">NgModuleRef</a></code> 的 <a href=\"api/core/Injector\">Injector</a> 中可用。比如，如果你在使用 <a href=\"api/platform-browser/platformBrowser\">platformBrowser</a> 或 <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\">platformBrowserDynamic</a>，就可以把 <code>extraProviders</code> 数组传给它们：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst bootstrapFn = (extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) =&gt; {\n  const platformRef = <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>(extraProviders);\n  return platformRef.bootstrapModule(MainAngularModule);\n};\n// or\nconst bootstrapFn = (extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) =&gt; {\n  const platformRef = <a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>(extraProviders);\n  return platformRef.bootstrapModuleFactory(MainAngularModuleFactory);\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xrmrq28ci7w5hpuzw4xxhdto\">使用 <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code> 需要更少的样板代码，并且是一个很好的默认选项，因为它支持 AOT 开箱即用。使用自定义函数需要稍多的代码，但是给你提供了更大的灵活性。</p>\n<h4 id=\"instantiating-the-angular-module-on-demand\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eteghxsghyhx2dpyjbqqbwz0y\">按需实例化 Angular 模块<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#instantiating-the-angular-module-on-demand\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7fjok37o0mm3sgfpaipzq3f6x\"><code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 和 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 之间的另一个关键区别，就是后者要求你预先实例化 AngularJS 和 Angular 的模块。这意味着你必须为实例化应用中的 Angular 而付出代价 —— 即使你以后不会用到任何 Angular 资产。<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 则不那么激进。它只会在第一次用到时才实例化 Angular 部分，也就是说，当它需要实例化一个降级后的组件时。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9vugdt11dovy98rp5s0dvu9wq\">你还可以更进一步，甚至不必将应用程序中 Angular 部分的代码下载到用户的浏览器中 —— 直到需要它的那一刻。当不需要初始渲染或用户尚未访问到混合式应用中的 Angular 部分时，这特别有用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9mxcerut8di8zjtzdldb1r2tk\">举一些例子：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ody30mxj5r1aujib4twjygtr\">你只想在特定的路由上使用 Angular，除非用户访问此路由，否则你不需要它。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"52hi2ho9axb5n526fdusachqj\">你可以将 Angular 用于仅对特定类型的用户可见的特性，比如：登录用户、管理员或 VIP 成员。这样在用户通过了身份验证之前，你都无需加载 Angular。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7o3tfohy2iw6gqubq8i1gplx8\">你可以把 Angular 用于应用中那些在初始渲染时不太重要的特性，并且愿意为了更好地初始加载性能，而忍受加载该特性时的一点延迟。</p>\n</li>\n</ul>\n<h3 id=\"bootstrapping-with-downgrademodule\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ed0exih5z23ognfz0zo0rtfe9\">通过 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 启动<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#bootstrapping-with-downgrademodule\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eb2rt201j7pgmtj6bd0q3ynz8\">你可能已经猜到了，你不需要修改引导现有 AngularJS 应用的方式。<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 需要一些额外的步骤，但 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 能自行引导 Angular 模块，你只要为它提供配方即可。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"55zn3zr950uyrbmoj83yebimj\">要开始使用任何 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> API，你仍然要像在普通 Angular 应用中一样加载 Angular 框架。要想用 SystemJS 做到这一点，你可以遵循<a href=\"guide/upgrade-setup\" title=\"Setup for Upgrading from AngularJS\">升级的准备工作</a>中的指导，有选择的从<a href=\"https://github.com/angular/quickstart\">快速上手项目的 GitHub 仓库</a>中复制代码。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f27dab9h28gk6ygd66amrlddy\">你还需要用 <code>npm install @angular/upgrade --save</code> 安装 <code>@angular/upgrade</code> 包，并添加一个指向 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 包的映射：</p>\n<code-example header=\"systemjs.config.js (map)\" path=\"upgrade-module/src/systemjs.config.1.js\" region=\"upgrade-static-package\">\n'@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/fesm2022/static.mjs',\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d4gfxp1ko4gjmtrt731xo4jbr\">接下来，创建一个 <code>app.module.ts</code> 文件，并添加下列 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 类：</p>\n<code-example header=\"app.module.ts\">\n\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>\n  ]\n})\nexport class MainAngularModule {\n  // Empty placeholder method to satisfy the `<a href=\"api/core/Compiler\" class=\"code-anchor\">Compiler</a>`.\n  ngDoBootstrap() {}\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2xhmqi9xlp14gc8el1dkp0ra6\">这个最小的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 导入了 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>，Angular 每个基于浏览器的应用都会导入该模块。它还定义了一个空的 <code>ngDoBootstrap()</code> 方法，来防止 <a href=\"api/core/Compiler\">Compiler</a> 返回错误。在这里它是必要的，因为 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 装饰器上还没有声明 <code>bootstrap</code>。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e90w0ct096qb1wbzrv0ppcbhw\">你不用把 <code>bootstrap</code> 声明加到 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 装饰器上，因为 AngularJS 拥有应用的根组件，并且 <code>ngUpgrade</code> 会负责启动必要的组件。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5u9l86y9pl3fnjgp2eqk42uly\">现在你可以用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 把 AngularJS 和 Angular 的模块联结在一起。</p>\n<code-example header=\"app.module.ts\">\n\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\nimport { <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nconst bootstrapFn = (extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) =&gt; {\n  const platformRef = <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>(extraProviders);\n  return platformRef.bootstrapModule(MainAngularModule);\n};\nconst downgradedModule = <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>(bootstrapFn);\n\nangular.module('mainAngularJsModule', [\n  downgradedModule\n]);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dehp2iufxggi45bz3bmj8eyou\">现有的 AngularJS 代码仍然在和以前一样正常工作，但你已经可以开始添加新的 Angular 代码了。</p>\n<h3 id=\"using-components-and-injectables\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"39p47gvgz5umazqxw3kphswcw\">使用组件与可注入对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-components-and-injectables\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yoya0rujnhv69rkdjdcqs53d\"><code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 和 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 之间的区别就是这些。其余的 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> API 和概念的工作方式在不同的混合式应用中都完全一样了。欲知详情，参阅<a href=\"guide/upgrade\">从 AngularJS 升级</a>。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"87c87p2w99wspe5s2akp7gxnl\"><a href=\"guide/upgrade#using-angular-components-from-angularjs-code\">从 AngularJS 代码中使用 Angular 组件</a>.</p>\n<div class=\"callout is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ym1l7galoa4pqtpfwkbsq6h7\"><strong>注意</strong>：<br>\n如果你要降级多个模块，就要在调用 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 时为每个组件所属的降级后模块指定一个模块名。</p>\n</div>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dy4lqlvkzfqf915lvi0nrwej2\"><a href=\"guide/upgrade#using-angularjs-component-directives-from-angular-code\">如何从 Angular 代码中使用 AngularJS 组件和指令</a>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eidh3zgyc6c4qy5q0e9ek3wu1\"><a href=\"guide/upgrade#projecting-angularjs-content-into-angular-components\">把 AngularJS 的内容投影进 Angular 组件中</a>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efjrzeiv38pctgw3rcukfvhix\"><a href=\"guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\">把 Angular 的内容透传进 AngularJS 组件和指令中</a>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"erwm22m12tv9tymhrnflco6sr\"><a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">让 AngularJS 的依赖可注入到 Angular 中</a>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dn00gizp95116w5dae19x19l7\"><a href=\"guide/upgrade#making-angular-dependencies-injectable-to-angularjs\">让 Angular 的依赖可注入到 AngularJS 中</a>.</p>\n<div class=\"callout is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6w84v9uurcff2r115piq2m5nx\"><strong>注意</strong>：<br>\n如果你正在降级多个模块，就要在调用 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> 时为每个包含可注入对象的模块指定降级后的模块名。</p>\n</div>\n</li>\n</ul>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xueha5t91fib6qtyzf23f2p3\">虽然可以降级可注入对象，但在实例化 Angular 模块之前，无法使用降级后的可注入对象。安全起见，你需要确保降级后的可注入对象不会用于应用中<em>不受</em> Angular 控制的任何地方。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"coyaitoteoxvf6ddnkmzn5egj\">比如，在只使用 Angular 组件的已升级组件中<em>可以</em>使用降级后的服务，但是，<em>不能</em>在那些不依赖 Angular 的 AngularJS 组件中使用它，也不能从其它模块中使用降级过的 Angular 组件。</p>\n</div>\n<h2 id=\"using-ahead-of-time-compilation-with-hybrid-apps\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8zpqjfk80fwigjgcuz0t8sdiy\">使用混合式应用进行预先编译<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-ahead-of-time-compilation-with-hybrid-apps\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cjogp4k43o3qwf1ckw5bwic7b\">你可以像在任何其它 Angular 应用中一样，利用混合式应用的预先（AOT）编译功能。混合式应用的设置与<a href=\"guide/aot-compiler\">预先（AOT）编译</a>一章所讲的大致相同，但 <code>index.html</code> 和 <code>main-aot.ts</code> 略有差异。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99q0x03zvccqr9dqbjilhzaxa\">AOT 需要在 AngularJS 的 <code>index.html</code> 中的 <code>&lt;script&gt;</code> 标签中加载所有 AngularJS 文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"521ouqg0m22yqf4s1ytc5kxng\">你还要将所生成的 <code>MainAngularModuleFactory</code> 传给 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 函数，而不是自定义引导函数。</p>\n<code-example header=\"app/main-aot.ts\">\n\nimport { <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\nimport { MainAngularModuleNgFactory } from '../aot/app/app.module.ngfactory';\n\nconst downgradedModule = <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>(MainAngularModuleNgFactory);\n\nangular.module('mainAngularJsModule', [\n  downgradedModule\n]);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0tqb0d9wrnib72um80h70pog\">这就是当你想让混合式应用受益于 AOT 时所要做的一切。</p>\n<h2 id=\"conclusion\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6lqfbaztqpzx6egw25gt59ob7\">总结<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#conclusion\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yjxay8f87r1lkf7utyk690f2\">该页面介绍了如何借助 <a href=\"api/upgrade/static\">upgrade/static</a> 包，来按照你自己的节奏逐步升级现有的 AngularJS 应用。并且升级过程中不会方案此应用的进一步开发。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ofderhstjqwx4cto2ntyyev5\">具体地，这个指南展示了如何通过使用 \n<a href=\"api/upgrade/static/downgradeModule\">downgradeModule()</a> 而不是 \n<a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a> 在混合应用程序中实现更好的性能和更大的灵活性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9imefpjs4n8zn0oeduj7kk6d1\">总结，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 中的关键差异性因素是：</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ojhax4vc79q4x2k83it67m8u\">它允许实例化甚至惰性加载 Angular 部分，这能改善初始加载时间。某些情况下，这可能会完全免除启动第二个框架的成本。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"49wpk2xkv9kpmuw31cl9rue7r\">通过避免运行不必要的变更检测，它提高了性能，给开发人员提供了更大的自定义能力。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eciv9je1k4w8f79rvuiizg5q1\">它不需要你更改引导 AngularJS 应用的方式。</p>\n</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7kia44uv6ovibw0yrnumbi1xc\">当你希望混合式应用的 AngularJS 部分和 Angular 部分保持松耦合时，使用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 是个很好的选择。你仍然可以混用并匹配两个框架中的组件和服务。作为回报，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 为你提供了更大的控制权和更好的性能。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/upgrade/static/downgradeModule\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/core/Compiler\n - api/core/Injector\n - api/core/Input\n - api/core/NgModule\n - api/core/NgModuleFactory\n - api/core/NgModuleRef\n - api/core/NgZone#run\n - api/core/PlatformRef#bootstrapModuleFactory\n - api/core/StaticProvider\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/BrowserModule\n - api/platform-browser/platformBrowser\n - api/upgrade/static\n - api/upgrade/static/UpgradeModule\n - api/upgrade/static/downgradeComponent\n - api/upgrade/static/downgradeInjectable\n - api/upgrade/static/downgradeModule\n - guide/aot-compiler\n - guide/upgrade\n - guide/upgrade#change-detection\n - guide/upgrade#how-ngupgrade-works\n - guide/upgrade#making-angular-dependencies-injectable-to-angularjs\n - guide/upgrade#making-angularjs-dependencies-injectable-to-angular\n - guide/upgrade#preparation\n - guide/upgrade#projecting-angularjs-content-into-angular-components\n - guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\n - guide/upgrade#using-angular-components-from-angularjs-code\n - guide/upgrade#using-angularjs-component-directives-from-angular-code\n - guide/upgrade-performance#bootstrapping-with-downgrademodule\n - guide/upgrade-performance#change-detection-with-downgrademodule\n - guide/upgrade-performance#conclusion\n - guide/upgrade-performance#how-ngupgrade-works\n - guide/upgrade-performance#instantiating-the-angular-module-on-demand\n - guide/upgrade-performance#preparation\n - guide/upgrade-performance#specifying-a-factory-for-the-angular-module\n - guide/upgrade-performance#upgrading-for-performance\n - guide/upgrade-performance#upgrading-with-ngupgrade\n - guide/upgrade-performance#using-ahead-of-time-compilation-with-hybrid-apps\n - guide/upgrade-performance#using-components-and-injectables\n - guide/upgrade-performance#using-downgrademodule\n - guide/upgrade-setup\n - https://docs.angularjs.org/api/ng/function/angular.module\n - https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply\n - https://github.com/angular/quickstart\n-->"}