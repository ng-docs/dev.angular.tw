{"id":"guide/upgrade","title":"从 AngularJS 升级到 Angular","contents":"<div class=\"content\">\n  <h1 id=\"upgrading-from-angularjs-to-angular\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1i825oxcad32rcw701axhrxel\">从 AngularJS 升级到 Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-from-angularjs-to-angular\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3m6ulnpzcn2y5u3f8vwoehnkh\"><em>Angular</em>是现在和未来的 Angular 名称。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uqkk63xsc5jgyb3fj0eka9ee\"><em>AngularJS</em>是所有 1.x 版本的 Angular 的名称。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9azqlh2gvrgvtuzjddjq9qdpe\">有很多大型 AngularJS 应用。在迁移到 Angular 之前，请始终考虑其业务案例。该案例的一个重要部分是迁移的时间和精力。本指南描述了用于将 AngularJS 项目高效迁移到 Angular 平台的内置工具，一次一个。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5m73aqlcm0k9jediieq9e4k12\">有些应用可能比其它的升级起来简单，还有一些方法能让把这项工作变得更简单。即使在正式开始升级过程之前，可以提前准备 AngularJS 的程序，让它向 Angular 看齐。这些准备步骤几乎都是关于如何让代码更加松耦合、更有可维护性，以及用现代开发工具提高速度的。这意味着，这种准备工作不仅能让最终的升级变得更简单，而且还能提升 AngularJS 程序的质量。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5dn225bi29vvuka0820swnvpq\">成功升级的关键之一是增量式的实现它，通过在同一个应用中一起运行这两个框架，并且逐个把 AngularJS 的组件迁移到 Angular 中。这意味着可以在不必打断其它业务的前提下，升级更大、更复杂的应用程序，因为这项工作可以多人协作完成，在一段时间内逐渐铺开。Angular <code>upgrade</code> 模块的设计目标就是让你渐进、无缝的完成升级。</p>\n<h2 id=\"preparation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"950c8mg85fl94yevwp15mppan\">准备工作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#preparation\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aktoobnyic8hxwubm51jmumjj\">AngularJS 应用程序的组织方式有很多种。当你想把它们升级到 Angular 的时候，有些做起来会比其它的更容易些。即使在开始升级之前，也有一些关键的技术和模式可以让你将来升级时更轻松。</p>\n<h3 id=\"follow-the-angularjs-style-guide\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9j0smlzff8ppa7ke0e4jeidzb\">遵循 AngularJS 风格指南<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#follow-the-angularjs-style-guide\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ahgxznojrimkvwxrd35gdie8l\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\" title=\"Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">AngularJS 风格指南</a>收集了一些已证明能写出干净且可维护的 AngularJS 程序的模式与实践。\n它包含了很多关于如何书写和组织 AngularJS 代码的有价值信息，同样重要的是，<strong>不应该</strong>采用的书写和组织 AngularJS 代码的方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ejlagesndgczo64tjaymbsmeo\">Angular 是一个基于 AngularJS 中最好的部分构思出来的版本。在这种意义上，它的目标和 AngularJS 风格指南是一样的：保留 AngularJS 中好的部分，去掉坏的部分。当然，Angular 还做了更多。说这些的意思是：<em>遵循这个风格指南可以让你写出更接近 Angular 程序的 AngularJS 程序</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"avn3vviarvegmo49cqyph5ao4\">有一些特别的规则可以让使用 Angular 的 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 模块进行<em>增量升级</em>变得更简单：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1upsj7epzeoduaua5l8k5kg2s\">规则</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"262xb05l06nnentnhahh2hpu1\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\" title=\"单一责任 - Angular 1 风格指南 | johnpapa/angular-styleguide | GitHub\">单一职责规则</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5bmwy7nvq5j1qu92y42m16imn\">每个文件应该有一个组件。这不仅使组件易于导航和查找，还使我们能够逐个迁移它们到不同的语言和框架中。在这个示例应用程序中，每个控制器、组件、服务和过滤器都在自己的源文件中。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"y3tbfmaowhcflzv59wgiqboo\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\" title=\"按特性划分文件夹结构 - Angular 1 风格指南 | johnpapa/angular-styleguide | GitHub\">按特性划分文件夹结构</a> \n<br> \n<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\" title=\"模块化 - Angular 1 风格指南 | johnpapa/angular-styleguide | GitHub\">模块化</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bblau8iahkvauew9g672vr3l0\">在更高的抽象层面上定义类似的原则：应用程序的不同部分应该位于不同的目录和 NgModules 中。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"qbnadh38ps7sjjkfdi8u48ka\">如果应用程序能用这种方式把每个特性分到一个独立目录中，它也就能每次迁移一个特性。对于那些还没有这么做的程序，强烈建议把应用这条规则作为准备步骤。而且这也不仅仅对升级有价值，它还是一个通用的规则，可以让你的程序更“坚实”。</p>\n<h3 id=\"using-a-module-loader\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"arz77jaegwgdnm373zx7j4yc4\">使用模块加载器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-a-module-loader\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4j93w6jqmivwxppxichajodlk\">当你把应用代码分解到每个文件中只放一个组件的粒度后，通常会得到一个由大量相对较小的文件组成的项目结构。这比组织成少量大文件要整洁得多，但如果你不得不通过 <code>&lt;script&gt;</code> 标签在 HTML 页面中加载所有这些文件，那就不好玩了。尤其是当你不得不自己按正确的顺序维护这些标签时更是如此，就要开始使用<em>模块加载器</em>了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3vhxeyygu6ytyqikxzvt5krnf\">使用模块加载器，比如<a href=\"https://github.com/systemjs/systemjs\" title=\"systemjs/systemjs | GitHub\">SystemJS</a>、\n<a href=\"https://webpack.github.io\" title=\"webpack module bundler | GitHub\">Webpack</a>或<a href=\"http://browserify.org\" title=\"Browserify\">Browserify</a>，\n可以让你在程序中使用 TypeScript 或 ES2015 语言内置的模块系统。\n你可以使用 <code>import</code> 和 <code>export</code> 特性来明确指定哪些代码应该以及将会被在程序的不同部分之间共享。\n对于 ES5 程序来说，可以改用 CommonJS 风格的 <code>require</code> 和 <code>module.exports</code> 特性代替。\n无是论哪种情况，模块加载器都会按正确的顺序加载程序中用到的所有代码。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wknzgto5h3wkoz1jol9bhzji\">当要把应用程序投入生产环境时，模块加载器也会让你把所有这些文件打成完整的产品包变得容易一些。</p>\n<h3 id=\"migrating-to-typescript\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a0iypptthzl3e3ryq30m2n2zd\">迁移到 TypeScript<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#migrating-to-typescript\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"979pn6ugqztatm3a2t0vferpu\">Angular 升级计划的一部分是引入 TypeScript，即使在开始升级之前，引入 TypeScript 编译器也是有意义的。这意味着等真正升级的时候需要学习和思考的东西会更少，并且你可以在 AngularJS 代码中开始使用 TypeScript 的特性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dabicl3hqnyx8rl88k0f5miih\">TypeScript 是 ECMAScript 2015 的超集，而 ES2015 又是 ECMAScript 5 的超集。这意味着除了安装一个 TypeScript 编译器，并把文件名都从 <code>*.js</code> 改成 <code>*.ts</code> 之外，其实什么都不用做。当然，如果仅仅这样做也没什么大用，也没什么有意思的地方。下面这些额外的步骤可以让你打起精神：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9w7bss2sqh5910hy7ldtcw9x5\">对那些使用了模块加载器的程序，TypeScript 的导入和导出语法（实际上是 ECMAScript 2015 的导入和导出）可以把代码组织成模块。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dd5mdpqkwb5v4axyfrv0lhi31\">可以逐步把类型注解添加到现有函数和变量上，以固定它们的类型，并获得其优点：比如编译期错误检查、更好的支持自动完成，以及内联式文档等。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7mykvgvjw38yy6x1scdsrnjzs\">那些 ES2015 中新增的特性，比如箭头函数、<code>let</code>、<code>const</code>、默认函数参数、解构赋值等也可以逐渐添加进来，让代码更有表现力。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7tubazzxg6687xakg4q5cx4ba\">服务和控制器可以转成<em>类</em>。这样它们就能一步步接近 Angular 的服务和组件类了，也会让升级变得简单一点。</li>\n</ul>\n<h3 id=\"using-component-directives\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"952aex07wlxrcbd07fkif89vr\">使用组件型指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-component-directives\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efu9gah6c78vuxsvhgs2isfcw\">在 Angular 中，组件是用来构建用户界面的主要元素。你把 UI 中的不同部分定义成组件，然后在模板中使用这些组件合成出最终的 UI。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"50tkdvetlphux9b822zk82788\">你在 AngularJS 中也能这么做。那就是一种定义了自己的模板、控制器和输入/输出绑定的指令 —— 跟 Angular 中对组件的定义是一样的。要迁移到 Angular，通过组件型指令构建的应用程序会比直接用 <code>ng-controller</code>、<code>ng-include</code> 和作用域继承等底层特性构建的要容易得多。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2j6txyi7tcyc3rpo417p7ob8z\">要与 Angular 兼容，AngularJS 的组件型指令应该配置下列属性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2e7a5u3w81azvyldqrbf228ud\">属性</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>restrict: 'E'</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d6vibw0s26ujwqjjpi2pyfh0x\">组件通常用作元素。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>scope: {}</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9sij744zm0u1bnymo90xpdcho\">独立作用域。在 Angular 中，组件始终与周围环境隔离，你也应该在 AngularJS 中这样做。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>bindToController: {}</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"30z33g4yt0d945g2o980m27yf\">组件的输入和输出应绑定到控制器，而不是使用 \n<code>$scope</code>。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tsgdrkisbj68a8elubssm3m\"><code>controller</code> \n<br> \n<code>controllerAs</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dw176ymmmudwsywda7y6id59s\">组件有自己的控制器。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78qcin6mpw7mipltb15nonlu0\"><code>template</code> \n<br> \n<code>templateUrl</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efi1fez3yfobb51shyxv8icmy\">组件有自己的模板。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ec4uhrdtptyvl4jte52hdkc6\">组件型指令还可能使用下列属性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2e7a5u3w81azvyldqrbf228ud\">属性</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>transclude: true/{}</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dtwsq73cmadfb6ma1qh53k3c\">如果组件需要从其他地方转入内容。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>require</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dz5sadwh3dz3n1aqbxth7o0sp\">如果组件需要与某个父组件的控制器通信。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"90uiq99nyd9n40veyqd1eyqiw\">组件型指令<strong>不能</strong>使用下列属性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6g4a8ku5pku8t8wpuk9dn0nju\">属性（避免使用）</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>compile</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5fm5nbraqvkb7a7ztze7d0g6g\">这在 Angular 中不会被支持。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>replace: true</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dp10irbe3d888fqmrta16mggx\">Angular 从不使用组件元素替换组件模板。该属性在 AngularJS 中也已被弃用。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bm6cnmjyap6q84bxskywmfez8\"><code>priority</code> \n<br> \n<code>terminal</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6t9naig722n73s2trp2xp7mrr\">虽然 AngularJS 组件可能会使用这些属性，但在 Angular 中不会使用，最好不要编写依赖于它们的代码。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a2km92nzzvzi0e9cdwkeisp36\">AngularJS 中一个完全向 Angular 架构对齐过的组件型指令是这样的：</p>\n<code-example header=\"hero-detail.directive.ts\" path=\"upgrade-module/src/app/hero-detail.directive.ts\">\nexport function heroDetailDirective() {\n  return {\n    restrict: 'E',\n    scope: {},\n    bindToController: {\n      hero: '=',\n      deleted: '&amp;'\n    },\n    template: `\n      &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt;\n      &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt;\n      &lt;button type=\"button\" ng-click=\"$ctrl.onDelete()\"&gt;Delete&lt;/button&gt;\n    `,\n    controller: function HeroDetailController() {\n      this.onDelete = () =&gt; {\n        this.deleted({hero: this.hero});\n      };\n    },\n    controllerAs: '$ctrl'\n  };\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1fs30q3nju4tcpyycgoggaz8b\">AngularJS 1.5 引入了<a href=\"https://docs.angularjs.org/api/ng/type/angular.Module#component\" title=\"component(name, options); - angular.Module | API | AngularJS\">组件 API</a>，它让定义指令变得更简单了。\n为组件型指令使用这个 API 是一个好主意，因为：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3jx0fra03f6n14jhhrad48sd\">它需要更少的样板代码。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ljvtu14h3cz8ypehnol3eodi\">它强制你遵循组件的最佳实践，比如 <code>controllerAs</code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6hjplya532d49sgn2tx232jgx\">指令中像 <code>scope</code> 和 <code>restrict</code> 这样的属性应该有良好的默认值。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5ryrqcnnv5c0eldb33j6m9jq\">如果使用这个组件 API 进行表示，那么上面看到的组件型指令就变成了这样：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io\">\nexport const heroDetail = {\n  bindings: {\n    hero: '&lt;',\n    deleted: '&amp;'\n  },\n  template: `\n    &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt;\n    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt;\n    &lt;button type=\"button\" ng-click=\"$ctrl.onDelete()\"&gt;Delete&lt;/button&gt;\n  `,\n  controller: function HeroDetailController() {\n    this.onDelete = () =&gt; {\n      this.deleted(this.hero);\n    };\n  }\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7fivwave5sqhewux1msgeexmz\">控制器的生命周期钩子 <code>$onInit()</code>、<code>$onDestroy()</code> 和 <code>$onChanges()</code> 是 AngularJS 1.5 引入的另一些便利特性。\n它们都很像<a href=\"guide/lifecycle-hooks\" title=\"Lifecycle hooks | Angular\">Angular 中的等价物</a>，所以，围绕它们组织组件生命周期的逻辑在升级到 Angular 时会更容易。</p>\n<h2 id=\"upgrading-with-ngupgrade\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3rnnpbxs5nro7j80tpc08zwo\">使用 ngUpgrade 升级<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-with-ngupgrade\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eunot9d67j6mmh1cvxup37cal\">不管要升级什么，Angular 中的 <code>ngUpgrade</code> 库都会是一个非常有用的工具 —— 除非是小到没功能的应用。借助它，你可以在同一个应用程序中混用并匹配 AngularJS 和 Angular 的组件，并让它们实现无缝的互操作。这意味着你不用被迫一次性做完所有的升级工作，因为在整个演进过程中，这两个框架可以很自然的和睦相处。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c6jn2pyjjbe4k2uzg0ls8udud\">由于 <a href=\"https://blog.angular.io/finding-a-path-forward-with-angularjs-7e186fdd4429\" title=\"Finding a Path Forward with AngularJS | Angular Blog\">AngularJS 即将停止维护</a>，ngUpgrade 现在处于特性开发完毕的状态。我们将会继续发布安全补丁和 BUG 修复，直到 2023-12-31。</p>\n</div>\n<h3 id=\"how-ngupgrade-works\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91jy19qrli16w6hv9a4n94jh4\">ngUpgrade 的工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#how-ngupgrade-works\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"96vpbexs5guzuowvjpcei3p61\"><code>ngUpgrade</code> 提供的主要工具之一被称为 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>。这是一个服务，它可以启动并管理一个能同时支持 Angular 和 AngularJS 的混合式应用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c7wgu2tni6mctx6fx9snpdcjf\">当使用 ngUpgrade 时，你实际上在<em>同时运行 AngularJS 和 Angular</em>。所有 Angular 的代码运行在 Angular 框架中，而 AngularJS 的代码运行在 AngularJS 框架中。所有这些都是真实的、全功能的框架版本。没有进行任何仿真，所以你可以认为同时存在着这两个框架的所有特性和自然行为。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"evizm7vj3d004dk469jgz8dgb\">所有这些事情的背后，本质上是一个框架中管理的组件和服务能和来自另一个框架的进行互操作。这些主要体现在三个方面：依赖注入、DOM 和变更检测。</p>\n<h4 id=\"dependency-injection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"o5rlb7acys3t8dxjenlygz93\">依赖注入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#dependency-injection\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d6n4ok1v4teju7x2fkykb27ls\">无论是在 AngularJS 中还是在 Angular 中，依赖注入都位于前沿和中心的位置，但在两个框架的工作原理上，却存在着一些关键的不同之处。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">AngularJS</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bju35ovz0mk4rwib9b5i0tcrl\">Angular</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uxrn5guboogevks131m8xmlh\">依赖注入令牌始终是字符串</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bfzvwue8k9uwak313uesp6im8\">令牌 \n<a href=\"guide/dependency-injection\" title=\"Angular 中的依赖注入 | Angular\">可以有不同类型</a>。\n<br>它们通常是类。\n<br>也可能是字符串。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bqquqfb5l8086x6l6xcvqyvxe\">存在一个注入器。\n<br>即使在多模块应用中，所有内容也都注入到一个大的命名空间中。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wvwm73t17xpz8ve3utagrjcz\">存在一个 \n<a href=\"guide/hierarchical-dependency-injection\" title=\"层次依赖注入器 | Angular\">注入器树层次结构</a>，有一个根注入器和每个组件都有一个额外的注入器。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4hw6hxw7w68gl8j26l0j9ep68\">就算有这么多不同点，也并不妨碍你在依赖注入时进行互操作。<code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 解决了这些差异，并让它们无缝的对接：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xz4t5f3yrdu5v94lzb4ydpjp\">通过升级它们，你就能让那些在 AngularJS 中能被注入的服务也可用于 Angular 的代码中。在框架之间共享的是服务的同一个单例对象。在 Angular 中，这些外来服务总是被放在<em>根注入器</em>中，并可用于所有组件。它们总是具有<em>字符串令牌</em> —— 跟它们在 AngularJS 中的令牌相同。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ui7qhey7fuy5mh1vzclli3hg\">通过降级它们，你也能让那些在 Angular 中能被注入的服务在 AngularJS 的代码中可用。只有那些来自 Angular 根注入器的服务才能被降级。同样的，在框架之间共享的是同一个单例对象。当你注册一个要降级的服务时，要明确指定一个打算在 AngularJS 中使用的<em>字符串令牌</em>。</p>\n</li>\n</ul>\n<div class=\"lightbox\">\n<img alt=\"The two injectors in a hybrid application\" src=\"generated/images/guide/upgrade/injectors.png\" width=\"700\" height=\"262\">\n</div>\n<h4 id=\"components-and-the-dom\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56tjnf5bhjmtwum0uzmw6r4dd\">组件与 DOM<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#components-and-the-dom\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44uaa9fb0iaj90df7v87aoldz\">在混合式应用中，同时存在来自 AngularJS 和 Angular 中组件和指令的 DOM。这些组件通过它们各自框架中的输入和输出绑定来互相通讯，它们由 ngUpgrade 桥接在一起。它们也能通过共享被注入的依赖彼此通讯，就像前面所说的那样。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xax914yp8uxgywc8jgxlpt8l\">理解混合式应用的关键在于，DOM 中的每一个元素都只能属于这两个框架之一，而另一个框架则会忽略它。如果一个元素属于 AngularJS，那么 Angular 就会当它不存在，反之亦然。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3w0whp4pfmpdd4j10y0hwfw4w\">所以，混合式应用总是像 AngularJS 程序那样启动，处理根模板的也是 AngularJS. 然后，当这个应用的模板中使用到了 Angular 的组件时，Angular 才开始参与。这个组件的视图由 Angular 进行管理，而且它还可以使用一系列的 Angular 组件和指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bqea88siidtheiuwoxndqr86e\">更进一步说，你可以按照需要，任意穿插使用这两个框架。使用下面的两种方式之一，你可以在这两个框架之间自由穿梭：</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1nxctc4h8fyeknbrpola9m0hq\">通过使用来自另一个框架的组件：AngularJS 的模板中用到了 Angular 的组件，或者 Angular 的模板中使用了 AngularJS 的组件。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e1nw33sgoc4homivhaxtac5a0\">通过透传（transclude）或投影（project）来自另一个框架的内容。<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 牵线搭桥，把 AngularJS 的透传概念和 Angular 的内容投影概念关联起来。</p>\n</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"DOM element ownership in a hybrid application\" src=\"generated/images/guide/upgrade/dom.png\" width=\"500\" height=\"294\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvp69b7vlreghcrz73qj9z263\">当你使用一个属于另一个框架的组件时，就会发生一次跨框架边界的切换。不过，这种切换只发生在该组件元素的<em>子节点</em>上。考虑一个场景，你从 AngularJS 中使用一个 Angular 组件，就像这样：</p>\n<code-example language=\"html\" escape=\"html\">\n\n&lt;a-component&gt;&lt;/a-component&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ec5iax8oasohvo8bcg0sbelso\">此时，<code>&lt;a-component&gt;</code> 这个 DOM 元素仍然由 AngularJS 管理，因为它是在 AngularJS 的模板中定义的。这也意味着你可以往它上面添加别的 AngularJS 指令，却<em>不能</em>添加 Angular 的指令。只有在 <code>&lt;a-component&gt;</code> 组件的模板中才是 Angular 的天下。同样的规则也适用于在 Angular 中使用 AngularJS 组件型指令的情况。</p>\n<h4 id=\"change-detection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7azixb8qk7ftis9xv31c3m4b7\">变更检测<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#change-detection\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2971knu4lqj6ml9tm6dyr1cxm\">AngularJS 中的变更检测全是关于 <code>scope.$apply()</code> 的。在每个事件发生之后，<code>scope.$apply()</code> 就会被调用。这或者由框架自动调用，或者在某些情况下由你自己的代码手动调用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9hwmuqg6ub67qv2jy10cuzz3n\">在 Angular 中，事情有点不一样。虽然变更检测仍然会在每一个事件之后发生，却不再需要每次调用 <code>scope.$apply()</code> 了。\n这是因为所有 Angular 代码都运行在一个叫做 <a href=\"api/core/NgZone\" title=\"NgZone | Core - API | Angular\">Angular zone</a> 的地方。\nAngular 总是知道什么时候代码执行完了，也就知道了它什么时候应该触发变更检测。代码本身并不需要调用 <code>scope.$apply()</code> 或其它类似的东西。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"lm4idmfk17jdspc158o67fgc\">在这种混合式应用的案例中，<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 在 AngularJS 的方法和 Angular 的方法之间建立了桥梁。发生了什么呢？</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2g3304mfm56v9ubq0exkjy9h\">应用中发生的每件事都运行在 Angular 的 zone 里。无论事件发生在 AngularJS 还是 Angular 的代码中，都是如此。这个 zone 会在每个事件之后触发 Angular 的变更检测。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"60fyv5o9toqf9960nvihmrlnm\"><code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 将在每一次离开 Angular zone 时调用 AngularJS 的 <code>$rootScope.$apply()</code>。这样也就同样会在每个事件之后触发 AngularJS 的变更检测。</p>\n</li>\n</ul>\n<div class=\"lightbox\">\n<img alt=\"Change detection in a hybrid application\" src=\"generated/images/guide/upgrade/change_detection.png\" width=\"600\" height=\"163\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"576bdp6uek6qqbtar2zjo3k9\">在实践中，你不用在自己的代码中调用 <code>$apply()</code>，而不用管这段代码是在 AngularJS 还是 Angular 中。<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 都替你做了。你仍然<em>可以</em>调用 <code>$apply()</code>，也就是说你不必从现有代码中移除此调用。在混合式应用中，这些调用只会触发一次额外的 AngularJS 变更检测。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qlvb01fo8yu2rncwkgd4qt3i\">当你降级一个 Angular 组件，然后把它用于 AngularJS 中时，组件的输入属性就会被 AngularJS 的变更检测体系监视起来。\n当那些输入属性发生变化时，组件中相应的属性就会被设置。你也能通过实现<a href=\"api/core/OnChanges\" title=\"OnChanges | Core - API | Angular\">OnChanges</a>\n接口来挂钩到这些更改，就像它未被降级时一样。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gbry2uwfo0vgri5hr1cnvaj9\">相应的，当你把 AngularJS 的组件升级给 Angular 使用时，在这个组件型指令的 <code>scope</code>（或 <code>bindToController</code>）中定义的所有绑定，都将被挂钩到 Angular 的变更检测体系中。它们将和标准的 Angular 输入属性被同等对待，并当它们发生变化时设置回 scope（或控制器）上。</p>\n<h3 id=\"using-upgrademodule-with-angular-ngmodules\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhvfaj6xib0jrbzvln7fh905\">通过 Angular 的 <em>NgModule</em> 来使用 UpgradeModule<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-upgrademodule-with-angular-ngmodules\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xu705qs3u18cfaa34gm2ivxj\">AngularJS 和 Angular 都有自己的模块概念，来帮你把应用按功能组织成内聚的代码块。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7tgkdzyk8z907fu80qqfj8ct7\">它们在架构和实现的细节上有着显著的不同。在 AngularJS 中，你要把 AngularJS 的资源添加到 <code>angular.module</code> 属性上。在 Angular 中，你要创建一个或多个带有 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 装饰器的类，这些装饰器用来在元数据中描述 Angular 资源。差异主要来自这里。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7u0zbpl9pshnm9hp4vyvscdnj\">在混合式应用中，你同时运行了两个版本的 Angular。这意味着你至少需要 AngularJS 和 Angular 各提供一个模块。当你使用 AngularJS 的模块进行引导时，就得把 Angular 的模块传给 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9z7ymeotts03wujdv5gvpe28r\">要了解更多，请参阅<a href=\"guide/ngmodules\" title=\"NgModules | Angular\">NgModules</a>页。</p>\n</div>\n<h3 id=\"bootstrapping-hybrid-applications\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"djsm82itiq3miyg0ul88fn66c\">引导混合应用程序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#bootstrapping-hybrid-applications\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6fabmqb8tu7hpd6ictcai200i\">要想引导混合式应用，就必须在应用中分别引导 Angular 和 AngularJS 应用的一部分。你必须先引导 Angular，然后再调用 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 来引导 AngularJS。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8uyzj2m1aeyhtzqs4ibr9y8b0\">在 AngularJS 应用中有一个 AngularJS 的根模块，它用于引导 AngularJS 应用。</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"ng1module\">\nangular.module('heroApp', [])\n  .controller('MainCtrl', function() {\n    this.message = 'Hello world';\n  });\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8p369x12upkcjie48vpbxul6w\">单纯的 AngularJS 应用可以在 HTML 页面中使用 <code>ng-app</code> 指令进行引导，但对于混合式应用你要通过 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 模块进行手动引导。因此，在切换成混合式应用之前，最好先把 AngularJS 改写成使用 <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\"><code>angular.bootstrap</code></a> 进行手动引导的方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8t331f8y8m63wzi1qogqedbp9\">比如你现在有这样一个通过 <code>ng-app</code> 进行引导的应用：</p>\n<code-example path=\"upgrade-module/src/index-ng-app.html\">\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;base href=\"/\"&gt;\n    &lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.5.3/angular.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"app/ajs-ng-app/app.module.js\"&gt;&lt;/script&gt;\n  &lt;/head&gt;\n\n  &lt;body ng-app=\"heroApp\" ng-strict-di&gt;\n    &lt;div id=\"message\" ng-controller=\"MainCtrl as mainCtrl\"&gt;\n      {{ mainCtrl.message }}\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4lrpwy8u6k8qyqgbx2qymiftp\">你可以从 HTML 中移除 <code>ng-app</code> 和 <code>ng-strict-di</code> 指令，改为从 JavaScript 中调用 <code>angular.bootstrap</code>，它能达到同样效果：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"bootstrap\">\nangular.bootstrap(document.body, ['heroApp'], { strictDi: true });\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"23dr5jzxj6oi2dycf6gjae0bi\">要想把 AngularJS 应用变成 Hybrid 应用，就要先加载 Angular 框架。\n根据<a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">准备升级到 AngularJS</a> 中给出的步骤，选择性的把<a href=\"https://github.com/angular/quickstart\" title=\"angular/quickstart | GitHub\">快速入门 GitHub 代码仓</a>中的代码复制过来。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f27dab9h28gk6ygd66amrlddy\">你还需要用 <code>npm install @angular/upgrade --save</code> 安装 <code>@angular/upgrade</code> 包，并添加一个指向 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 包的映射：</p>\n<code-example header=\"systemjs.config.js (map)\" path=\"upgrade-module/src/systemjs.config.1.js\" region=\"upgrade-static-package\">\n'@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/fesm2022/static.mjs',\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d4gfxp1ko4gjmtrt731xo4jbr\">接下来，创建一个 <code>app.module.ts</code> 文件，并添加下列 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 类：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"ngmodule\">\nimport { <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a>, <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1k427eyrimy1lpzw5ulvlflna\">最小化的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 导入了 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>，它是每个基于浏览器的 Angular 应用必备的。它还从 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 中导入了 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，它导出了一些服务提供者，这些提供者会用于升级、降级服务和组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"blap04644z7f5dxzyt5f02fwq\">在 <code>AppModule</code> 的构造函数中，使用依赖注入技术获取了一个 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 实例，并用它在 <code>AppModule.ngDoBootstrap</code> 方法中启动 AngularJS 应用。\n<code>upgrade.bootstrap</code> 方法接受和 <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\">angular.bootstrap</a> 完全相同的参数。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"903l4df7s7lihnjvyxlteknd8\"><strong>注意</strong>：<br>\n你不需要在 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中加入 <code>bootstrap</code> 声明，因为 AngularJS 控制着该应用的根模板。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26jhas7ni7kjqrossfoixdlmz\">现在，你就可以使用 <code>platformBrowserDynamic.bootstrapModule</code> 方法来启动 <code>AppModule</code> 了。</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"bootstrap\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"301kck3pw81iy2uc3m8cqxrfk\">恭喜！你就要开始运行这个混合式应用了！所有现存的 AngularJS 代码会像以前一样正常工作，但是你现在也同样可以运行 Angular 代码了。</p>\n<h3 id=\"using-angular-components-from-angularjs-code\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"885qrpd2cvz2vs2ikgn29p5vf\">从 AngularJS 代码中使用 Angular 组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-angular-components-from-angularjs-code\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"lightbox\">\n<img alt=\"Using an Angular component from AngularJS code\" class=\"left\" src=\"generated/images/guide/upgrade/ajs-to-a.png\" width=\"250\" height=\"44\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2wd1trypf8io22rkwbar5krg2\">一旦你开始运行混合式应用，你就可以开始逐渐升级代码了。一种更常见的工作模式就是在 AngularJS 的上下文中使用 Angular 的组件。该组件可能是全新的，也可能是把原本 AngularJS 的组件用 Angular 重写而成的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"m3kwvzz6admq42dep613xulc\">假设你有一个用来显示英雄信息的 Angular 组件：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/downgrade-static/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &lt;h2&gt;Windstorm details!&lt;/h2&gt;\n    &lt;div&gt;id: 1&lt;/div&gt;\n  `\n})\nexport class HeroDetailComponent { }\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"etd0w3j5o0cgzle7xzqcyay2b\">如果你想在 AngularJS 中使用这个组件，就得用 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 方法把它<em>降级</em>。其结果是一个 AngularJS 的<em>指令</em>，你可以把它注册到 AngularJS 的模块中：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"downgradecomponent\">\nimport { HeroDetailComponent } from './hero-detail.component';\n\n/* . . . */\n\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('heroApp', [])\n  .directive(\n    'heroDetail',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({ component: HeroDetailComponent }) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9lub8po62ndu7wkmnplr5oeqs\">默认情况下，Angular 变更检测也会在 AngularJS 的每个 <code>$digest</code> 周期中运行。如果你希望只在输入属性发生变化时才运行变更检测，可以在调用 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 时把 <code>propagateDigest</code> 设置为 <code>false</code>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8uc2s450gg2qnr417n2me21pf\">由于 <code>HeroDetailComponent</code> 是一个 Angular 组件，所以你必须同时把它加入 <code>AppModule</code> 的 <code>declarations</code> 字段中。</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"ngmodule\">\nimport { HeroDetailComponent } from './hero-detail.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  declarations: [\n    HeroDetailComponent\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9uv6bvenm3hgppjv8ajw4uqr4\">所有 Angular 组件、指令和管道都必须声明在 NgModule 中。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0infihzr3pmgieqw2qtxph1s\">最终的结果是一个叫做 <code>heroDetail</code> 的 AngularJS 指令，你可以像用其它指令一样把它用在 AngularJS 模板中。</p>\n<code-example path=\"upgrade-module/src/index-downgrade-static.html\" region=\"usecomponent\">\n&lt;hero-detail&gt;&lt;/hero-detail&gt;\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b7in1z0e3yqmhcqpn6h09on2j\"><strong>注意</strong>：<br>\n它在 AngularJS 中是一个名叫 <code>heroDetail</code> 的元素型指令（<code>restrict: 'E'</code>）。\nAngularJS 的元素型指令是基于它的<em>名字</em>匹配的。\n<em>Angular 组件中的 <code>selector</code> 元数据，在降级后的版本中会被忽略。</em></p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7g8ya8eg367955tl87yms7qyx\">当然，大多数组件都不像这个这么简单。它们中很多都有<em>输入属性和输出属性</em>，来把它们连接到外部世界。Angular 的英雄详情组件带有像这样的输入属性与输出属性：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/downgrade-io/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\nimport { Hero }&nbsp;from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;\n    &lt;div&gt;id: {{hero.id}}&lt;/div&gt;\n    &lt;button type=\"button\" (click)=\"onDelete()\"&gt;Delete&lt;/button&gt;\n  `\n})\nexport class HeroDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleted = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;Hero&gt;();\n  onDelete() {\n    this.deleted.emit(this.hero);\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"926khw4galox5m7pud21l0n4b\">这些输入属性和输出属性的值来自于 AngularJS 的模板，而 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 方法负责桥接它们：</p>\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"usecomponent\">\n&lt;div ng-controller=\"MainController as mainCtrl\"&gt;\n  &lt;hero-detail [hero]=\"mainCtrl.hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\"&gt;\n  &lt;/hero-detail&gt;\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71wj2f2vuofl4hoc7u41zs0d3\">注意，虽然你正在 AngularJS 的模板中，<strong>但却在使用 Angular 的属性（Attribute）语法来绑定到输入属性与输出属性</strong>。这是降级的组件本身要求的。而表达式本身仍然是标准的 AngularJS 表达式。</p>\n<div class=\"callout is-important\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c7r5iykqoa0dqxq1m466mbwwi\">在降级过的组件属性中使用中线命名法</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvfnusu48k5upmdcrt969f55c\">为降级过的组件使用 Angular 的属性(Attribute)语法规则时有一个值得注意的例外。它适用于由多个单词组成的输入或输出属性。在 Angular 中，你要使用小驼峰命名法绑定这些属性：</p>\n<code-example language=\"html\">\n\n[myHero]=\"hero\"\n(heroDeleted)=\"handleHeroDeleted($event)\"\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vgf4aacuu1bscax6kvpgaflq\">但是从 AngularJS 的模板中使用它们时，你得使用中线命名法：</p>\n<code-example language=\"html\">\n\n[my-hero]=\"hero\"\n(hero-deleted)=\"handleHeroDeleted($event)\"\n\n</code-example>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74hy9adxhiixlel646byb7p3x\"><code>$event</code> 变量能被用在输出属性里，以访问这个事件所发出的对象。这个案例中它是 <code>Hero</code> 对象，因为 <code>this.deleted.emit()</code> 函数曾把它传了出来。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"89xgfghvl8uux4ms358vnem3y\">由于这是一个 AngularJS 模板，虽然它已经有了 Angular 中绑定的属性（Attribute），你仍可以在这个元素上使用其它 AngularJS 指令。比如，你可以用 <code>ng-repeat</code> 简单的制作该组件的多份拷贝：</p>\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"userepeatedcomponent\">\n&lt;div ng-controller=\"MainController as mainCtrl\"&gt;\n  &lt;hero-detail [hero]=\"hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\"\n               ng-repeat=\"hero in mainCtrl.heroes\"&gt;\n  &lt;/hero-detail&gt;\n&lt;/div&gt;\n\n</code-example>\n<h3 id=\"using-angularjs-component-directives-from-angular-code\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"38meio4200gddmv1p5m74rk0i\">从 Angular 代码使用 AngularJS 组件指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-angularjs-component-directives-from-angular-code\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"lightbox\">\n<img alt=\"Using an AngularJS component from Angular code\" class=\"left\" src=\"generated/images/guide/upgrade/a-to-ajs.png\" width=\"250\" height=\"44\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29y9kr31dcnaxzp07juqximlo\">现在，你已经能在 Angular 中写一个组件，并把它用于 AngularJS 代码中了。当你从低级组件开始移植，并往上走时，这非常有用。但在另外一些情况下，从相反的方向进行移植会更加方便：从高级组件开始，然后往下走。这也同样能用 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 完成。你可以<em>升级</em>AngularJS 组件型指令，然后从 Angular 中用它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1cv9f348pikr54emq3ndk36b5\">不是所有种类的 AngularJS 指令都能升级。该指令必须是一个严格的<em>组件型指令</em>，具有<a href=\"guide/upgrade#using-component-directives\" title=\"Using Component Directives - Upgrading from AngularJS to Angular | Angular\">上面的准备指南中描述的</a>那些特征。\n确保兼容性的最安全的方式是 AngularJS 1.5 中引入的<a href=\"https://docs.angularjs.org/api/ng/type/angular.Module\" title=\"angular.Module | API | AngularJS\">组件 API</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ep0hhrj45or88i1vvwvdsx5s\">可升级组件的简单例子是只有一个模板和一个控制器的指令：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-static/hero-detail.component.ts\" region=\"hero-detail\">\nexport const heroDetail = {\n  template: `\n    &lt;h2&gt;Windstorm details!&lt;/h2&gt;\n    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;1&lt;/div&gt;\n  `,\n  controller: function HeroDetailController() {\n  }\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6smt58lopz9g8pwft9sun3noc\">你可以使用 <code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code> 方法来把这个组件<em>升级</em>到 Angular。具体方法是创建一个 Angular<strong>指令</strong>，继承 <code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code>，在其构造函数中进行 <code>super</code> 调用，这样你就得到一个完全升级的 AngularJS 组件，并且可以 Angular 中使用。剩下是工作就是把它加入到 <code>AppModule</code> 的 <code>declarations</code> 数组。</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-static/hero-detail.component.ts\" region=\"hero-detail-upgrade\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>, <a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a> } from '@angular/core';\nimport { <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> {\n  constructor(elementRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n\n</code-example>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/upgrade-static/app.module.ts\" region=\"hero-detail-upgrade\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  declarations: [\n    HeroDetailDirective,\n  /* . . . */\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"55qmtltb7t0l7vsra3htvxwvi\">升级后的组件是 Angular 的<strong>指令</strong>，而不是<strong>组件</strong>，因为 Angular 不知道 AngularJS 将在它下面创建元素。Angular 所知道的是升级后的组件只是一个指令（一个标签），Angular 不需要关心组件本身及其子元素。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"31821igppuewbalu8h60amzab\">升级后的组件也可能有输入属性和输出属性，它们是在原 AngularJS 组件型指令的 scope/controller 绑定中定义的。当你从 Angular 模板中使用该组件时，就要使用<strong>Angular 模板语法</strong>来提供这些输入属性和输出属性，但要遵循下列规则：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7jkz5u13vo6be1cpi42eb3su9\">绑定</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2aqcs6fggsep2j4ot183cmbad\">绑定定义</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5w5kqvgmi0o4l4z6rjt7db87s\">模板语法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5muob4wh4fsl6ato4xv3jxnzs\">属性（Attribute）绑定</td>\n<td align=\"left\"><code>myAttribute: '@myAttribute'</code></td>\n<td align=\"left\"><code>&lt;my-component myAttribute=\"value\"&gt;</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d6p6bhfoywn6cx6njd1898fx9\">表达式绑定</td>\n<td align=\"left\"><code>myOutput: '&amp;myOutput'</code></td>\n<td align=\"left\"><code>&lt;my-component (myOutput)=\"action()\"&gt;</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"27bdkap4zwilifc2pv59n81ag\">单向绑定</td>\n<td align=\"left\"><code>myValue: '&lt;myValue'</code></td>\n<td align=\"left\"><code>&lt;my-component [myValue]=\"anExpression\"&gt;</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xy6wmoza9k1s7w2doa894ml4\">双向绑定</td>\n<td align=\"left\"><code>myValue: '=myValue'</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"am0s34f1zqdqmxu7uuqxp56yi\">作为双向绑定：\n<br>\n<code>&lt;my-component [(myValue)]=\"anExpression\"&gt;</code>\n<br>由于大多数 AngularJS 的双向绑定实际上只需要单向绑定，在实践中通常足够使用 \n<code>&lt;my-component [myValue]=\"anExpression\"&gt;</code>。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"diya9bml3crmxsad3gee7q1jp\">举个例子，假设 AngularJS 中有一个表示“英雄详情”的组件型指令，它带有一个输入属性和一个输出属性：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io\">\nexport const heroDetail = {\n  bindings: {\n    hero: '&lt;',\n    deleted: '&amp;'\n  },\n  template: `\n    &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt;\n    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt;\n    &lt;button type=\"button\" ng-click=\"$ctrl.onDelete()\"&gt;Delete&lt;/button&gt;\n  `,\n  controller: function HeroDetailController() {\n    this.onDelete = () =&gt; {\n      this.deleted(this.hero);\n    };\n  }\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"alpps0q0lerd2b7sq3xd93d5p\">你可以把这个组件升级到 Angular，然后使用 Angular 的模板语法提供这个输入属性和输出属性：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io-upgrade\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a> } from '@angular/core';\nimport { <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleted: <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;Hero&gt;;\n\n  constructor(elementRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n\n</code-example>\n<code-example header=\"container.component.ts\" path=\"upgrade-module/src/app/upgrade-io/container.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-container',\n  template: `\n    &lt;h1&gt;Tour of Heroes&lt;/h1&gt;\n    &lt;hero-detail [hero]=\"hero\"\n                 (deleted)=\"heroDeleted($event)\"&gt;\n    &lt;/hero-detail&gt;\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm');\n  heroDeleted(hero: Hero) {\n    hero.name = 'Ex-' + hero.name;\n  }\n}\n\n\n</code-example>\n<h3 id=\"projecting-angularjs-content-into-angular-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a9gxaoipbvjjdvhsxqdmvmai4\">把 AngularJS 的内容投影到 Angular 组件中<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#projecting-angularjs-content-into-angular-components\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"lightbox\">\n<img alt=\"Projecting AngularJS content into Angular\" class=\"left\" src=\"generated/images/guide/upgrade/ajs-to-a-with-projection.png\" width=\"250\" height=\"48\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7fw4iamr9lm77aspibw79clhh\">如果你在 AngularJS 模板中使用降级后的 Angular 组件时，可能会需要把模板中的一些内容投影进那个组件。这也是可能的，虽然在 Angular 中并没有透传（transclude）这样的东西，但它有一个非常相似的概念，叫做<em>内容投影</em>。<code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 也能让这两个特性实现互操作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"nj4ayzvh59n7d7gxsamyumrb\">Angular 的组件通过使用 <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 标签来支持内容投影。下面是这类组件的一个例子：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/ajs-to-a-projection/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &lt;h2&gt;{{hero.name}}&lt;/h2&gt;\n    &lt;div&gt;\n      &lt;ng-content&gt;&lt;/ng-content&gt;\n    &lt;/div&gt;\n  `\n})\nexport class HeroDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gg55xfngqlc194zeqotri4hq\">当从 AngularJS 中使用该组件时，你可以为它提供内容。正如它们将在 AngularJS 中被透传一样，它们也在 Angular 中被投影到了 <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 标签所在的位置：</p>\n<code-example path=\"upgrade-module/src/index-ajs-to-a-projection.html\" region=\"usecomponent\">\n&lt;div ng-controller=\"MainController as mainCtrl\"&gt;\n  &lt;hero-detail [hero]=\"mainCtrl.hero\"&gt;\n    &lt;!-- Everything here will get projected --&gt;\n    &lt;p&gt;{{mainCtrl.hero.description}}&lt;/p&gt;\n  &lt;/hero-detail&gt;\n&lt;/div&gt;\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvpy3wiu581sl0y7y3syg8wjq\">当 AngularJS 的内容被投影到 Angular 组件中时，它仍然留在“AngularJS 王国”中，并被 AngularJS 框架管理着。</p>\n</div>\n<h3 id=\"transcluding-angular-content-into-angularjs-component-directives\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7kxc169isbsiflxfsaqqst9tu\">把 Angular 的内容透传进 AngularJS 的组件型指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"lightbox\">\n<img alt=\"Projecting Angular content into AngularJS\" class=\"left\" src=\"generated/images/guide/upgrade/a-to-ajs-with-transclusion.png\" width=\"250\" height=\"48\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4kno0vkuhn41axe7hcxztuzja\">就像可以把 AngularJS 的内容投影进 Angular 组件一样，你也能把 Angular 的内容<em>透传</em>进 AngularJS 的组件，但不管怎样，你都要使用它们升级过的版本。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cyqmlwuwwnernnv7jtiqpvia4\">如果一个 AngularJS 组件型指令支持透传，它就会在自己的模板中使用 <code>ng-transclude</code> 指令标记出透传到的位置：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/a-to-ajs-transclusion/hero-detail.component.ts\">\nexport const heroDetail = {\n  bindings: {\n    hero: '='\n  },\n  template: `\n    &lt;h2&gt;{{$ctrl.hero.name}}&lt;/h2&gt;\n    &lt;div&gt;\n      &lt;ng-transclude&gt;&lt;/ng-transclude&gt;\n    &lt;/div&gt;\n  `,\n  transclude: true\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"65eobq2kgs9sqxallan564c8e\">如果你升级这个组件，并把它用在 Angular 中，你就能把准备透传的内容放进这个组件的标签中。</p>\n<code-example header=\"container.component.ts\" path=\"upgrade-module/src/app/a-to-ajs-transclusion/container.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-container',\n  template: `\n    &lt;hero-detail [hero]=\"hero\"&gt;\n      &lt;!-- Everything here will get transcluded --&gt;\n      &lt;p&gt;{{hero.description}}&lt;/p&gt;\n    &lt;/hero-detail&gt;\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm', 'Specific powers of controlling winds');\n}\n\n\n</code-example>\n<h3 id=\"making-angularjs-dependencies-injectable-to-angular\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cbo6a02p2xquu5gp3oyzy5fp3\">让 AngularJS 中的依赖可被注入到 Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"as0pkl55zdtc6pczusovwllht\">当运行一个混合式应用时，可能会遇到这种情况：你需要把某些 AngularJS 的依赖注入到 Angular 代码中。这可能是因为某些业务逻辑仍然在 AngularJS 服务中，或者需要某些 AngularJS 的内置服务，比如 <code>$location</code> 或 <code>$timeout</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dp69o9g04m90stut2e5g9uvtc\">在这些情况下，把一个 AngularJS 提供者<em>升级到</em>Angular 也是有可能的。这就让它将来有可能被注入到 Angular 代码中的某些地方。比如，你可能在 AngularJS 中有一个名叫 <code>HeroesService</code> 的服务：</p>\n<code-example header=\"heroes.service.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/heroes.service.ts\">\nimport { Hero }&nbsp;from '../hero';\n\nexport class HeroesService {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"964g8jv2kw076a8qjgjy8esd0\">你可以用 Angular 的[工厂提供者][AioGuideDependencyInjectionProvidersFactoryProviders]升级该服务，\n它从 AngularJS 的 <code>$injector</code> 请求服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dha5d54hqkjauin3p6uqzxd2\">很多开发者都喜欢在一个独立的 <code>ajs-upgraded-providers.ts</code> 中声明这个工厂提供者，以便把它们都放在一起，这样便于引用、创建新的以及在升级完毕时删除它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dn89ph1zxf7115hsifw5zd6ku\">同时，建议导出 <code>heroesServiceFactory</code> 函数，以便 AOT 编译器可以拿到它们。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8r2c5gllbrx5myex1p5r8lhga\"><strong>注意</strong>：<br>\n这个工厂中的字符串 'heroes' 指向的是 AngularJS 的 <code>HeroesService</code>。\nAngularJS 应用中通常使用服务名作为令牌，比如 'heroes'，并为其追加 'Service' 后缀来创建其类名。</p>\n</div>\n<code-example header=\"ajs-upgraded-providers.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/ajs-upgraded-providers.ts\">\nimport { HeroesService } from './heroes.service';\n\nexport function heroesServiceFactory(i: any) {\n  return i.get('heroes');\n}\n\nexport const heroesServiceProvider = {\n  provide: HeroesService,\n  useFactory: heroesServiceFactory,\n  deps: ['$injector']\n};\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9s2uhglmsdxnoz9aiibnmpd9q\">然后，你就可以把这个服务添加到 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中来把它暴露给 Angular：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/app.module.ts\" region=\"register\">\nimport { heroesServiceProvider } from './ajs-upgraded-providers';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  providers: [\n    heroesServiceProvider\n  ],\n/* . . . */\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8rdyxy2p06xhtja40rq20k5v9\">然后在组件的构造函数中使用该服务的类名作为类型注解注入到组件中，从而在组件中使用它：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { HeroesService } from './heroes.service';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &lt;h2&gt;{{hero.id}}: {{hero.name}}&lt;/h2&gt;\n  `\n})\nexport class HeroDetailComponent {\n  hero: Hero;\n  constructor(heroes: HeroesService) {\n    this.hero = heroes.get()[0];\n  }\n}\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"10m6skzfdk4loy0wudqh93e59\">在这个例子中，你升级了服务类。当注入它时，你可以使用 TypeScript 类型注解来获得这些额外的好处。它没有影响该依赖的处理过程，同时还得到了启用静态类型检查的好处。任何 AngularJS 中的服务、工厂和提供者都能被升级 —— 尽管这不是必须的。</p>\n</div>\n<h3 id=\"making-angular-dependencies-injectable-to-angularjs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e380i9qin7y0139imlr9ront7\">让 Angular 的依赖能被注入到 AngularJS 中<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#making-angular-dependencies-injectable-to-angularjs\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c02prf3cnq1r7n9bvq3he4wqi\">除了能升级 AngularJS 依赖之外，你还能<em>降级</em>Angular 的依赖，以便在 AngularJS 中使用它们。当你已经开始把服务移植到 Angular 或在 Angular 中创建新服务，但同时还有一些用 AngularJS 写成的组件时，这会非常有用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54x2tut843052x61qj4tga1f1\">比如，你可能有一个 Angular 的 <code>Heroes</code> 服务：</p>\n<code-example header=\"heroes.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/heroes.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Hero }&nbsp;from '../hero';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Heroes {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c618049pmus7pngs6jau0z0l0\">仿照 Angular 组件，把该提供者加入 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>providers</code> 列表中，以注册它。</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"ngmodule\">\nimport { Heroes } from './heroes';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  providers: [ Heroes ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2t4tfdrk015mu8a4azxvv8kb2\">现在，用 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> 来把 Angular 的 <code>Heroes</code> 包装成<em>AngularJS 的工厂函数</em>，并把这个工厂注册进 AngularJS 的模块中。依赖在 AngularJS 中的名字你可以自己定：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"register\">\nimport { Heroes } from './heroes';\n/* . . . */\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('heroApp', [])\n  .factory('heroes', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Heroes))\n  .component('heroDetail', heroDetailComponent);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1uv2g379bzd3h6a0fhvfedk7l\">此后，该服务就能被注入到 AngularJS 代码中的任何地方了：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/hero-detail.component.ts\">\nexport const heroDetailComponent = {\n  template: `\n    &lt;h2&gt;{{$ctrl.hero.id}}: {{$ctrl.hero.name}}&lt;/h2&gt;\n  `,\n  controller: ['heroes', function(heroes: Heroes) {\n    this.hero = heroes.get()[0];\n  }]\n};\n\n\n</code-example>\n<h2 id=\"lazy-loading-angularjs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3uv3f9h6ly5kkkij16yqx4o0m\">惰性加载 AngularJS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#lazy-loading-angularjs\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cxt9ypwzzk2niojfum0iefsrl\">在构建应用时，你需要确保只在必要的时候才加载所需的资源，无论是加载静态资产（Asset）还是代码。要确保任何事都尽量推迟到必要时才去做，以便让应用更高效的运行。当要在同一个应用中运行不同的框架时，更是如此。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5mfp4wnn1hel717ytyzlv4uqa\"><a href=\"guide/glossary#lazy-loading\" title=\"lazy loading - Glossary | Angular\">惰性加载</a>是一项技术，它会推迟到使用时才加载所需静态资产和代码资源。这可以减少启动时间、提高效率，特别是要在同一个应用中运行不同的框架时。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7t59w35o433gviaprfv1mot66\">当你采用混合式应用的方式将大型应用从 AngularJS 迁移到 Angular 时，你首先要迁移一些最常用的特性，并且只在必要的时候才使用那些不太常用的特性。这样做有助于确保应用程序在迁移过程中仍然能为用户提供无缝的体验。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"456t1yks6evu34rjlzoshj3uh\">在大多数需要同时用 Angular 和 AngularJS 渲染应用的环境中，这两个框架都会包含在发送给客户端的初始发布包中。这会导致发布包的体积增大、性能降低。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9emdejv926t61rrm07m28q3ts\">当用户停留在由 Angular 渲染的页面上时，应用的整体性能也会受到影响。这是因为 AngularJS 的框架和应用仍然被加载并运行了 —— 即使它们从未被访问过。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"qnhtwwrhgd9ggb7bnal3c11w\">你可以采取一些措施来缓解这些包的大小和性能问题。通过把 AngularJS 应用程序分离到一个单独的发布包中，你就可以利用<a href=\"guide/glossary#lazy-loading\" title=\"lazy loading - Glossary | Angular\">惰性加载</a>技术来只在必要的时候才加载、引导和渲染这个 AngularJS 应用。这种策略减少了你的初始发布包大小，推迟了同时加载两个框架的潜在影响 —— 直到绝对必要时才加载，以便让你的应用尽可能高效地运行。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ad4vzrwdnbhd9cmn31jqr0jpi\">下面的步骤介绍了应该如何去做：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aoljnmkmhxlwm4dflrwsvtzqa\">为你的 AngularJS 捆绑包设置回调函数。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d4peohi0h3aaioao35kgv3ze2\">创建一个服务，以便惰性加载并引导你的 AngularJS 应用。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6cmp0ltuvxi8idlmqhs3e0um8\">为 AngularJS 内容创建一个可路由的组件</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76vnbwodf1je34cc1ur3nwj57\">为 AngularJS 特有的 URL 创建自定义的 <code>matcher</code> 函数，并为 AngularJS 的各个路由配上带有自定义匹配器的 Angular 路由器。</li>\n</ul>\n<h3 id=\"create-a-service-to-lazy-load-angularjs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1y5zew03ky8dzcxaxlf5h9epy\">为惰性加载 AngularJS 创建一个服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-a-service-to-lazy-load-angularjs\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c67806jar0rzagqboadyo3ahj\">在 Angular 的版本 8 中，惰性加载代码只需使用动态导入语法 <code>import('...')</code> 即可。在这个应用中，你创建了一个新服务，它使用动态导入技术来惰性加载 AngularJS。</p>\n<code-example header=\"src/app/lazy-loader.service.ts\" path=\"upgrade-lazy-load-ajs/src/app/lazy-loader.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport * as angular from 'angular';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class LazyLoaderService {\n  private app: angular.auto.IInjectorService | undefined;\n\n  load(el: HTMLElement): void {\n    import('./angularjs-app').then(app =&gt; {\n      try {\n        this.app = app.bootstrap(el);\n      } catch (e) {\n        console.error(e);\n      }\n    });\n  }\n\n  destroy() {\n    if (this.app) {\n      this.app.get('$rootScope').$destroy();\n    }\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"yhz10vnpw45ewf3ev84biacs\">该服务使用 \n<code>import()</code> 方法来延迟加载捆绑的 AngularJS 应用程序。这会减少应用程序的初始捆绑包大小，因为你不会加载用户暂时不需要的代码。你还需要提供一种方式在加载后手动 \n<em>引导</em> 应用程序。AngularJS 提供了一种通过提供的 HTML 元素使用 \n<a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\">angular.bootstrap()</a> 方法手动引导应用程序的方式。你的 AngularJS 应用程序还应该暴露一个 \n<code>bootstrap</code> 方法来引导 AngularJS 应用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6gr1qanth22vzsete4fanqa2t\">要确保 AngularJS 应用中的任何清理工作都触发过（比如移除全局监听器），你还可以实现一个方法来调用 <code>$rootScope.destroy()</code> 方法。</p>\n<code-example header=\"angularjs-app\" path=\"upgrade-lazy-load-ajs/src/app/angularjs-app/index.ts\">\nimport * as angular from 'angular';\nimport 'angular-route';\n\nconst appModule = angular.module('myApp', [\n  'ngRoute'\n])\n.config(['$routeProvider', '$locationProvider',\n  function config($routeProvider: angular.route.IRouteProvider,\n                  $locationProvider: angular.ILocationProvider) {\n    $locationProvider.html5Mode(true);\n\n    $routeProvider.\n      when('/users', {\n        template: `\n          &lt;p&gt;\n            Users Page\n          &lt;/p&gt;\n        `\n      }).\n      otherwise({\n        template: ''\n      });\n  }]\n);\n\nexport function bootstrap(el: HTMLElement) {\n  return angular.bootstrap(el,  [appModule.name]);\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dsjkjnygnwuz0ni1qdkyp50c\">你的 AngularJS 应用只配置了渲染内容所需的那部分路由。而 Angular 路由器会处理应用中其余的路由。你的 Angular 应用中会调用公开的 <code>bootstrap</code> 方法，让它在加载完发布包之后引导 AngularJS 应用。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cmlth15rv8nohhw3mgdaiyvhn\"><strong>注意：</strong>当 AngularJS 加载并引导完毕后，监听器（比如路由配置中的那些监听器）会继续监听路由的变化。为了确保当 AngularJS 尚未显示时先关闭监听器，请在 <a href=\"https://docs.angularjs.org/api/ngRoute/provider/$routeProvider\" title=\"$routeProvider | API | AngularJS\">$routeProvider</a> 中配置一个渲染空模板 <code>otherwise</code> 选项。这里假设 Angular 将处理所有其它路由。</p>\n</div>\n<h3 id=\"create-a-component-to-render-angularjs-content\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"10b7k70ah20tx6d4tci1xp04h\">创建一个用来渲染 AngularJS 内容的组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-a-component-to-render-angularjs-content\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2169vu3fzzyhu0pk9sfd0uxk\">在 Angular 应用中，你需要一个组件作为 AngularJS 内容的占位符。该组件使用你创建的服务，并在组件初始化完成后加载并引导你的 AngularJS 应用。</p>\n<code-example header=\"src/app/angular-js/angular-js.component.ts\" path=\"upgrade-lazy-load-ajs/src/app/angular-js/angular-js.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a> } from '@angular/core';\nimport { LazyLoaderService } from '../lazy-loader.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-angular-js',\n  template: '&lt;div ng-view&gt;&lt;/div&gt;'\n})\nexport class AngularJSComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n  constructor(\n    private lazyLoader: LazyLoaderService,\n    private elRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>\n  ) {}\n\n  ngOnInit() {\n    this.lazyLoader.load(this.elRef.nativeElement);\n  }\n\n\n  ngOnDestroy() {\n    this.lazyLoader.destroy();\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drhsnyxh0yppeqxkmovr2clt0\">当 Angular 的路由器匹配到使用 AngularJS 的路由时，会渲染 <code>AngularJSComponent</code>，并在 AngularJS 的 <a href=\"https://docs.angularjs.org/api/ngRoute/directive/ngView\" title=\"ngView | API | AngularJS\"><code>ng-view</code></a> 指令中渲染内容。当用户导航离开本路由时，<code>$rootScope</code> 会在 AngularJS 应用中被销毁。</p>\n<h3 id=\"configure-a-custom-route-matcher-for-angularjs-routes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ks3rxdlyvrupppwk1gf7dmp6\">为那些 AngularJS 路由配置自定义路由匹配器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#configure-a-custom-route-matcher-for-angularjs-routes\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f3piaecup7kj0axj9fmj2ptu8\">为了配置 Angular 的路由器，你必须为 AngularJS 的 URL 定义路由。要匹配这些 URL，你需要添加一个使用 <code>matcher</code> 属性的路由配置。这个 <code>matcher</code> 允许你使用自定义模式来匹配这些 URL 路径。Angular 的路由器会首先尝试匹配更具体的路由，比如静态路由和可变路由。当它找不到匹配项时，就会求助于路由配置中的自定义匹配器。如果自定义匹配器与某个路由不匹配，它就会转到用于 \"捕获所有\"（catch-all）的路由，比如 404 页面。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0jjb5qh9swnew1cpsubi3dx6\">下面的例子给 AngularJS 路由定义了一个自定义匹配器函数。</p>\n<code-example header=\"src/app/app-routing.module.ts\" path=\"upgrade-lazy-load-ajs/src/app/app-routing.module.ts\" region=\"matcher\">\nexport function isAngularJSUrl(url: <a href=\"api/router/UrlSegment\" class=\"code-anchor\">UrlSegment</a>[]) {\n  return url.length &gt; 0 &amp;&amp; url[0].path.startsWith('users') ? ({consumed: url}) : null;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c6yvfzwvew0zt786py7ere83q\">下列代码往你的路由配置中添加了一个路由对象，其 <code>matcher</code> 属性是这个自定义匹配器，而 <code>component</code> 属性为 <code>AngularJSComponent</code>。</p>\n<code-example header=\"src/app/app-routing.module.ts\" path=\"upgrade-lazy-load-ajs/src/app/app-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/UrlSegment\" class=\"code-anchor\">UrlSegment</a> } from '@angular/router';\nimport { AngularJSComponent } from './angular-js/angular-js.component';\nimport { HomeComponent } from './home/home.component';\nimport { App404Component } from './app404/app404.component';\n\n// Match any URL that starts with `users`\nexport function isAngularJSUrl(url: <a href=\"api/router/UrlSegment\" class=\"code-anchor\">UrlSegment</a>[]) {\n  return url.length &gt; 0 &amp;&amp; url[0].path.startsWith('users') ? ({consumed: url}) : null;\n}\n\nexport const routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  // <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> rendered by Angular\n  { path: '', component: HomeComponent },\n\n  // AngularJS routes\n  { matcher: isAngularJSUrl, component: AngularJSComponent },\n\n  // Catch-all route\n  { path: '**', component: App404Component }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cz0gevg666h0asxjcr2q85dti\">当你的应用匹配上需要 AngularJS 的路由时，AngularJS 应用就会被加载并引导。AngularJS 路由会匹配必要的 URL 以渲染它们的内容，而接下来你的应用就会同时运行 AngularJS 和 Angular 框架。</p>\n<h2 id=\"using-the-unified-angular-location-service\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bid9rvltf0vgwb5i5s9qjhagr\">使用统一的 Angular 位置服务（Location）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-the-unified-angular-location-service\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9l94w7azhmotq6qi5djytiep4\">在 AngularJS 中，<a href=\"https://docs.angularjs.org/api/ng/service/$location\" title=\"$location | API | AngularJS\">$location 服务</a>会处理所有路由配置和导航工作，并对各个 URL 进行编码和解码、重定向、以及与浏览器 API 交互。Angular 在所有这些任务中都使用了自己的底层服务 <code><a href=\"api/common/Location\" class=\"code-anchor\">Location</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8stu4qo5y1ql78ll5abqp3t46\">当你从 AngularJS 迁移到 Angular 时，你会希望把尽可能多的责任移交给 Angular，以便利用新的 API。为了帮你完成这种转换，Angular 提供了 <code><a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a></code>。该模块支持<em>统一</em>位置服务，可以把 AngularJS 中 <code>$location</code> 服务的职责转给 Angular 的 <code><a href=\"api/common/Location\" class=\"code-anchor\">Location</a></code> 服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5yz5052o3aco6xh97kbgzlpb\">要使用 <code><a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a></code>，就会从 <code>@angular/common/upgrade</code> 中导入此符号，并使用静态方法 <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> 把它添加到你的 <code>AppModule</code> 导入表（<code>imports</code>）中。</p>\n<code-example language=\"typescript\">\n\n// Other imports …\nimport { <a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a> } from '@angular/common/upgrade';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    // Other <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> imports…\n    LocationUpgradeModule.config()\n  ]\n})\nexport class AppModule {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2xe3dnj2bgaosrzfo9p78nimp\"><code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> 方法接受一个配置对象，该对象的 <code>useHash</code> 为 <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code>，<code>hashPrefix</code> 为 URL 前缀。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cd07bg8hgssrruau8zefey1gx\"><code>useHash</code> 属性默认为 <code>false</code>，而 <code>hashPrefix</code> 默认为空 <code>string</code>。传递配置对象可以覆盖默认值。</p>\n<code-example language=\"typescript\">\n\nLocationUpgradeModule.config({\n  useHash: true,\n  hashPrefix: '!'\n})\n\n</code-example>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"38npab7ysm0pxw9yqcejcg91l\"><strong>注意：</strong>关于 <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> 方法的更多可用配置项，请参阅 <code><a href=\"api/common/upgrade/LocationUpgradeConfig\" class=\"code-anchor\">LocationUpgradeConfig</a></code>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7b81rog7rykxn8xefn0ibcy3b\">这会为 AngularJS 中的 <code>$location</code> 提供者注册一个替代品。一旦注册成功，导航过程中所有由 AngularJS 触发的导航、路由广播消息以及任何必需的变更检测周期都会改由 Angular 进行处理。这样，你就可以通过这个唯一的途径在此混合应用的两个框架间进行导航了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2xvna8h9iwr9wz2ohto6k1jrx\">要想在 AngularJS 中使用 <code>$location</code> 服务作为提供者，你需要使用一个工厂提供者来降级 <code><a href=\"api/common/upgrade/$locationShim\" class=\"code-anchor\">$locationShim</a></code>。</p>\n<code-example language=\"typescript\">\n\n// Other imports …\nimport { $locationShim } from '@angular/common/upgrade';\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('myHybridApp', […])\n  .factory('$location', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>($locationShim));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"19eqk6i174fr8pppcyi1xtpws\">一旦引入了 Angular 路由器，你只要使用 Angular 路由器就可以通过统一位置服务来触发导航了，同时，你仍然可以通过 AngularJS 和 Angular 进行导航。</p>\n<!--TODO:\nCorrectly document how to use AOT with SystemJS-based `ngUpgrade` apps (or better yet update the `ngUpgrade` examples/guides to use `@angular/cli`).\nSee [https://github.com/angular/angular/issues/35989][GithubAngularAngularIssues35989].\n\n## Using Ahead-of-time compilation with hybrid apps\n\nYou can take advantage of Ahead-of-time \\(AOT\\) compilation on hybrid apps just like on any other Angular application.\nThe setup for a hybrid app is mostly the same as described in the [Ahead-of-time Compilation chapter][AioGuideAotCompiler] save for differences in `index.html` and `main-aot.ts`\n\nThe `index.html` will likely have script tags loading AngularJS files, so the `index.html` for AOT must also load those files.\nAn easy way to copy them is by adding each to the `copy-dist-files.js` file.\n\nYou'll need to use the generated `AppModuleFactory`, instead of the original `AppModule` to bootstrap the hybrid app:\n\n<code-example header=\"app/main-aot.ts\" path=\"upgrade-phonecat-2-hybrid/app/main-aot.ts\">\nimport { platformBrowser } from &#39;@angular/platform-browser&#39;;\n\nimport { AppModule } from &#39;./app.module&#39;;\n\nplatformBrowser().bootstrapModule(AppModule);\n\n\n</code-example>\n\nAnd that s all you need do to get the full benefit of AOT for Angular apps!\n-->\n<h2 id=\"phonecat-upgrade-tutorial\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"jgri4q9swr39zjjzuzy9dtcg\">PhoneCat 升级教程<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#phonecat-upgrade-tutorial\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebwptp29un33j3zqsor63usx0\">在本节和下节中，你将看一个完整的例子，它使用 <code>upgrade</code> 模块准备和升级了一个应用程序。\n该应用就是来自<a href=\"https://docs.angularjs.org/tutorial\" title=\"PhoneCat Tutorial App | Tutorial | AngularJS\">原 AngularJS 教程</a>中的<a href=\"https://github.com/angular/angular-phonecat\" title=\"angular/angular-phonecat | GitHub\">Angular PhoneCat</a>。\n那是我们很多人当初开始 Angular 探险之旅的地方。\n现在，你会看到如何把该应用带入 Angular 的美丽新世界。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"98n3kntteieccc8dxn2pyfme0\">这期间，你将学到如何在实践中应用<a href=\"guide/upgrade#preparation\" title=\"Preparation - Upgrading from AngularJS to Angular | Angular\">准备指南</a>中列出的那些重点步骤。\n你要先让该应用向 Angular 看齐，并开始写 TypeScript。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cc75o3ouba09xqrkks30dfbvc\">本教程基于 <code>angular-phonecat</code> 教程的 1.5.x 版本，该教程保存在代码仓库的 <a href=\"https://github.com/angular/angular-phonecat/commits/1.5-snapshot\" title=\"angular/angular-phonecat v1.5 | GitHub\">1.5-snapshot</a> 分支中。接下来，克隆 <a href=\"https://github.com/angular/angular-phonecat\" title=\"angular/angular-phonecat | GitHub\">angular-phonecat</a> 代码仓库，check out <code>1.5-snapshot</code> 分支并应用这些步骤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ds02jhte0gfwdyov2y7gvth6r\">在项目结构方面，工作的起点是这样的：</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    angular-phonecat\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      bower.json\n    </div>\n    <div class=\"file\">\n      karma.conf.js\n    </div>\n    <div class=\"file\">\n      package.json\n    </div>\n    <div class=\"file\">\n      app\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        core\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          checkmark\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            checkmark.filter.js\n          </div>\n          <div class=\"file\">\n            checkmark.filter.spec.js\n          </div>\n        </div>\n        <div class=\"file\">\n          phone\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            phone.module.js\n          </div>\n          <div class=\"file\">\n            phone.service.js\n          </div>\n          <div class=\"file\">\n            phone.service.spec.js\n          </div>\n        </div>\n        <div class=\"file\">\n          core.module.js\n        </div>\n      </div>\n      <div class=\"file\">\n        phone-detail\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          phone-detail.component.js\n        </div>\n        <div class=\"file\">\n          phone-detail.component.spec.js\n        </div>\n        <div class=\"file\">\n          phone-detail.module.js\n        </div>\n        <div class=\"file\">\n          phone-detail.template.html\n        </div>\n      </div>\n      <div class=\"file\">\n        phone-list\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          phone-list.component.js\n        </div>\n        <div class=\"file\">\n          phone-list.component.spec.js\n        </div>\n        <div class=\"file\">\n          phone-list.module.js\n        </div>\n        <div class=\"file\">\n          phone-list.template.html\n        </div>\n      </div>\n      <div class=\"file\">\n        img\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n           …\n        </div>\n      </div>\n      <div class=\"file\">\n        phones\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n           …\n        </div>\n      </div>\n      <div class=\"file\">\n        app.animations.js\n      </div>\n      <div class=\"file\">\n        app.config.js\n      </div>\n      <div class=\"file\">\n        app.css\n      </div>\n      <div class=\"file\">\n        app.module.js\n      </div>\n      <div class=\"file\">\n        index.html\n      </div>\n    </div>\n    <div class=\"file\">\n      e2e-tests\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        protractor-conf.js\n      </div>\n      <div class=\"file\">\n        scenarios.js\n      </div>\n    </div>\n  </div>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26lcx5h040b9mpyc9nj0mgly4\">这确实是一个很好地起点。这些代码使用了 AngularJS 1.5 的组件 API，并遵循了 <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\" title=\"Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">AngularJS 风格指南</a>进行组织，\n在成功升级之前，这是一个很重要的<a href=\"guide/upgrade#follow-the-angularjs-style-guide\" title=\"Follow the AngularJS Style Guide - Upgrading from AngularJS to Angular | Angular\">准备步骤</a>。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bq2ebsm03oeh08zuta1mc6ehw\">每个组件、服务和过滤器都在它自己的源文件中 —— 就像<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\" title=\"Single Responsibility - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">单一规则</a>所要求的。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8bw28cn78yajeq2umwwehyfru\"><code>core</code>、<code>phone-detail</code> 和 <code>phone-list</code> 模块都在它们自己的子目录中。那些子目录除了包含 HTML 模板之外，还包含 JavaScript 代码，它们共同完成一个特性。\n这是<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\" title=\"Folders-by-Feature Structure - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">按特性分目录的结构</a>\n和<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\" title=\"Modularity - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">模块化</a>规则所要求的。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"32udpjhi39tl1ebalmxavnvll\">单元测试都和应用代码在一起，它们很容易找到。就像规则\n<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests\" title=\"Organizing Tests - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">组织测试文件</a>中要求的那样。</p>\n</li>\n</ul>\n<h3 id=\"switching-to-typescript\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7y7f56xnbmhgpagrzvt5alpqp\">切换到 TypeScript<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#switching-to-typescript\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9id457a42mbr8dstoulmceaci\">因为你将使用 TypeScript 编写 Angular 的代码，所以在开始升级之前，先要把 TypeScript 的编译器设置好。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a7lcy5frow2gsfew7yphkwbrq\">你还将开始逐步淘汰 Bower 包管理器，换成 NPM。后面你将使用 NPM 来安装新的依赖包，并最终从项目中移除 Bower。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xj8b1g47zs62ggoebjlkeuay\">先把 TypeScript 包安装到项目中。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm i typescript --save-dev\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24pwba0s60ajra1aidvgs39fi\">还要为那些没有自带类型信息的库（比如 AngularJS、AngularJS Material 和 Jasmine）安装类型定义文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3zvpe0ms0rksi6zuqmvr6znk\">对于 PhoneCat 应用，我们可以运行下列命令来安装必要的类型定义文件：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @types/jasmine @types/angular @types/angular-animate @types/angular-aria @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6qzh2m4neibqdgm3ji7vveer0\">如果你正在使用 AngularJS Material，你可以通过下列命令安装其类型定义：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @types/angular-material --save-dev\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8z40tkoaxz38dwrnk5ibpslkb\">你还应该要往项目目录下添加一个 <code>tsconfig.json</code> 文件，\n就像在 <a href=\"guide/typescript-configuration\" title=\"TypeScript configuration | Angular\">TypeScript 配置</a>中讲过的那样。\n<code>tsconfig.json</code> 文件会告诉 TypeScript 编译器如何把 TypeScript 文件转成 ES5 代码，并打包进 CommonJS 模块中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a1hx5h4sbdvb2p7kk71l5gfz0\">最后，你应该把下列 npm 脚本添加到 <code>package.json</code> 中，用于把 TypeScript 文件编译成 JavaScript（根据 <code>tsconfig.json</code> 的配置）：</p>\n<code-example format=\"shell\" language=\"shell\">\n\n\"scripts\": {\n  \"tsc\": \"tsc\",\n  \"tsc:w\": \"tsc -w\",\n  …\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eaa2rzwoten42fdkz03a9yu2l\">现在，从命令行中用监视模式启动 TypeScript 编译器：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm run tsc:w\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"22mvu9ww53f68ztxszcq63mrw\">让这个进程一直在后台运行，监听任何变化并自动重新编译。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44xzs5xwz3z46pz3zpfi8tw66\">接下来，把 JavaScript 文件转换成 TypeScript 文件。由于 TypeScript 是 ECMAScript 2015 的一个超集，而 ES2015 又是 ECMAScript 5 的超集，所以你可以简单的把文件的扩展名从 <code>.js</code> 换成 <code>.ts</code>，它们还是会像以前一样工作。由于 TypeScript 编译器仍在运行，它会为每一个 <code>.ts</code> 文件生成对应的 <code>.js</code> 文件，而真正运行的是编译后的 <code>.js</code> 文件。如果你用 <code>npm start</code> 开启了本项目的 HTTP 服务器，你会在浏览器中看到一个功能完好的应用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1cc8ik8yace0usi9vfjcsymtg\">有了 TypeScript，你就可以从它的一些特性中获益了。此语言可以为 AngularJS 应用提供很多价值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"j98ijr27ijno2nd036qcsdaw\">首先，TypeScript 是一个 ES2015 的超集。任何以前用 ES5 写的程序（就像 PhoneCat 范例）都可以开始通过 TypeScript 纳入那些添加到 ES2015 中的新特性。这包括 <code>let</code>、<code>const</code>、箭头函数、函数默认参数以及解构（destructure）赋值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5m1bolkuyitg4mlxj5g9haeso\">你能做的另一件事就是把<em>类型安全</em>添加到代码中。这实际上已经部分完成了，因为你已经安装了 AngularJS 的类型定义。TypeScript 会帮你检查是否正确调用了 AngularJS 的 API，—— 比如往 Angular 模块中注册组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"hzhsx56ynm6lmu9pjoo7zdev\">你还能开始把<em>类型注解</em>添加到自己的代码中，来从 TypeScript 的类型系统中获得更多帮助。比如，你可以给 <code>checkmark</code> 过滤器加上注解，表明它期待一个 <code>boolean</code> 类型的参数。这可以更清楚的表明此过滤器打算做什么。</p>\n<code-example header=\"app/core/checkmark/checkmark.filter.ts\" path=\"upgrade-phonecat-1-typescript/app/core/checkmark/checkmark.filter.ts\">\nangular.\n  module('core').\n  filter('checkmark', () =&gt; (input: boolean) =&gt; input ? '\\u2713' : '\\u2718');\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1sxvs232y3c55aey0s1pxwjoo\">在 <code>Phone</code> 服务中，你可以明确的把 <code>$resource</code> 服务声明为 <code>angular.resource.IResourceService</code>，一个 AngularJS 类型定义提供的类型。</p>\n<code-example header=\"app/core/phone/phone.service.ts\" path=\"upgrade-phonecat-1-typescript/app/core/phone/phone.service.ts\">\nangular.\n  module('core.phone').\n  factory('Phone', ['$resource',\n    ($resource: angular.resource.IResourceService) =&gt;\n      $resource('phones/:phoneId.json', {}, {\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: {\n          method: 'GET',\n          params: {phoneId: 'phones'},\n          isArray: true\n        }\n      })\n  ]);\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dmh6ecrljbttwl4sswgbzmdi5\">你可以在应用的路由配置中使用同样的技巧，那里你用到了 location 和 route 服务。一旦为它们提供了类型信息，TypeScript 就能检查你是否在用类型的正确参数来调用它们了。</p>\n<code-example header=\"app/app.config.ts\" path=\"upgrade-phonecat-1-typescript/app/app.config.ts\">\nangular.\n  module('phonecatApp').\n  config(['$locationProvider', '$routeProvider',\n    function config($locationProvider: angular.ILocationProvider,\n                    $routeProvider: angular.route.IRouteProvider) {\n      $locationProvider.hashPrefix('!');\n\n      $routeProvider.\n        when('/phones', {\n          template: '&lt;phone-list&gt;&lt;/phone-list&gt;'\n        }).\n        when('/phones/:phoneId', {\n          template: '&lt;phone-detail&gt;&lt;/phone-detail&gt;'\n        }).\n        otherwise('/phones');\n    }\n  ]);\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7kg7bk1xhl7c2pmhzeut6n4h2\">你用安装的这个<a href=\"https://www.npmjs.com/package/@types/angular\" title=\"@types/angular | npm\">AngularJS.x 类型定义文件</a>\n并不是由 Angular 开发组维护的，但它也已经足够全面了。借助这些类型定义的帮助，它可以为 AngularJS.x 程序加上全面的类型注解。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ub2wlmo3uozpl2fwd0e6up7u\">如果你想这么做，就在 <code>tsconfig.json</code> 中启用 <code>noImplicitAny</code> 配置项。这样，如果遇到什么还没有类型注解的代码，TypeScript 编译器就会显示一个警告。你可以用它作为指南，告诉你现在与一个完全类型化的项目距离还有多远。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6kgm0vwmpvj1ol58uw3emjwsu\">你能用的另一个 TypeScript 特性是<em>类</em>。具体来讲，你可以把控制器转换成类。这种方式下，你离成为 Angular 组件类就又近了一步，它会令你的升级之路变得更简单。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4g78rdxt965kx6gt7rjwqpd35\">AngularJS 期望控制器是一个构造函数。这实际上就是 ES2015/TypeScript 中的类，这也就意味着只要你把一个类注册为组件控制器，AngularJS 就会愉快的使用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csv7xud6xi72126hpumx8up5k\">新的“电话列表（phone list）”组件控制器类是这样的：</p>\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-1-typescript/app/phone-list/phone-list.component.ts\">\nclass PhoneListController {\n  phones: any[];\n  orderProp: string;\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['Phone'];\n  constructor(Phone: any) {\n    this.phones = Phone.query();\n    this.orderProp = 'age';\n  }\n\n}\n\nangular.\n  module('phoneList').\n  component('phoneList', {\n    templateUrl: 'phone-list/phone-list.template.html',\n    controller: PhoneListController\n  });\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4gpxojxgvhmkqikcddi56fied\">以前在控制器函数中实现的一切，现在都改由类的构造函数来实现了。类型注入注解通过静态属性 <code>$inject</code> 被附加到了类上。在运行时，它们变成了 <code>PhoneListController.$inject</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cfzvd1fzacc0isqqgs4z3ivdv\">该类还声明了另外三个成员：电话列表、当前排序键的名字和搜索条件。这些东西你以前就加到了控制器上，只是从来没有在任何地方显式定义过它们。最后一个成员从未真正在 TypeScript 代码中用过，因为它只是在模板中被引用过。但为了清晰起见，你还是应该定义出此控制器应有的所有成员。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54ica4cafk4p8qurj8svf8ccb\">在电话详情控制器中，你有两个成员：一个是用户正在查看的电话，另一个是正在显示的图像：</p>\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.ts\">\nclass PhoneDetailController {\n  phone: any;\n  mainImageUrl: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['$routeParams', 'Phone'];\n  constructor($routeParams: angular.route.IRouteParamsService, Phone: any) {\n    const phoneId = $routeParams.phoneId;\n    this.phone = Phone.get({phoneId}, (phone: any) =&gt; {\n      this.setImage(phone.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module('phoneDetail').\n  component('phoneDetail', {\n    templateUrl: 'phone-detail/phone-detail.template.html',\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ad6u7fxx79jkenzf2uogtwzz4\">这已经让你的控制器代码看起来更像 Angular 了。你的准备工作做好了，可以引进 Angular 到项目中了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aqfg2smltpetqj108hj2embff\">如果项目中有任何 AngularJS 的服务，它们也是转换成类的优秀候选人，像控制器一样，它们也是构造函数。但是在本项目中，你只有一个 <code>Phone</code> 工厂，这有点特别，因为它是一个 <code>ngResource</code> 工厂。所以你不会在准备阶段中处理它，而是在下一节中直接把它转换成 Angular 服务。</p>\n<h3 id=\"installing-angular\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2znofqnml4e8p9iiwbmbvosgc\">安装 Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#installing-angular\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ai4ifz854o0dglqq5lveipvji\">准备工作做完了，接下来就开始把 PhoneCat 升级到 Angular。\n你将在 Angular<a href=\"guide/upgrade#upgrading-with-ngupgrade\" title=\"Upgrading with ngUpgrade - Upgrading from AngularJS to Angular | Angular\">升级模块</a>的帮助下增量式的完成此项工作。\n做完这些之后，就能把 AngularJS 从项目中完全移除了，但其中的关键是在不破坏此程序的前提下一小块一小块的完成它。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"11lm2x2u3dwsrkqv36l6qs6g\">该项目还包含一些动画，在此指南的当前版本你先不升级它，请到 <a href=\"guide/animations\" title=\"Introduction to Angular animations | Angular\">Angular 动画</a>中进一步学习。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2m10qqyetj8ofakqmuvr4981p\">用 SystemJS 模块加载器把 Angular 安装到项目中。\n看看<a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">升级的准备工作</a>中的指南，并从那里获得如下配置：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bl8olvaj2jiqx52xriubqmjvs\">把 Angular 和其它新依赖添加到 <code>package.json</code> 中</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6n6wb73gxx032puqyf6ng60pb\">把 SystemJS 的配置文件 <code>systemjs.config.js</code> 添加到项目的根目录。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crvro543i3qapgcrqeak6fj5o\">这些完成之后，就运行：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2btloj4bnqkvmdmn2x126f1wf\">很快你就可以通过 <code>index.html</code> 来把 Angular 的依赖快速加载到应用中，但首先，你得做一些目录结构调整。这是因为你正准备从 <code>node_modules</code> 中加载文件，然而目前项目中的每一个文件都是从 <code>/app</code> 目录下加载的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4zt060qzjr71zndyf5bhfqgfo\">把 <code>app/index.html</code> 移入项目的根目录，然后把 <code>package.json</code> 中的开发服务器根目录也指向项目的根目录，而不再是 <code>app</code> 目录：</p>\n<code-example language=\"json\">\n\n\"start\": \"http-server ./ -a localhost -p 8000 -c-1\",\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5f5686n444rhe4svjbcj4dtda\">现在，你就能把项目根目录下的每一样东西发给浏览器了。但你<em>不想</em>为了适应开发环境中的设置，被迫修改应用代码中用到的所有图片和数据的路径。因此，你要往 <code>index.html</code> 中添加一个 <code>&lt;base&gt;</code> 标签，它将导致各种相对路径被解析回 <code>/app</code> 目录：</p>\n<code-example header=\"index.html\" path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"base\">\n&lt;base href=\"/app/\"&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cxapl4jruxphqy3wx9jj00t9h\">现在你可以通过 SystemJS 加载 Angular 了。你还要把 Angular 的腻子脚本（polyfills） 和 SystemJS 的配置加到 <code>&lt;head&gt;</code> 区的末尾，然后，你能就用 <code>System.import</code> 来加载实际的应用了：</p>\n<code-example header=\"index.html\" path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"angular\">\n&lt;script src=\"/node_modules/core-js/client/shim.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/node_modules/zone.js/bundles/zone.umd.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/node_modules/systemjs/dist/system.src.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/systemjs.config.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  System.import('/app');\n&lt;/script&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"90byeodd0wuoksdrsigkv4quy\">你还需要对<a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">升级的准备工作</a>期间安装的 <code>systemjs.config.js</code> 文件做一些调整。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tydf3xjf68uo1nq6b407l1tf\">在 SystemJS 加载期间为浏览器指出项目的根在哪里，而不再使用 <code>&lt;base&gt;</code> URL。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6q4opiw6p9n187nerfvhwgfel\">再通过 <code>npm install @angular/upgrade --save</code> 安装 <code>upgrade</code> 包，并为 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 包添加一个映射。</p>\n<code-example header=\"systemjs.config.js\" path=\"upgrade-phonecat-2-hybrid/systemjs.config.1.js\" region=\"paths\">\nSystem.config({\n  paths: {\n    // paths serve as alias\n    'npm:': '/node_modules/'\n  },\n  map: {\n    'ng-loader': '../src/systemjs-angular-loader.js',\n    app: '/app',\n    /* . . . */\n    '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/fesm2022/static.mjs',\n    /* . . . */\n  },\n\n</code-example>\n<h3 id=\"creating-the-appmodule\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"469dlpeyuq1s9enewj6axozt8\">创建 <code>AppModule</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#creating-the-appmodule\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6nakrshjt5804ywvv45eho0es\">现在，创建一个名叫 <code>AppModule</code> 的根 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 类。这里已经有了一个名叫 <code>app.module.ts</code> 的文件，其中存放着 AngularJS 的模块。把它改名为 <code>app.module.ajs.ts</code>，同时也要在 <code>index.html</code> 中修改对应的脚本名。文件的内容保留：</p>\n<code-example header=\"app.module.ajs.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ajs.ts\">\n// Define the `phonecatApp` AngularJS module\nangular.module('phonecatApp', [\n  'ngAnimate',\n  'ngRoute',\n  'core',\n  'phoneDetail',\n  'phoneList',\n]);\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6hq6eed001ay4uz4ecsq0wssw\">然后创建一个新的 <code>app.module.ts</code> 文件，其中是一个最小化的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 类：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"bare\">\nimport { <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a>, <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n}\n\n</code-example>\n<h3 id=\"bootstrapping-a-hybrid-phonecat\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2awdmccx8wycf3lj476w46epu\">引导 PhoneCat 的混合式应用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#bootstrapping-a-hybrid-phonecat\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3f4dzl2n1p3ig3hudtl5apelb\">接下来，你把该应用程序引导改装为一个同时支持 AngularJS 和 Angular 的<em>混合式应用</em>。然后，就能开始把这些不可分割的小块转换到 Angular 了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d78gmvmrk6hqyx3idwqss7014\">本应用现在是使用宿主页面中附加到 <code>&lt;html&gt;</code> 元素上的 AngularJS 指令 <code>ng-app</code> 引导的。\n但在混合式应用中，不能再这么用了。你得用<a href=\"guide/upgrade#bootstrapping-hybrid-applications\" title=\"Bootstrapping hybrid applications - Upgrading from AngularJS to Angular | Angular\">ngUpgrade bootstrap</a>方法代替。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"p6ar52v34g9xut3h90c3165x\">首先，从 <code>index.html</code> 中移除 <code>ng-app</code>。然后在 <code>AppModule</code> 中导入 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，并改写它的 <code>ngDoBootstrap</code> 方法：</p>\n<code-example header=\"app/app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"upgrademodule\">\nimport { <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72wo20nl11el0ucbcghiknarp\">注意，你正在从内部的 <code>ngDoBootstrap</code> 中引导 AngularJS 模块。它的参数和你在手动引导 AngularJS 时传给 <code>angular.bootstrap</code> 的是一样的：应用的根元素，和所要加载的 AngularJS 1.x 模块的数组。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rfftlsl5g2yudge3qsf56zkw\">最后，在 <code>app/main.ts</code> 中引导这个 <code>AppModule</code>。该文件在 <code>systemjs.config.js</code> 中被配置为了应用的入口，所以它已经被加载进了浏览器中。</p>\n<code-example header=\"app/main.ts\" path=\"upgrade-phonecat-2-hybrid/app/main.ts\" region=\"bootstrap\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ce9501i91tdxo0s0fum64jwr3\">现在，你同时运行着 AngularJS 和 Angular。漂亮！不过你还没有运行什么实际的 Angular 组件，这就是接下来要做的。</p>\n<div class=\"callout is-helpful\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2s64pzx4yq6wzcs8nk5m6voy4\">为何要声明 *angular* 为*angular.IAngularStatic*？</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97jrr6i3f5sw0zqczo82f842a\"><code>@types/angular</code> 声明为 UMD 模块，根据 <a href=\"https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#support-for-umd-module-definitions\" title=\"Support for UMD module definitions - What's new in TypeScript | microsoft/TypeScript | GitHub\">UMD 类型</a>的工作方式，一旦你在文件中有一条 ES6 的 <code>import</code> 语句，所有的 UMD 类型化的模型必须都通过 <code>import</code> 语句导入，\n而是不是全局可用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4d56wxf4mc0j2yhj6plz44hwo\">AngularJS 是日前是通过 <code>index.html</code> 中的 script 标签加载，这意味着整个应用是作为一个全局变量进行访问的，使用同一个 <code>angular</code> 变量的实例。但如果你使用 <code>import * as angular from 'angular'</code>，我还需要彻底修改 AngularJS 应用中加载每个文件的方式，确保 AngularJS 应用被正确加载。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yl4niv5ctmkwe1ynihtcav49\">这需要相当多的努力，通常也不值得去做，特别是当你正在朝着 Angular 前进时。但如果你把 <code>angular</code> 声明为 <code>angular.IAngularStatic</code>，指明它是一个全局变量，仍然可以获得全面的类型支持。</p>\n<div class=\"callout is-important\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1m08pu4mhosi1m62xxlhb3d95\">为 Angular 应用手动创建 UMD 包</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csx6miwnmeic5oochhx3z4hzo\">从 Angular 版本 13 开始，<a href=\"https://github.com/angular/angular/issues/38366\" title=\" Issue 38366: RFC: Ivy Library Distribution| angular/angular | GitHub\">分发格式</a> 中不再包含 UMD 包。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bnw9atk8sz78yztvvxox8n3z3\">如果你的用例需要 UMD 格式，请使用 <a href=\"https://rollupjs.org\" title=\"rollup.js\"><code>rollup</code></a> 从平面 ES 模块文件手动生成包。</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b90gqrsxmg83aibnwbgkune2d\">使用 <code>npm</code> 全局安装 <code>rollup</code></p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm i -g rollup\n\n</code-example>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3kyky6bgqveb5o1evrl6zyaz\">输出 <code>rollup</code> 的版本并验证安装是否成功</p>\n<code-example format=\"shell\" language=\"shell\">\n\nrollup -v\n\n</code-example>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"21p7xxr55egwmnkpc9wzapzzr\">为 <code>rollup</code> 创建 <code>rollup.config.js</code> 配置文件，以使用全局 <code>ng</code> 命令来引用所有 Angular 框架的导出。</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9kvbju62jsj6z07y3k69w9fjm\">创建一个名为 <code>rollup.config.js</code> 的文件</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cl2da77k4m8632nzx7uxqwqrb\">将以下内容复制到 <code>rollup.config.js</code></p>\n<code-example language=\"javascript\">\n\nexport default {\n  input: 'node_modules/@angular/core/fesm2022/core.js',\n  output: {\n    file: 'bundle.js',\n    format: 'umd',\n    name: 'ng'\n  }\n}\n\n</code-example>\n</li>\n</ol>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ks4f1sfuri6j332x3yasaoku\">使用 <code>rollup</code> 根据 <code>rollup.config.js</code> 中的设置创建 <code>bundle.js</code> UMD 包</p>\n<code-example format=\"shell\" language=\"shell\">\n\nrollup -c rollup.config.js\n\n</code-example>\n</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"70xs4f71yfttn1ezsnezf1poc\"><code>bundle.js</code> 文件包含你的 UMD 包。有关 GitHub 上的示例，请参阅 <a href=\"https://github.com/mgechev/angular-umd-bundle\" title=\"UMD Angular bundle | mgechev/angular-umd-bundle | GitHub\">UMD Angular 包</a>。</p>\n</div>\n</div>\n<h3 id=\"upgrading-the-phone-service\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8dwv6wzkogntbiizz3iy6r02h\">升级 <code>Phone</code> 服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-the-phone-service\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bb8zjh3ihgd3ryrzxivrflkmj\">你要移植到 Angular 的第一个片段是 <code>Phone</code> 工厂（位于 <code>app/core/phone/phone.service.ts</code>），并且让它能帮助控制器从服务器上加载电话信息。目前，它是用 <code>ngResource</code> 实现的，你用它做两件事：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1bnep086agjgdsolz9q8qx659\">把所有电话的列表加载到电话列表组件中。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9o8vss9x06gjrlrzwsrtehl2q\">把一台电话的详情加载到电话详情组件中。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8tahqa9az6udjv06xqc4sobcq\">你可以用 Angular 的服务类来替换这个实现，而把控制器继续留在 AngularJS 的地盘上。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cjuqfdrr5q9dys55rlyl96omi\">在这个新版本中，你导入了 Angular 的 HTTP 模块，并且用它的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务替换掉 <code>ngResource</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bgi4hc3lct6uy2vjszcrjzqjv\">再次打开 <code>app.module.ts</code> 文件，导入并把 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> 添加到 <code>AppModule</code> 的 <code>imports</code> 数组中：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"httpclientmodule\">\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5yhiio0dvfrc9t8whdrylpkq\">现在，你已经准备好了升级 <code>Phone</code> 服务本身。你将为 <code>phone.service.ts</code> 文件中基于 ngResource 的服务加上 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 装饰器：</p>\n<code-example header=\"app/core/phone/phone.service.ts (skeleton)\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"classdef\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n/* . . . */\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"88svncqrhn4o4egnrjplmn9fi\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 装饰器将把一些依赖注入相关的元数据附加到该类上，让 Angular 知道它的依赖信息。\n就像在<a href=\"guide/dependency-injection\" title=\"Dependency injection in Angular | Angular\">依赖注入指南</a>中描述过的那样，\n这是一个令牌装饰器，你要把它用在那些没有其它 Angular 装饰器，并且自己有依赖注入的类上。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54mm97s6rtuph8fnpd094rocu\">在它的构造函数中，该类期待一个 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务。<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务将被注入进来并存入一个私有字段。然后该服务在两个实例方法中被使用到，一个加载所有电话的列表，另一个加载一台指定电话的详情：</p>\n<code-example header=\"app/core/phone/phone.service.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"fullclass\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&lt;PhoneData[]&gt; {\n    return this.http.get&lt;PhoneData[]&gt;(`phones/phones.json`);\n  }\n  get(id: string): Observable&lt;PhoneData&gt; {\n    return this.http.get&lt;PhoneData&gt;(`phones/${id}.json`);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6gc81sexl9g8e4taez6q8ay3t\">该方法现在返回一个 <code>Phone</code> 类型或 <code>Phone[]</code> 类型的可观察对象（Observable）。这是一个你从未用过的类型，因此你得为它新增一个简单的接口：</p>\n<code-example header=\"app/core/phone/phone.service.ts (interface)\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"phonedata-interface\">\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"564avzesdda7knej1nga4u1x4\"><code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 有一个 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a></code> 方法，可以使 Angular 服务在 AngularJS 的代码中可用。使用它来插入 <code>Phone</code> 服务：</p>\n<code-example header=\"app/core/phone/phone.service.ts (downgrade)\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"downgrade-injectable\">\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n/* . . . */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n/* . . . */\n}\n\nangular.module('core.phone')\n  .factory('phone', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Phone));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ezjlctbd17iq9m0wa0f6bn95c\">最终，该类的全部代码如下：</p>\n<code-example header=\"app/core/phone/phone.service.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\nimport { Observable } from 'rxjs';\n\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&lt;PhoneData[]&gt; {\n    return this.http.get&lt;PhoneData[]&gt;(`phones/phones.json`);\n  }\n  get(id: string): Observable&lt;PhoneData&gt; {\n    return this.http.get&lt;PhoneData&gt;(`phones/${id}.json`);\n  }\n}\n\nangular.module('core.phone')\n  .factory('phone', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Phone));\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1kmlwy4h0ft65g8g2zzurhlat\">注意，你要单独导入了 RxJS <code>Observable</code> 中的 <code>map</code> 操作符。对每个 RxJS 操作符都要这么做。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3o5scof4ez9sei71np2sifya\">这个新的 <code>Phone</code> 服务具有和老的基于 <code>ngResource</code> 的服务相同的特性。因为它是 Angular 服务，你通过 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>providers</code> 数组来注册它：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phone\">\nimport { Phone } from './core/phone/phone.service';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  ],\n  providers: [\n    Phone,\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"v6zov4dhnyvefctiivtpeneo\">现在，你正在用 SystemJS 加载 <code>phone.service.ts</code>，你应该从 <code>index.html</code> 中<strong>移除该服务的 <code>&lt;script&gt;</code> 标签</strong>。这也是你在升级所有组件时将会做的事。在从 AngularJS 向 Angular 升级的同时，你也把代码从脚本移植为模块。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dw7blgy07goadymyx8pz0c6tp\">这时，你可以把两个控制器从使用老的服务切换成使用新的。你像降级过的 <code>phone</code> 工厂一样 <code>$inject</code> 它，但它实际上是一个 <code>Phone</code> 类的实例，并且你可以据此注解它的类型：</p>\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ajs.ts\">\ndeclare const angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass PhoneListController {\n  phones: PhoneData[];\n  orderProp: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['phone'];\n  constructor(phone: Phone) {\n    phone.query().subscribe(phones =&gt; {\n      this.phones = phones;\n    });\n    this.orderProp = 'age';\n  }\n\n}\n\nangular.\n  module('phoneList').\n  component('phoneList', {\n    templateUrl: 'app/phone-list/phone-list.template.html',\n    controller: PhoneListController\n  });\n\n\n</code-example>\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ajs.ts\">\ndeclare const angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass PhoneDetailController {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['$routeParams', 'phone'];\n  constructor($routeParams: angular.route.IRouteParamsService, phone: Phone) {\n    const phoneId = $routeParams.phoneId;\n    phone.get(phoneId).subscribe(data =&gt; {\n      this.phone = data;\n      this.setImage(data.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module('phoneDetail').\n  component('phoneDetail', {\n    templateUrl: 'phone-detail/phone-detail.template.html',\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"djowhshpdcqrxacv88lgl9mpu\">这里的两个 AngularJS 控制器在使用 Angular 的服务！控制器不需要关心这一点，尽管实际上该服务返回的是可观察对象（Observable），而不是承诺（Promise）。无论如何，你达到的效果都是把服务移植到 Angular，而不用被迫移植组件来使用它。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bs58wj0w16zmufjo8o0djxflr\">你也能使用 <code>Observable</code> 的 <code>toPromise</code> 方法来在服务中把这些可观察对象转变成 Promise，以进一步减小组件控制器中需要修改的代码量。</p>\n</div>\n<h3 id=\"upgrading-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"49fjbai69f41uyxcqaza9kbx5\">升级组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-components\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b6hz0l55mmjt68q0h7tjuyc6p\">接下来，把 AngularJS 的控制器升级成 Angular 的组件。每次升级一个，同时仍然保持应用运行在混合模式下。在做转换的同时，你还将自定义首个 Angular<em>管道</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ewfmjahuxa3wdbn2pcggjyjj4\">先看看电话列表组件。它目前包含一个 TypeScript 控制器类和一个组件定义对象。重命名控制器类，并把 AngularJS 的组件定义对象更换为 Angular <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 装饰器，这样你就把它变形为 Angular 的组件了。然后，你还要从类中移除静态 <code>$inject</code> 属性。</p>\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"initialclass\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-list',\n  templateUrl: './phone-list.template.html'\n})\nexport class PhoneListComponent {\n  phones: PhoneData[];\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: string;\n  orderProp: string;\n\n  constructor(phone: Phone) {\n    phone.query().subscribe(phones =&gt; {\n      this.phones = phones;\n    });\n    this.orderProp = 'age';\n  }\n  /* . . . */\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"boefxua4y21by9dx1r7aiya3\"><code>selector</code> 属性是一个 CSS 选择器，用来定义组件应该被放在页面的哪。在 AngularJS 中，你会基于组件名字来匹配，但是在 Angular 中，你要显式指定这些选择器。本组件将会对应元素名字 <code>phone-list</code>，和 AngularJS 版本一样。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"as8s215nb45za8ty1xxg7t2rr\">现在，将组件的模版也转换为 Angular 语法。在搜索控件中，把 AngularJS 的 <code>$ctrl</code> 表达式替换成 Angular 的双向绑定语法 <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code>：</p>\n<code-example header=\"app/phone-list/phone-list.template.html (search controls)\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"controls\">\n&lt;p&gt;\n  Search:\n  &lt;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"<a href=\"api/animations/query\" class=\"code-anchor\">query</a>\" /&gt;\n&lt;/p&gt;\n\n&lt;p&gt;\n  Sort by:\n  &lt;select [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"orderProp\"&gt;\n    &lt;option value=\"name\"&gt;Alphabetical&lt;/option&gt;\n    &lt;option value=\"age\"&gt;Newest&lt;/option&gt;\n  &lt;/select&gt;\n&lt;/p&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ke84bi3ws3dn8ir4lc7s2z06\">把列表中的 <code>ng-repeat</code> 替换为 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>，\n就像<a href=\"guide/built-in-directives\" title=\"Built-in directives | Angular\">模板语法指南</a>中所讲的那样。\n再把 <code><a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a></code> 标签的 <code>ng-src</code> 替换为一个标准的 <code>src</code> 属性（property）绑定。</p>\n<code-example header=\"app/phone-list/phone-list.template.html (phones)\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"list\">\n&lt;ul class=\"phones\"&gt;\n  &lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let phone of getPhones()\"\n      class=\"thumbnail phone-list-item\"&gt;\n    &lt;a href=\"/#!/phones/{{phone.id}}\" class=\"thumb\"&gt;\n      &lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"phone.imageUrl\" [alt]=\"phone.name\" /&gt;\n    &lt;/a&gt;\n    &lt;a href=\"/#!/phones/{{phone.id}}\" class=\"name\"&gt;{{phone.name}}&lt;/a&gt;\n    &lt;p&gt;{{phone.snippet}}&lt;/p&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n</code-example>\n<h4 id=\"no-angular-filter-or-orderby-filters\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7qwi6syagr7qggn8es3zjzv3s\">没有 Angular <code>filter</code> 或 <code>orderBy</code> 过滤器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#no-angular-filter-or-orderby-filters\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71c20fl7jmratkpjlmlu536gw\">Angular 中并不存在 AngularJS 中内置的 <code>filter</code> 和 <code>orderBy</code> 过滤器。所以你得自己实现进行过滤和排序。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xp322ta84gqzdy1iglxqjt1\">你把 <code>filter</code> 和 <code>orderBy</code> 过滤器改成绑定到控制器中的 <code>getPhones()</code> 方法，通过该方法，组件本身实现了过滤和排序逻辑。</p>\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"getphones\">\ngetPhones(): PhoneData[] {\n  return this.sortPhones(this.filterPhones(this.phones));\n}\n\nprivate filterPhones(phones: PhoneData[]) {\n  if (phones &amp;&amp; this.query) {\n    return phones.filter(phone =&gt; {\n      const name = phone.name.toLowerCase();\n      const snippet = phone.snippet.toLowerCase();\n      return name.indexOf(this.query) &gt;= 0 || snippet.indexOf(this.query) &gt;= 0;\n    });\n  }\n  return phones;\n}\n\nprivate sortPhones(phones: PhoneData[]) {\n  if (phones &amp;&amp; this.orderProp) {\n    return phones\n      .slice(0) // Make a copy\n      .sort((a, b) =&gt; {\n        if (a[this.orderProp] &lt; b[this.orderProp]) {\n          return -1;\n        } else if ([b[this.orderProp] &lt; a[this.orderProp]]) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n  }\n  return phones;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2hfo0a7cyb9ekgdnt3fxbwgz7\">现在你需要降级你的 Angular 组件，这样你就可以在 AngularJS 中使用它了。你要注册一个 <code>phoneList</code><em>指令</em>，而不是注册一个组件，它是一个降级版的 Angular 组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"42vv9738x8q8b2zmmhawiy2xv\">强制类型转换 <code>as angular.IDirectiveFactory</code> 告诉 TypeScript 编译器 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a></code> 方法 的返回值是一个指令工厂。</p>\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"downgrade-component\">\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n/* . . . */\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-list',\n  templateUrl: './phone-list.template.html'\n})\nexport class PhoneListComponent {\n  /* . . . */\n}\n\nangular.module('phoneList')\n  .directive(\n    'phoneList',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({component: PhoneListComponent}) as angular.IDirectiveFactory\n  );\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bxqzs0jmvez75zd02earpftkk\">新的 <code>PhoneListComponent</code> 使用 Angular 的 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 指令，它位于 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 中。把 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 添加到 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>imports</code> 中，并声明新的 <code>PhoneListComponent</code> 组件，因为你降级了它：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonelist\">\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eu8c66u4bgg4sq6ctob87uflx\">从 <code>index.html</code> 中移除电话列表组件的&lt;script&gt;标签。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2elcpviv35bin548l5jn1nup\">现在，剩下的 <code>phone-detail.component.ts</code> 文件变成了这样：</p>\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ts\">\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { Phone, PhoneData } from '../core/phone/phone.service';\nimport { RouteParams } from '../ajs-upgraded-providers';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-detail',\n  templateUrl: './phone-detail.template.html',\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(routeParams: RouteParams, phone: Phone) {\n    phone.get(routeParams.phoneId).subscribe(data =&gt; {\n      this.phone = data;\n      this.setImage(data.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.module('phoneDetail')\n  .directive(\n    'phoneDetail',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({component: PhoneDetailComponent}) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cajspvqvv7t28qdw3lp7ni2d0\">这和电话列表组件很相似。这里的窍门在于 <code>RouteParams</code> 类型装饰器，它标记出了 <code>routeParams</code> 依赖项。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"45l1dxv4rx1lkpmkcv29bigo1\">AngularJS 注入器具有 AngularJS 路由器的依赖，叫做 <code>$routeParams</code>。它被注入到了 <code>PhoneDetails</code> 中，但 <code>PhoneDetails</code> 现在还是一个 AngularJS 控制器。你要把它注入到新的 <code>PhoneDetailsComponent</code> 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"syvi3kgjs3jd6e619k69rye6\">不幸的是，AngularJS 的依赖不会自动在 Angular 的组件中可用。\n你必须使用<a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\" title=\"Making AngularJS Dependencies Injectable to Angular - Upgrading from AngularJS to Angular | Angular\">工厂提供者（factory provider）</a>\n来把 <code>$routeParams</code> 包装成 Angular 的服务提供者。\n新建一个名叫 <code>ajs-upgraded-providers.ts</code> 的文件，并且在 <code>app.module.ts</code> 中导入它：</p>\n<code-example header=\"app/ajs-upgraded-providers.ts\" path=\"upgrade-phonecat-2-hybrid/app/ajs-upgraded-providers.ts\">\nexport abstract class RouteParams {\n  [key: string]: string;\n}\n\nexport function routeParamsFactory(i: any) {\n  return i.get('$routeParams');\n}\n\nexport const routeParamsProvider = {\n  provide: RouteParams,\n  useFactory: routeParamsFactory,\n  deps: ['$injector']\n};\n\n\n</code-example>\n<code-example header=\"app/app.module.ts ($routeParams)\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"routeparams\">\nimport { routeParamsProvider } from './ajs-upgraded-providers';\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aky4ddqt0935pmfz1nj4ht3v5\">把该组件的模板转变成 Angular 的语法，代码如下：</p>\n<code-example header=\"app/phone-detail/phone-detail.template.html\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.template.html\">\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"phone\"&gt;\n  &lt;div class=\"phone-images\"&gt;\n    &lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>\" class=\"phone\" alt=\"Phone {{ phone.name }} - thumbnail {{ index }}\"\n        [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"{'selected': <a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> === mainImageUrl}\"\n        *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> of phone.images; let index = index;\" /&gt;\n  &lt;/div&gt;\n\n  &lt;h1&gt;{{phone.name}}&lt;/h1&gt;\n\n  &lt;p&gt;{{phone.description}}&lt;/p&gt;\n\n  &lt;ul class=\"phone-thumbs\"&gt;\n    &lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> of phone.images; let index = index\"&gt;\n      &lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>\" (click)=\"setImage(<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>)\" alt=\"Phone {{ phone.name }} - thumbnail {{ index }}\"/&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n\n  &lt;ul class=\"specs\"&gt;\n    &lt;li&gt;\n      &lt;span&gt;Availability and Networks&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Availability&lt;/dt&gt;\n        &lt;dd *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let availability of phone.availability\"&gt;{{availability}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Battery&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;<a href=\"api/core/Type\" class=\"code-anchor\">Type</a>&lt;/dt&gt;\n        &lt;dd&gt;{{phone.battery?.type}}&lt;/dd&gt;\n        &lt;dt&gt;Talk <a href=\"api/common/Time\" class=\"code-anchor\">Time</a>&lt;/dt&gt;\n        &lt;dd&gt;{{phone.battery?.talkTime}}&lt;/dd&gt;\n        &lt;dt&gt;Standby time (<a href=\"api/forms/MaxValidator\" class=\"code-anchor\">max</a>)&lt;/dt&gt;\n        &lt;dd&gt;{{phone.battery?.standbyTime}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Storage and Memory&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;RAM&lt;/dt&gt;\n        &lt;dd&gt;{{phone.storage?.ram}}&lt;/dd&gt;\n        &lt;dt&gt;Internal Storage&lt;/dt&gt;\n        &lt;dd&gt;{{phone.storage?.flash}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Connectivity&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Network Support&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.cell}}&lt;/dd&gt;\n        &lt;dt&gt;WiFi&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.wifi}}&lt;/dd&gt;\n        &lt;dt&gt;Bluetooth&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.bluetooth}}&lt;/dd&gt;\n        &lt;dt&gt;Infrared&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.infrared | checkmark}}&lt;/dd&gt;\n        &lt;dt&gt;GPS&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.gps | checkmark}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Android&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;OS <a href=\"api/core/Version\" class=\"code-anchor\">Version</a>&lt;/dt&gt;\n        &lt;dd&gt;{{phone.android?.os}}&lt;/dd&gt;\n        &lt;dt&gt;UI&lt;/dt&gt;\n        &lt;dd&gt;{{phone.android?.ui}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Size and Weight&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Dimensions&lt;/dt&gt;\n        &lt;dd *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let dim of phone.sizeAndWeight?.dimensions\"&gt;{{dim}}&lt;/dd&gt;\n        &lt;dt&gt;Weight&lt;/dt&gt;\n        &lt;dd&gt;{{phone.sizeAndWeight?.weight}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Display&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Screen size&lt;/dt&gt;\n        &lt;dd&gt;{{phone.display?.screenSize}}&lt;/dd&gt;\n        &lt;dt&gt;Screen resolution&lt;/dt&gt;\n        &lt;dd&gt;{{phone.display?.screenResolution}}&lt;/dd&gt;\n        &lt;dt&gt;Touch screen&lt;/dt&gt;\n        &lt;dd&gt;{{phone.display?.touchScreen | checkmark}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Hardware&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;CPU&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.cpu}}&lt;/dd&gt;\n        &lt;dt&gt;USB&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.usb}}&lt;/dd&gt;\n        &lt;dt&gt;Audio / headphone jack&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.audioJack}}&lt;/dd&gt;\n        &lt;dt&gt;FM Radio&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.fmRadio | checkmark}}&lt;/dd&gt;\n        &lt;dt&gt;Accelerometer&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.accelerometer | checkmark}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Camera&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Primary&lt;/dt&gt;\n        &lt;dd&gt;{{phone.camera?.primary}}&lt;/dd&gt;\n        &lt;dt&gt;Features&lt;/dt&gt;\n        &lt;dd&gt;{{phone.camera?.features?.join(', ')}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Additional Features&lt;/span&gt;\n      &lt;dd&gt;{{phone.additionalFeatures}}&lt;/dd&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehvhpgahgo3tuvd7nt5ezzsh4\">这里有几个值得注意的改动：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74evo0ecswxqqbngpi9ii8q2i\">你从所有表达式中移除了 <code>$ctrl.</code> 前缀。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7k0miua6q9omg17j20fftq2ri\">正如你在电话列表中做过的那样，你把 <code>ng-src</code> 替换成了标准的 <code>src</code> 属性绑定。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"605pyhzdmxpdpqs03uftxifyy\">你在 <code>ng-class</code> 周围使用了属性绑定语法。虽然 Angular 中有一个\n和 AngularJS 中<a href=\"guide/built-in-directives\" title=\"Built-in directives | Angular\">非常相似的 <code>ngClass</code></a>指令，\n但是它的值不会神奇的作为表达式进行计算。在 Angular 中，模板中的属性（Attribute）值总是被作为\n属性（Property）表达式计算，而不是作为字符串字面量。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f1ry2qy7liozemnutbub7md2x\">你把 <code>ng-repeat</code> 替换成了 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code></p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"463w4xn7vydffd0548irsdbgf\">你把 <code>ng-click</code> 替换成了一个到标准 <code>click</code> 事件的绑定</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8n5kiyo78xh1nhp2hwddnpl6c\">你把整个模板都包裹进了一个 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 中，这导致只有当存在一个电话时它才会渲染。你必须这么做，是因为组件首次加载时你还没有 <code>phone</code> 变量，这些表达式就会引用到一个不存在的值。和 AngularJS 不同，当你尝试引用未定义对象上的属性时，Angular 中的表达式不会默默失败。你必须明确指出这种情况是你所期望的。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a2mczjtzdyltng45w8rgthxrx\">把 <code>PhoneDetailComponent</code> 组件添加到 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <em>declarations</em> 中：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonedetail\">\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ejcwliit5ln8ky1zxdke1ae1e\">你现在应该从 <code>index.html</code> 中移除电话详情组件的&lt;script&gt;。</p>\n<h4 id=\"add-the-checkmarkpipe\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8p7n1d41pj804mb8uw90l1k4l\">添加 <em>CheckmarkPipe</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#add-the-checkmarkpipe\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bzy26ijw6q3f4ci86428jpw7f\">AngularJS 指令中有一个 <code>checkmark</code><em>过滤器</em>，把它转换成 Angular 的<strong>管道</strong>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4a3nn65as5ou22prxukvo71dn\">没有什么升级方法能把过滤器转换成管道。但你也并不需要它。把过滤器函数转换成等价的 Pipe 类非常简单。实现方式和以前一样，但把它们包装进 <code>transform</code> 方法中就可以了。把该文件改名成 <code>checkmark.pipe.ts</code>，以符合 Angular 中的命名约定：</p>\n<code-example header=\"app/core/checkmark/checkmark.pipe.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.ts\">\nimport { <a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>, <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> } from '@angular/core';\n\n@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({name: 'checkmark'})\nexport class CheckmarkPipe implements <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> {\n  transform(input: boolean) {\n    return input ? '\\u2713' : '\\u2718';\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cxdq0oyapm7rc0fffdp4tij15\">现在，导入并声明这个新创建的管道，同时从 <code>index.html</code> 文件中移除该过滤器的 <code>&lt;script&gt;</code> 标签：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"checkmarkpipe\">\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n    CheckmarkPipe\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<h3 id=\"aot-compile-the-hybrid-app\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3rivxl7jm3kfk3xcs8hitoj59\">对混合式应用做 AOT 编译<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#aot-compile-the-hybrid-app\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dv29u1npx71bztg7dmrqicnvt\">要在混合式应用中使用 AOT 编译，你首先要像其它 Angular 应用一样设置它，就像<a href=\"guide/aot-compiler\" title=\"Ahead-of-time (AOT) compilation | Angular\">AOT 编译一章</a>所讲的那样。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9qby0dyp89zql55jpirlvgm03\">然后修改 <code>main-aot.ts</code> 的引导代码，来引导 AOT 编译器所生成的 <code>AppComponentFactory</code>：</p>\n<code-example header=\"app/main-aot.ts\" path=\"upgrade-phonecat-2-hybrid/app/main-aot.ts\">\nimport { <a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a> } from '@angular/platform-browser';\n\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>().bootstrapModule(AppModule);\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cwmaohvfwctg03k21nzusaciz\">你还要把在 <code>index.html</code> 中已经用到的所有 AngularJS 文件加载到 <code>aot/index.html</code> 中：</p>\n<code-example header=\"aot/index.html\" path=\"upgrade-phonecat-2-hybrid/aot/index.html\">\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n\n    &lt;base href=\"/app/\"&gt;\n\n    &lt;title&gt;Google Phone Gallery&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" /&gt;\n    &lt;link rel=\"stylesheet\" href=\"app.css\" /&gt;\n    &lt;link rel=\"stylesheet\" href=\"app.animations.css\" /&gt;\n\n    &lt;script src=\"https://code.jquery.com/jquery-2.2.4.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://code.angularjs.org/1.5.5/angular.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://code.angularjs.org/1.5.5/angular-animate.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://code.angularjs.org/1.5.5/angular-resource.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://code.angularjs.org/1.5.5/angular-route.js\"&gt;&lt;/script&gt;\n\n    &lt;script src=\"app.module.ajs.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"app.config.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"app.animations.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"core/core.module.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"core/phone/phone.module.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"phone-list/phone-list.module.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"phone-detail/phone-detail.module.js\"&gt;&lt;/script&gt;\n\n    &lt;script src=\"/node_modules/core-js/client/shim.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"/node_modules/zone.js/bundles/zone.umd.min.js\"&gt;&lt;/script&gt;\n\n    &lt;script&gt;window.module = 'aot';&lt;/script&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;div class=\"view-container\"&gt;\n      &lt;div ng-view class=\"view-frame\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n  &lt;script src=\"/dist/build.js\"&gt;&lt;/script&gt;\n&lt;/html&gt;\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6nrt47wz4ijl6osls4i145q1\">这些文件要带着相应的腻子脚本复制到一起。应用运行时需要的文件，比如电话列表 <code>.json</code> 和图片，也需要复制过去。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aujydlvixig2w4v4y98qahk3d\">通过 <code>npm install fs-extra --save-dev</code> 安装 <code>fs-extra</code> 可以更好的复制文件，并且把 <code>copy-dist-files.js</code> 文件改成这样：</p>\n<code-example header=\"copy-dist-files.js\" path=\"upgrade-phonecat-2-hybrid/copy-dist-files.js\">\nvar fsExtra = require('fs-extra');\nvar resources = [\n  // polyfills\n  'node_modules/core-js/client/shim.min.js',\n  'node_modules/zone.js/bundles/zone.umd.min.js',\n  // css\n  'app/app.css',\n  'app/app.animations.css',\n  // images and json files\n  'app/<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>/',\n  'app/phones/',\n  // app files\n  'app/app.module.ajs.js',\n  'app/app.config.js',\n  'app/app.animations.js',\n  'app/core/core.module.js',\n  'app/core/phone/phone.module.js',\n  'app/phone-list/phone-list.module.js',\n  'app/phone-detail/phone-detail.module.js'\n];\nresources.map(function(sourcePath) {\n  // Need to rename zone.umd.min.js to zone.min.js\n  var destPath = `aot/${sourcePath}`.replace('.umd.min.js', '.min.js');\n  fsExtra.copySync(sourcePath, destPath);\n});\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2y7kzp6aqz6ml4jcmuuiy9exd\">这就是想要在升级应用期间 AOT 编译所需的一切！</p>\n<h3 id=\"adding-the-angular-router-and-bootstrap\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"89sjoxfppumsw0kot19e7a2u0\">添加 Angular 路由器和引导程序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#adding-the-angular-router-and-bootstrap\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5weqn7yv0o9f88ds7ljm7ztoq\">此刻，你已经把所有 AngularJS 的组件替换成了它们在 Angular 中的等价物，不过你仍然在 AngularJS 路由器中使用它们。</p>\n<h4 id=\"add-the-angular-router\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8i5lngpd5rud5ku9p1s6e8r6c\">添加 Angular 路由器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#add-the-angular-router\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7y3jnslffhhymit10e0ndumjt\">Angular 有一个<a href=\"guide/router\" title=\"Common Routing Tasks | Angular\">全新的路由器</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"av17j8f5alk0a7ddjxc8xhhmx\">像所有的路由器一样，它需要在 UI 中指定一个位置来显示路由的视图。在 Angular 中，它是 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>，并位于应用组件树顶部的<em>根组件</em>中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"33w1nja6m3ua0wb0q1ocrp4u4\">你还没有这样一个根组件，因为该应用仍然是像一个 AngularJS 应用那样被管理的。创建新的 <code>app.component.ts</code> 文件，放入像这样的 <code>AppComponent</code> 类：</p>\n<code-example header=\"app/app.component.ts\" path=\"upgrade-phonecat-3-final/app/app.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phonecat-app',\n  template: '&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;'\n})\nexport class AppComponent { }\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8j8z8pqe1rp8jff85wk420zvs\">它有一个很简单的模板，只包含 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>。该组件只负责渲染活动路由的内容，此外啥也不干。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56aszszfco0y146j05p5wta53\">该选择器告诉 Angular：当应用启动时就把这个根组件插入到宿主页面的 <code>&lt;phonecat-app&gt;</code> 元素中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekx0zqvhwwqfxur5lxwzclyzy\">把这个 <code>&lt;phonecat-app&gt;</code> 元素插入到 <code>index.html</code> 中。用它来代替 AngularJS 中的 <code>ng-view</code> 指令：</p>\n<code-example header=\"index.html (body)\" path=\"upgrade-phonecat-3-final/index.html\" region=\"appcomponent\">\n&lt;body&gt;\n  &lt;phonecat-app&gt;&lt;/phonecat-app&gt;\n&lt;/body&gt;\n\n</code-example>\n<h4 id=\"create-the-routing-module\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4dhtn2vvbhja2vzgccu18a8da\">创建<em>路由模块</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-the-routing-module\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wf4ks68f4bbi6xpi0v4lo3ef\">无论在 AngularJS 还是 Angular 或其它框架中，路由器都需要进行配置。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4yltjwkonpcvkxpz23rwvghdc\">Angular 路由器配置的详情最好去查阅下<a href=\"guide/router\" title=\"Common Routing Tasks | Angular\">路由与导航</a>文档。\n它建议你创建一个专们用于路由器配置的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>（名叫<em>路由模块</em>）。</p>\n<code-example header=\"app/app-routing.module.ts\" path=\"upgrade-phonecat-3-final/app/app-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router';\nimport { <a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a>, <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a>, <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a> } from '@angular/common';\n\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: '', redirectTo: 'phones', pathMatch: 'full' },\n  { path: 'phones',          component: PhoneListComponent },\n  { path: 'phones/:phoneId', component: PhoneDetailComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ RouterModule.forRoot(routes) ],\n  exports: [ <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> ],\n  providers: [\n    { provide: <a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a>, useValue: '!' },\n    { provide: <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a>, useClass: <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a> },\n  ]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37tmswd4p1n1gwnf7z1ffc08p\">该模块定义了一个 <code>routes</code> 对象，它带有两个路由，分别指向两个电话组件，以及为空路径指定的默认路由。它把 <code>routes</code> 传给 <code>RouterModule.forRoot</code> 方法，该方法会完成剩下的事。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1kreqg5n60clgs2egxfuuvs8o\">一些额外的提供者让路由器使用“hash”策略解析 URL，比如 <code>#!/phones</code>，而不是默认的“Push State”策略。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"djnovvy5nx5zq09tpk2p7kcv7\">现在，修改 <code>AppModule</code>，让它导入这个 <code>AppRoutingModule</code>，并同时声明根组件 <code>AppComponent</code>。这会告诉 Angular，它应该使用根组件 <code>AppComponent</code> 引导应用，并把它的视图插入到宿主页面中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ypfdsusoy7tyoqai2el8r7po\">你还要从 <code>app.module.ts</code> 中移除调用 <code>ngDoBootstrap()</code> 来引导 AngularJS 模块的代码，以及对 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 的导入代码。</p>\n<code-example header=\"app/app.module.ts\" path=\"upgrade-phonecat-3-final/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\nimport { Phone } from './core/phone/phone.service';\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"17raz9nvng13eiv51h5uo5vmj\">而且，由于你现在直接路由到 <code>PhoneListComponent</code> 和 <code>PhoneDetailComponent</code>，而不再使用带 <code>&lt;phone-list&gt;</code> 或 <code>&lt;phone-detail&gt;</code> 标签的路由模板，因此你同样不再需要它们的 Angular 选择器。</p>\n<h4 id=\"generate-links-for-each-phone\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5khpmh2kixb29568yuz4vzmgo\">为每个电话生成链接<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#generate-links-for-each-phone\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6wr6rawo96h965xu8ha5fgacn\">在电话列表中，你不用再被迫硬编码电话详情的链接了。你可以通过把每个电话的 <code>id</code> 绑定到 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 指令来生成它们了，该指令的构造函数会为 <code>PhoneDetailComponent</code> 生成正确的 URL：</p>\n<code-example header=\"app/phone-list/phone-list.template.html (list with links)\" path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.template.html\" region=\"list\">\n&lt;ul class=\"phones\"&gt;\n  &lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let phone of getPhones()\"\n      class=\"thumbnail phone-list-item\"&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/phones', phone.id]\" class=\"thumb\"&gt;\n      &lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"phone.imageUrl\" [alt]=\"phone.name\" /&gt;\n    &lt;/a&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/phones', phone.id]\" class=\"name\"&gt;{{phone.name}}&lt;/a&gt;\n    &lt;p&gt;{{phone.snippet}}&lt;/p&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eoz6phduhkzsf3912cukt6z1w\">要了解详情，请查看<a href=\"guide/router\">路由与导航</a>页。</p>\n</div>\n<h4 id=\"use-route-parameters\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a74h5g517am5ijlrhaeylo9ll\">使用路由参数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#use-route-parameters\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ddm96lu74vq2tj5uiir3r6dr\">Angular 路由器会传入不同的路由参数。改正 <code>PhoneDetail</code> 组件的构造函数，让它改用注入进来的 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 对象。从 <code>ActivatedRoute.snapshot.params</code> 中提取出 <code>phoneId</code>，并像以前一样获取手机的数据：</p>\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-detail',\n  templateUrl: './phone-detail.template.html'\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(activatedRoute: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, phone: Phone) {\n    phone.get(activatedRoute.snapshot.paramMap.get('phoneId'))\n      .subscribe((p: PhoneData) =&gt; {\n        this.phone = p;\n        this.setImage(p.images[0]);\n      });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bylv6mboeefk0bwumnfndvfjy\">你现在运行的就是纯正的 Angular 应用了！</p>\n<h3 id=\"say-goodbye-to-angularjs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jk30yicn3yf3ylvkhjl7qzr7\">再见，AngularJS！<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#say-goodbye-to-angularjs\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6n7eog71lop7isuokd17c00m1\">终于可以把辅助训练的轮子摘下来了！让你的应用作为一个纯粹、闪亮的 Angular 程序开始它的新生命吧。剩下的所有任务就是移除代码 —— 这当然是每个程序员最喜欢的任务！</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eglryhb40y0u563ik5q0axesg\">应用仍然以混合式应用的方式启动，然而这再也没有必要了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"87sqohtt0erx6k0g4vpdu2335\">把应用的引导（<code>bootstrap</code>）方式从 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 的改为 Angular 的。</p>\n<code-example header=\"main.ts\" path=\"upgrade-phonecat-3-final/app/main.ts\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1v6luafdwozmagc8ptbs6t9ct\">如果你还没有这么做，请从 <code>app.module.ts 删除所有 </code>UpgradeModule 的引用，\n以及所有用于 AngularJS 服务的<a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">工厂提供者（factory provider）</a>和 <code>app/ajs-upgraded-providers.ts</code> 文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cfn7uk4a7jjcqlvgr96o94g9u\">还要删除所有的 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> 或 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 以及与 AngularJS 相关的工厂或指令声明。</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-3-final/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\nimport { Phone } from './core/phone/phone.service';\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ajv18ltme7i0i0lsmatmhiev\">你还要完全移除了下列文件。它们是 AngularJS 的模块配置文件和类型定义文件，在 Angular 中不需要了：</p>\n<ul>\n<li><code>app/app.module.ajs.ts</code></li>\n<li><code>app/app.config.ts</code></li>\n<li><code>app/core/core.module.ts</code></li>\n<li><code>app/core/phone/phone.module.ts</code></li>\n<li><code>app/phone-detail/phone-detail.module.ts</code></li>\n<li><code>app/phone-list/phone-list.module.ts</code></li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4amnphy488xz2xjx18uzy7d33\">还需要卸载 AngularJS 的外部类型定义文件。你现在只需要留下 Jasmine 和 Angular 所需的腻子脚本。<code>systemjs.config.js</code> 中的 <code>@angular/upgrade</code> 包及其映射也可以移除了。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm uninstall @angular/upgrade --save\nnpm uninstall @types/angular @types/angular-animate @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8t39g6gvnf3h18sbdch6eek8q\">最后，从 <code>index.html</code> 中，移除所有对 AngularJS 和 jQuery 脚本的引用。当这些全部做完时，<code>index.html</code> 应该是这样的：</p>\n<code-example header=\"index.html\" path=\"upgrade-phonecat-3-final/index.html\" region=\"full\">\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;base href=\"/app/\"&gt;\n    &lt;title&gt;Google Phone Gallery&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" /&gt;\n    &lt;link rel=\"stylesheet\" href=\"app.css\" /&gt;\n\n    &lt;script src=\"/node_modules/core-js/client/shim.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"/node_modules/zone.js/bundles/zone.umd.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"/node_modules/systemjs/dist/system.src.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"/systemjs.config.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n      System.import('/app');\n    &lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;phonecat-app&gt;&lt;/phonecat-app&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63gpn6l8xr8u5t084z04cbux\">这是你最后一次看到 AngularJS 了！它曾经带给你很多帮助，不过现在，该说再见了。</p>\n<h2 id=\"appendix-upgrading-phonecat-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"93h9q1ecby8g0mt62fnrvqz7b\">附录：升级 PhoneCat 的测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#appendix-upgrading-phonecat-tests\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7qllitjdbi3soumslqrdh80gs\">测试不仅要在升级过程中被保留，它还是确保应用在升级过程中不会被破坏的一个安全指示器。要达到这个目的，E2E 测试尤其有用。</p>\n<h3 id=\"e2e-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bycajx2kfk5kvivpigw6ictqp\">E2E 测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#e2e-tests\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6h2qbei12xhyqjhcp4c163flb\">PhoneCat 项目中同时有基于 Protractor 的 E2E 测试和一些基于 Karma 的单元测试。对这两者来说，E2E 测试的转换要容易得多：根据定义，E2E 测试通过与应用中显示的这些 UI 元素互动，从<em>外部</em>访问你的应用来进行测试。E2E 测试实际上并不关心这些应用中各部件的内部结构。这也意味着，虽然你已经修改了此应用程序，但是 E2E 测试套件仍然应该能像以前一样全部通过。因为从用户的角度来说，你并没有改变应用的行为。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4rip7ayw64b3o5lee3wp7sj1x\">在转成 TypeScript 期间，你不用做什么就能让 E2E 测试正常工作。但是当你想改成按照混合式应用进行引导时，必须做一些修改。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6cbvijdqcbdo70n568nc46a\">再对 <code>protractor-conf.js</code> 做下列修改，与混合应用同步：</p>\n<code-example language=\"javascript\">\n\nng12Hybrid: true\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qw0grfumnlz53n8qyotg4943\">当你开始组件和模块升级到 Angular 时，还需要一系列后续的修改。这是因为 E2E 测试有一些匹配器是 AngularJS 中特有的。对于 PhoneCat 来说，为了让它能在 Angular 下工作，你得做下列修改：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5l5yjt6u9p6x5rbra0kndg2p2\">以前的代码</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4g1ygklwijsosjbphu8fvwuxw\">新代码</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>by.repeater('phone in $ctrl.phones').column('phone.name')</code></td>\n<td align=\"left\"><code>by.css('.phones .name')</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72ymqgale68ksrzzic8xjua9s\">重复器匹配器依赖于 AngularJS 的 \n<code>ng-repeat</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.repeater('phone in $ctrl.phones')</code></td>\n<td align=\"left\"><code>by.css('.phones li')</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72ymqgale68ksrzzic8xjua9s\">重复器匹配器依赖于 AngularJS 的 \n<code>ng-repeat</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.model('$ctrl.query')</code></td>\n<td align=\"left\"><code>by.css('input')</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bi8kwrnur727udslng5e67st\">模型匹配器依赖于 AngularJS 的 \n<code>ng-model</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.model('$ctrl.orderProp')</code></td>\n<td align=\"left\"><code>by.css('select')</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bi8kwrnur727udslng5e67st\">模型匹配器依赖于 AngularJS 的 \n<code>ng-model</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.binding('$ctrl.phone.name')</code></td>\n<td align=\"left\"><code>by.css('h1')</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bxffalog0cu8l3uvcgwwdex61\">绑定匹配器依赖于 AngularJS 的数据绑定</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4s66p9s8srhvg7fco8pxfu3ra\">当引导方式从 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 切换到纯 Angular 的时，AngularJS 就从页面中完全消失了。此时，你需要告诉 Protractor，它不用再找 AngularJS 应用了，而是从页面中查找 <em>Angular</em> 应用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bznksfrw69zgjmv4xefjw7l0q\">替换之前在 <code>protractor-conf.js</code> 中加入 <code>ng12Hybrid</code>，象这样：</p>\n<code-example language=\"javascript\">\n\nuseAllAngular2AppRoots: true,\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3rxvpgpe8o5plgmkvk527kugq\">同样，<code>PhoneCat</code> 的测试代码中有两个 Protractor API 调用内部使用了 AngularJS 的 <code>$location</code>。该服务没有了，你就得把这些调用用一个 WebDriver 的通用 URL API 代替。第一个 API 是“重定向（redirect）”规约：</p>\n<code-example header=\"e2e-tests/scenarios.ts\" path=\"upgrade-phonecat-3-final/e2e-spec.ts\" region=\"redirect\">\nit('should redirect `index.html` to `index.html#!/phones', <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await browser.get('index.html');\n  await browser.waitForAngular();\n  const url = await browser.getCurrentUrl();\n  expect(url.endsWith('/phones')).toBe(true);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2nynk4xe9rh4py7ojuw68k6x\">然后是“电话链接（phone links）”规约：</p>\n<code-example header=\"e2e-tests/scenarios.ts\" path=\"upgrade-phonecat-3-final/e2e-spec.ts\" region=\"links\">\nit('should render phone specific links', <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  const <a href=\"api/animations/query\" class=\"code-anchor\">query</a> = element(by.css('input'));\n  await query.sendKeys('nexus');\n  await element.all(by.css('.phones li a')).first().click();\n  const url = await browser.getCurrentUrl();\n  expect(url.endsWith('/phones/nexus-s')).toBe(true);\n});\n\n</code-example>\n<h3 id=\"unit-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cphicttr9x4gr1yr1e8yq440r\">单元测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#unit-tests\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aakqoii9k6339qjclxmre4j42\">另一方面，对于单元测试来说，需要更多的转化工作。实际上，它们需要随着产品代码一起升级。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5uvz3opun4jsqy8a7qh8a2efm\">在转成 TypeScript 期间，严格来讲没有什么改动是必须的。但把单元测试代码转成 TypeScript 仍然是个好主意，。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3d39vng1wxycgeic8dgopheqx\">比如，在这个电话详情组件的规约中，你不仅用到了 ES2015 中的箭头函数和块作用域变量这些特性，还为所用的一些 AngularJS 服务提供了类型定义。</p>\n<code-example header=\"app/phone-detail/phone-detail.component.spec.ts\" path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.spec.ts\">\ndescribe('phoneDetail', () =&gt; {\n\n  // Load the module that contains the `phoneDetail` component before each test\n  beforeEach(angular.mock.module('phoneDetail'));\n\n  // Test the controller\n  describe('PhoneDetailController', () =&gt; {\n    let $httpBackend: angular.IHttpBackendService;\n    let ctrl: any;\n    const xyzPhoneData = {\n      name: 'phone xyz',\n      images: ['image/url1.png', 'image/url2.png']\n    };\n\n    beforeEach(inject(($componentController: any,\n                       _$httpBackend_: angular.IHttpBackendService,\n                       $routeParams: angular.route.IRouteParamsService) =&gt; {\n      $httpBackend = _$httpBackend_;\n      $httpBackend.expectGET('phones/xyz.json').respond(xyzPhoneData);\n\n      $routeParams.phoneId = 'xyz';\n\n      ctrl = $componentController('phoneDetail');\n    }));\n\n    it('should fetch the phone details', () =&gt; {\n      jasmine.addCustomEqualityTester(angular.equals);\n\n      expect(ctrl.phone).toEqual({});\n\n      $httpBackend.flush();\n      expect(ctrl.phone).toEqual(xyzPhoneData);\n    });\n\n  });\n\n});\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ei7eyemx9b1t3x63rvg14s9dj\">一旦你开始了升级过程并引入了 SystemJS，还需要对 Karma 进行配置修改。你需要让 SystemJS 加载所有的 Angular 新代码，</p>\n<code-example header=\"karma-test-shim.js\" path=\"upgrade-phonecat-2-hybrid/karma-test-shim.1.js\">\n// /*global jasmine, __karma__, window*/\nError.stackTraceLimit = 0; // \"No stacktrace\"\" is usually best for app testing.\n\n// Uncomment to get full stacktrace output. Sometimes helpful, usually not.\n// Error.stackTraceLimit = Infinity; //\n\njasmine.DEFAULT_TIMEOUT_INTERVAL = 1000;\n\nvar builtPath = '/base/app/';\n\n__karma__.loaded = function () { };\n\nfunction isJsFile(path) {\n  return path.slice(-3) == '.js';\n}\n\nfunction isSpecFile(path) {\n  return /\\.spec\\.(.*\\.)?js$/.test(path);\n}\n\nfunction isBuiltFile(path) {\n  return isJsFile(path) &amp;&amp; (path.slice(0, builtPath.length) == builtPath);\n}\n\nvar allSpecFiles = Object.keys(window.__karma__.files)\n  .filter(isSpecFile)\n  .filter(isBuiltFile);\n\nSystem.config({\n  baseURL: '/base',\n  // Extend usual application package list with test folder\n  packages: { 'testing': { main: 'index.js', defaultExtension: 'js' } },\n\n  // Assume npm: is set in `paths` in systemjs.config\n  // Map the angular testing bundles\n  map: {\n    '@angular/core/testing': 'npm:@angular/core/fesm2022/testing.mjs',\n    '@angular/common/testing': 'npm:@angular/common/fesm2022/testing.mjs',\n    '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing': 'npm:@angular/common/fesm2022/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing.mjs',\n    '@angular/platform-browser/testing': 'npm:@angular/platform-browser/fesm2022/testing.mjs',\n    '@angular/platform-browser-dynamic/testing': 'npm:@angular/platform-browser-dynamic/fesm2022/testing.mjs',\n    '@angular/router/testing': 'npm:@angular/router/fesm2022/testing.mjs',\n    '@angular/forms/testing': 'npm:@angular/forms/fesm2022/testing.mjs',\n  },\n});\n\nSystem.import('systemjs.config.js')\n  .then(importSystemJsExtras)\n  .then(initTestBed)\n  .then(initTesting);\n\n/** <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a> SystemJS configuration extras. Keep going w/o it */\nfunction importSystemJsExtras(){\n  return System.import('systemjs.config.extras.js')\n  .catch(function(reason) {\n    console.log(\n      'Warning: System.import could not load the optional \"systemjs.config.extras.js\". Did you omit it by accident? Continuing without it.'\n    );\n    console.log(reason);\n  });\n}\n\nfunction initTestBed() {\n  return Promise.all([\n    System.import('@angular/core/testing'),\n    System.import('@angular/platform-browser-dynamic/testing')\n  ])\n\n  .then(function (providers) {\n    var coreTesting    = providers[0];\n    var browserTesting = providers[1];\n\n    coreTesting.TestBed.initTestEnvironment(\n      browserTesting.BrowserDynamicTestingModule,\n      browserTesting.platformBrowserDynamicTesting());\n  })\n}\n\n// Import all spec files and start karma\nfunction initTesting() {\n  return Promise.all(\n    allSpecFiles.map(function (moduleName) {\n      return System.import(moduleName);\n    })\n  )\n  .then(__karma__.start, __karma__.error);\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3s9irvzi9wwzh63yyunmqhaiw\">这个 shim 文件首先加载了 SystemJS 的配置，然后是 Angular 的测试支持库，然后是应用本身的规约文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"lao1iqeglogizjq6zmzzcivx\">然后需要修改 Karma 配置，来让它使用本应用的根目录作为基础目录（base directory），而不是 <code>app</code>。</p>\n<code-example header=\"karma.conf.js\" path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"basepath\">\nbasePath: './',\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e1rq2jmok1ew7dmapoljwu103\">一旦这些完成了，你就能加载 SystemJS 和其它依赖，并切换配置文件来加载那些应用文件，而<em>不用</em>在 Karma 页面中包含它们。你要让这个 shim 文件和 SystemJS 去加载它们。</p>\n<code-example header=\"karma.conf.js\" path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"files\">\n// System.js for module loading\n'node_modules/systemjs/dist/system.src.js',\n\n// Polyfills\n'node_modules/core-js/client/shim.js',\n\n// zone.js\n'node_modules/zone.js/bundles/zone.umd.js',\n'node_modules/zone.js/bundles/zone-testing.umd.js',\n\n// RxJs.\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/rxjs/**/*.js', included: false, watched: false },\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/rxjs/**/*.js.map', included: false, watched: false },\n\n// Angular itself and the testing library\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/@angular/**/*.mjs', included: false, watched: false },\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/@angular/**/*.mjs.map', included: false, watched: false },\n\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/tslib/tslib.js', included: false, watched: false },\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/systemjs-plugin-babel/**/*.js', included: false, watched: false },\n\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'systemjs.config.js', included: false, watched: false},\n'karma-test-shim.js',\n\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/**/*.module.js', included: false, watched: true},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/*!(.module|.spec).js', included: false, watched: true},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/!(bower_components)/**/*!(.module|.spec).js', included: false, watched: true},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/**/*.spec.js', included: false, watched: true},\n\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: '**/*.html', included: false, watched: true},\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91hnjagujeutwkn8n11wjcvvz\">由于 Angular 组件中的 HTML 模板也同样要被加载，所以你得帮 Karma 一把，帮它在正确的路径下找到这些模板：</p>\n<code-example header=\"karma.conf.js\" path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"html\">\n// proxied base paths for loading assets\nproxies: {\n  // required for component assets fetched by Angular's compiler\n  '/phone-detail': '/base/app/phone-detail',\n  '/phone-list': '/base/app/phone-list'\n},\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2w4j5qntxkcjislenhnjzbj5n\">如果产品代码被切换到了 Angular，单元测试文件本身也需要切换过来。对勾（checkmark）管道的规约可能是最直观的，因为它没有任何依赖：</p>\n<code-example header=\"app/core/checkmark/checkmark.pipe.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.spec.ts\">\nimport { CheckmarkPipe } from './checkmark.pipe';\n\ndescribe('CheckmarkPipe', () =&gt; {\n\n  it('should convert boolean values to unicode checkmark or cross', () =&gt; {\n    const checkmarkPipe = new CheckmarkPipe();\n    expect(checkmarkPipe.transform(true)).toBe('\\u2713');\n    expect(checkmarkPipe.transform(false)).toBe('\\u2718');\n  });\n});\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8b078inmpyt28v6s5gt7tf20g\"><code>Phone</code> 服务的测试会牵扯到一点别的。你需要把模拟版的 AngularJS <code>$httpBackend</code> 服务切换到模拟板的 Angular Http 后端。</p>\n<code-example header=\"app/core/phone/phone.service.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.spec.ts\">\nimport { inject, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>, <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing';\nimport { Phone, PhoneData } from './phone.service';\n\ndescribe('Phone', () =&gt; {\n  let phone: Phone;\n  const phonesData: PhoneData[] = [\n    {name: 'Phone X', snippet: '', images: []},\n    {name: 'Phone Y', snippet: '', images: []},\n    {name: 'Phone Z', snippet: '', images: []}\n  ];\n  let httpMock: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>;\n\n  beforeEach(() =&gt; {\n    TestBed.configureTestingModule({\n      imports: [\n        <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>\n      ],\n      providers: [\n        Phone,\n      ]\n    });\n  });\n\n  beforeEach(inject([<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>, Phone], (_httpMock_: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>, _phone_: Phone) =&gt; {\n    httpMock = _httpMock_;\n    phone = _phone_;\n  }));\n\n  afterEach(() =&gt; {\n    httpMock.verify();\n  });\n\n  it('should fetch the phones data from `/phones/phones.json`', () =&gt; {\n    phone.query().subscribe(result =&gt; {\n      expect(result).toEqual(phonesData);\n    });\n    const req = httpMock.expectOne(`/phones/phones.json`);\n    req.flush(phonesData);\n  });\n\n});\n\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3vna7g85coqh4jhzhahg7439s\">对于组件的规约，你可以模拟出 <code>Phone</code> 服务本身，并且让它提供电话的数据。你可以对这些组件使用 Angular 的组件单元测试 API。</p>\n<code-example header=\"app/phone-detail/phone-detail.component.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.spec.ts\">\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\nimport { PhoneDetailComponent&nbsp;} from './phone-detail.component';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\nimport { CheckmarkPipe } from '../core/checkmark/checkmark.pipe';\n\nfunction xyzPhoneData(): PhoneData {\n  return {name: 'phone xyz', snippet: '', images: ['image/url1.png', 'image/url2.png']};\n}\n\nclass MockPhone {\n  get(id: string): Observable&lt;PhoneData&gt; {\n    return of(xyzPhoneData());\n  }\n}\n\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n\ndescribe('PhoneDetailComponent', () =&gt; {\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n    TestBed.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({ params: { phoneId: 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n  it('should fetch phone detail', () =&gt; {\n    const fixture = TestBed.createComponent(PhoneDetailComponent);\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('h1').textContent).toContain(xyzPhoneData().name);\n  });\n});\n\n\n</code-example>\n<code-example header=\"app/phone-list/phone-list.component.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.spec.ts\">\nimport {<a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>} from '@angular/common/testing';\nimport {<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>} from '@angular/core';\nimport {<a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>} from '@angular/core/testing';\nimport {<a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>} from '@angular/router';\nimport {Observable, of} from 'rxjs';\n\nimport {Phone, PhoneData} from '../core/phone/phone.service';\n\nimport {PhoneListComponent} from './phone-list.component';\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\nclass MockPhone {\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&lt;PhoneData[]&gt; {\n    return of([\n      {name: 'Nexus S', snippet: '', images: []}, {name: 'Motorola DROID', snippet: '', images: []}\n    ]);\n  }\n}\n\nlet fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&lt;PhoneListComponent&gt;;\n\ndescribe('PhoneList', () =&gt; {\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n        .configureTestingModule({\n          declarations: [PhoneListComponent],\n          providers: [\n            {provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({params: {phoneId: 1}})},\n            {provide: <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>, useClass: <a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>},\n            {provide: Phone, useClass: MockPhone},\n          ],\n          schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>]\n        })\n        .compileComponents();\n  }));\n\n  beforeEach(() =&gt; {\n    fixture = TestBed.createComponent(PhoneListComponent);\n  });\n\n  it('should create \"phones\" <a href=\"api/core/model\" class=\"code-anchor\">model</a> with 2 phones fetched from xhr', () =&gt; {\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelectorAll('.phone-list-item').length).toBe(2);\n    expect(compiled.querySelector('.phone-list-item:nth-child(1)').textContent)\n        .toContain('Motorola DROID');\n    expect(compiled.querySelector('.phone-list-item:nth-child(2)').textContent)\n        .toContain('Nexus S');\n  });\n\n  xit('should set the default value of orderProp <a href=\"api/core/model\" class=\"code-anchor\">model</a>', () =&gt; {\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('select option:last-child').selected).toBe(true);\n  });\n});\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7zm2le084hditznhlggdfrhae\">最后，当你切换到 Angular 路由时，需要重新过一遍这些组件测试。对详情组件来说，你需要提供一个 Angular <code>RouteParams</code> 的 mock 对象，而不再用 AngularJS 中的 <code>$routeParams</code>。</p>\n<code-example header=\"app/phone-detail/phone-detail.component.spec.ts\" path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.spec.ts\" region=\"activatedroute\">\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n/* . . . */\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n  /* . . . */\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n    TestBed.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({ params: { phoneId: 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vptpixkf8d42f8zpzg5uujkg\">对于电话列表组件，还要再做少量的调整，以便路由器能让 <code>RouteLink</code> 指令正常工作。</p>\n<code-example header=\"app/phone-list/phone-list.component.spec.ts\" path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.component.spec.ts\" region=\"routestuff\">\nimport {<a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>} from '@angular/common/testing';\nimport {<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>} from '@angular/core';\nimport {<a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>} from '@angular/core/testing';\nimport {<a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>} from '@angular/router';\nimport {Observable, of} from 'rxjs';\n\nimport {Phone, PhoneData} from '../core/phone/phone.service';\n\nimport {PhoneListComponent} from './phone-list.component';\n\n  /* . . . */\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n        .configureTestingModule({\n          declarations: [PhoneListComponent],\n          providers: [\n            {provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({params: {phoneId: 1}})},\n            {provide: <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>, useClass: <a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>},\n            {provide: Phone, useClass: MockPhone},\n          ],\n          schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>]\n        })\n        .compileComponents();\n  }));\n\n  beforeEach(() =&gt; {\n    fixture = TestBed.createComponent(PhoneListComponent);\n  });\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/common\n - api/common/upgrade\n - api/common/upgrade/$locationShim\n - api/common/upgrade/LocationUpgradeModule\n - api/upgrade/static/downgradeComponent\n - guide/deprecations\n - guide/releases\n - guide/updating\n - guide/upgrade-performance\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/APP_BASE_HREF\n - api/common/HashLocationStrategy\n - api/common/Location\n - api/common/LocationStrategy\n - api/common/NgClass\n - api/common/NgFor\n - api/common/NgIf\n - api/common/NgOptimizedImage\n - api/common/Time\n - api/common/http\n - api/common/http/HttpClient\n - api/common/http/HttpClientModule\n - api/common/http/testing/HttpClientTestingModule\n - api/common/http/testing/HttpTestingController\n - api/common/testing/SpyLocation\n - api/common/upgrade/$locationShim\n - api/common/upgrade/LocationUpgradeConfig\n - api/common/upgrade/LocationUpgradeModule\n - api/common/upgrade/LocationUpgradeModule#config\n - api/core/Component\n - api/core/Directive\n - api/core/DoBootstrap\n - api/core/ElementRef\n - api/core/EventEmitter\n - api/core/Injectable\n - api/core/Injector\n - api/core/Input\n - api/core/NO_ERRORS_SCHEMA\n - api/core/NgModule\n - api/core/NgZone\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - api/core/Optional\n - api/core/Output\n - api/core/Pipe\n - api/core/PipeTransform\n - api/core/SimpleChanges\n - api/core/Type\n - api/core/Version\n - api/core/model\n - api/core/ng-content\n - api/core/testing/ComponentFixture\n - api/core/testing/TestBed\n - api/core/testing/waitForAsync\n - api/forms/FormsModule\n - api/forms/MaxValidator\n - api/forms/NgModel\n - api/forms/PatternValidator\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/BrowserModule\n - api/platform-browser/animations/async\n - api/platform-browser/platformBrowser\n - api/router/ActivatedRoute\n - api/router/Router\n - api/router/RouterLink\n - api/router/RouterModule\n - api/router/RouterOutlet\n - api/router/Routes\n - api/router/UrlSegment\n - api/upgrade/static\n - api/upgrade/static/UpgradeComponent\n - api/upgrade/static/UpgradeModule\n - api/upgrade/static/downgradeComponent\n - api/upgrade/static/downgradeInjectable\n - guide/animations\n - guide/aot-compiler\n - guide/built-in-directives\n - guide/dependency-injection\n - guide/glossary#lazy-loading\n - guide/hierarchical-dependency-injection\n - guide/lifecycle-hooks\n - guide/ngmodules\n - guide/router\n - guide/typescript-configuration\n - guide/upgrade#add-the-angular-router\n - guide/upgrade#add-the-checkmarkpipe\n - guide/upgrade#adding-the-angular-router-and-bootstrap\n - guide/upgrade#aot-compile-the-hybrid-app\n - guide/upgrade#appendix-upgrading-phonecat-tests\n - guide/upgrade#bootstrapping-a-hybrid-phonecat\n - guide/upgrade#bootstrapping-hybrid-applications\n - guide/upgrade#change-detection\n - guide/upgrade#components-and-the-dom\n - guide/upgrade#configure-a-custom-route-matcher-for-angularjs-routes\n - guide/upgrade#create-a-component-to-render-angularjs-content\n - guide/upgrade#create-a-service-to-lazy-load-angularjs\n - guide/upgrade#create-the-routing-module\n - guide/upgrade#creating-the-appmodule\n - guide/upgrade#dependency-injection\n - guide/upgrade#e2e-tests\n - guide/upgrade#follow-the-angularjs-style-guide\n - guide/upgrade#generate-links-for-each-phone\n - guide/upgrade#how-ngupgrade-works\n - guide/upgrade#installing-angular\n - guide/upgrade#lazy-loading-angularjs\n - guide/upgrade#making-angular-dependencies-injectable-to-angularjs\n - guide/upgrade#making-angularjs-dependencies-injectable-to-angular\n - guide/upgrade#migrating-to-typescript\n - guide/upgrade#no-angular-filter-or-orderby-filters\n - guide/upgrade#phonecat-upgrade-tutorial\n - guide/upgrade#preparation\n - guide/upgrade#projecting-angularjs-content-into-angular-components\n - guide/upgrade#say-goodbye-to-angularjs\n - guide/upgrade#switching-to-typescript\n - guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\n - guide/upgrade#unit-tests\n - guide/upgrade#upgrading-components\n - guide/upgrade#upgrading-from-angularjs-to-angular\n - guide/upgrade#upgrading-the-phone-service\n - guide/upgrade#upgrading-with-ngupgrade\n - guide/upgrade#use-route-parameters\n - guide/upgrade#using-a-module-loader\n - guide/upgrade#using-angular-components-from-angularjs-code\n - guide/upgrade#using-angularjs-component-directives-from-angular-code\n - guide/upgrade#using-component-directives\n - guide/upgrade#using-the-unified-angular-location-service\n - guide/upgrade#using-upgrademodule-with-angular-ngmodules\n - guide/upgrade-setup\n - http://browserify.org\n - https://blog.angular.io/finding-a-path-forward-with-angularjs-7e186fdd4429\n - https://docs.angularjs.org/api/ng/function/angular.bootstrap\n - https://docs.angularjs.org/api/ng/service/$location\n - https://docs.angularjs.org/api/ng/type/angular.Module\n - https://docs.angularjs.org/api/ng/type/angular.Module#component\n - https://docs.angularjs.org/api/ngRoute/directive/ngView\n - https://docs.angularjs.org/api/ngRoute/provider/$routeProvider\n - https://docs.angularjs.org/tutorial\n - https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#support-for-umd-module-definitions\n - https://github.com/angular/angular-phonecat\n - https://github.com/angular/angular-phonecat/commits/1.5-snapshot\n - https://github.com/angular/angular/issues/38366\n - https://github.com/angular/quickstart\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\n - https://github.com/mgechev/angular-umd-bundle\n - https://github.com/systemjs/systemjs\n - https://rollupjs.org\n - https://webpack.github.io\n - https://www.npmjs.com/package/@types/angular\n-->"}