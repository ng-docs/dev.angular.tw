{"id":"guide/upgrade","title":"從 AngularJS 升級到 Angular","contents":"<div class=\"content\">\n  <h1 id=\"upgrading-from-angularjs-to-angular\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1i825oxcad32rcw701axhrxel\">從 AngularJS 升級到 Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-from-angularjs-to-angular\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3m6ulnpzcn2y5u3f8vwoehnkh\"><em>Angular</em>是現在和未來的 Angular 名稱。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uqkk63xsc5jgyb3fj0eka9ee\"><em>AngularJS</em>是所有 1.x 版本的 Angular 的名稱。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9azqlh2gvrgvtuzjddjq9qdpe\">有很多大型 AngularJS 應用。在遷移到 Angular 之前，請始終考慮其業務案例。該案例的一個重要部分是遷移的時間和精力。本指南描述了用於將 AngularJS 專案高效遷移到 Angular 平台的內建工具，一次一個。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5m73aqlcm0k9jediieq9e4k12\">有些應用可能比其它的升級起來簡單，還有一些方法能讓把這項工作變得更簡單。即使在正式開始升級過程之前，可以提前準備 AngularJS 的程式，讓它向 Angular 看齊。這些準備步驟幾乎都是關於如何讓程式碼更加松耦合、更有可維護性，以及用現代開發工具提高速度的。這意味著，這種準備工作不僅能讓最終的升級變得更簡單，而且還能提升 AngularJS 程式的質量。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5dn225bi29vvuka0820swnvpq\">成功升級的關鍵之一是增量式的實現它，透過在同一個應用中一起執行這兩個框架，並且逐個把 AngularJS 的元件遷移到 Angular 中。這意味著可以在不必打斷其它業務的前提下，升級更大、更復雜的應用程式，因為這項工作可以多人協作完成，在一段時間內逐漸鋪開。Angular <code>upgrade</code> 模組的設計目標就是讓你漸進、無縫的完成升級。</p>\n<h2 id=\"preparation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"950c8mg85fl94yevwp15mppan\">準備工作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#preparation\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aktoobnyic8hxwubm51jmumjj\">AngularJS 應用程式的組織方式有很多種。當你想把它們升級到 Angular 的時候，有些做起來會比其它的更容易些。即使在開始升級之前，也有一些關鍵的技術和模式可以讓你將來升級時更輕鬆。</p>\n<h3 id=\"follow-the-angularjs-style-guide\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9j0smlzff8ppa7ke0e4jeidzb\">遵循 AngularJS 風格指南<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#follow-the-angularjs-style-guide\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ahgxznojrimkvwxrd35gdie8l\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\" title=\"Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">AngularJS 風格指南</a>收集了一些已證明能寫出乾淨且可維護的 AngularJS 程式的模式與實踐。\n它包含了很多關於如何書寫和組織 AngularJS 程式碼的有價值訊息，同樣重要的是，<strong>不應該</strong>採用的書寫和組織 AngularJS 程式碼的方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ejlagesndgczo64tjaymbsmeo\">Angular 是一個基於 AngularJS 中最好的部分構思出來的版本。在這種意義上，它的目標和 AngularJS 風格指南是一樣的：保留 AngularJS 中好的部分，去掉壞的部分。當然，Angular 還做了更多。說這些的意思是：<em>遵循這個風格指南可以讓你寫出更接近 Angular 程式的 AngularJS 程式</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"avn3vviarvegmo49cqyph5ao4\">有一些特別的規則可以讓使用 Angular 的 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 模組進行<em>增量升級</em>變得更簡單：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1upsj7epzeoduaua5l8k5kg2s\">規則</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"262xb05l06nnentnhahh2hpu1\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\" title=\"單一責任 - Angular 1 風格指南 | johnpapa/angular-styleguide | GitHub\">單一職責規則</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5bmwy7nvq5j1qu92y42m16imn\">每個檔案應該有一個元件。這不僅使元件易於導向和查詢，還使我們能夠逐個遷移它們到不同的語言和框架中。在這個範例應用程式中，每個控制器、元件、服務和過濾器都在自己的源檔案中。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"y3tbfmaowhcflzv59wgiqboo\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\" title=\"按屬性劃分資料夾結構 - Angular 1 風格指南 | johnpapa/angular-styleguide | GitHub\">按屬性劃分資料夾結構</a> \n<br> \n<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\" title=\"模組化 - Angular 1 風格指南 | johnpapa/angular-styleguide | GitHub\">模組化</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bblau8iahkvauew9g672vr3l0\">在更高的抽象層面上定義類似的原則：應用程式的不同部分應該位於不同的目錄和 NgModules 中。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"qbnadh38ps7sjjkfdi8u48ka\">如果應用程式能用這種方式把每個屬性分到一個獨立目錄中，它也就能每次遷移一個屬性。對於那些還沒有這麼做的程式，強烈建議把應用這條規則作為準備步驟。而且這也不僅僅對升級有價值，它還是一個通用的規則，可以讓你的程式更『堅實』。</p>\n<h3 id=\"using-a-module-loader\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"arz77jaegwgdnm373zx7j4yc4\">使用模組載入器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-a-module-loader\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4j93w6jqmivwxppxichajodlk\">當你把應用程式碼分解到每個檔案中只放一個元件的粒度後，通常會得到一個由大量相對較小的檔案組成的專案結構。這比組織成少量大檔案要整潔得多，但如果你不得不透過 <code>&lt;script&gt;</code> 標籤在 HTML 頁面中載入所有這些檔案，那就不好玩了。尤其是當你不得不自己按正確的順序維護這些標籤時更是如此，就要開始使用<em>模組載入器</em>了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3vhxeyygu6ytyqikxzvt5krnf\">使用模組載入器，比如<a href=\"https://github.com/systemjs/systemjs\" title=\"systemjs/systemjs | GitHub\">SystemJS</a>、\n<a href=\"https://webpack.github.io\" title=\"webpack module bundler | GitHub\">Webpack</a>或<a href=\"http://browserify.org\" title=\"Browserify\">Browserify</a>，\n可以讓你在程式中使用 TypeScript 或 ES2015 語言內建的模組系統。\n你可以使用 <code>import</code> 和 <code>export</code> 屬性來明確指定哪些程式碼應該以及將會被在程式的不同部分之間共享。\n對於 ES5 程式來說，可以改用 CommonJS 風格的 <code>require</code> 和 <code>module.exports</code> 屬性代替。\n無是論哪種情況，模組載入器都會按正確的順序載入程式中用到的所有程式碼。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wknzgto5h3wkoz1jol9bhzji\">當要把應用程式投入生產環境時，模組載入器也會讓你把所有這些檔案打成完整的產品封裝變得容易一些。</p>\n<h3 id=\"migrating-to-typescript\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a0iypptthzl3e3ryq30m2n2zd\">遷移到 TypeScript<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#migrating-to-typescript\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"979pn6ugqztatm3a2t0vferpu\">Angular 升級計劃的一部分是引入 TypeScript，即使在開始升級之前，引入 TypeScript 編譯器也是有意義的。這意味著等真正升級的時候需要學習和思考的東西會更少，並且你可以在 AngularJS 程式碼中開始使用 TypeScript 的屬性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dabicl3hqnyx8rl88k0f5miih\">TypeScript 是 ECMAScript 2015 的超集，而 ES2015 又是 ECMAScript 5 的超集。這意味著除了安裝一個 TypeScript 編譯器，並把檔案名都從 <code>*.js</code> 改成 <code>*.ts</code> 之外，其實什麼都不用做。當然，如果僅僅這樣做也沒什麼大用，也沒什麼有意思的地方。下面這些額外的步驟可以讓你打起精神：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9w7bss2sqh5910hy7ldtcw9x5\">對那些使用了模組載入器的程式，TypeScript 的匯入和匯出語法（實際上是 ECMAScript 2015 的匯入和匯出）可以把程式碼組織成模組。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dd5mdpqkwb5v4axyfrv0lhi31\">可以逐步把型別註解新增到現有函式和變數上，以固定它們的型別，並獲得其優點：比如編譯期錯誤檢查、更好的支援自動完成，以及行內式文件等。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7mykvgvjw38yy6x1scdsrnjzs\">那些 ES2015 中新增的屬性，比如箭頭函式、<code>let</code>、<code>const</code>、預設函式引數、解構賦值等也可以逐漸新增進來，讓程式碼更有表現力。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7tubazzxg6687xakg4q5cx4ba\">服務和控制器可以轉成<em>類</em>。這樣它們就能一步步接近 Angular 的服務和元件類別了，也會讓升級變得簡單一點。</li>\n</ul>\n<h3 id=\"using-component-directives\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"952aex07wlxrcbd07fkif89vr\">使用元件型指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-component-directives\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efu9gah6c78vuxsvhgs2isfcw\">在 Angular 中，元件是用來建立使用者介面的主要元素。你把 UI 中的不同部分定義成元件，然後在樣板中使用這些元件合成出最終的 UI。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"50tkdvetlphux9b822zk82788\">你在 AngularJS 中也能這麼做。那就是一種定義了自己的樣板、控制器和輸入/輸出繫結的指令 —— 跟 Angular 中對元件的定義是一樣的。要遷移到 Angular，透過元件型指令建立的應用程式會比直接用 <code>ng-controller</code>、<code>ng-include</code> 和作用域繼承等底層屬性建立的要容易得多。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2j6txyi7tcyc3rpo417p7ob8z\">要與 Angular 相容，AngularJS 的元件型指令應該設定下列屬性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2e7a5u3w81azvyldqrbf228ud\">屬性</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>restrict: 'E'</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d6vibw0s26ujwqjjpi2pyfh0x\">元件通常用作元素。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>scope: {}</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9sij744zm0u1bnymo90xpdcho\">獨立作用域。在 Angular 中，元件始終與周圍環境隔離，你也應該在 AngularJS 中這樣做。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>bindToController: {}</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"30z33g4yt0d945g2o980m27yf\">元件的輸入和輸出應繫結到控制器，而不是使用 \n<code>$scope</code>。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tsgdrkisbj68a8elubssm3m\"><code>controller</code> \n<br> \n<code>controllerAs</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dw176ymmmudwsywda7y6id59s\">元件有自己的控制器。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78qcin6mpw7mipltb15nonlu0\"><code>template</code> \n<br> \n<code>templateUrl</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efi1fez3yfobb51shyxv8icmy\">元件有自己的樣板。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ec4uhrdtptyvl4jte52hdkc6\">元件型指令還可能使用下列屬性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2e7a5u3w81azvyldqrbf228ud\">屬性</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>transclude: true/{}</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dtwsq73cmadfb6ma1qh53k3c\">如果元件需要從其他地方轉入內容。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>require</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dz5sadwh3dz3n1aqbxth7o0sp\">如果元件需要與某個父元件的控制器通訊。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"90uiq99nyd9n40veyqd1eyqiw\">元件型指令<strong>不能</strong>使用下列屬性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6g4a8ku5pku8t8wpuk9dn0nju\">屬性（避免使用）</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>compile</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5fm5nbraqvkb7a7ztze7d0g6g\">這在 Angular 中不會被支援。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>replace: true</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dp10irbe3d888fqmrta16mggx\">Angular 從不使用元件元素替換元件樣板。該屬性在 AngularJS 中也已被棄用。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bm6cnmjyap6q84bxskywmfez8\"><code>priority</code> \n<br> \n<code>terminal</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6t9naig722n73s2trp2xp7mrr\">雖然 AngularJS 元件可能會使用這些屬性，但在 Angular 中不會使用，最好不要編寫依賴於它們的程式碼。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a2km92nzzvzi0e9cdwkeisp36\">AngularJS 中一個完全向 Angular 架構對齊過的元件型指令是這樣的：</p>\n<code-example header=\"hero-detail.directive.ts\" path=\"upgrade-module/src/app/hero-detail.directive.ts\">\nexport function heroDetailDirective() {\n  return {\n    restrict: 'E',\n    scope: {},\n    bindToController: {\n      hero: '=',\n      deleted: '&amp;'\n    },\n    template: `\n      &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt;\n      &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt;\n      &lt;button type=\"button\" ng-click=\"$ctrl.onDelete()\"&gt;Delete&lt;/button&gt;\n    `,\n    controller: function HeroDetailController() {\n      this.onDelete = () =&gt; {\n        this.deleted({hero: this.hero});\n      };\n    },\n    controllerAs: '$ctrl'\n  };\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1fs30q3nju4tcpyycgoggaz8b\">AngularJS 1.5 引入了<a href=\"https://docs.angularjs.org/api/ng/type/angular.Module#component\" title=\"component(name, options); - angular.Module | API | AngularJS\">元件 API</a>，它讓定義指令變得更簡單了。\n為元件型指令使用這個 API 是一個好主意，因為：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3jx0fra03f6n14jhhrad48sd\">它需要更少的樣板程式碼。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ljvtu14h3cz8ypehnol3eodi\">它強制你遵循元件的最佳實踐，比如 <code>controllerAs</code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6hjplya532d49sgn2tx232jgx\">指令中像 <code>scope</code> 和 <code>restrict</code> 這樣的屬性應該有良好的預設值。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5ryrqcnnv5c0eldb33j6m9jq\">如果使用這個元件 API 進行表示，那麼上面看到的元件型指令就變成了這樣：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io\">\nexport const heroDetail = {\n  bindings: {\n    hero: '&lt;',\n    deleted: '&amp;'\n  },\n  template: `\n    &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt;\n    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt;\n    &lt;button type=\"button\" ng-click=\"$ctrl.onDelete()\"&gt;Delete&lt;/button&gt;\n  `,\n  controller: function HeroDetailController() {\n    this.onDelete = () =&gt; {\n      this.deleted(this.hero);\n    };\n  }\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7fivwave5sqhewux1msgeexmz\">控制器的生命週期鉤子 <code>$onInit()</code>、<code>$onDestroy()</code> 和 <code>$onChanges()</code> 是 AngularJS 1.5 引入的另一些便利屬性。\n它們都很像<a href=\"guide/lifecycle-hooks\" title=\"Lifecycle hooks | Angular\">Angular 中的等價物</a>，所以，圍繞它們組織元件生命週期的邏輯在升級到 Angular 時會更容易。</p>\n<h2 id=\"upgrading-with-ngupgrade\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3rnnpbxs5nro7j80tpc08zwo\">使用 ngUpgrade 升級<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-with-ngupgrade\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eunot9d67j6mmh1cvxup37cal\">不管要升級什麼，Angular 中的 <code>ngUpgrade</code> 函式庫都會是一個非常有用的工具 —— 除非是小到沒功能的應用。藉助它，你可以在同一個應用程式中混用並對應 AngularJS 和 Angular 的元件，並讓它們實現無縫的互操作。這意味著你不用被迫一次性做完所有的升級工作，因為在整個演進過程中，這兩個框架可以很自然的和睦相處。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c6jn2pyjjbe4k2uzg0ls8udud\">由於 <a href=\"https://blog.angular.io/finding-a-path-forward-with-angularjs-7e186fdd4429\" title=\"Finding a Path Forward with AngularJS | Angular Blog\">AngularJS 即將停止維護</a>，ngUpgrade 現在處於屬性開發完畢的狀態。我們將會繼續發布安全補丁和 BUG 修復，直到 2023-12-31。</p>\n</div>\n<h3 id=\"how-ngupgrade-works\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91jy19qrli16w6hv9a4n94jh4\">ngUpgrade 的工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#how-ngupgrade-works\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"96vpbexs5guzuowvjpcei3p61\"><code>ngUpgrade</code> 提供的主要工具之一被稱為 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>。這是一個服務，它可以啟動並管理一個能同時支援 Angular 和 AngularJS 的混合式應用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c7wgu2tni6mctx6fx9snpdcjf\">當使用 ngUpgrade 時，你實際上在<em>同時執行 AngularJS 和 Angular</em>。所有 Angular 的程式碼執行在 Angular 框架中，而 AngularJS 的程式碼執行在 AngularJS 框架中。所有這些都是真實的、全功能的框架版本。沒有進行任何模擬，所以你可以認為同時存在著這兩個框架的所有屬性和自然行為。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"evizm7vj3d004dk469jgz8dgb\">所有這些事情的背後，本質上是一個框架中管理的元件和服務能和來自另一個框架的進行互操作。這些主要體現在三個方面：依賴注入、DOM 和變更檢測。</p>\n<h4 id=\"dependency-injection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"o5rlb7acys3t8dxjenlygz93\">依賴注入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#dependency-injection\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d6n4ok1v4teju7x2fkykb27ls\">無論是在 AngularJS 中還是在 Angular 中，依賴注入都位於前沿和中心的位置，但在兩個框架的工作原理上，卻存在著一些關鍵的不同之處。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">AngularJS</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bju35ovz0mk4rwib9b5i0tcrl\">Angular</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uxrn5guboogevks131m8xmlh\">依賴注入令牌始終是字串</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bfzvwue8k9uwak313uesp6im8\">令牌 \n<a href=\"guide/dependency-injection\" title=\"Angular 中的依賴注入 | Angular\">可以有不同型別</a>。\n<br>它們通常是類。\n<br>也可能是字串。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bqquqfb5l8086x6l6xcvqyvxe\">存在一個注入器。\n<br>即使在多模組應用中，所有內容也都注入到一個大的命名空間中。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wvwm73t17xpz8ve3utagrjcz\">存在一個 \n<a href=\"guide/hierarchical-dependency-injection\" title=\"層次依賴注入器 | Angular\">注入器樹層次結構</a>，有一個根注入器和每個元件都有一個額外的注入器。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4hw6hxw7w68gl8j26l0j9ep68\">就算有這麼多不同點，也並不妨礙你在依賴注入時進行互操作。<code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 解決了這些差異，並讓它們無縫的對接：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xz4t5f3yrdu5v94lzb4ydpjp\">透過升級它們，你就能讓那些在 AngularJS 中能被注入的服務也可用於 Angular 的程式碼中。在框架之間共享的是服務的同一個單例物件。在 Angular 中，這些外來服務總是被放在<em>根注入器</em>中，並可用於所有元件。它們總是具有<em>字串令牌</em> —— 跟它們在 AngularJS 中的令牌相同。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ui7qhey7fuy5mh1vzclli3hg\">透過降級它們，你也能讓那些在 Angular 中能被注入的服務在 AngularJS 的程式碼中可用。只有那些來自 Angular 根注入器的服務才能被降級。同樣的，在框架之間共享的是同一個單例物件。當你註冊一個要降級的服務時，要明確指定一個打算在 AngularJS 中使用的<em>字串令牌</em>。</p>\n</li>\n</ul>\n<div class=\"lightbox\">\n<img alt=\"The two injectors in a hybrid application\" src=\"generated/images/guide/upgrade/injectors.png\" width=\"700\" height=\"262\">\n</div>\n<h4 id=\"components-and-the-dom\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56tjnf5bhjmtwum0uzmw6r4dd\">元件與 DOM<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#components-and-the-dom\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44uaa9fb0iaj90df7v87aoldz\">在混合式應用中，同時存在來自 AngularJS 和 Angular 中元件和指令的 DOM。這些元件透過它們各自框架中的輸入和輸出繫結來互相通訊，它們由 ngUpgrade 橋接在一起。它們也能透過共享被注入的依賴彼此通訊，就像前面所說的那樣。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xax914yp8uxgywc8jgxlpt8l\">理解混合式應用的關鍵在於，DOM 中的每一個元素都只能屬於這兩個框架之一，而另一個框架則會忽略它。如果一個元素屬於 AngularJS，那麼 Angular 就會當它不存在，反之亦然。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3w0whp4pfmpdd4j10y0hwfw4w\">所以，混合式應用總是像 AngularJS 程式那樣啟動，處理根樣板的也是 AngularJS. 然後，當這個應用的樣板中使用到了 Angular 的元件時，Angular 才開始參與。這個元件的檢視由 Angular 進行管理，而且它還可以使用一系列的 Angular 元件和指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bqea88siidtheiuwoxndqr86e\">更進一步說，你可以按照需要，任意穿插使用這兩個框架。使用下面的兩種方式之一，你可以在這兩個框架之間自由穿梭：</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1nxctc4h8fyeknbrpola9m0hq\">透過使用來自另一個框架的元件：AngularJS 的樣板中用到了 Angular 的元件，或者 Angular 的樣板中使用了 AngularJS 的元件。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e1nw33sgoc4homivhaxtac5a0\">透過透傳（transclude）或投影（project）來自另一個框架的內容。<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 牽線搭橋，把 AngularJS 的透傳概念和 Angular 的內容投影概念關聯起來。</p>\n</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"DOM element ownership in a hybrid application\" src=\"generated/images/guide/upgrade/dom.png\" width=\"500\" height=\"294\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvp69b7vlreghcrz73qj9z263\">當你使用一個屬於另一個框架的元件時，就會發生一次跨框架邊界的切換。不過，這種切換只發生在該組件元素的<em>子節點</em>上。考慮一個場景，你從 AngularJS 中使用一個 Angular 元件，就像這樣：</p>\n<code-example language=\"html\" escape=\"html\">\n\n&lt;a-component&gt;&lt;/a-component&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ec5iax8oasohvo8bcg0sbelso\">此時，<code>&lt;a-component&gt;</code> 這個 DOM 元素仍然由 AngularJS 管理，因為它是在 AngularJS 的樣板中定義的。這也意味著你可以往它上面新增別的 AngularJS 指令，卻<em>不能</em>新增 Angular 的指令。只有在 <code>&lt;a-component&gt;</code> 元件的樣板中才是 Angular 的天下。同樣的規則也適用於在 Angular 中使用 AngularJS 元件型指令的情況。</p>\n<h4 id=\"change-detection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7azixb8qk7ftis9xv31c3m4b7\">變更檢測<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#change-detection\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2971knu4lqj6ml9tm6dyr1cxm\">AngularJS 中的變更檢測全是關於 <code>scope.$apply()</code> 的。在每個事件發生之後，<code>scope.$apply()</code> 就會被呼叫。這或者由框架自動呼叫，或者在某些情況下由你自己的程式碼手動呼叫。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9hwmuqg6ub67qv2jy10cuzz3n\">在 Angular 中，事情有點不一樣。雖然變更檢測仍然會在每一個事件之後發生，卻不再需要每次呼叫 <code>scope.$apply()</code> 了。\n這是因為所有 Angular 程式碼都執行在一個叫做 <a href=\"api/core/NgZone\" title=\"NgZone | Core - API | Angular\">Angular zone</a> 的地方。\nAngular 總是知道什麼時候程式碼執行完了，也就知道了它什麼時候應該觸發變更檢測。程式碼本身並不需要呼叫 <code>scope.$apply()</code> 或其它類似的東西。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"lm4idmfk17jdspc158o67fgc\">在這種混合式應用的案例中，<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 在 AngularJS 的方法和 Angular 的方法之間建立了橋樑。發生了什麼呢？</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2g3304mfm56v9ubq0exkjy9h\">應用中發生的每件事都執行在 Angular 的 zone 裡。無論事件發生在 AngularJS 還是 Angular 的程式碼中，都是如此。這個 zone 會在每個事件之後觸發 Angular 的變更檢測。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"60fyv5o9toqf9960nvihmrlnm\"><code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 將在每一次離開 Angular zone 時調用 AngularJS 的 <code>$rootScope.$apply()</code>。這樣也就同樣會在每個事件之後觸發 AngularJS 的變更檢測。</p>\n</li>\n</ul>\n<div class=\"lightbox\">\n<img alt=\"Change detection in a hybrid application\" src=\"generated/images/guide/upgrade/change_detection.png\" width=\"600\" height=\"163\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"576bdp6uek6qqbtar2zjo3k9\">在實踐中，你不用在自己的程式碼中呼叫 <code>$apply()</code>，而不用管這段程式碼是在 AngularJS 還是 Angular 中。<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 都替你做了。你仍然<em>可以</em>呼叫 <code>$apply()</code>，也就是說你不必從現有程式碼中移除此呼叫。在混合式應用中，這些呼叫只會觸發一次額外的 AngularJS 變更檢測。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qlvb01fo8yu2rncwkgd4qt3i\">當你降級一個 Angular 元件，然後把它用於 AngularJS 中時，元件的輸入屬性就會被 AngularJS 的變更檢測體系監視起來。\n當那些輸入屬性發生變化時，元件中相應的屬性就會被設定。你也能透過實現<a href=\"api/core/OnChanges\" title=\"OnChanges | Core - API | Angular\">OnChanges</a>\n介面來掛鉤到這些更改，就像它未被降級時一樣。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gbry2uwfo0vgri5hr1cnvaj9\">相應的，當你把 AngularJS 的元件升級給 Angular 使用時，在這個元件型指令的 <code>scope</code>（或 <code>bindToController</code>）中定義的所有繫結，都將被掛鉤到 Angular 的變更檢測體系中。它們將和標準的 Angular 輸入屬性被同等對待，並當它們發生變化時設定回 scope（或控制器）上。</p>\n<h3 id=\"using-upgrademodule-with-angular-ngmodules\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhvfaj6xib0jrbzvln7fh905\">透過 Angular 的 <em>NgModule</em> 來使用 UpgradeModule<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-upgrademodule-with-angular-ngmodules\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xu705qs3u18cfaa34gm2ivxj\">AngularJS 和 Angular 都有自己的模組概念，來幫你把應用按功能組織成內聚的程式碼區塊。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7tgkdzyk8z907fu80qqfj8ct7\">它們在架構和實現的細節上有著顯著的不同。在 AngularJS 中，你要把 AngularJS 的資源新增到 <code>angular.module</code> 屬性上。在 Angular 中，你要建立一個或多個帶有 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 裝飾器的類，這些裝飾器用來在元資料中描述 Angular 資源。差異主要來自這裡。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7u0zbpl9pshnm9hp4vyvscdnj\">在混合式應用中，你同時執行了兩個版本的 Angular。這意味著你至少需要 AngularJS 和 Angular 各提供一個模組。當你使用 AngularJS 的模組進行引導時，就得把 Angular 的模組傳給 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9z7ymeotts03wujdv5gvpe28r\">要了解更多，請參閱<a href=\"guide/ngmodules\" title=\"NgModules | Angular\">NgModules</a>頁。</p>\n</div>\n<h3 id=\"bootstrapping-hybrid-applications\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"djsm82itiq3miyg0ul88fn66c\">引導混合應用程式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#bootstrapping-hybrid-applications\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6fabmqb8tu7hpd6ictcai200i\">要想引導混合式應用，就必須在應用中分別引導 Angular 和 AngularJS 應用的一部分。你必須先引導 Angular，然後再呼叫 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 來引導 AngularJS。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8uyzj2m1aeyhtzqs4ibr9y8b0\">在 AngularJS 應用中有一個 AngularJS 的根模組，它用於引導 AngularJS 應用。</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"ng1module\">\nangular.module('heroApp', [])\n  .controller('MainCtrl', function() {\n    this.message = 'Hello world';\n  });\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8p369x12upkcjie48vpbxul6w\">單純的 AngularJS 應用可以在 HTML 頁面中使用 <code>ng-app</code> 指令進行引導，但對於混合式應用你要透過 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 模組進行手動引導。因此，在切換成混合式應用之前，最好先把 AngularJS 改寫成使用 <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\"><code>angular.bootstrap</code></a> 進行手動引導的方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8t331f8y8m63wzi1qogqedbp9\">比如你現在有這樣一個透過 <code>ng-app</code> 進行引導的應用：</p>\n<code-example path=\"upgrade-module/src/index-ng-app.html\">\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;base href=\"/\"&gt;\n    &lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.5.3/angular.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"app/ajs-ng-app/app.module.js\"&gt;&lt;/script&gt;\n  &lt;/head&gt;\n\n  &lt;body ng-app=\"heroApp\" ng-strict-di&gt;\n    &lt;div id=\"message\" ng-controller=\"MainCtrl as mainCtrl\"&gt;\n      {{ mainCtrl.message }}\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4lrpwy8u6k8qyqgbx2qymiftp\">你可以從 HTML 中移除 <code>ng-app</code> 和 <code>ng-strict-di</code> 指令，改為從 JavaScript 中呼叫 <code>angular.bootstrap</code>，它能達到同樣效果：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"bootstrap\">\nangular.bootstrap(document.body, ['heroApp'], { strictDi: true });\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"23dr5jzxj6oi2dycf6gjae0bi\">要想把 AngularJS 應用變成 Hybrid 應用，就要先載入 Angular 框架。\n根據<a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">準備升級到 AngularJS</a> 中給出的步驟，選擇性的把<a href=\"https://github.com/angular/quickstart\" title=\"angular/quickstart | GitHub\">快速入門 GitHub 程式碼倉庫</a>中的程式碼複製過來。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f27dab9h28gk6ygd66amrlddy\">你還需要用 <code>npm install @angular/upgrade --save</code> 安裝 <code>@angular/upgrade</code> 套件，並新增一個指向 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 套件的對映：</p>\n<code-example header=\"systemjs.config.js (map)\" path=\"upgrade-module/src/systemjs.config.1.js\" region=\"upgrade-static-package\">\n'@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/fesm2022/static.mjs',\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d4gfxp1ko4gjmtrt731xo4jbr\">接下來，建立一個 <code>app.module.ts</code> 檔案，並新增下列 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 類：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"ngmodule\">\nimport { <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a>, <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1k427eyrimy1lpzw5ulvlflna\">最小化的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 匯入了 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>，它是每個基於瀏覽器的 Angular 應用必備的。它還從 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 中匯入了 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，它匯出了一些服務提供者，這些提供者會用於升級、降級服務和元件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"blap04644z7f5dxzyt5f02fwq\">在 <code>AppModule</code> 的建構式函式中，使用依賴注入技術獲取了一個 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 實例，並用它在 <code>AppModule.ngDoBootstrap</code> 方法中啟動 AngularJS 應用。\n<code>upgrade.bootstrap</code> 方法接受和 <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\">angular.bootstrap</a> 完全相同的引數。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"903l4df7s7lihnjvyxlteknd8\"><strong>注意</strong>：<br>\n你不需要在 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中加入 <code>bootstrap</code> 宣告，因為 AngularJS 控制著該應用的根樣板。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26jhas7ni7kjqrossfoixdlmz\">現在，你就可以使用 <code>platformBrowserDynamic.bootstrapModule</code> 方法來啟動 <code>AppModule</code> 了。</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"bootstrap\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"301kck3pw81iy2uc3m8cqxrfk\">恭喜！你就要開始執行這個混合式應用了！所有現存的 AngularJS 程式碼會像以前一樣正常工作，但是你現在也同樣可以執行 Angular 程式碼了。</p>\n<h3 id=\"using-angular-components-from-angularjs-code\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"885qrpd2cvz2vs2ikgn29p5vf\">從 AngularJS 程式碼中使用 Angular 元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-angular-components-from-angularjs-code\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"lightbox\">\n<img alt=\"Using an Angular component from AngularJS code\" class=\"left\" src=\"generated/images/guide/upgrade/ajs-to-a.png\" width=\"250\" height=\"44\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2wd1trypf8io22rkwbar5krg2\">一旦你開始執行混合式應用，你就可以開始逐漸升級程式碼了。一種更常見的工作模式就是在 AngularJS 的上下文中使用 Angular 的元件。該組件可能是全新的，也可能是把原本 AngularJS 的元件用 Angular 重寫而成的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"m3kwvzz6admq42dep613xulc\">假設你有一個用來顯示英雄訊息的 Angular 元件：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/downgrade-static/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &lt;h2&gt;Windstorm details!&lt;/h2&gt;\n    &lt;div&gt;id: 1&lt;/div&gt;\n  `\n})\nexport class HeroDetailComponent { }\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"etd0w3j5o0cgzle7xzqcyay2b\">如果你想在 AngularJS 中使用這個元件，就得用 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 方法把它<em>降級</em>。其結果是一個 AngularJS 的<em>指令</em>，你可以把它註冊到 AngularJS 的模組中：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"downgradecomponent\">\nimport { HeroDetailComponent } from './hero-detail.component';\n\n/* . . . */\n\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('heroApp', [])\n  .directive(\n    'heroDetail',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({ component: HeroDetailComponent }) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9lub8po62ndu7wkmnplr5oeqs\">預設情況下，Angular 變更檢測也會在 AngularJS 的每個 <code>$digest</code> 週期中執行。如果你希望只在輸入屬性發生變化時才執行變更檢測，可以在呼叫 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 時把 <code>propagateDigest</code> 設定為 <code>false</code>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8uc2s450gg2qnr417n2me21pf\">由於 <code>HeroDetailComponent</code> 是一個 Angular 元件，所以你必須同時把它加入 <code>AppModule</code> 的 <code>declarations</code> 欄位中。</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"ngmodule\">\nimport { HeroDetailComponent } from './hero-detail.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  declarations: [\n    HeroDetailComponent\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9uv6bvenm3hgppjv8ajw4uqr4\">所有 Angular 元件、指令和通道都必須宣告在 NgModule 中。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0infihzr3pmgieqw2qtxph1s\">最終的結果是一個叫做 <code>heroDetail</code> 的 AngularJS 指令，你可以像用其它指令一樣把它用在 AngularJS 樣板中。</p>\n<code-example path=\"upgrade-module/src/index-downgrade-static.html\" region=\"usecomponent\">\n&lt;hero-detail&gt;&lt;/hero-detail&gt;\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b7in1z0e3yqmhcqpn6h09on2j\"><strong>注意</strong>：<br>\n它在 AngularJS 中是一個名叫 <code>heroDetail</code> 的元素型指令（<code>restrict: 'E'</code>）。\nAngularJS 的元素型指令是基於它的<em>名字</em>對應的。\n<em>Angular 元件中的 <code>selector</code> 元資料，在降級後的版本中會被忽略。</em></p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7g8ya8eg367955tl87yms7qyx\">當然，大多數元件都不像這個這麼簡單。它們中很多都有<em>輸入屬性和輸出屬性</em>，來把它們連線到外部世界。Angular 的英雄詳情元件帶有像這樣的輸入屬性與輸出屬性：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/downgrade-io/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\nimport { Hero }&nbsp;from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;\n    &lt;div&gt;id: {{hero.id}}&lt;/div&gt;\n    &lt;button type=\"button\" (click)=\"onDelete()\"&gt;Delete&lt;/button&gt;\n  `\n})\nexport class HeroDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleted = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;Hero&gt;();\n  onDelete() {\n    this.deleted.emit(this.hero);\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"926khw4galox5m7pud21l0n4b\">這些輸入屬性和輸出屬性的值來自於 AngularJS 的樣板，而 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 方法負責橋接它們：</p>\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"usecomponent\">\n&lt;div ng-controller=\"MainController as mainCtrl\"&gt;\n  &lt;hero-detail [hero]=\"mainCtrl.hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\"&gt;\n  &lt;/hero-detail&gt;\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71wj2f2vuofl4hoc7u41zs0d3\">注意，雖然你正在 AngularJS 的樣板中，<strong>但卻在使用 Angular 的屬性（Attribute）語法來繫結到輸入屬性與輸出屬性</strong>。這是降級的元件本身要求的。而表示式本身仍然是標準的 AngularJS 表示式。</p>\n<div class=\"callout is-important\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c7r5iykqoa0dqxq1m466mbwwi\">在降級過的元件屬性中使用中線命名法</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvfnusu48k5upmdcrt969f55c\">為降級過的元件使用 Angular 的屬性(Attribute)語法規則時有一個值得注意的例外。它適用於由多個單詞組成的輸入或輸出屬性。在 Angular 中，你要使用小駝峰命名法繫結這些屬性：</p>\n<code-example language=\"html\">\n\n[myHero]=\"hero\"\n(heroDeleted)=\"handleHeroDeleted($event)\"\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vgf4aacuu1bscax6kvpgaflq\">但是從 AngularJS 的樣板中使用它們時，你得使用中線命名法：</p>\n<code-example language=\"html\">\n\n[my-hero]=\"hero\"\n(hero-deleted)=\"handleHeroDeleted($event)\"\n\n</code-example>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74hy9adxhiixlel646byb7p3x\"><code>$event</code> 變數能被用在輸出屬性裡，以訪問這個事件所發出的物件。這個案例中它是 <code>Hero</code> 物件，因為 <code>this.deleted.emit()</code> 函式曾把它傳了出來。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"89xgfghvl8uux4ms358vnem3y\">由於這是一個 AngularJS 樣板，雖然它已經有了 Angular 中繫結的屬性（Attribute），你仍可以在這個元素上使用其它 AngularJS 指令。比如，你可以用 <code>ng-repeat</code> 簡單的製作該組件的多份複製：</p>\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"userepeatedcomponent\">\n&lt;div ng-controller=\"MainController as mainCtrl\"&gt;\n  &lt;hero-detail [hero]=\"hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\"\n               ng-repeat=\"hero in mainCtrl.heroes\"&gt;\n  &lt;/hero-detail&gt;\n&lt;/div&gt;\n\n</code-example>\n<h3 id=\"using-angularjs-component-directives-from-angular-code\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"38meio4200gddmv1p5m74rk0i\">從 Angular 程式碼使用 AngularJS 元件指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-angularjs-component-directives-from-angular-code\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"lightbox\">\n<img alt=\"Using an AngularJS component from Angular code\" class=\"left\" src=\"generated/images/guide/upgrade/a-to-ajs.png\" width=\"250\" height=\"44\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29y9kr31dcnaxzp07juqximlo\">現在，你已經能在 Angular 中寫一個元件，並把它用於 AngularJS 程式碼中了。當你從低階元件開始移植，並往上走時，這非常有用。但在另外一些情況下，從相反的方向進行移植會更加方便：從高階元件開始，然後往下走。這也同樣能用 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 完成。你可以<em>升級</em>AngularJS 元件型指令，然後從 Angular 中用它們。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1cv9f348pikr54emq3ndk36b5\">不是所有種類的 AngularJS 指令都能升級。該指令必須是一個嚴格的<em>元件型指令</em>，具有<a href=\"guide/upgrade#using-component-directives\" title=\"Using Component Directives - Upgrading from AngularJS to Angular | Angular\">上面的準備指南中描述的</a>那些特徵。\n確保相容性的最安全的方式是 AngularJS 1.5 中引入的<a href=\"https://docs.angularjs.org/api/ng/type/angular.Module\" title=\"angular.Module | API | AngularJS\">元件 API</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ep0hhrj45or88i1vvwvdsx5s\">可升級元件的簡單例子是隻有一個樣板和一個控制器的指令：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-static/hero-detail.component.ts\" region=\"hero-detail\">\nexport const heroDetail = {\n  template: `\n    &lt;h2&gt;Windstorm details!&lt;/h2&gt;\n    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;1&lt;/div&gt;\n  `,\n  controller: function HeroDetailController() {\n  }\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6smt58lopz9g8pwft9sun3noc\">你可以使用 <code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code> 方法來把這個元件<em>升級</em>到 Angular。具體方法是建立一個 Angular<strong>指令</strong>，繼承 <code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code>，在其建構式函式中進行 <code>super</code> 呼叫，這樣你就得到一個完全升級的 AngularJS 元件，並且可以 Angular 中使用。剩下是工作就是把它加入到 <code>AppModule</code> 的 <code>declarations</code> 陣列。</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-static/hero-detail.component.ts\" region=\"hero-detail-upgrade\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>, <a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a> } from '@angular/core';\nimport { <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> {\n  constructor(elementRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n\n</code-example>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/upgrade-static/app.module.ts\" region=\"hero-detail-upgrade\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  declarations: [\n    HeroDetailDirective,\n  /* . . . */\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"55qmtltb7t0l7vsra3htvxwvi\">升級後的元件是 Angular 的<strong>指令</strong>，而不是<strong>元件</strong>，因為 Angular 不知道 AngularJS 將在它下面建立元素。Angular 所知道的是升級後的元件只是一個指令（一個標籤），Angular 不需要關心元件本身及其子元素。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"31821igppuewbalu8h60amzab\">升級後的元件也可能有輸入屬性和輸出屬性，它們是在原 AngularJS 元件型指令的 scope/controller 繫結中定義的。當你從 Angular 樣板中使用該組件時，就要使用<strong>Angular 樣板語法</strong>來提供這些輸入屬性和輸出屬性，但要遵循下列規則：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7jkz5u13vo6be1cpi42eb3su9\">繫結</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2aqcs6fggsep2j4ot183cmbad\">繫結定義</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5w5kqvgmi0o4l4z6rjt7db87s\">樣板語法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5muob4wh4fsl6ato4xv3jxnzs\">屬性（Attribute）繫結</td>\n<td align=\"left\"><code>myAttribute: '@myAttribute'</code></td>\n<td align=\"left\"><code>&lt;my-component myAttribute=\"value\"&gt;</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d6p6bhfoywn6cx6njd1898fx9\">表示式繫結</td>\n<td align=\"left\"><code>myOutput: '&amp;myOutput'</code></td>\n<td align=\"left\"><code>&lt;my-component (myOutput)=\"action()\"&gt;</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"27bdkap4zwilifc2pv59n81ag\">單向繫結</td>\n<td align=\"left\"><code>myValue: '&lt;myValue'</code></td>\n<td align=\"left\"><code>&lt;my-component [myValue]=\"anExpression\"&gt;</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xy6wmoza9k1s7w2doa894ml4\">雙向繫結</td>\n<td align=\"left\"><code>myValue: '=myValue'</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"am0s34f1zqdqmxu7uuqxp56yi\">作為雙向繫結：\n<br>\n<code>&lt;my-component [(myValue)]=\"anExpression\"&gt;</code>\n<br>由於大多數 AngularJS 的雙向繫結實際上只需要單向繫結，在實踐中通常足夠使用 \n<code>&lt;my-component [myValue]=\"anExpression\"&gt;</code>。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"diya9bml3crmxsad3gee7q1jp\">舉個例子，假設 AngularJS 中有一個表示『英雄詳情』的元件型指令，它帶有一個輸入屬性和一個輸出屬性：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io\">\nexport const heroDetail = {\n  bindings: {\n    hero: '&lt;',\n    deleted: '&amp;'\n  },\n  template: `\n    &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt;\n    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt;\n    &lt;button type=\"button\" ng-click=\"$ctrl.onDelete()\"&gt;Delete&lt;/button&gt;\n  `,\n  controller: function HeroDetailController() {\n    this.onDelete = () =&gt; {\n      this.deleted(this.hero);\n    };\n  }\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"alpps0q0lerd2b7sq3xd93d5p\">你可以把這個元件升級到 Angular，然後使用 Angular 的樣板語法提供這個輸入屬性和輸出屬性：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io-upgrade\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a> } from '@angular/core';\nimport { <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleted: <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;Hero&gt;;\n\n  constructor(elementRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n\n</code-example>\n<code-example header=\"container.component.ts\" path=\"upgrade-module/src/app/upgrade-io/container.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-container',\n  template: `\n    &lt;h1&gt;Tour of Heroes&lt;/h1&gt;\n    &lt;hero-detail [hero]=\"hero\"\n                 (deleted)=\"heroDeleted($event)\"&gt;\n    &lt;/hero-detail&gt;\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm');\n  heroDeleted(hero: Hero) {\n    hero.name = 'Ex-' + hero.name;\n  }\n}\n\n\n</code-example>\n<h3 id=\"projecting-angularjs-content-into-angular-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a9gxaoipbvjjdvhsxqdmvmai4\">把 AngularJS 的內容投影到 Angular 元件中<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#projecting-angularjs-content-into-angular-components\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"lightbox\">\n<img alt=\"Projecting AngularJS content into Angular\" class=\"left\" src=\"generated/images/guide/upgrade/ajs-to-a-with-projection.png\" width=\"250\" height=\"48\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7fw4iamr9lm77aspibw79clhh\">如果你在 AngularJS 樣板中使用降級後的 Angular 元件時，可能會需要把樣板中的一些內容投影進那個元件。這也是可能的，雖然在 Angular 中並沒有透傳（transclude）這樣的東西，但它有一個非常相似的概念，叫做<em>內容投影</em>。<code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 也能讓這兩個屬性實現互操作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"nj4ayzvh59n7d7gxsamyumrb\">Angular 的元件透過使用 <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 標籤來支援內容投影。下面是這類元件的一個例子：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/ajs-to-a-projection/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &lt;h2&gt;{{hero.name}}&lt;/h2&gt;\n    &lt;div&gt;\n      &lt;ng-content&gt;&lt;/ng-content&gt;\n    &lt;/div&gt;\n  `\n})\nexport class HeroDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gg55xfngqlc194zeqotri4hq\">當從 AngularJS 中使用該組件時，你可以為它提供內容。正如它們將在 AngularJS 中被透傳一樣，它們也在 Angular 中被投影到了 <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 標籤所在的位置：</p>\n<code-example path=\"upgrade-module/src/index-ajs-to-a-projection.html\" region=\"usecomponent\">\n&lt;div ng-controller=\"MainController as mainCtrl\"&gt;\n  &lt;hero-detail [hero]=\"mainCtrl.hero\"&gt;\n    &lt;!-- Everything here will get projected --&gt;\n    &lt;p&gt;{{mainCtrl.hero.description}}&lt;/p&gt;\n  &lt;/hero-detail&gt;\n&lt;/div&gt;\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvpy3wiu581sl0y7y3syg8wjq\">當 AngularJS 的內容被投影到 Angular 元件中時，它仍然留在『AngularJS 王國』中，並被 AngularJS 框架管理著。</p>\n</div>\n<h3 id=\"transcluding-angular-content-into-angularjs-component-directives\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7kxc169isbsiflxfsaqqst9tu\">把 Angular 的內容透傳進 AngularJS 的元件型指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"lightbox\">\n<img alt=\"Projecting Angular content into AngularJS\" class=\"left\" src=\"generated/images/guide/upgrade/a-to-ajs-with-transclusion.png\" width=\"250\" height=\"48\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4kno0vkuhn41axe7hcxztuzja\">就像可以把 AngularJS 的內容投影進 Angular 元件一樣，你也能把 Angular 的內容<em>透傳</em>進 AngularJS 的元件，但不管怎樣，你都要使用它們升級過的版本。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cyqmlwuwwnernnv7jtiqpvia4\">如果一個 AngularJS 元件型指令支援透傳，它就會在自己的樣板中使用 <code>ng-transclude</code> 指令標記出透傳到的位置：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/a-to-ajs-transclusion/hero-detail.component.ts\">\nexport const heroDetail = {\n  bindings: {\n    hero: '='\n  },\n  template: `\n    &lt;h2&gt;{{$ctrl.hero.name}}&lt;/h2&gt;\n    &lt;div&gt;\n      &lt;ng-transclude&gt;&lt;/ng-transclude&gt;\n    &lt;/div&gt;\n  `,\n  transclude: true\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"65eobq2kgs9sqxallan564c8e\">如果你升級這個元件，並把它用在 Angular 中，你就能把準備透傳的內容放進這個元件的標籤中。</p>\n<code-example header=\"container.component.ts\" path=\"upgrade-module/src/app/a-to-ajs-transclusion/container.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-container',\n  template: `\n    &lt;hero-detail [hero]=\"hero\"&gt;\n      &lt;!-- Everything here will get transcluded --&gt;\n      &lt;p&gt;{{hero.description}}&lt;/p&gt;\n    &lt;/hero-detail&gt;\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm', 'Specific powers of controlling winds');\n}\n\n\n</code-example>\n<h3 id=\"making-angularjs-dependencies-injectable-to-angular\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cbo6a02p2xquu5gp3oyzy5fp3\">讓 AngularJS 中的依賴可被注入到 Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"as0pkl55zdtc6pczusovwllht\">當執行一個混合式應用時，可能會遇到這種情況：你需要把某些 AngularJS 的依賴注入到 Angular 程式碼中。這可能是因為某些業務邏輯仍然在 AngularJS 服務中，或者需要某些 AngularJS 的內建服務，比如 <code>$location</code> 或 <code>$timeout</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dp69o9g04m90stut2e5g9uvtc\">在這些情況下，把一個 AngularJS 提供者<em>升級到</em>Angular 也是有可能的。這就讓它將來有可能被注入到 Angular 程式碼中的某些地方。比如，你可能在 AngularJS 中有一個名叫 <code>HeroesService</code> 的服務：</p>\n<code-example header=\"heroes.service.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/heroes.service.ts\">\nimport { Hero }&nbsp;from '../hero';\n\nexport class HeroesService {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"964g8jv2kw076a8qjgjy8esd0\">你可以用 Angular 的[工廠提供者][AioGuideDependencyInjectionProvidersFactoryProviders]升級該服務，\n它從 AngularJS 的 <code>$injector</code> 請求服務。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dha5d54hqkjauin3p6uqzxd2\">很多開發者都喜歡在一個獨立的 <code>ajs-upgraded-providers.ts</code> 中宣告這個工廠提供者，以便把它們都放在一起，這樣便於引用、建立新的以及在升級完畢時刪除它們。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dn89ph1zxf7115hsifw5zd6ku\">同時，建議匯出 <code>heroesServiceFactory</code> 函式，以便 AOT 編譯器可以拿到它們。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8r2c5gllbrx5myex1p5r8lhga\"><strong>注意</strong>：<br>\n這個工廠中的字串 'heroes' 指向的是 AngularJS 的 <code>HeroesService</code>。\nAngularJS 應用中通常使用服務名作為令牌，比如 'heroes'，併為其追加 'Service' 字尾來建立其類別名稱。</p>\n</div>\n<code-example header=\"ajs-upgraded-providers.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/ajs-upgraded-providers.ts\">\nimport { HeroesService } from './heroes.service';\n\nexport function heroesServiceFactory(i: any) {\n  return i.get('heroes');\n}\n\nexport const heroesServiceProvider = {\n  provide: HeroesService,\n  useFactory: heroesServiceFactory,\n  deps: ['$injector']\n};\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9s2uhglmsdxnoz9aiibnmpd9q\">然後，你就可以把這個服務新增到 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中來把它暴露給 Angular：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/app.module.ts\" region=\"register\">\nimport { heroesServiceProvider } from './ajs-upgraded-providers';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  providers: [\n    heroesServiceProvider\n  ],\n/* . . . */\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8rdyxy2p06xhtja40rq20k5v9\">然後在元件的建構式函式中使用該服務的類別名稱作為型別註解注入到元件中，從而在元件中使用它：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { HeroesService } from './heroes.service';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &lt;h2&gt;{{hero.id}}: {{hero.name}}&lt;/h2&gt;\n  `\n})\nexport class HeroDetailComponent {\n  hero: Hero;\n  constructor(heroes: HeroesService) {\n    this.hero = heroes.get()[0];\n  }\n}\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"10m6skzfdk4loy0wudqh93e59\">在這個例子中，你升級了服務類別。當注入它時，你可以使用 TypeScript 型別註解來獲得這些額外的好處。它沒有影響該依賴的處理過程，同時還得到了啟用靜態型別檢查的好處。任何 AngularJS 中的服務、工廠和提供者都能被升級 —— 儘管這不是必須的。</p>\n</div>\n<h3 id=\"making-angular-dependencies-injectable-to-angularjs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e380i9qin7y0139imlr9ront7\">讓 Angular 的依賴能被注入到 AngularJS 中<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#making-angular-dependencies-injectable-to-angularjs\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c02prf3cnq1r7n9bvq3he4wqi\">除了能升級 AngularJS 依賴之外，你還能<em>降級</em>Angular 的依賴，以便在 AngularJS 中使用它們。當你已經開始把服務移植到 Angular 或在 Angular 中建立新服務，但同時還有一些用 AngularJS 寫成的元件時，這會非常有用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54x2tut843052x61qj4tga1f1\">比如，你可能有一個 Angular 的 <code>Heroes</code> 服務：</p>\n<code-example header=\"heroes.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/heroes.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Hero }&nbsp;from '../hero';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Heroes {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c618049pmus7pngs6jau0z0l0\">仿照 Angular 元件，把該提供者加入 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>providers</code> 清單中，以註冊它。</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"ngmodule\">\nimport { Heroes } from './heroes';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  providers: [ Heroes ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2t4tfdrk015mu8a4azxvv8kb2\">現在，用 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> 來把 Angular 的 <code>Heroes</code> 包裝成<em>AngularJS 的工廠函式</em>，並把這個工廠註冊進 AngularJS 的模組中。依賴在 AngularJS 中的名字你可以自己定：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"register\">\nimport { Heroes } from './heroes';\n/* . . . */\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('heroApp', [])\n  .factory('heroes', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Heroes))\n  .component('heroDetail', heroDetailComponent);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1uv2g379bzd3h6a0fhvfedk7l\">此後，該服務就能被注入到 AngularJS 程式碼中的任何地方了：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/hero-detail.component.ts\">\nexport const heroDetailComponent = {\n  template: `\n    &lt;h2&gt;{{$ctrl.hero.id}}: {{$ctrl.hero.name}}&lt;/h2&gt;\n  `,\n  controller: ['heroes', function(heroes: Heroes) {\n    this.hero = heroes.get()[0];\n  }]\n};\n\n\n</code-example>\n<h2 id=\"lazy-loading-angularjs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3uv3f9h6ly5kkkij16yqx4o0m\">延遲載入 AngularJS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#lazy-loading-angularjs\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cxt9ypwzzk2niojfum0iefsrl\">在建立應用時，你需要確保只在必要的時候才載入所需的資源，無論是載入靜態資產（Asset）還是程式碼。要確保任何事都儘量推遲到必要時才去做，以便讓應用更高效的執行。當要在同一個應用中執行不同的框架時，更是如此。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5mfp4wnn1hel717ytyzlv4uqa\"><a href=\"guide/glossary#lazy-loading\" title=\"lazy loading - Glossary | Angular\">延遲載入</a>是一項技術，它會推遲到使用時才載入所需靜態資產和程式碼資源。這可以減少啟動時間、提高效率，特別是要在同一個應用中執行不同的框架時。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7t59w35o433gviaprfv1mot66\">當你採用混合式應用的方式將大型應用從 AngularJS 遷移到 Angular 時，你首先要遷移一些最常用的屬性，並且只在必要的時候才使用那些不太常用的屬性。這樣做有助於確保應用程式在遷移過程中仍然能為使用者提供無縫的體驗。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"456t1yks6evu34rjlzoshj3uh\">在大多數需要同時用 Angular 和 AngularJS 渲染應用的環境中，這兩個框架都會包含在傳送給用戶端的初始發布包中。這會導致發布套件的體積增大、效能降低。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9emdejv926t61rrm07m28q3ts\">當用戶停留在由 Angular 渲染的頁面上時，應用的整體性能也會受到影響。這是因為 AngularJS 的框架和應用仍然被載入並執行了 —— 即使它們從未被訪問過。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"qnhtwwrhgd9ggb7bnal3c11w\">你可以採取一些措施來緩解這些套件的大小和效能問題。透過把 AngularJS 應用程式分離到一個單獨的發布套件中，你就可以利用<a href=\"guide/glossary#lazy-loading\" title=\"lazy loading - Glossary | Angular\">延遲載入</a>技術來只在必要的時候才載入、引導和渲染這個 AngularJS 應用。這種策略減少了你的初始發布包大小，推遲了同時載入兩個框架的潛在影響 —— 直到絕對必要時才載入，以便讓你的應用儘可能高效地執行。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ad4vzrwdnbhd9cmn31jqr0jpi\">下面的步驟介紹了應該如何去做：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aoljnmkmhxlwm4dflrwsvtzqa\">為你的 AngularJS 捆綁包設定回呼函式。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d4peohi0h3aaioao35kgv3ze2\">建立一個服務，以便延遲載入並引導你的 AngularJS 應用。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6cmp0ltuvxi8idlmqhs3e0um8\">為 AngularJS 內容建立一個可路由的元件</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76vnbwodf1je34cc1ur3nwj57\">為 AngularJS 特有的 URL 建立自定義的 <code>matcher</code> 函式，併為 AngularJS 的各個路由配上帶有自定義對應器的 Angular 路由器。</li>\n</ul>\n<h3 id=\"create-a-service-to-lazy-load-angularjs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1y5zew03ky8dzcxaxlf5h9epy\">為延遲載入 AngularJS 建立一個服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-a-service-to-lazy-load-angularjs\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c67806jar0rzagqboadyo3ahj\">在 Angular 的版本 8 中，延遲載入程式碼只需使用動態匯入語法 <code>import('...')</code> 即可。在這個應用中，你建立了一個新服務，它使用動態匯入技術來延遲載入 AngularJS。</p>\n<code-example header=\"src/app/lazy-loader.service.ts\" path=\"upgrade-lazy-load-ajs/src/app/lazy-loader.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport * as angular from 'angular';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class LazyLoaderService {\n  private app: angular.auto.IInjectorService | undefined;\n\n  load(el: HTMLElement): void {\n    import('./angularjs-app').then(app =&gt; {\n      try {\n        this.app = app.bootstrap(el);\n      } catch (e) {\n        console.error(e);\n      }\n    });\n  }\n\n  destroy() {\n    if (this.app) {\n      this.app.get('$rootScope').$destroy();\n    }\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"yhz10vnpw45ewf3ev84biacs\">該服務使用 \n<code>import()</code> 方法來延遲載入捆綁的 AngularJS 應用程式。這會減少應用程式的初始捆綁包大小，因為你不會載入使用者暫時不需要的程式碼。你還需要提供一種方式在載入後手動 \n<em>引導</em> 應用程式。AngularJS 提供了一種透過提供的 HTML 元素使用 \n<a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\">angular.bootstrap()</a> 方法手動引導應用程式的方式。你的 AngularJS 應用程式還應該暴露一個 \n<code>bootstrap</code> 方法來引導 AngularJS 應用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6gr1qanth22vzsete4fanqa2t\">要確保 AngularJS 應用中的任何清理工作都觸發過（比如移除全域監聽器），你還可以實現一個方法來呼叫 <code>$rootScope.destroy()</code> 方法。</p>\n<code-example header=\"angularjs-app\" path=\"upgrade-lazy-load-ajs/src/app/angularjs-app/index.ts\">\nimport * as angular from 'angular';\nimport 'angular-route';\n\nconst appModule = angular.module('myApp', [\n  'ngRoute'\n])\n.config(['$routeProvider', '$locationProvider',\n  function config($routeProvider: angular.route.IRouteProvider,\n                  $locationProvider: angular.ILocationProvider) {\n    $locationProvider.html5Mode(true);\n\n    $routeProvider.\n      when('/users', {\n        template: `\n          &lt;p&gt;\n            Users Page\n          &lt;/p&gt;\n        `\n      }).\n      otherwise({\n        template: ''\n      });\n  }]\n);\n\nexport function bootstrap(el: HTMLElement) {\n  return angular.bootstrap(el,  [appModule.name]);\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dsjkjnygnwuz0ni1qdkyp50c\">你的 AngularJS 應用只配置了渲染內容所需的那部分路由。而 Angular 路由器會處理應用中其餘的路由。你的 Angular 應用中會呼叫公開的 <code>bootstrap</code> 方法，讓它在載入完發布套件之後引導 AngularJS 應用。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cmlth15rv8nohhw3mgdaiyvhn\"><strong>注意：</strong>當 AngularJS 載入並引導完畢後，監聽器（比如路由設定中的那些監聽器）會繼續監聽路由的變化。為了確保當 AngularJS 尚未顯示時先關閉監聽器，請在 <a href=\"https://docs.angularjs.org/api/ngRoute/provider/$routeProvider\" title=\"$routeProvider | API | AngularJS\">$routeProvider</a> 中設定一個渲染空樣板 <code>otherwise</code> 選項。這裡假設 Angular 將處理所有其它路由。</p>\n</div>\n<h3 id=\"create-a-component-to-render-angularjs-content\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"10b7k70ah20tx6d4tci1xp04h\">建立一個用來渲染 AngularJS 內容的元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-a-component-to-render-angularjs-content\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2169vu3fzzyhu0pk9sfd0uxk\">在 Angular 應用中，你需要一個元件作為 AngularJS 內容的佔位符。該組件使用你建立的服務，並在元件初始化完成後載入並引導你的 AngularJS 應用。</p>\n<code-example header=\"src/app/angular-js/angular-js.component.ts\" path=\"upgrade-lazy-load-ajs/src/app/angular-js/angular-js.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a> } from '@angular/core';\nimport { LazyLoaderService } from '../lazy-loader.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-angular-js',\n  template: '&lt;div ng-view&gt;&lt;/div&gt;'\n})\nexport class AngularJSComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n  constructor(\n    private lazyLoader: LazyLoaderService,\n    private elRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>\n  ) {}\n\n  ngOnInit() {\n    this.lazyLoader.load(this.elRef.nativeElement);\n  }\n\n\n  ngOnDestroy() {\n    this.lazyLoader.destroy();\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drhsnyxh0yppeqxkmovr2clt0\">當 Angular 的路由器對應到使用 AngularJS 的路由時，會渲染 <code>AngularJSComponent</code>，並在 AngularJS 的 <a href=\"https://docs.angularjs.org/api/ngRoute/directive/ngView\" title=\"ngView | API | AngularJS\"><code>ng-view</code></a> 指令中渲染內容。當用戶導向離開本路由時，<code>$rootScope</code> 會在 AngularJS 應用中被銷燬。</p>\n<h3 id=\"configure-a-custom-route-matcher-for-angularjs-routes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ks3rxdlyvrupppwk1gf7dmp6\">為那些 AngularJS 路由設定自定義路由對應器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#configure-a-custom-route-matcher-for-angularjs-routes\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f3piaecup7kj0axj9fmj2ptu8\">為了設定 Angular 的路由器，你必須為 AngularJS 的 URL 定義路由。要對應這些 URL，你需要新增一個使用 <code>matcher</code> 屬性的路由設定。這個 <code>matcher</code> 允許你使用自定義模式來對應這些 URL 路徑。Angular 的路由器會首先嘗試對應更具體的路由，比如靜態路由和可變路由。當它找不到對應項時，就會求助於路由設定中的自定義對應器。如果自定義對應器與某個路由不對應，它就會轉到用於 \"捕獲所有\"（catch-all）的路由，比如 404 頁面。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0jjb5qh9swnew1cpsubi3dx6\">下面的例子給 AngularJS 路由定義了一個自定義對應器函式。</p>\n<code-example header=\"src/app/app-routing.module.ts\" path=\"upgrade-lazy-load-ajs/src/app/app-routing.module.ts\" region=\"matcher\">\nexport function isAngularJSUrl(url: <a href=\"api/router/UrlSegment\" class=\"code-anchor\">UrlSegment</a>[]) {\n  return url.length &gt; 0 &amp;&amp; url[0].path.startsWith('users') ? ({consumed: url}) : null;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c6yvfzwvew0zt786py7ere83q\">下列程式碼往你的路由設定中新增了一個路由物件，其 <code>matcher</code> 屬性是這個自定義對應器，而 <code>component</code> 屬性為 <code>AngularJSComponent</code>。</p>\n<code-example header=\"src/app/app-routing.module.ts\" path=\"upgrade-lazy-load-ajs/src/app/app-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/UrlSegment\" class=\"code-anchor\">UrlSegment</a> } from '@angular/router';\nimport { AngularJSComponent } from './angular-js/angular-js.component';\nimport { HomeComponent } from './home/home.component';\nimport { App404Component } from './app404/app404.component';\n\n// Match any URL that starts with `users`\nexport function isAngularJSUrl(url: <a href=\"api/router/UrlSegment\" class=\"code-anchor\">UrlSegment</a>[]) {\n  return url.length &gt; 0 &amp;&amp; url[0].path.startsWith('users') ? ({consumed: url}) : null;\n}\n\nexport const routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  // <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> rendered by Angular\n  { path: '', component: HomeComponent },\n\n  // AngularJS routes\n  { matcher: isAngularJSUrl, component: AngularJSComponent },\n\n  // Catch-all route\n  { path: '**', component: App404Component }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cz0gevg666h0asxjcr2q85dti\">當你的應用對應上需要 AngularJS 的路由時，AngularJS 應用就會被載入並引導。AngularJS 路由會對應必要的 URL 以渲染它們的內容，而接下來你的應用就會同時執行 AngularJS 和 Angular 框架。</p>\n<h2 id=\"using-the-unified-angular-location-service\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bid9rvltf0vgwb5i5s9qjhagr\">使用統一的 Angular 位置服務（Location）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-the-unified-angular-location-service\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9l94w7azhmotq6qi5djytiep4\">在 AngularJS 中，<a href=\"https://docs.angularjs.org/api/ng/service/$location\" title=\"$location | API | AngularJS\">$location 服務</a>會處理所有路由設定和導向工作，並對各個 URL 進行編碼和解碼、重導向、以及與瀏覽器 API 互動。Angular 在所有這些任務中都使用了自己的底層服務 <code><a href=\"api/common/Location\" class=\"code-anchor\">Location</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8stu4qo5y1ql78ll5abqp3t46\">當你從 AngularJS 遷移到 Angular 時，你會希望把儘可能多的責任移交給 Angular，以便利用新的 API。為了幫你完成這種轉換，Angular 提供了 <code><a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a></code>。該模組支援<em>統一</em>位置服務，可以把 AngularJS 中 <code>$location</code> 服務的職責轉給 Angular 的 <code><a href=\"api/common/Location\" class=\"code-anchor\">Location</a></code> 服務。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5yz5052o3aco6xh97kbgzlpb\">要使用 <code><a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a></code>，就會從 <code>@angular/common/upgrade</code> 中匯入此符號，並使用靜態方法 <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> 把它新增到你的 <code>AppModule</code> 匯入表（<code>imports</code>）中。</p>\n<code-example language=\"typescript\">\n\n// Other imports …\nimport { <a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a> } from '@angular/common/upgrade';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    // Other <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> imports…\n    LocationUpgradeModule.config()\n  ]\n})\nexport class AppModule {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2xe3dnj2bgaosrzfo9p78nimp\"><code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> 方法接受一個設定物件，該物件的 <code>useHash</code> 為 <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code>，<code>hashPrefix</code> 為 URL 字首。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cd07bg8hgssrruau8zefey1gx\"><code>useHash</code> 屬性預設為 <code>false</code>，而 <code>hashPrefix</code> 預設為空 <code>string</code>。傳遞設定物件可以覆蓋預設值。</p>\n<code-example language=\"typescript\">\n\nLocationUpgradeModule.config({\n  useHash: true,\n  hashPrefix: '!'\n})\n\n</code-example>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"38npab7ysm0pxw9yqcejcg91l\"><strong>注意：</strong>關於 <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> 方法的更多可用設定項，請參閱 <code><a href=\"api/common/upgrade/LocationUpgradeConfig\" class=\"code-anchor\">LocationUpgradeConfig</a></code>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7b81rog7rykxn8xefn0ibcy3b\">這會為 AngularJS 中的 <code>$location</code> 提供者註冊一個替代品。一旦註冊成功，導向過程中所有由 AngularJS 觸發的導向、路由廣播訊息以及任何必需的變更檢測週期都會改由 Angular 進行處理。這樣，你就可以透過這個唯一的途徑在此混合應用的兩個框架間進行導向了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2xvna8h9iwr9wz2ohto6k1jrx\">要想在 AngularJS 中使用 <code>$location</code> 服務作為提供者，你需要使用一個工廠提供者來降級 <code><a href=\"api/common/upgrade/$locationShim\" class=\"code-anchor\">$locationShim</a></code>。</p>\n<code-example language=\"typescript\">\n\n// Other imports …\nimport { $locationShim } from '@angular/common/upgrade';\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('myHybridApp', […])\n  .factory('$location', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>($locationShim));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"19eqk6i174fr8pppcyi1xtpws\">一旦引入了 Angular 路由器，你只要使用 Angular 路由器就可以透過統一位置服務來觸發導向了，同時，你仍然可以透過 AngularJS 和 Angular 進行導向。</p>\n<!--TODO:\nCorrectly document how to use AOT with SystemJS-based `ngUpgrade` apps (or better yet update the `ngUpgrade` examples/guides to use `@angular/cli`).\nSee [https://github.com/angular/angular/issues/35989][GithubAngularAngularIssues35989].\n\n## Using Ahead-of-time compilation with hybrid apps\n\nYou can take advantage of Ahead-of-time \\(AOT\\) compilation on hybrid apps just like on any other Angular application.\nThe setup for a hybrid app is mostly the same as described in the [Ahead-of-time Compilation chapter][AioGuideAotCompiler] save for differences in `index.html` and `main-aot.ts`\n\nThe `index.html` will likely have script tags loading AngularJS files, so the `index.html` for AOT must also load those files.\nAn easy way to copy them is by adding each to the `copy-dist-files.js` file.\n\nYou'll need to use the generated `AppModuleFactory`, instead of the original `AppModule` to bootstrap the hybrid app:\n\n<code-example header=\"app/main-aot.ts\" path=\"upgrade-phonecat-2-hybrid/app/main-aot.ts\">\nimport { platformBrowser } from &#39;@angular/platform-browser&#39;;\n\nimport { AppModule } from &#39;./app.module&#39;;\n\nplatformBrowser().bootstrapModule(AppModule);\n\n\n</code-example>\n\nAnd that s all you need do to get the full benefit of AOT for Angular apps!\n-->\n<h2 id=\"phonecat-upgrade-tutorial\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"jgri4q9swr39zjjzuzy9dtcg\">PhoneCat 升級教程<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#phonecat-upgrade-tutorial\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebwptp29un33j3zqsor63usx0\">在本節和下節中，你將看一個完整的例子，它使用 <code>upgrade</code> 模組準備和升級了一個應用程式。\n該應用就是來自<a href=\"https://docs.angularjs.org/tutorial\" title=\"PhoneCat Tutorial App | Tutorial | AngularJS\">原 AngularJS 教程</a>中的<a href=\"https://github.com/angular/angular-phonecat\" title=\"angular/angular-phonecat | GitHub\">Angular PhoneCat</a>。\n那是我們很多人當初開始 Angular 探險之旅的地方。\n現在，你會看到如何把該應用帶入 Angular 的美麗新世界。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"98n3kntteieccc8dxn2pyfme0\">這期間，你將學到如何在實踐中應用<a href=\"guide/upgrade#preparation\" title=\"Preparation - Upgrading from AngularJS to Angular | Angular\">準備指南</a>中列出的那些重點步驟。\n你要先讓該應用向 Angular 看齊，並開始寫 TypeScript。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cc75o3ouba09xqrkks30dfbvc\">本教程基於 <code>angular-phonecat</code> 教程的 1.5.x 版本，該教程儲存在程式碼倉庫的 <a href=\"https://github.com/angular/angular-phonecat/commits/1.5-snapshot\" title=\"angular/angular-phonecat v1.5 | GitHub\">1.5-snapshot</a> 分支中。接下來，克隆 <a href=\"https://github.com/angular/angular-phonecat\" title=\"angular/angular-phonecat | GitHub\">angular-phonecat</a> 程式碼倉庫，check out <code>1.5-snapshot</code> 分支並應用這些步驟。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ds02jhte0gfwdyov2y7gvth6r\">在專案結構方面，工作的起點是這樣的：</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    angular-phonecat\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      bower.json\n    </div>\n    <div class=\"file\">\n      karma.conf.js\n    </div>\n    <div class=\"file\">\n      package.json\n    </div>\n    <div class=\"file\">\n      app\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        core\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          checkmark\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            checkmark.filter.js\n          </div>\n          <div class=\"file\">\n            checkmark.filter.spec.js\n          </div>\n        </div>\n        <div class=\"file\">\n          phone\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            phone.module.js\n          </div>\n          <div class=\"file\">\n            phone.service.js\n          </div>\n          <div class=\"file\">\n            phone.service.spec.js\n          </div>\n        </div>\n        <div class=\"file\">\n          core.module.js\n        </div>\n      </div>\n      <div class=\"file\">\n        phone-detail\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          phone-detail.component.js\n        </div>\n        <div class=\"file\">\n          phone-detail.component.spec.js\n        </div>\n        <div class=\"file\">\n          phone-detail.module.js\n        </div>\n        <div class=\"file\">\n          phone-detail.template.html\n        </div>\n      </div>\n      <div class=\"file\">\n        phone-list\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          phone-list.component.js\n        </div>\n        <div class=\"file\">\n          phone-list.component.spec.js\n        </div>\n        <div class=\"file\">\n          phone-list.module.js\n        </div>\n        <div class=\"file\">\n          phone-list.template.html\n        </div>\n      </div>\n      <div class=\"file\">\n        img\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n           …\n        </div>\n      </div>\n      <div class=\"file\">\n        phones\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n           …\n        </div>\n      </div>\n      <div class=\"file\">\n        app.animations.js\n      </div>\n      <div class=\"file\">\n        app.config.js\n      </div>\n      <div class=\"file\">\n        app.css\n      </div>\n      <div class=\"file\">\n        app.module.js\n      </div>\n      <div class=\"file\">\n        index.html\n      </div>\n    </div>\n    <div class=\"file\">\n      e2e-tests\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        protractor-conf.js\n      </div>\n      <div class=\"file\">\n        scenarios.js\n      </div>\n    </div>\n  </div>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26lcx5h040b9mpyc9nj0mgly4\">這確實是一個很好地起點。這些程式碼使用了 AngularJS 1.5 的元件 API，並遵循了 <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\" title=\"Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">AngularJS 風格指南</a>進行組織，\n在成功升級之前，這是一個很重要的<a href=\"guide/upgrade#follow-the-angularjs-style-guide\" title=\"Follow the AngularJS Style Guide - Upgrading from AngularJS to Angular | Angular\">準備步驟</a>。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bq2ebsm03oeh08zuta1mc6ehw\">每個元件、服務和過濾器都在它自己的源檔案中 —— 就像<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\" title=\"Single Responsibility - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">單一規則</a>所要求的。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8bw28cn78yajeq2umwwehyfru\"><code>core</code>、<code>phone-detail</code> 和 <code>phone-list</code> 模組都在它們自己的子目錄中。那些子目錄除了包含 HTML 樣板之外，還包含 JavaScript 程式碼，它們共同完成一個屬性。\n這是<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\" title=\"Folders-by-Feature Structure - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">按屬性分目錄的結構</a>\n和<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\" title=\"Modularity - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">模組化</a>規則所要求的。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"32udpjhi39tl1ebalmxavnvll\">單元測試都和應用程式碼在一起，它們很容易找到。就像規則\n<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests\" title=\"Organizing Tests - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">組織測試檔案</a>中要求的那樣。</p>\n</li>\n</ul>\n<h3 id=\"switching-to-typescript\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7y7f56xnbmhgpagrzvt5alpqp\">切換到 TypeScript<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#switching-to-typescript\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9id457a42mbr8dstoulmceaci\">因為你將使用 TypeScript 編寫 Angular 的程式碼，所以在開始升級之前，先要把 TypeScript 的編譯器設定好。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a7lcy5frow2gsfew7yphkwbrq\">你還將開始逐步淘汰 Bower 套件管理器，換成 NPM。後面你將使用 NPM 來安裝新的依賴套件，並最終從專案中移除 Bower。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xj8b1g47zs62ggoebjlkeuay\">先把 TypeScript 套件安裝到專案中。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm i typescript --save-dev\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24pwba0s60ajra1aidvgs39fi\">還要為那些沒有自帶型別訊息的函式庫（比如 AngularJS、AngularJS Material 和 Jasmine）安裝型別定義檔案。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3zvpe0ms0rksi6zuqmvr6znk\">對於 PhoneCat 應用，我們可以執行下列指令來安裝必要的型別定義檔案：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @types/jasmine @types/angular @types/angular-animate @types/angular-aria @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6qzh2m4neibqdgm3ji7vveer0\">如果你正在使用 AngularJS Material，你可以透過下列指令安裝其型別定義：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @types/angular-material --save-dev\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8z40tkoaxz38dwrnk5ibpslkb\">你還應該要往專案目錄下新增一個 <code>tsconfig.json</code> 檔案，\n就像在 <a href=\"guide/typescript-configuration\" title=\"TypeScript configuration | Angular\">TypeScript 設定</a>中講過的那樣。\n<code>tsconfig.json</code> 檔案會告訴 TypeScript 編譯器如何把 TypeScript 檔案轉成 ES5 程式碼，並打包進 CommonJS 模組中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a1hx5h4sbdvb2p7kk71l5gfz0\">最後，你應該把下列 npm 指令碼新增到 <code>package.json</code> 中，用於把 TypeScript 檔案編譯成 JavaScript（根據 <code>tsconfig.json</code> 的設定）：</p>\n<code-example format=\"shell\" language=\"shell\">\n\n\"scripts\": {\n  \"tsc\": \"tsc\",\n  \"tsc:w\": \"tsc -w\",\n  …\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eaa2rzwoten42fdkz03a9yu2l\">現在，從命令行中用監視模式啟動 TypeScript 編譯器：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm run tsc:w\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"22mvu9ww53f68ztxszcq63mrw\">讓這個程序一直在後台執行，監聽任何變化並自動重新編譯。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44xzs5xwz3z46pz3zpfi8tw66\">接下來，把 JavaScript 檔案轉換成 TypeScript 檔案。由於 TypeScript 是 ECMAScript 2015 的一個超集，而 ES2015 又是 ECMAScript 5 的超集，所以你可以簡單的把檔案的副檔名從 <code>.js</code> 換成 <code>.ts</code>，它們還是會像以前一樣工作。由於 TypeScript 編譯器仍在執行，它會為每一個 <code>.ts</code> 檔案生成對應的 <code>.js</code> 檔案，而真正執行的是編譯後的 <code>.js</code> 檔案。如果你用 <code>npm start</code> 開啟了本專案的 HTTP 伺服器，你會在瀏覽器中看到一個功能完好的應用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1cc8ik8yace0usi9vfjcsymtg\">有了 TypeScript，你就可以從它的一些屬性中獲益了。此語言可以為 AngularJS 應用提供很多價值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"j98ijr27ijno2nd036qcsdaw\">首先，TypeScript 是一個 ES2015 的超集。任何以前用 ES5 寫的程式（就像 PhoneCat 範例）都可以開始透過 TypeScript 納入那些新增到 ES2015 中的新屬性。這包括 <code>let</code>、<code>const</code>、箭頭函式、函式預設引數以及解構（destructure）賦值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5m1bolkuyitg4mlxj5g9haeso\">你能做的另一件事就是把<em>型別安全</em>新增到程式碼中。這實際上已經部分完成了，因為你已經安裝了 AngularJS 的型別定義。TypeScript 會幫你檢查是否正確呼叫了 AngularJS 的 API，—— 比如往 Angular 模組中註冊元件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"hzhsx56ynm6lmu9pjoo7zdev\">你還能開始把<em>型別註解</em>新增到自己的程式碼中，來從 TypeScript 的型別系統中獲得更多幫助。比如，你可以給 <code>checkmark</code> 過濾器加上註解，表明它期待一個 <code>boolean</code> 型別的引數。這可以更清楚的表明此過濾器打算做什麼。</p>\n<code-example header=\"app/core/checkmark/checkmark.filter.ts\" path=\"upgrade-phonecat-1-typescript/app/core/checkmark/checkmark.filter.ts\">\nangular.\n  module('core').\n  filter('checkmark', () =&gt; (input: boolean) =&gt; input ? '\\u2713' : '\\u2718');\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1sxvs232y3c55aey0s1pxwjoo\">在 <code>Phone</code> 服務中，你可以明確的把 <code>$resource</code> 服務宣告為 <code>angular.resource.IResourceService</code>，一個 AngularJS 型別定義提供的型別。</p>\n<code-example header=\"app/core/phone/phone.service.ts\" path=\"upgrade-phonecat-1-typescript/app/core/phone/phone.service.ts\">\nangular.\n  module('core.phone').\n  factory('Phone', ['$resource',\n    ($resource: angular.resource.IResourceService) =&gt;\n      $resource('phones/:phoneId.json', {}, {\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: {\n          method: 'GET',\n          params: {phoneId: 'phones'},\n          isArray: true\n        }\n      })\n  ]);\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dmh6ecrljbttwl4sswgbzmdi5\">你可以在應用的路由設定中使用同樣的技巧，那裡你用到了 location 和 route 服務。一旦為它們提供了型別訊息，TypeScript 就能檢查你是否在用型別的正確引數來呼叫它們了。</p>\n<code-example header=\"app/app.config.ts\" path=\"upgrade-phonecat-1-typescript/app/app.config.ts\">\nangular.\n  module('phonecatApp').\n  config(['$locationProvider', '$routeProvider',\n    function config($locationProvider: angular.ILocationProvider,\n                    $routeProvider: angular.route.IRouteProvider) {\n      $locationProvider.hashPrefix('!');\n\n      $routeProvider.\n        when('/phones', {\n          template: '&lt;phone-list&gt;&lt;/phone-list&gt;'\n        }).\n        when('/phones/:phoneId', {\n          template: '&lt;phone-detail&gt;&lt;/phone-detail&gt;'\n        }).\n        otherwise('/phones');\n    }\n  ]);\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7kg7bk1xhl7c2pmhzeut6n4h2\">你用安裝的這個<a href=\"https://www.npmjs.com/package/@types/angular\" title=\"@types/angular | npm\">AngularJS.x 型別定義檔案</a>\n並不是由 Angular 開發組維護的，但它也已經足夠全面了。藉助這些型別定義的幫助，它可以為 AngularJS.x 程式加上全面的型別註解。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ub2wlmo3uozpl2fwd0e6up7u\">如果你想這麼做，就在 <code>tsconfig.json</code> 中啟用 <code>noImplicitAny</code> 設定項。這樣，如果遇到什麼還沒有型別註解的程式碼，TypeScript 編譯器就會顯示一個警告。你可以用它作為指南，告訴你現在與一個完全型別化的專案距離還有多遠。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6kgm0vwmpvj1ol58uw3emjwsu\">你能用的另一個 TypeScript 屬性是<em>類</em>。具體來講，你可以把控制器轉換成類。這種方式下，你離成為 Angular 元件類別就又近了一步，它會令你的升級之路變得更簡單。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4g78rdxt965kx6gt7rjwqpd35\">AngularJS 期望控制器是一個建構式函式。這實際上就是 ES2015/TypeScript 中的類，這也就意味著只要你把一個類註冊為元件控制器，AngularJS 就會愉快的使用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csv7xud6xi72126hpumx8up5k\">新的『電話清單（phone list）』元件控制器類是這樣的：</p>\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-1-typescript/app/phone-list/phone-list.component.ts\">\nclass PhoneListController {\n  phones: any[];\n  orderProp: string;\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['Phone'];\n  constructor(Phone: any) {\n    this.phones = Phone.query();\n    this.orderProp = 'age';\n  }\n\n}\n\nangular.\n  module('phoneList').\n  component('phoneList', {\n    templateUrl: 'phone-list/phone-list.template.html',\n    controller: PhoneListController\n  });\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4gpxojxgvhmkqikcddi56fied\">以前在控制器函式中實現的一切，現在都改由類別的建構式函式來實現了。型別注入註解透過靜態屬性 <code>$inject</code> 被附加到了類別上。在執行時，它們變成了 <code>PhoneListController.$inject</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cfzvd1fzacc0isqqgs4z3ivdv\">該類別還宣告了另外三個成員：電話清單、當前排序鍵的名字和搜尋條件。這些東西你以前就加到了控制器上，只是從來沒有在任何地方顯式定義過它們。最後一個成員從未真正在 TypeScript 程式碼中用過，因為它只是在樣板中被引用過。但為了清晰起見，你還是應該定義出此控制器應有的所有成員。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54ica4cafk4p8qurj8svf8ccb\">在電話詳情控制器中，你有兩個成員：一個是使用者正在檢視的電話，另一個是正在顯示的影象：</p>\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.ts\">\nclass PhoneDetailController {\n  phone: any;\n  mainImageUrl: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['$routeParams', 'Phone'];\n  constructor($routeParams: angular.route.IRouteParamsService, Phone: any) {\n    const phoneId = $routeParams.phoneId;\n    this.phone = Phone.get({phoneId}, (phone: any) =&gt; {\n      this.setImage(phone.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module('phoneDetail').\n  component('phoneDetail', {\n    templateUrl: 'phone-detail/phone-detail.template.html',\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ad6u7fxx79jkenzf2uogtwzz4\">這已經讓你的控制器程式碼看起來更像 Angular 了。你的準備工作做好了，可以引進 Angular 到專案中了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aqfg2smltpetqj108hj2embff\">如果專案中有任何 AngularJS 的服務，它們也是轉換成類別的優秀候選人，像控制器一樣，它們也是建構式函式。但是在本專案中，你只有一個 <code>Phone</code> 工廠，這有點特別，因為它是一個 <code>ngResource</code> 工廠。所以你不會在準備階段中處理它，而是在下一節中直接把它轉換成 Angular 服務。</p>\n<h3 id=\"installing-angular\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2znofqnml4e8p9iiwbmbvosgc\">安裝 Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#installing-angular\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ai4ifz854o0dglqq5lveipvji\">準備工作做完了，接下來就開始把 PhoneCat 升級到 Angular。\n你將在 Angular<a href=\"guide/upgrade#upgrading-with-ngupgrade\" title=\"Upgrading with ngUpgrade - Upgrading from AngularJS to Angular | Angular\">升級模組</a>的幫助下增量式的完成此項工作。\n做完這些之後，就能把 AngularJS 從專案中完全移除了，但其中的關鍵是在不破壞此程式的前提下一小塊一小塊的完成它。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"11lm2x2u3dwsrkqv36l6qs6g\">該專案還包含一些動畫，在此指南的當前版本你先不升級它，請到 <a href=\"guide/animations\" title=\"Introduction to Angular animations | Angular\">Angular 動畫</a>中進一步學習。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2m10qqyetj8ofakqmuvr4981p\">用 SystemJS 模組載入器把 Angular 安裝到專案中。\n看看<a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">升級的準備工作</a>中的指南，並從那裡獲得如下設定：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bl8olvaj2jiqx52xriubqmjvs\">把 Angular 和其它新依賴新增到 <code>package.json</code> 中</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6n6wb73gxx032puqyf6ng60pb\">把 SystemJS 的設定檔案 <code>systemjs.config.js</code> 新增到專案的根目錄。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crvro543i3qapgcrqeak6fj5o\">這些完成之後，就執行：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2btloj4bnqkvmdmn2x126f1wf\">很快你就可以透過 <code>index.html</code> 來把 Angular 的依賴快速載入到應用中，但首先，你得做一些目錄結構調整。這是因為你正準備從 <code>node_modules</code> 中載入檔案，然而目前專案中的每一個檔案都是從 <code>/app</code> 目錄下載入的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4zt060qzjr71zndyf5bhfqgfo\">把 <code>app/index.html</code> 移入專案的根目錄，然後把 <code>package.json</code> 中的開發伺服器根目錄也指向專案的根目錄，而不再是 <code>app</code> 目錄：</p>\n<code-example language=\"json\">\n\n\"start\": \"http-server ./ -a localhost -p 8000 -c-1\",\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5f5686n444rhe4svjbcj4dtda\">現在，你就能把專案根目錄下的每一樣東西發給瀏覽器了。但你<em>不想</em>為了適應開發環境中的設定，被迫修改應用程式碼中用到的所有圖片和數據的路徑。因此，你要往 <code>index.html</code> 中新增一個 <code>&lt;base&gt;</code> 標籤，它將導致各種相對路徑被解析回 <code>/app</code> 目錄：</p>\n<code-example header=\"index.html\" path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"base\">\n&lt;base href=\"/app/\"&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cxapl4jruxphqy3wx9jj00t9h\">現在你可以透過 SystemJS 載入 Angular 了。你還要把 Angular 的膩子指令碼（polyfills） 和 SystemJS 的設定加到 <code>&lt;head&gt;</code> 區的末尾，然後，你能就用 <code>System.import</code> 來載入實際的應用了：</p>\n<code-example header=\"index.html\" path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"angular\">\n&lt;script src=\"/node_modules/core-js/client/shim.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/node_modules/zone.js/bundles/zone.umd.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/node_modules/systemjs/dist/system.src.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/systemjs.config.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  System.import('/app');\n&lt;/script&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"90byeodd0wuoksdrsigkv4quy\">你還需要對<a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">升級的準備工作</a>期間安裝的 <code>systemjs.config.js</code> 檔案做一些調整。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tydf3xjf68uo1nq6b407l1tf\">在 SystemJS 載入期間為瀏覽器指出專案的根在哪裡，而不再使用 <code>&lt;base&gt;</code> URL。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6q4opiw6p9n187nerfvhwgfel\">再透過 <code>npm install @angular/upgrade --save</code> 安裝 <code>upgrade</code> 套件，併為 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 套件新增一個對映。</p>\n<code-example header=\"systemjs.config.js\" path=\"upgrade-phonecat-2-hybrid/systemjs.config.1.js\" region=\"paths\">\nSystem.config({\n  paths: {\n    // paths serve as alias\n    'npm:': '/node_modules/'\n  },\n  map: {\n    'ng-loader': '../src/systemjs-angular-loader.js',\n    app: '/app',\n    /* . . . */\n    '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/fesm2022/static.mjs',\n    /* . . . */\n  },\n\n</code-example>\n<h3 id=\"creating-the-appmodule\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"469dlpeyuq1s9enewj6axozt8\">建立 <code>AppModule</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#creating-the-appmodule\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6nakrshjt5804ywvv45eho0es\">現在，建立一個名叫 <code>AppModule</code> 的根 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 類。這裡已經有了一個名叫 <code>app.module.ts</code> 的檔案，其中存放著 AngularJS 的模組。把它改名為 <code>app.module.ajs.ts</code>，同時也要在 <code>index.html</code> 中修改對應的指令碼名。檔案的內容保留：</p>\n<code-example header=\"app.module.ajs.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ajs.ts\">\n// Define the `phonecatApp` AngularJS module\nangular.module('phonecatApp', [\n  'ngAnimate',\n  'ngRoute',\n  'core',\n  'phoneDetail',\n  'phoneList',\n]);\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6hq6eed001ay4uz4ecsq0wssw\">然後建立一個新的 <code>app.module.ts</code> 檔案，其中是一個最小化的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 類：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"bare\">\nimport { <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a>, <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n}\n\n</code-example>\n<h3 id=\"bootstrapping-a-hybrid-phonecat\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2awdmccx8wycf3lj476w46epu\">引導 PhoneCat 的混合式應用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#bootstrapping-a-hybrid-phonecat\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3f4dzl2n1p3ig3hudtl5apelb\">接下來，你把該應用程式引導改裝為一個同時支援 AngularJS 和 Angular 的<em>混合式應用</em>。然後，就能開始把這些不可分割的小塊轉換到 Angular 了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d78gmvmrk6hqyx3idwqss7014\">本應用現在是使用宿主頁面中附加到 <code>&lt;html&gt;</code> 元素上的 AngularJS 指令 <code>ng-app</code> 引導的。\n但在混合式應用中，不能再這麼用了。你得用<a href=\"guide/upgrade#bootstrapping-hybrid-applications\" title=\"Bootstrapping hybrid applications - Upgrading from AngularJS to Angular | Angular\">ngUpgrade bootstrap</a>方法代替。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"p6ar52v34g9xut3h90c3165x\">首先，從 <code>index.html</code> 中移除 <code>ng-app</code>。然後在 <code>AppModule</code> 中匯入 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，並改寫它的 <code>ngDoBootstrap</code> 方法：</p>\n<code-example header=\"app/app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"upgrademodule\">\nimport { <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72wo20nl11el0ucbcghiknarp\">注意，你正在從內部的 <code>ngDoBootstrap</code> 中引導 AngularJS 模組。它的引數和你在手動引導 AngularJS 時傳給 <code>angular.bootstrap</code> 的是一樣的：應用的根元素，和所要載入的 AngularJS 1.x 模組的陣列。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rfftlsl5g2yudge3qsf56zkw\">最後，在 <code>app/main.ts</code> 中引導這個 <code>AppModule</code>。該檔案在 <code>systemjs.config.js</code> 中被設定為了應用的入口，所以它已經被載入進了瀏覽器中。</p>\n<code-example header=\"app/main.ts\" path=\"upgrade-phonecat-2-hybrid/app/main.ts\" region=\"bootstrap\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ce9501i91tdxo0s0fum64jwr3\">現在，你同時執行著 AngularJS 和 Angular。漂亮！不過你還沒有執行什麼實際的 Angular 元件，這就是接下來要做的。</p>\n<div class=\"callout is-helpful\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2s64pzx4yq6wzcs8nk5m6voy4\">為何要宣告 *angular* 為*angular.IAngularStatic*？</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97jrr6i3f5sw0zqczo82f842a\"><code>@types/angular</code> 宣告為 UMD 模組，根據 <a href=\"https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#support-for-umd-module-definitions\" title=\"Support for UMD module definitions - What's new in TypeScript | microsoft/TypeScript | GitHub\">UMD 型別</a>的工作方式，一旦你在檔案中有一條 ES6 的 <code>import</code> 語句，所有的 UMD 型別化的模型必須都透過 <code>import</code> 語句匯入，\n而是不是全域可用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4d56wxf4mc0j2yhj6plz44hwo\">AngularJS 是日前是透過 <code>index.html</code> 中的 script 標籤載入，這意味著整個應用是作為一個全域變數進行訪問的，使用同一個 <code>angular</code> 變數的實例。但如果你使用 <code>import * as angular from 'angular'</code>，我還需要徹底修改 AngularJS 應用中載入每個檔案的方式，確保 AngularJS 應用被正確載入。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yl4niv5ctmkwe1ynihtcav49\">這需要相當多的努力，通常也不值得去做，特別是當你正在朝著 Angular 前進時。但如果你把 <code>angular</code> 宣告為 <code>angular.IAngularStatic</code>，指明它是一個全域變數，仍然可以獲得全面的型別支援。</p>\n<div class=\"callout is-important\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1m08pu4mhosi1m62xxlhb3d95\">為 Angular 應用手動建立 UMD 套件</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csx6miwnmeic5oochhx3z4hzo\">從 Angular 版本 13 開始，<a href=\"https://github.com/angular/angular/issues/38366\" title=\" Issue 38366: RFC: Ivy Library Distribution| angular/angular | GitHub\">分發格式</a> 中不再包含 UMD 套件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bnw9atk8sz78yztvvxox8n3z3\">如果你的用例需要 UMD 格式，請使用 <a href=\"https://rollupjs.org\" title=\"rollup.js\"><code>rollup</code></a> 從平面 ES 模組檔案手動生成套件。</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b90gqrsxmg83aibnwbgkune2d\">使用 <code>npm</code> 全域安裝 <code>rollup</code></p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm i -g rollup\n\n</code-example>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3kyky6bgqveb5o1evrl6zyaz\">輸出 <code>rollup</code> 的版本並驗證安裝是否成功</p>\n<code-example format=\"shell\" language=\"shell\">\n\nrollup -v\n\n</code-example>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"21p7xxr55egwmnkpc9wzapzzr\">為 <code>rollup</code> 建立 <code>rollup.config.js</code> 設定檔案，以使用全域 <code>ng</code> 指令來引用所有 Angular 框架的匯出。</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9kvbju62jsj6z07y3k69w9fjm\">建立一個名為 <code>rollup.config.js</code> 的檔案</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cl2da77k4m8632nzx7uxqwqrb\">將以下內容複製到 <code>rollup.config.js</code></p>\n<code-example language=\"javascript\">\n\nexport default {\n  input: 'node_modules/@angular/core/fesm2022/core.js',\n  output: {\n    file: 'bundle.js',\n    format: 'umd',\n    name: 'ng'\n  }\n}\n\n</code-example>\n</li>\n</ol>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ks4f1sfuri6j332x3yasaoku\">使用 <code>rollup</code> 根據 <code>rollup.config.js</code> 中的設定建立 <code>bundle.js</code> UMD 套件</p>\n<code-example format=\"shell\" language=\"shell\">\n\nrollup -c rollup.config.js\n\n</code-example>\n</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"70xs4f71yfttn1ezsnezf1poc\"><code>bundle.js</code> 檔案包含你的 UMD 套件。有關 GitHub 上的範例，請參閱 <a href=\"https://github.com/mgechev/angular-umd-bundle\" title=\"UMD Angular bundle | mgechev/angular-umd-bundle | GitHub\">UMD Angular 套件</a>。</p>\n</div>\n</div>\n<h3 id=\"upgrading-the-phone-service\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8dwv6wzkogntbiizz3iy6r02h\">升級 <code>Phone</code> 服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-the-phone-service\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bb8zjh3ihgd3ryrzxivrflkmj\">你要移植到 Angular 的第一個片段是 <code>Phone</code> 工廠（位於 <code>app/core/phone/phone.service.ts</code>），並且讓它能幫助控制器從伺服器上載入電話訊息。目前，它是用 <code>ngResource</code> 實現的，你用它做兩件事：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1bnep086agjgdsolz9q8qx659\">把所有電話的清單載入到電話清單元件中。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9o8vss9x06gjrlrzwsrtehl2q\">把一台電話的詳情載入到電話詳情元件中。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8tahqa9az6udjv06xqc4sobcq\">你可以用 Angular 的服務類別來替換這個實現，而把控制器繼續留在 AngularJS 的地盤上。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cjuqfdrr5q9dys55rlyl96omi\">在這個新版本中，你匯入了 Angular 的 HTTP 模組，並且用它的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務替換掉 <code>ngResource</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bgi4hc3lct6uy2vjszcrjzqjv\">再次開啟 <code>app.module.ts</code> 檔案，匯入並把 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> 新增到 <code>AppModule</code> 的 <code>imports</code> 陣列中：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"httpclientmodule\">\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5yhiio0dvfrc9t8whdrylpkq\">現在，你已經準備好了升級 <code>Phone</code> 服務本身。你將為 <code>phone.service.ts</code> 檔案中基於 ngResource 的服務加上 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 裝飾器：</p>\n<code-example header=\"app/core/phone/phone.service.ts (skeleton)\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"classdef\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n/* . . . */\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"88svncqrhn4o4egnrjplmn9fi\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 裝飾器將把一些依賴注入相關的元資料附加到該類別上，讓 Angular 知道它的依賴訊息。\n就像在<a href=\"guide/dependency-injection\" title=\"Dependency injection in Angular | Angular\">依賴注入指南</a>中描述過的那樣，\n這是一個令牌裝飾器，你要把它用在那些沒有其它 Angular 裝飾器，並且自己有依賴注入的類別上。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54mm97s6rtuph8fnpd094rocu\">在它的建構式函式中，該類別期待一個 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務。<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務將被注入進來並存入一個私有欄位。然後該服務在兩個實例方法中被使用到，一個載入所有電話的清單，另一個載入一台指定電話的詳情：</p>\n<code-example header=\"app/core/phone/phone.service.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"fullclass\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&lt;PhoneData[]&gt; {\n    return this.http.get&lt;PhoneData[]&gt;(`phones/phones.json`);\n  }\n  get(id: string): Observable&lt;PhoneData&gt; {\n    return this.http.get&lt;PhoneData&gt;(`phones/${id}.json`);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6gc81sexl9g8e4taez6q8ay3t\">該方法現在回傳一個 <code>Phone</code> 型別或 <code>Phone[]</code> 型別的可觀察物件（Observable）。這是一個你從未用過的型別，因此你得為它新增一個簡單的介面：</p>\n<code-example header=\"app/core/phone/phone.service.ts (interface)\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"phonedata-interface\">\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"564avzesdda7knej1nga4u1x4\"><code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 有一個 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a></code> 方法，可以使 Angular 服務在 AngularJS 的程式碼中可用。使用它來插入 <code>Phone</code> 服務：</p>\n<code-example header=\"app/core/phone/phone.service.ts (downgrade)\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"downgrade-injectable\">\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n/* . . . */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n/* . . . */\n}\n\nangular.module('core.phone')\n  .factory('phone', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Phone));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ezjlctbd17iq9m0wa0f6bn95c\">最終，該類別的全部程式碼如下：</p>\n<code-example header=\"app/core/phone/phone.service.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\nimport { Observable } from 'rxjs';\n\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&lt;PhoneData[]&gt; {\n    return this.http.get&lt;PhoneData[]&gt;(`phones/phones.json`);\n  }\n  get(id: string): Observable&lt;PhoneData&gt; {\n    return this.http.get&lt;PhoneData&gt;(`phones/${id}.json`);\n  }\n}\n\nangular.module('core.phone')\n  .factory('phone', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Phone));\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1kmlwy4h0ft65g8g2zzurhlat\">注意，你要單獨匯入了 RxJS <code>Observable</code> 中的 <code>map</code> 運算子。對每個 RxJS 運算子都要這麼做。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3o5scof4ez9sei71np2sifya\">這個新的 <code>Phone</code> 服務具有和老的基於 <code>ngResource</code> 的服務相同的屬性。因為它是 Angular 服務，你透過 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>providers</code> 陣列來註冊它：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phone\">\nimport { Phone } from './core/phone/phone.service';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  ],\n  providers: [\n    Phone,\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"v6zov4dhnyvefctiivtpeneo\">現在，你正在用 SystemJS 載入 <code>phone.service.ts</code>，你應該從 <code>index.html</code> 中<strong>移除該服務的 <code>&lt;script&gt;</code> 標籤</strong>。這也是你在升級所有元件時將會做的事。在從 AngularJS 向 Angular 升級的同時，你也把程式碼從指令碼移植為模組。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dw7blgy07goadymyx8pz0c6tp\">這時，你可以把兩個控制器從使用老的服務切換成使用新的。你像降級過的 <code>phone</code> 工廠一樣 <code>$inject</code> 它，但它實際上是一個 <code>Phone</code> 類別的實例，並且你可以據此註解它的型別：</p>\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ajs.ts\">\ndeclare const angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass PhoneListController {\n  phones: PhoneData[];\n  orderProp: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['phone'];\n  constructor(phone: Phone) {\n    phone.query().subscribe(phones =&gt; {\n      this.phones = phones;\n    });\n    this.orderProp = 'age';\n  }\n\n}\n\nangular.\n  module('phoneList').\n  component('phoneList', {\n    templateUrl: 'app/phone-list/phone-list.template.html',\n    controller: PhoneListController\n  });\n\n\n</code-example>\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ajs.ts\">\ndeclare const angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass PhoneDetailController {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['$routeParams', 'phone'];\n  constructor($routeParams: angular.route.IRouteParamsService, phone: Phone) {\n    const phoneId = $routeParams.phoneId;\n    phone.get(phoneId).subscribe(data =&gt; {\n      this.phone = data;\n      this.setImage(data.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module('phoneDetail').\n  component('phoneDetail', {\n    templateUrl: 'phone-detail/phone-detail.template.html',\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"djowhshpdcqrxacv88lgl9mpu\">這裡的兩個 AngularJS 控制器在使用 Angular 的服務！控制器不需要關心這一點，儘管實際上該服務回傳的是可觀察物件（Observable），而不是承諾（Promise）。無論如何，你達到的效果都是把服務移植到 Angular，而不用被迫移植元件來使用它。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bs58wj0w16zmufjo8o0djxflr\">你也能使用 <code>Observable</code> 的 <code>toPromise</code> 方法來在服務中把這些可觀察物件轉變成 Promise，以進一步減小元件控制器中需要修改的程式碼量。</p>\n</div>\n<h3 id=\"upgrading-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"49fjbai69f41uyxcqaza9kbx5\">升級元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-components\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b6hz0l55mmjt68q0h7tjuyc6p\">接下來，把 AngularJS 的控制器升級成 Angular 的元件。每次升級一個，同時仍然保持應用執行在混合模式下。在做轉換的同時，你還將自定義首個 Angular<em>通道</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ewfmjahuxa3wdbn2pcggjyjj4\">先看看電話清單元件。它目前包含一個 TypeScript 控制器類別和一個元件定義物件。重新命名控制器類，並把 AngularJS 的元件定義物件更換為 Angular <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 裝飾器，這樣你就把它變形為 Angular 的元件了。然後，你還要從類別中移除靜態 <code>$inject</code> 屬性。</p>\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"initialclass\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-list',\n  templateUrl: './phone-list.template.html'\n})\nexport class PhoneListComponent {\n  phones: PhoneData[];\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: string;\n  orderProp: string;\n\n  constructor(phone: Phone) {\n    phone.query().subscribe(phones =&gt; {\n      this.phones = phones;\n    });\n    this.orderProp = 'age';\n  }\n  /* . . . */\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"boefxua4y21by9dx1r7aiya3\"><code>selector</code> 屬性是一個 CSS 選擇器，用來定義元件應該被放在頁面的哪。在 AngularJS 中，你會基於元件名字來對應，但是在 Angular 中，你要顯式指定這些選擇器。本元件將會對應元素名字 <code>phone-list</code>，和 AngularJS 版本一樣。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"as8s215nb45za8ty1xxg7t2rr\">現在，將元件的模版也轉換為 Angular 語法。在搜尋控制元件中，把 AngularJS 的 <code>$ctrl</code> 表示式替換成 Angular 的雙向綁定語法 <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code>：</p>\n<code-example header=\"app/phone-list/phone-list.template.html (search controls)\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"controls\">\n&lt;p&gt;\n  Search:\n  &lt;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"<a href=\"api/animations/query\" class=\"code-anchor\">query</a>\" /&gt;\n&lt;/p&gt;\n\n&lt;p&gt;\n  Sort by:\n  &lt;select [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"orderProp\"&gt;\n    &lt;option value=\"name\"&gt;Alphabetical&lt;/option&gt;\n    &lt;option value=\"age\"&gt;Newest&lt;/option&gt;\n  &lt;/select&gt;\n&lt;/p&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ke84bi3ws3dn8ir4lc7s2z06\">把清單中的 <code>ng-repeat</code> 替換為 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>，\n就像<a href=\"guide/built-in-directives\" title=\"Built-in directives | Angular\">樣板語法指南</a>中所講的那樣。\n再把 <code><a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a></code> 標籤的 <code>ng-src</code> 替換為一個標準的 <code>src</code> 屬性（property）繫結。</p>\n<code-example header=\"app/phone-list/phone-list.template.html (phones)\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"list\">\n&lt;ul class=\"phones\"&gt;\n  &lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let phone of getPhones()\"\n      class=\"thumbnail phone-list-item\"&gt;\n    &lt;a href=\"/#!/phones/{{phone.id}}\" class=\"thumb\"&gt;\n      &lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"phone.imageUrl\" [alt]=\"phone.name\" /&gt;\n    &lt;/a&gt;\n    &lt;a href=\"/#!/phones/{{phone.id}}\" class=\"name\"&gt;{{phone.name}}&lt;/a&gt;\n    &lt;p&gt;{{phone.snippet}}&lt;/p&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n</code-example>\n<h4 id=\"no-angular-filter-or-orderby-filters\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7qwi6syagr7qggn8es3zjzv3s\">沒有 Angular <code>filter</code> 或 <code>orderBy</code> 過濾器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#no-angular-filter-or-orderby-filters\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71c20fl7jmratkpjlmlu536gw\">Angular 中並不存在 AngularJS 中內建的 <code>filter</code> 和 <code>orderBy</code> 過濾器。所以你得自己實現進行過濾和排序。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xp322ta84gqzdy1iglxqjt1\">你把 <code>filter</code> 和 <code>orderBy</code> 過濾器改成繫結到控制器中的 <code>getPhones()</code> 方法，透過該方法，元件本身實現了過濾和排序邏輯。</p>\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"getphones\">\ngetPhones(): PhoneData[] {\n  return this.sortPhones(this.filterPhones(this.phones));\n}\n\nprivate filterPhones(phones: PhoneData[]) {\n  if (phones &amp;&amp; this.query) {\n    return phones.filter(phone =&gt; {\n      const name = phone.name.toLowerCase();\n      const snippet = phone.snippet.toLowerCase();\n      return name.indexOf(this.query) &gt;= 0 || snippet.indexOf(this.query) &gt;= 0;\n    });\n  }\n  return phones;\n}\n\nprivate sortPhones(phones: PhoneData[]) {\n  if (phones &amp;&amp; this.orderProp) {\n    return phones\n      .slice(0) // Make a copy\n      .sort((a, b) =&gt; {\n        if (a[this.orderProp] &lt; b[this.orderProp]) {\n          return -1;\n        } else if ([b[this.orderProp] &lt; a[this.orderProp]]) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n  }\n  return phones;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2hfo0a7cyb9ekgdnt3fxbwgz7\">現在你需要降級你的 Angular 元件，這樣你就可以在 AngularJS 中使用它了。你要註冊一個 <code>phoneList</code><em>指令</em>，而不是註冊一個元件，它是一個降級版的 Angular 元件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"42vv9738x8q8b2zmmhawiy2xv\">強制型別轉換 <code>as angular.IDirectiveFactory</code> 告訴 TypeScript 編譯器 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a></code> 方法 的回傳值是一個指令工廠。</p>\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"downgrade-component\">\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n/* . . . */\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-list',\n  templateUrl: './phone-list.template.html'\n})\nexport class PhoneListComponent {\n  /* . . . */\n}\n\nangular.module('phoneList')\n  .directive(\n    'phoneList',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({component: PhoneListComponent}) as angular.IDirectiveFactory\n  );\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bxqzs0jmvez75zd02earpftkk\">新的 <code>PhoneListComponent</code> 使用 Angular 的 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 指令，它位於 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 中。把 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 新增到 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>imports</code> 中，並宣告新的 <code>PhoneListComponent</code> 元件，因為你降級了它：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonelist\">\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eu8c66u4bgg4sq6ctob87uflx\">從 <code>index.html</code> 中移除電話清單元件的&lt;script&gt;標籤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2elcpviv35bin548l5jn1nup\">現在，剩下的 <code>phone-detail.component.ts</code> 檔案變成了這樣：</p>\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ts\">\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { Phone, PhoneData } from '../core/phone/phone.service';\nimport { RouteParams } from '../ajs-upgraded-providers';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-detail',\n  templateUrl: './phone-detail.template.html',\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(routeParams: RouteParams, phone: Phone) {\n    phone.get(routeParams.phoneId).subscribe(data =&gt; {\n      this.phone = data;\n      this.setImage(data.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.module('phoneDetail')\n  .directive(\n    'phoneDetail',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({component: PhoneDetailComponent}) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cajspvqvv7t28qdw3lp7ni2d0\">這和電話清單元件很相似。這裡的竅門在於 <code>RouteParams</code> 型別裝飾器，它標記出了 <code>routeParams</code> 依賴項。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"45l1dxv4rx1lkpmkcv29bigo1\">AngularJS 注入器具有 AngularJS 路由器的依賴，叫做 <code>$routeParams</code>。它被注入到了 <code>PhoneDetails</code> 中，但 <code>PhoneDetails</code> 現在還是一個 AngularJS 控制器。你要把它注入到新的 <code>PhoneDetailsComponent</code> 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"syvi3kgjs3jd6e619k69rye6\">不幸的是，AngularJS 的依賴不會自動在 Angular 的元件中可用。\n你必須使用<a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\" title=\"Making AngularJS Dependencies Injectable to Angular - Upgrading from AngularJS to Angular | Angular\">工廠提供者（factory provider）</a>\n來把 <code>$routeParams</code> 包裝成 Angular 的服務提供者。\n新建一個名叫 <code>ajs-upgraded-providers.ts</code> 的檔案，並且在 <code>app.module.ts</code> 中匯入它：</p>\n<code-example header=\"app/ajs-upgraded-providers.ts\" path=\"upgrade-phonecat-2-hybrid/app/ajs-upgraded-providers.ts\">\nexport abstract class RouteParams {\n  [key: string]: string;\n}\n\nexport function routeParamsFactory(i: any) {\n  return i.get('$routeParams');\n}\n\nexport const routeParamsProvider = {\n  provide: RouteParams,\n  useFactory: routeParamsFactory,\n  deps: ['$injector']\n};\n\n\n</code-example>\n<code-example header=\"app/app.module.ts ($routeParams)\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"routeparams\">\nimport { routeParamsProvider } from './ajs-upgraded-providers';\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aky4ddqt0935pmfz1nj4ht3v5\">把該組件的樣板轉變成 Angular 的語法，程式碼如下：</p>\n<code-example header=\"app/phone-detail/phone-detail.template.html\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.template.html\">\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"phone\"&gt;\n  &lt;div class=\"phone-images\"&gt;\n    &lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>\" class=\"phone\" alt=\"Phone {{ phone.name }} - thumbnail {{ index }}\"\n        [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"{'selected': <a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> === mainImageUrl}\"\n        *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> of phone.images; let index = index;\" /&gt;\n  &lt;/div&gt;\n\n  &lt;h1&gt;{{phone.name}}&lt;/h1&gt;\n\n  &lt;p&gt;{{phone.description}}&lt;/p&gt;\n\n  &lt;ul class=\"phone-thumbs\"&gt;\n    &lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> of phone.images; let index = index\"&gt;\n      &lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>\" (click)=\"setImage(<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>)\" alt=\"Phone {{ phone.name }} - thumbnail {{ index }}\"/&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n\n  &lt;ul class=\"specs\"&gt;\n    &lt;li&gt;\n      &lt;span&gt;Availability and Networks&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Availability&lt;/dt&gt;\n        &lt;dd *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let availability of phone.availability\"&gt;{{availability}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Battery&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;<a href=\"api/core/Type\" class=\"code-anchor\">Type</a>&lt;/dt&gt;\n        &lt;dd&gt;{{phone.battery?.type}}&lt;/dd&gt;\n        &lt;dt&gt;Talk <a href=\"api/common/Time\" class=\"code-anchor\">Time</a>&lt;/dt&gt;\n        &lt;dd&gt;{{phone.battery?.talkTime}}&lt;/dd&gt;\n        &lt;dt&gt;Standby time (<a href=\"api/forms/MaxValidator\" class=\"code-anchor\">max</a>)&lt;/dt&gt;\n        &lt;dd&gt;{{phone.battery?.standbyTime}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Storage and Memory&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;RAM&lt;/dt&gt;\n        &lt;dd&gt;{{phone.storage?.ram}}&lt;/dd&gt;\n        &lt;dt&gt;Internal Storage&lt;/dt&gt;\n        &lt;dd&gt;{{phone.storage?.flash}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Connectivity&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Network Support&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.cell}}&lt;/dd&gt;\n        &lt;dt&gt;WiFi&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.wifi}}&lt;/dd&gt;\n        &lt;dt&gt;Bluetooth&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.bluetooth}}&lt;/dd&gt;\n        &lt;dt&gt;Infrared&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.infrared | checkmark}}&lt;/dd&gt;\n        &lt;dt&gt;GPS&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.gps | checkmark}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Android&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;OS <a href=\"api/core/Version\" class=\"code-anchor\">Version</a>&lt;/dt&gt;\n        &lt;dd&gt;{{phone.android?.os}}&lt;/dd&gt;\n        &lt;dt&gt;UI&lt;/dt&gt;\n        &lt;dd&gt;{{phone.android?.ui}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Size and Weight&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Dimensions&lt;/dt&gt;\n        &lt;dd *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let dim of phone.sizeAndWeight?.dimensions\"&gt;{{dim}}&lt;/dd&gt;\n        &lt;dt&gt;Weight&lt;/dt&gt;\n        &lt;dd&gt;{{phone.sizeAndWeight?.weight}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Display&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Screen size&lt;/dt&gt;\n        &lt;dd&gt;{{phone.display?.screenSize}}&lt;/dd&gt;\n        &lt;dt&gt;Screen resolution&lt;/dt&gt;\n        &lt;dd&gt;{{phone.display?.screenResolution}}&lt;/dd&gt;\n        &lt;dt&gt;Touch screen&lt;/dt&gt;\n        &lt;dd&gt;{{phone.display?.touchScreen | checkmark}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Hardware&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;CPU&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.cpu}}&lt;/dd&gt;\n        &lt;dt&gt;USB&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.usb}}&lt;/dd&gt;\n        &lt;dt&gt;Audio / headphone jack&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.audioJack}}&lt;/dd&gt;\n        &lt;dt&gt;FM Radio&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.fmRadio | checkmark}}&lt;/dd&gt;\n        &lt;dt&gt;Accelerometer&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.accelerometer | checkmark}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Camera&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Primary&lt;/dt&gt;\n        &lt;dd&gt;{{phone.camera?.primary}}&lt;/dd&gt;\n        &lt;dt&gt;Features&lt;/dt&gt;\n        &lt;dd&gt;{{phone.camera?.features?.join(', ')}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Additional Features&lt;/span&gt;\n      &lt;dd&gt;{{phone.additionalFeatures}}&lt;/dd&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehvhpgahgo3tuvd7nt5ezzsh4\">這裡有幾個值得注意的改動：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74evo0ecswxqqbngpi9ii8q2i\">你從所有表示式中移除了 <code>$ctrl.</code> 字首。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7k0miua6q9omg17j20fftq2ri\">正如你在電話清單中做過的那樣，你把 <code>ng-src</code> 替換成了標準的 <code>src</code> 屬性繫結。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"605pyhzdmxpdpqs03uftxifyy\">你在 <code>ng-class</code> 周圍使用了屬性綁定語法。雖然 Angular 中有一個\n和 AngularJS 中<a href=\"guide/built-in-directives\" title=\"Built-in directives | Angular\">非常相似的 <code>ngClass</code></a>指令，\n但是它的值不會神奇的作為表示式進行計算。在 Angular 中，樣板中的屬性（Attribute）值總是被作為\n屬性（Property）表示式計算，而不是作為字串字面量。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f1ry2qy7liozemnutbub7md2x\">你把 <code>ng-repeat</code> 替換成了 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code></p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"463w4xn7vydffd0548irsdbgf\">你把 <code>ng-click</code> 替換成了一個到標準 <code>click</code> 事件的繫結</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8n5kiyo78xh1nhp2hwddnpl6c\">你把整個樣板都包裹進了一個 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 中，這導致只有當存在一個電話時它才會渲染。你必須這麼做，是因為元件首次載入時你還沒有 <code>phone</code> 變數，這些表示式就會引用到一個不存在的值。和 AngularJS 不同，當你嘗試引用未定義物件上的屬性時，Angular 中的表示式不會默默失敗。你必須明確指出這種情況是你所期望的。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a2mczjtzdyltng45w8rgthxrx\">把 <code>PhoneDetailComponent</code> 元件新增到 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <em>declarations</em> 中：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonedetail\">\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ejcwliit5ln8ky1zxdke1ae1e\">你現在應該從 <code>index.html</code> 中移除電話詳情元件的&lt;script&gt;。</p>\n<h4 id=\"add-the-checkmarkpipe\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8p7n1d41pj804mb8uw90l1k4l\">新增 <em>CheckmarkPipe</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#add-the-checkmarkpipe\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bzy26ijw6q3f4ci86428jpw7f\">AngularJS 指令中有一個 <code>checkmark</code><em>過濾器</em>，把它轉換成 Angular 的<strong>通道</strong>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4a3nn65as5ou22prxukvo71dn\">沒有什麼升級方法能把過濾器轉換成通道。但你也並不需要它。把過濾器函式轉換成等價的 Pipe 類非常簡單。實現方式和以前一樣，但把它們包裝進 <code>transform</code> 方法中就可以了。把該檔案改名成 <code>checkmark.pipe.ts</code>，以符合 Angular 中的命名約定：</p>\n<code-example header=\"app/core/checkmark/checkmark.pipe.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.ts\">\nimport { <a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>, <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> } from '@angular/core';\n\n@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({name: 'checkmark'})\nexport class CheckmarkPipe implements <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> {\n  transform(input: boolean) {\n    return input ? '\\u2713' : '\\u2718';\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cxdq0oyapm7rc0fffdp4tij15\">現在，匯入並宣告這個新創建的通道，同時從 <code>index.html</code> 檔案中移除該過濾器的 <code>&lt;script&gt;</code> 標籤：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"checkmarkpipe\">\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n    CheckmarkPipe\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<h3 id=\"aot-compile-the-hybrid-app\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3rivxl7jm3kfk3xcs8hitoj59\">對混合式應用做 AOT 編譯<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#aot-compile-the-hybrid-app\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dv29u1npx71bztg7dmrqicnvt\">要在混合式應用中使用 AOT 編譯，你首先要像其它 Angular 應用一樣設定它，就像<a href=\"guide/aot-compiler\" title=\"Ahead-of-time (AOT) compilation | Angular\">AOT 編譯一章</a>所講的那樣。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9qby0dyp89zql55jpirlvgm03\">然後修改 <code>main-aot.ts</code> 的引導程式碼，來引導 AOT 編譯器所生成的 <code>AppComponentFactory</code>：</p>\n<code-example header=\"app/main-aot.ts\" path=\"upgrade-phonecat-2-hybrid/app/main-aot.ts\">\nimport { <a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a> } from '@angular/platform-browser';\n\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>().bootstrapModule(AppModule);\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cwmaohvfwctg03k21nzusaciz\">你還要把在 <code>index.html</code> 中已經用到的所有 AngularJS 檔案載入到 <code>aot/index.html</code> 中：</p>\n<code-example header=\"aot/index.html\" path=\"upgrade-phonecat-2-hybrid/aot/index.html\">\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n\n    &lt;base href=\"/app/\"&gt;\n\n    &lt;title&gt;Google Phone Gallery&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" /&gt;\n    &lt;link rel=\"stylesheet\" href=\"app.css\" /&gt;\n    &lt;link rel=\"stylesheet\" href=\"app.animations.css\" /&gt;\n\n    &lt;script src=\"https://code.jquery.com/jquery-2.2.4.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://code.angularjs.org/1.5.5/angular.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://code.angularjs.org/1.5.5/angular-animate.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://code.angularjs.org/1.5.5/angular-resource.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://code.angularjs.org/1.5.5/angular-route.js\"&gt;&lt;/script&gt;\n\n    &lt;script src=\"app.module.ajs.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"app.config.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"app.animations.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"core/core.module.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"core/phone/phone.module.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"phone-list/phone-list.module.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"phone-detail/phone-detail.module.js\"&gt;&lt;/script&gt;\n\n    &lt;script src=\"/node_modules/core-js/client/shim.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"/node_modules/zone.js/bundles/zone.umd.min.js\"&gt;&lt;/script&gt;\n\n    &lt;script&gt;window.module = 'aot';&lt;/script&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;div class=\"view-container\"&gt;\n      &lt;div ng-view class=\"view-frame\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n  &lt;script src=\"/dist/build.js\"&gt;&lt;/script&gt;\n&lt;/html&gt;\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6nrt47wz4ijl6osls4i145q1\">這些檔案要帶著相應的膩子指令碼複製到一起。應用執行時需要的檔案，比如電話清單 <code>.json</code> 和圖片，也需要複製過去。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aujydlvixig2w4v4y98qahk3d\">透過 <code>npm install fs-extra --save-dev</code> 安裝 <code>fs-extra</code> 可以更好的複製檔案，並且把 <code>copy-dist-files.js</code> 檔案改成這樣：</p>\n<code-example header=\"copy-dist-files.js\" path=\"upgrade-phonecat-2-hybrid/copy-dist-files.js\">\nvar fsExtra = require('fs-extra');\nvar resources = [\n  // polyfills\n  'node_modules/core-js/client/shim.min.js',\n  'node_modules/zone.js/bundles/zone.umd.min.js',\n  // css\n  'app/app.css',\n  'app/app.animations.css',\n  // images and json files\n  'app/<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>/',\n  'app/phones/',\n  // app files\n  'app/app.module.ajs.js',\n  'app/app.config.js',\n  'app/app.animations.js',\n  'app/core/core.module.js',\n  'app/core/phone/phone.module.js',\n  'app/phone-list/phone-list.module.js',\n  'app/phone-detail/phone-detail.module.js'\n];\nresources.map(function(sourcePath) {\n  // Need to rename zone.umd.min.js to zone.min.js\n  var destPath = `aot/${sourcePath}`.replace('.umd.min.js', '.min.js');\n  fsExtra.copySync(sourcePath, destPath);\n});\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2y7kzp6aqz6ml4jcmuuiy9exd\">這就是想要在升級應用期間 AOT 編譯所需的一切！</p>\n<h3 id=\"adding-the-angular-router-and-bootstrap\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"89sjoxfppumsw0kot19e7a2u0\">新增 Angular 路由器和引導程式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#adding-the-angular-router-and-bootstrap\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5weqn7yv0o9f88ds7ljm7ztoq\">此刻，你已經把所有 AngularJS 的元件替換成了它們在 Angular 中的等價物，不過你仍然在 AngularJS 路由器中使用它們。</p>\n<h4 id=\"add-the-angular-router\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8i5lngpd5rud5ku9p1s6e8r6c\">新增 Angular 路由器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#add-the-angular-router\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7y3jnslffhhymit10e0ndumjt\">Angular 有一個<a href=\"guide/router\" title=\"Common Routing Tasks | Angular\">全新的路由器</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"av17j8f5alk0a7ddjxc8xhhmx\">像所有的路由器一樣，它需要在 UI 中指定一個位置來顯示路由的檢視。在 Angular 中，它是 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>，並位於應用元件樹頂部的<em>根元件</em>中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"33w1nja6m3ua0wb0q1ocrp4u4\">你還沒有這樣一個根元件，因為該應用仍然是像一個 AngularJS 應用那樣被管理的。建立新的 <code>app.component.ts</code> 檔案，放入像這樣的 <code>AppComponent</code> 類：</p>\n<code-example header=\"app/app.component.ts\" path=\"upgrade-phonecat-3-final/app/app.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phonecat-app',\n  template: '&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;'\n})\nexport class AppComponent { }\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8j8z8pqe1rp8jff85wk420zvs\">它有一個很簡單的樣板，只包含 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>。該組件只負責渲染活動路由的內容，此外啥也不幹。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56aszszfco0y146j05p5wta53\">該選擇器告訴 Angular：當應用啟動時就把這個根元件插入到宿主頁面的 <code>&lt;phonecat-app&gt;</code> 元素中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekx0zqvhwwqfxur5lxwzclyzy\">把這個 <code>&lt;phonecat-app&gt;</code> 元素插入到 <code>index.html</code> 中。用它來代替 AngularJS 中的 <code>ng-view</code> 指令：</p>\n<code-example header=\"index.html (body)\" path=\"upgrade-phonecat-3-final/index.html\" region=\"appcomponent\">\n&lt;body&gt;\n  &lt;phonecat-app&gt;&lt;/phonecat-app&gt;\n&lt;/body&gt;\n\n</code-example>\n<h4 id=\"create-the-routing-module\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4dhtn2vvbhja2vzgccu18a8da\">建立<em>路由模組</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-the-routing-module\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wf4ks68f4bbi6xpi0v4lo3ef\">無論在 AngularJS 還是 Angular 或其它框架中，路由器都需要進行設定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4yltjwkonpcvkxpz23rwvghdc\">Angular 路由器設定的詳情最好去查閱下<a href=\"guide/router\" title=\"Common Routing Tasks | Angular\">路由與導向</a>文件。\n它建議你建立一個專們用於路由器設定的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>（名叫<em>路由模組</em>）。</p>\n<code-example header=\"app/app-routing.module.ts\" path=\"upgrade-phonecat-3-final/app/app-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router';\nimport { <a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a>, <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a>, <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a> } from '@angular/common';\n\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: '', redirectTo: 'phones', pathMatch: 'full' },\n  { path: 'phones',          component: PhoneListComponent },\n  { path: 'phones/:phoneId', component: PhoneDetailComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ RouterModule.forRoot(routes) ],\n  exports: [ <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> ],\n  providers: [\n    { provide: <a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a>, useValue: '!' },\n    { provide: <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a>, useClass: <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a> },\n  ]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37tmswd4p1n1gwnf7z1ffc08p\">該模組定義了一個 <code>routes</code> 物件，它帶有兩個路由，分別指向兩個電話元件，以及為空路徑指定的預設路由。它把 <code>routes</code> 傳給 <code>RouterModule.forRoot</code> 方法，該方法會完成剩下的事。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1kreqg5n60clgs2egxfuuvs8o\">一些額外的提供者讓路由器使用『hash』策略解析 URL，比如 <code>#!/phones</code>，而不是預設的『Push State』策略。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"djnovvy5nx5zq09tpk2p7kcv7\">現在，修改 <code>AppModule</code>，讓它匯入這個 <code>AppRoutingModule</code>，並同時宣告根元件 <code>AppComponent</code>。這會告訴 Angular，它應該使用根元件 <code>AppComponent</code> 引導應用，並把它的檢視插入到宿主頁面中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ypfdsusoy7tyoqai2el8r7po\">你還要從 <code>app.module.ts</code> 中移除呼叫 <code>ngDoBootstrap()</code> 來引導 AngularJS 模組的程式碼，以及對 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 的匯入程式碼。</p>\n<code-example header=\"app/app.module.ts\" path=\"upgrade-phonecat-3-final/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\nimport { Phone } from './core/phone/phone.service';\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"17raz9nvng13eiv51h5uo5vmj\">而且，由於你現在直接路由到 <code>PhoneListComponent</code> 和 <code>PhoneDetailComponent</code>，而不再使用帶 <code>&lt;phone-list&gt;</code> 或 <code>&lt;phone-detail&gt;</code> 標籤的路由樣板，因此你同樣不再需要它們的 Angular 選擇器。</p>\n<h4 id=\"generate-links-for-each-phone\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5khpmh2kixb29568yuz4vzmgo\">為每個電話生成連結<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#generate-links-for-each-phone\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6wr6rawo96h965xu8ha5fgacn\">在電話清單中，你不用再被迫硬編碼電話詳情的連結了。你可以透過把每個電話的 <code>id</code> 繫結到 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 指令來生成它們了，該指令的建構式函式會為 <code>PhoneDetailComponent</code> 生成正確的 URL：</p>\n<code-example header=\"app/phone-list/phone-list.template.html (list with links)\" path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.template.html\" region=\"list\">\n&lt;ul class=\"phones\"&gt;\n  &lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let phone of getPhones()\"\n      class=\"thumbnail phone-list-item\"&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/phones', phone.id]\" class=\"thumb\"&gt;\n      &lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"phone.imageUrl\" [alt]=\"phone.name\" /&gt;\n    &lt;/a&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/phones', phone.id]\" class=\"name\"&gt;{{phone.name}}&lt;/a&gt;\n    &lt;p&gt;{{phone.snippet}}&lt;/p&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eoz6phduhkzsf3912cukt6z1w\">要了解詳情，請檢視<a href=\"guide/router\">路由與導向</a>頁。</p>\n</div>\n<h4 id=\"use-route-parameters\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a74h5g517am5ijlrhaeylo9ll\">使用路由引數<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#use-route-parameters\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ddm96lu74vq2tj5uiir3r6dr\">Angular 路由器會傳入不同的路由引數。改正 <code>PhoneDetail</code> 元件的建構式函式，讓它改用注入進來的 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 物件。從 <code>ActivatedRoute.snapshot.params</code> 中提取出 <code>phoneId</code>，並像以前一樣獲取手機的資料：</p>\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-detail',\n  templateUrl: './phone-detail.template.html'\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(activatedRoute: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, phone: Phone) {\n    phone.get(activatedRoute.snapshot.paramMap.get('phoneId'))\n      .subscribe((p: PhoneData) =&gt; {\n        this.phone = p;\n        this.setImage(p.images[0]);\n      });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bylv6mboeefk0bwumnfndvfjy\">你現在執行的就是純正的 Angular 應用了！</p>\n<h3 id=\"say-goodbye-to-angularjs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jk30yicn3yf3ylvkhjl7qzr7\">再見，AngularJS！<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#say-goodbye-to-angularjs\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6n7eog71lop7isuokd17c00m1\">終於可以把輔助訓練的輪子摘下來了！讓你的應用作為一個純粹、閃亮的 Angular 程式開始它的新生命吧。剩下的所有任務就是移除程式碼 —— 這當然是每個工程師最喜歡的任務！</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eglryhb40y0u563ik5q0axesg\">應用仍然以混合式應用的方式啟動，然而這再也沒有必要了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"87sqohtt0erx6k0g4vpdu2335\">把應用的引導（<code>bootstrap</code>）方式從 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 的改為 Angular 的。</p>\n<code-example header=\"main.ts\" path=\"upgrade-phonecat-3-final/app/main.ts\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1v6luafdwozmagc8ptbs6t9ct\">如果你還沒有這麼做，請從 <code>app.module.ts 刪除所有 </code>UpgradeModule 的引用，\n以及所有用於 AngularJS 服務的<a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">工廠提供者（factory provider）</a>和 <code>app/ajs-upgraded-providers.ts</code> 檔案。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cfn7uk4a7jjcqlvgr96o94g9u\">還要刪除所有的 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> 或 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 以及與 AngularJS 相關的工廠或指令宣告。</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-3-final/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\nimport { Phone } from './core/phone/phone.service';\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ajv18ltme7i0i0lsmatmhiev\">你還要完全移除了下列檔案。它們是 AngularJS 的模組設定檔案和型別定義檔案，在 Angular 中不需要了：</p>\n<ul>\n<li><code>app/app.module.ajs.ts</code></li>\n<li><code>app/app.config.ts</code></li>\n<li><code>app/core/core.module.ts</code></li>\n<li><code>app/core/phone/phone.module.ts</code></li>\n<li><code>app/phone-detail/phone-detail.module.ts</code></li>\n<li><code>app/phone-list/phone-list.module.ts</code></li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4amnphy488xz2xjx18uzy7d33\">還需要解除安裝 AngularJS 的外部型別定義檔案。你現在只需要留下 Jasmine 和 Angular 所需的膩子指令碼。<code>systemjs.config.js</code> 中的 <code>@angular/upgrade</code> 套件及其對映也可以移除了。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm uninstall @angular/upgrade --save\nnpm uninstall @types/angular @types/angular-animate @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8t39g6gvnf3h18sbdch6eek8q\">最後，從 <code>index.html</code> 中，移除所有對 AngularJS 和 jQuery 指令碼的引用。當這些全部做完時，<code>index.html</code> 應該是這樣的：</p>\n<code-example header=\"index.html\" path=\"upgrade-phonecat-3-final/index.html\" region=\"full\">\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;base href=\"/app/\"&gt;\n    &lt;title&gt;Google Phone Gallery&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" /&gt;\n    &lt;link rel=\"stylesheet\" href=\"app.css\" /&gt;\n\n    &lt;script src=\"/node_modules/core-js/client/shim.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"/node_modules/zone.js/bundles/zone.umd.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"/node_modules/systemjs/dist/system.src.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"/systemjs.config.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n      System.import('/app');\n    &lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;phonecat-app&gt;&lt;/phonecat-app&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63gpn6l8xr8u5t084z04cbux\">這是你最後一次看到 AngularJS 了！它曾經帶給你很多幫助，不過現在，該說再見了。</p>\n<h2 id=\"appendix-upgrading-phonecat-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"93h9q1ecby8g0mt62fnrvqz7b\">附錄：升級 PhoneCat 的測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#appendix-upgrading-phonecat-tests\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7qllitjdbi3soumslqrdh80gs\">測試不僅要在升級過程中被保留，它還是確保應用在升級過程中不會被破壞的一個安全指示器。要達到這個目的，E2E 測試尤其有用。</p>\n<h3 id=\"e2e-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bycajx2kfk5kvivpigw6ictqp\">E2E 測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#e2e-tests\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6h2qbei12xhyqjhcp4c163flb\">PhoneCat 專案中同時有基於 Protractor 的 E2E 測試和一些基於 Karma 的單元測試。對這兩者來說，E2E 測試的轉換要容易得多：根據定義，E2E 測試透過與應用中顯示的這些 UI 元素互動，從<em>外部</em>訪問你的應用來進行測試。E2E 測試實際上並不關心這些應用中各部件的內部結構。這也意味著，雖然你已經修改了此應用程式，但是 E2E 測試套件仍然應該能像以前一樣全部透過。因為從使用者的角度來說，你並沒有改變應用的行為。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4rip7ayw64b3o5lee3wp7sj1x\">在轉成 TypeScript 期間，你不用做什麼就能讓 E2E 測試正常工作。但是當你想改成按照混合式應用進行引導時，必須做一些修改。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6cbvijdqcbdo70n568nc46a\">再對 <code>protractor-conf.js</code> 做下列修改，與混合應用同步：</p>\n<code-example language=\"javascript\">\n\nng12Hybrid: true\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qw0grfumnlz53n8qyotg4943\">當你開始元件和模組升級到 Angular 時，還需要一系列後續的修改。這是因為 E2E 測試有一些對應器是 AngularJS 中特有的。對於 PhoneCat 來說，為了讓它能在 Angular 下工作，你得做下列修改：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5l5yjt6u9p6x5rbra0kndg2p2\">以前的程式碼</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4g1ygklwijsosjbphu8fvwuxw\">新程式碼</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>by.repeater('phone in $ctrl.phones').column('phone.name')</code></td>\n<td align=\"left\"><code>by.css('.phones .name')</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72ymqgale68ksrzzic8xjua9s\">重複器對應器依賴於 AngularJS 的 \n<code>ng-repeat</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.repeater('phone in $ctrl.phones')</code></td>\n<td align=\"left\"><code>by.css('.phones li')</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72ymqgale68ksrzzic8xjua9s\">重複器對應器依賴於 AngularJS 的 \n<code>ng-repeat</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.model('$ctrl.query')</code></td>\n<td align=\"left\"><code>by.css('input')</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bi8kwrnur727udslng5e67st\">模型對應器依賴於 AngularJS 的 \n<code>ng-model</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.model('$ctrl.orderProp')</code></td>\n<td align=\"left\"><code>by.css('select')</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bi8kwrnur727udslng5e67st\">模型對應器依賴於 AngularJS 的 \n<code>ng-model</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.binding('$ctrl.phone.name')</code></td>\n<td align=\"left\"><code>by.css('h1')</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bxffalog0cu8l3uvcgwwdex61\">繫結對應器依賴於 AngularJS 的資料繫結</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4s66p9s8srhvg7fco8pxfu3ra\">當引導方式從 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 切換到純 Angular 的時，AngularJS 就從頁面中完全消失了。此時，你需要告訴 Protractor，它不用再找 AngularJS 應用了，而是從頁面中查詢 <em>Angular</em> 應用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bznksfrw69zgjmv4xefjw7l0q\">替換之前在 <code>protractor-conf.js</code> 中加入 <code>ng12Hybrid</code>，象這樣：</p>\n<code-example language=\"javascript\">\n\nuseAllAngular2AppRoots: true,\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3rxvpgpe8o5plgmkvk527kugq\">同樣，<code>PhoneCat</code> 的測試程式碼中有兩個 Protractor API 呼叫內部使用了 AngularJS 的 <code>$location</code>。該服務沒有了，你就得把這些呼叫用一個 WebDriver 的通用 URL API 代替。第一個 API 是『重導向（redirect）』規約：</p>\n<code-example header=\"e2e-tests/scenarios.ts\" path=\"upgrade-phonecat-3-final/e2e-spec.ts\" region=\"redirect\">\nit('should redirect `index.html` to `index.html#!/phones', <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  await browser.get('index.html');\n  await browser.waitForAngular();\n  const url = await browser.getCurrentUrl();\n  expect(url.endsWith('/phones')).toBe(true);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2nynk4xe9rh4py7ojuw68k6x\">然後是『電話連結（phone links）』規約：</p>\n<code-example header=\"e2e-tests/scenarios.ts\" path=\"upgrade-phonecat-3-final/e2e-spec.ts\" region=\"links\">\nit('should render phone specific links', <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a> () =&gt; {\n  const <a href=\"api/animations/query\" class=\"code-anchor\">query</a> = element(by.css('input'));\n  await query.sendKeys('nexus');\n  await element.all(by.css('.phones li a')).first().click();\n  const url = await browser.getCurrentUrl();\n  expect(url.endsWith('/phones/nexus-s')).toBe(true);\n});\n\n</code-example>\n<h3 id=\"unit-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cphicttr9x4gr1yr1e8yq440r\">單元測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#unit-tests\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aakqoii9k6339qjclxmre4j42\">另一方面，對於單元測試來說，需要更多的轉化工作。實際上，它們需要隨著產品程式碼一起升級。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5uvz3opun4jsqy8a7qh8a2efm\">在轉成 TypeScript 期間，嚴格來講沒有什麼改動是必須的。但把單元測試程式碼轉成 TypeScript 仍然是個好主意，。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3d39vng1wxycgeic8dgopheqx\">比如，在這個電話詳情元件的規約中，你不僅用到了 ES2015 中的箭頭函式和塊作用域變數這些屬性，還為所用的一些 AngularJS 服務提供了型別定義。</p>\n<code-example header=\"app/phone-detail/phone-detail.component.spec.ts\" path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.spec.ts\">\ndescribe('phoneDetail', () =&gt; {\n\n  // Load the module that contains the `phoneDetail` component before each test\n  beforeEach(angular.mock.module('phoneDetail'));\n\n  // Test the controller\n  describe('PhoneDetailController', () =&gt; {\n    let $httpBackend: angular.IHttpBackendService;\n    let ctrl: any;\n    const xyzPhoneData = {\n      name: 'phone xyz',\n      images: ['image/url1.png', 'image/url2.png']\n    };\n\n    beforeEach(inject(($componentController: any,\n                       _$httpBackend_: angular.IHttpBackendService,\n                       $routeParams: angular.route.IRouteParamsService) =&gt; {\n      $httpBackend = _$httpBackend_;\n      $httpBackend.expectGET('phones/xyz.json').respond(xyzPhoneData);\n\n      $routeParams.phoneId = 'xyz';\n\n      ctrl = $componentController('phoneDetail');\n    }));\n\n    it('should fetch the phone details', () =&gt; {\n      jasmine.addCustomEqualityTester(angular.equals);\n\n      expect(ctrl.phone).toEqual({});\n\n      $httpBackend.flush();\n      expect(ctrl.phone).toEqual(xyzPhoneData);\n    });\n\n  });\n\n});\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ei7eyemx9b1t3x63rvg14s9dj\">一旦你開始了升級過程並引入了 SystemJS，還需要對 Karma 進行設定修改。你需要讓 SystemJS 載入所有的 Angular 新程式碼，</p>\n<code-example header=\"karma-test-shim.js\" path=\"upgrade-phonecat-2-hybrid/karma-test-shim.1.js\">\n// /*global jasmine, __karma__, window*/\nError.stackTraceLimit = 0; // \"No stacktrace\"\" is usually best for app testing.\n\n// Uncomment to get full stacktrace output. Sometimes helpful, usually not.\n// Error.stackTraceLimit = Infinity; //\n\njasmine.DEFAULT_TIMEOUT_INTERVAL = 1000;\n\nvar builtPath = '/base/app/';\n\n__karma__.loaded = function () { };\n\nfunction isJsFile(path) {\n  return path.slice(-3) == '.js';\n}\n\nfunction isSpecFile(path) {\n  return /\\.spec\\.(.*\\.)?js$/.test(path);\n}\n\nfunction isBuiltFile(path) {\n  return isJsFile(path) &amp;&amp; (path.slice(0, builtPath.length) == builtPath);\n}\n\nvar allSpecFiles = Object.keys(window.__karma__.files)\n  .filter(isSpecFile)\n  .filter(isBuiltFile);\n\nSystem.config({\n  baseURL: '/base',\n  // Extend usual application package list with test folder\n  packages: { 'testing': { main: 'index.js', defaultExtension: 'js' } },\n\n  // Assume npm: is set in `paths` in systemjs.config\n  // Map the angular testing bundles\n  map: {\n    '@angular/core/testing': 'npm:@angular/core/fesm2022/testing.mjs',\n    '@angular/common/testing': 'npm:@angular/common/fesm2022/testing.mjs',\n    '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing': 'npm:@angular/common/fesm2022/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing.mjs',\n    '@angular/platform-browser/testing': 'npm:@angular/platform-browser/fesm2022/testing.mjs',\n    '@angular/platform-browser-dynamic/testing': 'npm:@angular/platform-browser-dynamic/fesm2022/testing.mjs',\n    '@angular/router/testing': 'npm:@angular/router/fesm2022/testing.mjs',\n    '@angular/forms/testing': 'npm:@angular/forms/fesm2022/testing.mjs',\n  },\n});\n\nSystem.import('systemjs.config.js')\n  .then(importSystemJsExtras)\n  .then(initTestBed)\n  .then(initTesting);\n\n/** <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a> SystemJS configuration extras. Keep going w/o it */\nfunction importSystemJsExtras(){\n  return System.import('systemjs.config.extras.js')\n  .catch(function(reason) {\n    console.log(\n      'Warning: System.import could not load the optional \"systemjs.config.extras.js\". Did you omit it by accident? Continuing without it.'\n    );\n    console.log(reason);\n  });\n}\n\nfunction initTestBed() {\n  return Promise.all([\n    System.import('@angular/core/testing'),\n    System.import('@angular/platform-browser-dynamic/testing')\n  ])\n\n  .then(function (providers) {\n    var coreTesting    = providers[0];\n    var browserTesting = providers[1];\n\n    coreTesting.TestBed.initTestEnvironment(\n      browserTesting.BrowserDynamicTestingModule,\n      browserTesting.platformBrowserDynamicTesting());\n  })\n}\n\n// Import all spec files and start karma\nfunction initTesting() {\n  return Promise.all(\n    allSpecFiles.map(function (moduleName) {\n      return System.import(moduleName);\n    })\n  )\n  .then(__karma__.start, __karma__.error);\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3s9irvzi9wwzh63yyunmqhaiw\">這個 shim 檔案首先載入了 SystemJS 的設定，然後是 Angular 的測試支援庫，然後是應用本身的規約檔案。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"lao1iqeglogizjq6zmzzcivx\">然後需要修改 Karma 設定，來讓它使用本應用的根目錄作為基礎目錄（base directory），而不是 <code>app</code>。</p>\n<code-example header=\"karma.conf.js\" path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"basepath\">\nbasePath: './',\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e1rq2jmok1ew7dmapoljwu103\">一旦這些完成了，你就能載入 SystemJS 和其它依賴，並切換設定檔案來載入那些應用文件，而<em>不用</em>在 Karma 頁面中包含它們。你要讓這個 shim 檔案和 SystemJS 去載入它們。</p>\n<code-example header=\"karma.conf.js\" path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"files\">\n// System.js for module loading\n'node_modules/systemjs/dist/system.src.js',\n\n// Polyfills\n'node_modules/core-js/client/shim.js',\n\n// zone.js\n'node_modules/zone.js/bundles/zone.umd.js',\n'node_modules/zone.js/bundles/zone-testing.umd.js',\n\n// RxJs.\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/rxjs/**/*.js', included: false, watched: false },\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/rxjs/**/*.js.map', included: false, watched: false },\n\n// Angular itself and the testing library\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/@angular/**/*.mjs', included: false, watched: false },\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/@angular/**/*.mjs.map', included: false, watched: false },\n\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/tslib/tslib.js', included: false, watched: false },\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/systemjs-plugin-babel/**/*.js', included: false, watched: false },\n\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'systemjs.config.js', included: false, watched: false},\n'karma-test-shim.js',\n\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/**/*.module.js', included: false, watched: true},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/*!(.module|.spec).js', included: false, watched: true},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/!(bower_components)/**/*!(.module|.spec).js', included: false, watched: true},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/**/*.spec.js', included: false, watched: true},\n\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: '**/*.html', included: false, watched: true},\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91hnjagujeutwkn8n11wjcvvz\">由於 Angular 元件中的 HTML 樣板也同樣要被載入，所以你得幫 Karma 一把，幫它在正確的路徑下找到這些樣板：</p>\n<code-example header=\"karma.conf.js\" path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"html\">\n// proxied base paths for loading assets\nproxies: {\n  // required for component assets fetched by Angular's compiler\n  '/phone-detail': '/base/app/phone-detail',\n  '/phone-list': '/base/app/phone-list'\n},\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2w4j5qntxkcjislenhnjzbj5n\">如果產品程式碼被切換到了 Angular，單元測試檔案本身也需要切換過來。對勾（checkmark）通道的規約可能是最直觀的，因為它沒有任何依賴：</p>\n<code-example header=\"app/core/checkmark/checkmark.pipe.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.spec.ts\">\nimport { CheckmarkPipe } from './checkmark.pipe';\n\ndescribe('CheckmarkPipe', () =&gt; {\n\n  it('should convert boolean values to unicode checkmark or cross', () =&gt; {\n    const checkmarkPipe = new CheckmarkPipe();\n    expect(checkmarkPipe.transform(true)).toBe('\\u2713');\n    expect(checkmarkPipe.transform(false)).toBe('\\u2718');\n  });\n});\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8b078inmpyt28v6s5gt7tf20g\"><code>Phone</code> 服務的測試會牽扯到一點別的。你需要把模擬版的 AngularJS <code>$httpBackend</code> 服務切換到模擬板的 Angular Http 後端。</p>\n<code-example header=\"app/core/phone/phone.service.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.spec.ts\">\nimport { inject, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>, <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing';\nimport { Phone, PhoneData } from './phone.service';\n\ndescribe('Phone', () =&gt; {\n  let phone: Phone;\n  const phonesData: PhoneData[] = [\n    {name: 'Phone X', snippet: '', images: []},\n    {name: 'Phone Y', snippet: '', images: []},\n    {name: 'Phone Z', snippet: '', images: []}\n  ];\n  let httpMock: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>;\n\n  beforeEach(() =&gt; {\n    TestBed.configureTestingModule({\n      imports: [\n        <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>\n      ],\n      providers: [\n        Phone,\n      ]\n    });\n  });\n\n  beforeEach(inject([<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>, Phone], (_httpMock_: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>, _phone_: Phone) =&gt; {\n    httpMock = _httpMock_;\n    phone = _phone_;\n  }));\n\n  afterEach(() =&gt; {\n    httpMock.verify();\n  });\n\n  it('should fetch the phones data from `/phones/phones.json`', () =&gt; {\n    phone.query().subscribe(result =&gt; {\n      expect(result).toEqual(phonesData);\n    });\n    const req = httpMock.expectOne(`/phones/phones.json`);\n    req.flush(phonesData);\n  });\n\n});\n\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3vna7g85coqh4jhzhahg7439s\">對於元件的規約，你可以模擬出 <code>Phone</code> 服務本身，並且讓它提供電話的資料。你可以對這些元件使用 Angular 的元件單元測試 API。</p>\n<code-example header=\"app/phone-detail/phone-detail.component.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.spec.ts\">\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\nimport { PhoneDetailComponent&nbsp;} from './phone-detail.component';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\nimport { CheckmarkPipe } from '../core/checkmark/checkmark.pipe';\n\nfunction xyzPhoneData(): PhoneData {\n  return {name: 'phone xyz', snippet: '', images: ['image/url1.png', 'image/url2.png']};\n}\n\nclass MockPhone {\n  get(id: string): Observable&lt;PhoneData&gt; {\n    return of(xyzPhoneData());\n  }\n}\n\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n\ndescribe('PhoneDetailComponent', () =&gt; {\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n    TestBed.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({ params: { phoneId: 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n  it('should fetch phone detail', () =&gt; {\n    const fixture = TestBed.createComponent(PhoneDetailComponent);\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('h1').textContent).toContain(xyzPhoneData().name);\n  });\n});\n\n\n</code-example>\n<code-example header=\"app/phone-list/phone-list.component.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.spec.ts\">\nimport {<a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>} from '@angular/common/testing';\nimport {<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>} from '@angular/core';\nimport {<a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>} from '@angular/core/testing';\nimport {<a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>} from '@angular/router';\nimport {Observable, of} from 'rxjs';\n\nimport {Phone, PhoneData} from '../core/phone/phone.service';\n\nimport {PhoneListComponent} from './phone-list.component';\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\nclass MockPhone {\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&lt;PhoneData[]&gt; {\n    return of([\n      {name: 'Nexus S', snippet: '', images: []}, {name: 'Motorola DROID', snippet: '', images: []}\n    ]);\n  }\n}\n\nlet fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&lt;PhoneListComponent&gt;;\n\ndescribe('PhoneList', () =&gt; {\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n        .configureTestingModule({\n          declarations: [PhoneListComponent],\n          providers: [\n            {provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({params: {phoneId: 1}})},\n            {provide: <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>, useClass: <a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>},\n            {provide: Phone, useClass: MockPhone},\n          ],\n          schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>]\n        })\n        .compileComponents();\n  }));\n\n  beforeEach(() =&gt; {\n    fixture = TestBed.createComponent(PhoneListComponent);\n  });\n\n  it('should create \"phones\" <a href=\"api/core/model\" class=\"code-anchor\">model</a> with 2 phones fetched from xhr', () =&gt; {\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelectorAll('.phone-list-item').length).toBe(2);\n    expect(compiled.querySelector('.phone-list-item:nth-child(1)').textContent)\n        .toContain('Motorola DROID');\n    expect(compiled.querySelector('.phone-list-item:nth-child(2)').textContent)\n        .toContain('Nexus S');\n  });\n\n  xit('should set the default value of orderProp <a href=\"api/core/model\" class=\"code-anchor\">model</a>', () =&gt; {\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('select option:last-child').selected).toBe(true);\n  });\n});\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7zm2le084hditznhlggdfrhae\">最後，當你切換到 Angular 路由時，需要重新過一遍這些元件測試。對詳情元件來說，你需要提供一個 Angular <code>RouteParams</code> 的 mock 物件，而不再用 AngularJS 中的 <code>$routeParams</code>。</p>\n<code-example header=\"app/phone-detail/phone-detail.component.spec.ts\" path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.spec.ts\" region=\"activatedroute\">\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n/* . . . */\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n  /* . . . */\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n    TestBed.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({ params: { phoneId: 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vptpixkf8d42f8zpzg5uujkg\">對於電話清單元件，還要再做少量的調整，以便路由器能讓 <code>RouteLink</code> 指令正常工作。</p>\n<code-example header=\"app/phone-list/phone-list.component.spec.ts\" path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.component.spec.ts\" region=\"routestuff\">\nimport {<a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>} from '@angular/common/testing';\nimport {<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>} from '@angular/core';\nimport {<a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>} from '@angular/core/testing';\nimport {<a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>} from '@angular/router';\nimport {Observable, of} from 'rxjs';\n\nimport {Phone, PhoneData} from '../core/phone/phone.service';\n\nimport {PhoneListComponent} from './phone-list.component';\n\n  /* . . . */\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n        .configureTestingModule({\n          declarations: [PhoneListComponent],\n          providers: [\n            {provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({params: {phoneId: 1}})},\n            {provide: <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>, useClass: <a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>},\n            {provide: Phone, useClass: MockPhone},\n          ],\n          schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>]\n        })\n        .compileComponents();\n  }));\n\n  beforeEach(() =&gt; {\n    fixture = TestBed.createComponent(PhoneListComponent);\n  });\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/common\n - api/common/upgrade\n - api/common/upgrade/$locationShim\n - api/common/upgrade/LocationUpgradeModule\n - api/upgrade/static/downgradeComponent\n - guide/deprecations\n - guide/releases\n - guide/updating\n - guide/upgrade-performance\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/APP_BASE_HREF\n - api/common/HashLocationStrategy\n - api/common/Location\n - api/common/LocationStrategy\n - api/common/NgClass\n - api/common/NgFor\n - api/common/NgIf\n - api/common/NgOptimizedImage\n - api/common/Time\n - api/common/http\n - api/common/http/HttpClient\n - api/common/http/HttpClientModule\n - api/common/http/testing/HttpClientTestingModule\n - api/common/http/testing/HttpTestingController\n - api/common/testing/SpyLocation\n - api/common/upgrade/$locationShim\n - api/common/upgrade/LocationUpgradeConfig\n - api/common/upgrade/LocationUpgradeModule\n - api/common/upgrade/LocationUpgradeModule#config\n - api/core/Component\n - api/core/Directive\n - api/core/DoBootstrap\n - api/core/ElementRef\n - api/core/EventEmitter\n - api/core/Injectable\n - api/core/Injector\n - api/core/Input\n - api/core/NO_ERRORS_SCHEMA\n - api/core/NgModule\n - api/core/NgZone\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - api/core/Optional\n - api/core/Output\n - api/core/Pipe\n - api/core/PipeTransform\n - api/core/SimpleChanges\n - api/core/Type\n - api/core/Version\n - api/core/model\n - api/core/ng-content\n - api/core/testing/ComponentFixture\n - api/core/testing/TestBed\n - api/core/testing/waitForAsync\n - api/forms/FormsModule\n - api/forms/MaxValidator\n - api/forms/NgModel\n - api/forms/PatternValidator\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/BrowserModule\n - api/platform-browser/animations/async\n - api/platform-browser/platformBrowser\n - api/router/ActivatedRoute\n - api/router/Router\n - api/router/RouterLink\n - api/router/RouterModule\n - api/router/RouterOutlet\n - api/router/Routes\n - api/router/UrlSegment\n - api/upgrade/static\n - api/upgrade/static/UpgradeComponent\n - api/upgrade/static/UpgradeModule\n - api/upgrade/static/downgradeComponent\n - api/upgrade/static/downgradeInjectable\n - guide/animations\n - guide/aot-compiler\n - guide/built-in-directives\n - guide/dependency-injection\n - guide/glossary#lazy-loading\n - guide/hierarchical-dependency-injection\n - guide/lifecycle-hooks\n - guide/ngmodules\n - guide/router\n - guide/typescript-configuration\n - guide/upgrade#add-the-angular-router\n - guide/upgrade#add-the-checkmarkpipe\n - guide/upgrade#adding-the-angular-router-and-bootstrap\n - guide/upgrade#aot-compile-the-hybrid-app\n - guide/upgrade#appendix-upgrading-phonecat-tests\n - guide/upgrade#bootstrapping-a-hybrid-phonecat\n - guide/upgrade#bootstrapping-hybrid-applications\n - guide/upgrade#change-detection\n - guide/upgrade#components-and-the-dom\n - guide/upgrade#configure-a-custom-route-matcher-for-angularjs-routes\n - guide/upgrade#create-a-component-to-render-angularjs-content\n - guide/upgrade#create-a-service-to-lazy-load-angularjs\n - guide/upgrade#create-the-routing-module\n - guide/upgrade#creating-the-appmodule\n - guide/upgrade#dependency-injection\n - guide/upgrade#e2e-tests\n - guide/upgrade#follow-the-angularjs-style-guide\n - guide/upgrade#generate-links-for-each-phone\n - guide/upgrade#how-ngupgrade-works\n - guide/upgrade#installing-angular\n - guide/upgrade#lazy-loading-angularjs\n - guide/upgrade#making-angular-dependencies-injectable-to-angularjs\n - guide/upgrade#making-angularjs-dependencies-injectable-to-angular\n - guide/upgrade#migrating-to-typescript\n - guide/upgrade#no-angular-filter-or-orderby-filters\n - guide/upgrade#phonecat-upgrade-tutorial\n - guide/upgrade#preparation\n - guide/upgrade#projecting-angularjs-content-into-angular-components\n - guide/upgrade#say-goodbye-to-angularjs\n - guide/upgrade#switching-to-typescript\n - guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\n - guide/upgrade#unit-tests\n - guide/upgrade#upgrading-components\n - guide/upgrade#upgrading-from-angularjs-to-angular\n - guide/upgrade#upgrading-the-phone-service\n - guide/upgrade#upgrading-with-ngupgrade\n - guide/upgrade#use-route-parameters\n - guide/upgrade#using-a-module-loader\n - guide/upgrade#using-angular-components-from-angularjs-code\n - guide/upgrade#using-angularjs-component-directives-from-angular-code\n - guide/upgrade#using-component-directives\n - guide/upgrade#using-the-unified-angular-location-service\n - guide/upgrade#using-upgrademodule-with-angular-ngmodules\n - guide/upgrade-setup\n - http://browserify.org\n - https://blog.angular.io/finding-a-path-forward-with-angularjs-7e186fdd4429\n - https://docs.angularjs.org/api/ng/function/angular.bootstrap\n - https://docs.angularjs.org/api/ng/service/$location\n - https://docs.angularjs.org/api/ng/type/angular.Module\n - https://docs.angularjs.org/api/ng/type/angular.Module#component\n - https://docs.angularjs.org/api/ngRoute/directive/ngView\n - https://docs.angularjs.org/api/ngRoute/provider/$routeProvider\n - https://docs.angularjs.org/tutorial\n - https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#support-for-umd-module-definitions\n - https://github.com/angular/angular-phonecat\n - https://github.com/angular/angular-phonecat/commits/1.5-snapshot\n - https://github.com/angular/angular/issues/38366\n - https://github.com/angular/quickstart\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\n - https://github.com/mgechev/angular-umd-bundle\n - https://github.com/systemjs/systemjs\n - https://rollupjs.org\n - https://webpack.github.io\n - https://www.npmjs.com/package/@types/angular\n-->"}