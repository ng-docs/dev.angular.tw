{"id":"guide/http-pass-metadata-to-interceptors","title":"HTTP - 將元資料傳遞給攔截器","contents":"<div class=\"content\">\n  <h1 id=\"http---pass-metadata-to-interceptors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4scz5i1iprpa8ne3dj8la8fc6\">HTTP - 將元資料傳遞給攔截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#http---pass-metadata-to-interceptors\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3z0s4447ii6txe2rayig85e31\">許多攔截器都需要進行設定或從設定中受益。考慮一個重試失敗請求的攔截器。預設情況下，攔截器可能會重試請求三次，但是對於特別容易出錯或敏感的請求，你可能要改寫這個重試次數。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cj8fj4241cn46e7pobbetle74\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 請求包含一個<em>上下文</em>，該上下文可以攜帶有關請求的元資料。該上下文可供攔截器讀取或修改，儘管傳送請求時它並不會傳輸到後端伺服器。這允許應用程式或其他攔截器使用設定引數來標記這些請求，比如重試請求的次數。</p>\n<h2 id=\"create-a-context-token\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ab7n15p50xvzr31adhf2qajov\">建立上下文標記<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#create-a-context-token\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"25u2xd745veefbgisc32606x\"><code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code> 用於在上下文中儲存和檢索值。你可以用 <code>new</code> 運算符建立上下文令牌，如以下例所示：</p>\n<code-example header=\"creating a context token\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"context-token\">\nexport const RETRY_COUNT = new <a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>(() =&gt; 3);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1tfgqz9so4m6wh9flny9i8wvb\"><code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code> 建立期間傳遞的 lambda 函式 <code>() =&gt; 3</code> 有兩個用途：</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24fkyxzf2c4c6oqcxo6n4laz9\">它允許 TypeScript 推斷此令牌的型別：<code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>&lt;number&gt;</code>。這個請求上下文是型別安全的 —— 從請求上下文中讀取令牌將回傳適當型別的值。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"25nsllav463oh7zh35a7cra6s\">它會設定令牌的預設值。如果尚未為此令牌設定其他值，那麼這就是請求上下文回傳的值。使用預設值可以避免檢查是否已設定了特定值。</p>\n</li>\n</ol>\n<h2 id=\"set-context-values-when-making-a-request\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xp2gidhtl8sne71247lodxmf\">發出請求時設定上下文值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#set-context-values-when-making-a-request\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c4za7vlymp7ej1ccyrkynnv4h\">發出請求時，你可以提供一個 <code><a href=\"api/common/http/HttpContext\" class=\"code-anchor\">HttpContext</a></code> 實例，在該實例中你已經設定了一些上下文值。</p>\n<code-example header=\"setting context values\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"set-context\">\nthis.httpClient\n    .get('/data/feed', {\n      context: new <a href=\"api/common/http/HttpContext\" class=\"code-anchor\">HttpContext</a>().set(RETRY_COUNT, 5),\n    })\n    .subscribe(results =&gt; {/* ... */});\n\n</code-example>\n<h2 id=\"read-context-values-in-an-interceptor\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8c5hpf1tp630gr3qikdxckyy\">在攔截器中讀取上下文值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#read-context-values-in-an-interceptor\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d14m5pbxr11wfym3nqwfqyevf\"><code><a href=\"api/common/http/HttpContext#get\" class=\"code-anchor\">HttpContext.get()</a></code> 在給定請求的上下文中讀取令牌的值。如果尚未顯式設定令牌的值，則 Angular 將回傳標記中指定的預設值。</p>\n<code-example header=\"reading context values in an interceptor\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"reading-context\">\nimport {retry} from 'rxjs';\n\nexport class RetryInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n    const retryCount = req.context.get(RETRY_COUNT);\n\n    return next.handle(req).pipe(\n        // Retry the request a configurable number of times.\n        retry(retryCount),\n    );\n  }\n}\n\n</code-example>\n<h2 id=\"contexts-are-mutable\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d091x3xvqt6ow0dx9fzxouna0\">上下文是可變的（Mutable）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#contexts-are-mutable\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ft1kt86brn0dmr3ws12fcji8\">與 <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 實例的大多數其他方面不同，請求上下文是可變的，並且在請求的其他不可變轉換過程中仍然存在。這允許攔截器透過此上下文協調來操作。比如，<code>RetryInterceptor</code> 範例可以使用第二個上下文令牌來跟蹤在執行給定請求期間發生過多少錯誤：</p>\n<code-example header=\"coordinating operations through the context\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"mutable-context\">\nimport {retry, tap} from 'rxjs/operators';\nexport const RETRY_COUNT = new <a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>(() =&gt; 3);\nexport const ERROR_COUNT = new <a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>(() =&gt; 0);\n\nexport class RetryInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n    const retryCount = req.context.get(RETRY_COUNT);\n\n    return next.handle(req).pipe(\n        tap({\n              // An error has occurred, so increment this request's ERROR_COUNT.\n             error: () =&gt; req.context.set(ERROR_COUNT, req.context.get(ERROR_COUNT) + 1)\n            }),\n        // Retry the request a configurable number of times.\n        retry(retryCount),\n    );\n  }\n}\n\n</code-example>\n\n  <div class=\"reviewed\">最後複查時間：Tue Nov 15 2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpContext\n - api/common/http/HttpContext#get\n - api/common/http/HttpContextToken\n - api/common/http/HttpEvent\n - api/common/http/HttpHandler\n - api/common/http/HttpInterceptor\n - api/common/http/HttpRequest\n - guide/http-pass-metadata-to-interceptors#contexts-are-mutable\n - guide/http-pass-metadata-to-interceptors#create-a-context-token\n - guide/http-pass-metadata-to-interceptors#http---pass-metadata-to-interceptors\n - guide/http-pass-metadata-to-interceptors#read-context-values-in-an-interceptor\n - guide/http-pass-metadata-to-interceptors#set-context-values-when-making-a-request\n-->"}