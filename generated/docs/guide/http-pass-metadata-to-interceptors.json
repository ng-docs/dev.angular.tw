{"id":"guide/http-pass-metadata-to-interceptors","title":"HTTP - 将元数据传递给拦截器","contents":"<div class=\"content\">\n  <h1 id=\"http---pass-metadata-to-interceptors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4scz5i1iprpa8ne3dj8la8fc6\">HTTP - 将元数据传递给拦截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#http---pass-metadata-to-interceptors\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3z0s4447ii6txe2rayig85e31\">许多拦截器都需要进行配置或从配置中受益。考虑一个重试失败请求的拦截器。默认情况下，拦截器可能会重试请求三次，但是对于特别容易出错或敏感的请求，你可能要改写这个重试次数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cj8fj4241cn46e7pobbetle74\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 请求包含一个<em>上下文</em>，该上下文可以携带有关请求的元数据。该上下文可供拦截器读取或修改，尽管发送请求时它并不会传输到后端服务器。这允许应用程序或其他拦截器使用配置参数来标记这些请求，比如重试请求的次数。</p>\n<h2 id=\"create-a-context-token\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ab7n15p50xvzr31adhf2qajov\">创建上下文标记<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#create-a-context-token\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"25u2xd745veefbgisc32606x\"><code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code> 用于在上下文中存储和检索值。你可以用 <code>new</code> 运算符创建上下文令牌，如以下例所示：</p>\n<code-example header=\"creating a context token\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"context-token\">\nexport const RETRY_COUNT = new <a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>(() =&gt; 3);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1tfgqz9so4m6wh9flny9i8wvb\"><code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code> 创建期间传递的 lambda 函数 <code>() =&gt; 3</code> 有两个用途：</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24fkyxzf2c4c6oqcxo6n4laz9\">它允许 TypeScript 推断此令牌的类型：<code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>&lt;number&gt;</code>。这个请求上下文是类型安全的 —— 从请求上下文中读取令牌将返回适当类型的值。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"25nsllav463oh7zh35a7cra6s\">它会设置令牌的默认值。如果尚未为此令牌设置其他值，那么这就是请求上下文返回的值。使用默认值可以避免检查是否已设置了特定值。</p>\n</li>\n</ol>\n<h2 id=\"set-context-values-when-making-a-request\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xp2gidhtl8sne71247lodxmf\">发出请求时设置上下文值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#set-context-values-when-making-a-request\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c4za7vlymp7ej1ccyrkynnv4h\">发出请求时，你可以提供一个 <code><a href=\"api/common/http/HttpContext\" class=\"code-anchor\">HttpContext</a></code> 实例，在该实例中你已经设置了一些上下文值。</p>\n<code-example header=\"setting context values\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"set-context\">\nthis.httpClient\n    .get('/data/feed', {\n      context: new <a href=\"api/common/http/HttpContext\" class=\"code-anchor\">HttpContext</a>().set(RETRY_COUNT, 5),\n    })\n    .subscribe(results =&gt; {/* ... */});\n\n</code-example>\n<h2 id=\"read-context-values-in-an-interceptor\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8c5hpf1tp630gr3qikdxckyy\">在拦截器中读取上下文值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#read-context-values-in-an-interceptor\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d14m5pbxr11wfym3nqwfqyevf\"><code><a href=\"api/common/http/HttpContext#get\" class=\"code-anchor\">HttpContext.get()</a></code> 在给定请求的上下文中读取令牌的值。如果尚未显式设置令牌的值，则 Angular 将返回标记中指定的默认值。</p>\n<code-example header=\"reading context values in an interceptor\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"reading-context\">\nimport {retry} from 'rxjs';\n\nexport class RetryInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n    const retryCount = req.context.get(RETRY_COUNT);\n\n    return next.handle(req).pipe(\n        // Retry the request a configurable number of times.\n        retry(retryCount),\n    );\n  }\n}\n\n</code-example>\n<h2 id=\"contexts-are-mutable\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d091x3xvqt6ow0dx9fzxouna0\">上下文是可变的（Mutable）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#contexts-are-mutable\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ft1kt86brn0dmr3ws12fcji8\">与 <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 实例的大多数其他方面不同，请求上下文是可变的，并且在请求的其他不可变转换过程中仍然存在。这允许拦截器通过此上下文协调来操作。比如，<code>RetryInterceptor</code> 示例可以使用第二个上下文令牌来跟踪在执行给定请求期间发生过多少错误：</p>\n<code-example header=\"coordinating operations through the context\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"mutable-context\">\nimport {retry, tap} from 'rxjs/operators';\nexport const RETRY_COUNT = new <a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>(() =&gt; 3);\nexport const ERROR_COUNT = new <a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>(() =&gt; 0);\n\nexport class RetryInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n    const retryCount = req.context.get(RETRY_COUNT);\n\n    return next.handle(req).pipe(\n        tap({\n              // An error has occurred, so increment this request's ERROR_COUNT.\n             error: () =&gt; req.context.set(ERROR_COUNT, req.context.get(ERROR_COUNT) + 1)\n            }),\n        // Retry the request a configurable number of times.\n        retry(retryCount),\n    );\n  }\n}\n\n</code-example>\n\n  <div class=\"reviewed\">最后复查时间：Tue Nov 15 2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpContext\n - api/common/http/HttpContext#get\n - api/common/http/HttpContextToken\n - api/common/http/HttpEvent\n - api/common/http/HttpHandler\n - api/common/http/HttpInterceptor\n - api/common/http/HttpRequest\n - guide/http-pass-metadata-to-interceptors#contexts-are-mutable\n - guide/http-pass-metadata-to-interceptors#create-a-context-token\n - guide/http-pass-metadata-to-interceptors#http---pass-metadata-to-interceptors\n - guide/http-pass-metadata-to-interceptors#read-context-values-in-an-interceptor\n - guide/http-pass-metadata-to-interceptors#set-context-values-when-making-a-request\n-->"}