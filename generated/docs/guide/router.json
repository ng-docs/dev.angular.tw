{"id":"guide/router","title":"常见路由任务","contents":"<div class=\"content\">\n  <h1 id=\"common-routing-tasks\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6yfs1kmhiyiv4r32nvdu0rsmc\">常见路由任务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#common-routing-tasks\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"471orehxuzjoyjiw7uznv54jh\">本主题讲述当把 Angular 路由器添加到应用中时，如何实现多种常见路由任务。</p>\n<p><a id=\"basics\"></a></p>\n<h2 id=\"generate-an-application\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"77eix3gmn0k5ci5ocg7wogm4z\">生成一个应用程序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#generate-an-application\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ne4uhkjndnuxobwd24tc96by\">以下命令使用 Angular CLI 生成一个带有应用程序路由的基本 Angular 应用程序。以下示例中的应用程序名称为\n<code>routing-app</code>。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng new routing-app\n\n</code-example>\n<h3 id=\"adding-components-for-routing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8w9g3cq2flvfgre7s43wf229h\">为路由添加组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#adding-components-for-routing\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bzf17f82n86qnpyxjrlblz2zt\">为了使用 Angular 的路由器，应用至少要有两个组件才能从一个导航到另一个。要使用 CLI 创建组件，请在命令行输入以下内容，其中 <code>first</code> 是组件的名称：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component first\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zrr04peqo98hoj6lfyzy63vp\">为第二个组件重复这个步骤，但给它一个不同的名字。这里的新名字是 <code>second</code>。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component second\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"989vhyym6pf5ck9orkbw5w0zc\">CLI 会自动添加 <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 后缀，所以如果在编写 <code>first-component</code>，那么其组件名就是 <code>FirstComponentComponent</code>。</p>\n<p><a id=\"basics-base-href\"></a></p>\n<div class=\"alert is-helpful\">\n<header><code>&lt;base href&gt;</code></header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1wuom04mycej8w87t6ibtuy7o\">此指南适用于使用 CLI 生成的 Angular 应用程序。</p>\n</div>\n<h3 id=\"importing-your-new-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"754j9wgphjoioo84434yj84i0\">导入这些新组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#importing-your-new-components\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"emfitcsv6d9vjtuis4kljkzhm\">要使用新组件，将其导入到\n<code>app.routes.ts</code>文件的顶部，如下所示：</p>\n<code-example>\nimport {FirstComponent} from './first/first.component';\nimport {SecondComponent} from './second/second.component';\n</code-example>\n<p><a id=\"basic-route\"></a></p>\n<h2 id=\"defining-a-basic-route\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5nwyz52auwe1skyafrmu7vnr8\">定义一个基本路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#defining-a-basic-route\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f0x03vm9rom9nwtyeyrhbptzw\">创建路由有三个基本的构建块。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"563z5iyniwogwgpunvr8c5cch\">将路由导入到\n<code>app.config.ts</code>中，并将其添加到\n<code><a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a></code>函数中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6z60dllt538eswbttthioh7pl\">Angular CLI 会为您执行此步骤。 但是，如果您手动创建应用程序或使用现有非 CLI 应用程序，则请验证导入和配置是否正确。以下是使用 CLI 的默认\n<code><a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a></code>。</p>\n<code-example>\nexport const appConfig: <a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a> = {\n  providers: [<a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>(routes)]\n};\n</code-example>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c5eomfft5edcaq71mro9wupva\">为您的路由设置一个\n<code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code>数组</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6jg88x9c0ezaovg51z5qvarmj\">Angular CLI 会自动执行此步骤。</p>\n</li>\n</ol>\n<code-example>\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nexport const routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [];\n</code-example>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ppp1kni20diqcbjecx7gur1v\">在 <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 数组中定义你的路由。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"du181sm2ajlg973yb451tturr\">这个数组中的每个路由都是一个包含两个属性的 JavaScript 对象。第一个属性 <code>path</code> 定义了该路由的 URL 路径。第二个属性 <code>component</code> 定义了要让 Angular 用作相应路径的组件。</p>\n</li>\n</ol>\n<code-example>\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n];\n</code-example>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46usjxuup5a3hifw73o5wofhk\">把这些路由添加到你的应用中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cyfextsy8gysgq9g8x8gxleyk\">现在你已经定义了路由，可以把它们添加到应用中了。首先，添加到这两个组件的链接。把要添加路由的链接赋值给 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 属性。将属性的值设置为该组件，以便在用户点击各个链接时显示这个值。接下来，修改组件模板以包含 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 标签。该元素会通知 Angular，你可以用所选路由的组件更新应用的视图。</p>\n</li>\n</ol>\n<code-example>\n&lt;h1&gt;Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> App&lt;/h1&gt;\n&lt;nav&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/first-component\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;First <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/second-component\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Second <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/nav&gt;\n&lt;!-- The routed views render in the &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;--&gt;\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6r2an1t2ozu9hy4wu041e8f9w\">您还需要将\n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>、\n<code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a></code>和\n<code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>添加到\n<code>AppComponent</code>的导入数组中。</p>\n<code-example>\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  standalone: true,\n  imports: [<a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a>, <a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>, <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">RouterLinkActive</a>],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'routing-app';\n}\n</code-example>\n<p><a id=\"route-order\"></a></p>\n<h3 id=\"route-order\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b07tqkuaeqbu6ftd6hesx7p5o\">路由顺序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#route-order\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2nzndb9wdjiihlmrt5jxc5t96\">路由的顺序很重要，因为 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 在匹配路由时使用“先到先得”策略，所以应该在不那么具体的路由前面放置更具体的路由。首先列出静态路径的路由，然后是一个与默认路由匹配的空路径路由。<a href=\"guide/router#setting-up-wildcard-routes\">通配符路由</a>是最后一个，因为它匹配每一个 URL，只有当其它路由都没有匹配时，<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 才会选择它。</p>\n<p><a id=\"getting-route-information\"></a></p>\n<h2 id=\"getting-route-information\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"20n06h04ms112eszs2htisb5t\">获取路由信息<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#getting-route-information\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8gbgunblsv82f0o9um1jnuzti\">通常，当用户导航你的应用时，你会希望把信息从一个组件传递到另一个组件。比如，考虑一个显示杂货商品购物清单的应用。列表中的每一项都有一个唯一的 <code>id</code>。要想编辑某个项目，用户需要单击“编辑”按钮，打开一个 <code>EditGroceryItem</code> 组件。你希望该组件得到该商品的 <code>id</code>，以便它能向用户显示正确的信息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3w05mudb7tqe2y0cpagh02o5i\">可以用一个路由把这种类型的信息传给你的应用组件。要做到这一点，你可以使用 <a href=\"api/router/ActivatedRoute\">ActivatedRoute</a> 接口。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9s0zx5vtxhcv71rdgzry41uow\">要从路由中获取信息：</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9a6cs8ioaqljy366bsrerzplk\">将 <code><a href=\"api/router/withComponentInputBinding\" class=\"code-anchor\">withComponentInputBinding</a></code> 特性添加到 <code><a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a></code> 方法。</p>\n<code-example header=\"provideRouter feature\" path=\"router/src/app/app-routing.module.11.ts\" region=\"withComponentInputBinding\">\nproviders: [\n  <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>(appRoutes, <a href=\"api/router/withComponentInputBinding\" class=\"code-anchor\">withComponentInputBinding</a>()),\n]\n\n</code-example>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5mc8am3cizwqzbkjyqzbt8l9\">更新 <code>ngOnInit()</code> 方法来访问这个 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 并跟踪 <code>name</code> 参数：</p>\n<code-example header=\"The component input (excerpt)\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.4.ts\" region=\"id-input\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\nset id(heroId: string) {\n  this.hero$ = this.service.getHero(heroId);\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6g41zcotayizdg85kebtmyudd\"><strong>注意：</strong>\n<br> 您可以将所有路由数据与键值对绑定到组件输入：静态或已解析的路由数据、路径参数、矩阵参数和查询参数。 \n<br> 如果要使用父组件的路由信息，您需要设置路由器的\n<code>paramsInheritanceStrategy</code>选项：\n<code><a href=\"api/router/withRouterConfig\" class=\"code-anchor\">withRouterConfig</a>({paramsInheritanceStrategy: 'always'})</code></p>\n</div>\n</li>\n</ol>\n<p><a id=\"wildcard-route-how-to\"></a></p>\n<h2 id=\"setting-up-wildcard-routes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9e4a1c9rr4vmzwir1gb1m8qbl\">设置通配符路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#setting-up-wildcard-routes\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"627vznnx5nmk45r4bc5olwo5z\">当用户试图导航到那些不存在的应用部件时，在正常的应用中应该能得到很好的处理。要在应用中添加此功能，需要设置通配符路由。当所请求的 URL 与任何路由器路径都不匹配时，Angular 路由器就会选择这个路由。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0fqm7j4zfxxemzxykonjwsde\">要设置通配符路由，请在 <code>routes</code> 定义中添加以下代码。</p>\n<code-example>\n{ path: '**', component: PageNotFoundComponent }\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eydu9ej4w5tqqofk0cjpi4hz8\">这两个星号 <code>**</code> 告诉 Angular，这个 <code>routes</code> 定义是通配符路由。对于 component 属性，你可以使用应用中的任何组件。常见的选择包括应用专属的 <code>PageNotFoundComponent</code>，你可以定义它来向用户<a href=\"guide/router#404-page-how-to\">展示 404 页面</a>，或者跳转到应用的主组件。通配符路由是最后一个路由，因为它匹配所有的 URL。关于路由顺序的更多详细信息，请参阅<a href=\"guide/router#route-order\">路由顺序</a>。</p>\n<p><a id=\"404-page-how-to\"></a></p>\n<h2 id=\"displaying-a-404-page\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4fom1klv8evh3gy16gkcga42v\">显示 404 页面<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#displaying-a-404-page\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wmltn0e4m9cr7ye71f9xfpd9\">要显示 404 页面，请设置一个<a href=\"guide/router#wildcard-route-how-to\">通配符路由</a>，并将 <code>component</code> 属性设置为你要用于 404 页面的组件，如下所示：</p>\n<code-example>\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9t1fbzeofx78mtwhhdunj5oju\"><code>path</code> 为 <code>**</code> 的最后一条路由是通配符路由。如果请求的 URL 与前面列出的路径不匹配，路由器会选择这个路由，并把该用户送到 <code>PageNotFoundComponent</code>。</p>\n<h2 id=\"setting-up-redirects\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bziljukomircsk5ev5roy3zqv\">设置重定向<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#setting-up-redirects\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"62kbtaguk0jicwzogg4ncrqpc\">要设置重定向，请使用重定向源的 <code>path</code>、要重定向目标的 <code>component</code> 和一个 <code>pathMatch</code> 值来配置路由，以告诉路由器该如何匹配 URL。</p>\n<code-example>\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '',   redirectTo: '/first-component', pathMatch: 'full' }, // redirect to `first-component`\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3bv856oml03gltbzx0ijzwubj\">在这个例子中，第三个路由是重定向路由，所以路由器会默认跳到 <code>first-component</code> 路由。注意，这个重定向路由位于通配符路由之前。这里的 <code>path: ''</code> 表示使用初始的相对 URL（<code>''</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8m6g24pcwgaw3bkf4532gcto0\">关于 <code>pathMatch</code> 的详情，请参阅<a href=\"guide/router-tutorial-toh#pathmatch\">聚焦 <code>pathMatch</code></a>部分。</p>\n<p><a id=\"nesting-routes\"></a></p>\n<h2 id=\"nesting-routes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35sbodgukx4kf7s4hhy1y9vbf\">嵌套路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#nesting-routes\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8kxysqzei9lew1cd4s0iy9g3i\">随着你的应用变得越来越复杂，你可能要创建一些根组件之外的相对路由。这些嵌套路由类型称为子路由。这意味着你要为你的应用添加第二 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>，因为它是 <code>AppComponent</code> 之外的另一个 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1r46m7jc9x63hk2y80g67lnjh\">在这个例子中，还有两个子组件，<code>child-a</code> 和 <code>child-b</code>。这里的 <code>FirstComponent</code> 有它自己的 <code>&lt;nav&gt;</code> 和 <code>AppComponent</code> 之外的第二 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>。</p>\n<code-example>\n&lt;h2&gt;First <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&lt;/h2&gt;\n\n&lt;nav&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"child-a\"&gt;Child A&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"child-b\"&gt;Child B&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/nav&gt;\n\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efde84adlxsrwbhinlgvflx38\">子路由和其它路由一样，同时需要 <code>path</code> 和 <code>component</code>。唯一的区别是你要把子路由放在父路由的 <code>children</code> 数组中。</p>\n<code-example>\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'first-component',\n    component: FirstComponent, // this is the component with the &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt; in the template\n    children: [\n      {\n        path: 'child-a', // child route path\n        component: ChildAComponent, // child route component that the router renders\n      },\n      {\n        path: 'child-b',\n        component: ChildBComponent, // another child route component that the router renders\n      },\n    ],\n  },\n];\n</code-example>\n<p><a id=\"setting-the-page-title\"></a></p>\n<h2 id=\"setting-the-page-title\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d1y3f1ogu3i7n1ywbvjgh1xb3\">设置页面标题<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#setting-the-page-title\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8syuyypt4lftak6dqra1x7yef\">应用程序中的每个页面都应该有一个唯一的标题，以便可以在浏览器历史记录中识别它们。<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 使用 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> 配置中的 <code>title</code> 属性设置文档的标题。</p>\n<code-example>\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'first-component',\n    title: 'First component',\n    component: FirstComponent,  // this is the component with the &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt; in the template\n    children: [\n      {\n        path: 'child-a',  // child route path\n        title: resolvedChildATitle,\n        component: ChildAComponent,  // child route component that the router renders\n      },\n      {\n        path: 'child-b',\n        title: 'child b',\n        component: ChildBComponent,  // another child route component that the router renders\n      },\n    ],\n  },\n];\n\nconst resolvedChildATitle: <a href=\"api/router/ResolveFn\" class=\"code-anchor\">ResolveFn</a>&lt;string&gt; = () =&gt; Promise.resolve('child a');\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"afjqpkqt31nba1uikp29euhff\"><strong>注意</strong>：<br>\n<code>title</code> 属性遵循与实现 <code><a href=\"api/router/ResolveFn\" class=\"code-anchor\">ResolveFn</a></code> 的静态路由 <code>data</code> 和动态值相同的规则。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7idrtp241295g15ac1h6uun5w\">你还可以通过扩展 <code><a href=\"api/router/TitleStrategy\" class=\"code-anchor\">TitleStrategy</a></code> 来提供自定义标题策略。</p>\n<code-example>\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({providedIn: 'root'})\nexport class TemplatePageTitleStrategy extends <a href=\"api/router/TitleStrategy\" class=\"code-anchor\">TitleStrategy</a> {\n  constructor(private readonly title: <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>) {\n    super();\n  }\n\n  override updateTitle(routerState: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>) {\n    const title = this.buildTitle(routerState);\n    if (title !== undefined) {\n      this.title.setTitle(`My Application | ${title}`);\n    }\n  }\n}\n\n\nexport const appConfig: <a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a> = {\n  providers: [\n    <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>(routes),\n    {provide: <a href=\"api/router/TitleStrategy\" class=\"code-anchor\">TitleStrategy</a>, useClass: TemplatePageTitleStrategy},\n  ]\n};\n</code-example>\n<p><a id=\"using-relative-paths\"></a></p>\n<h2 id=\"using-relative-paths\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3kxeqse99fu3esa2cetfbrm6c\">使用相对路径<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#using-relative-paths\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9mug18rwyhrpcxgnifc2mroz0\">相对路径允许你定义相对于当前 URL 段的路径。下面的例子展示了到另一个组件 <code>second-component</code> 的相对路由。<code>FirstComponent</code> 和 <code>SecondComponent</code> 在树中处于同一级别，但是，指向 <code>SecondComponent</code> 的链接位于 <code>FirstComponent</code> 中，这意味着路由器必须先上升一个级别，然后进入二级目录才能找到 <code>SecondComponent</code>。可以用 <code>../</code> 符号来上升一个级别，而不用写出到 <code>SecondComponent</code> 的完整路径。</p>\n<code-example>\n&lt;h2&gt;First <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&lt;/h2&gt;\n\n&lt;nav&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"../second-component\"&gt;Relative <a href=\"api/router/Route\" class=\"code-anchor\">Route</a> to second component&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/nav&gt;\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vhb6zw0xe82g7mflcdutpput\">除了 <code>../</code>，还可以使用 <code>./</code> 或者不带前导斜杠来指定当前级别。</p>\n<h3 id=\"specifying-a-relative-route\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3v5degv9d4glv5pbv8mgsavye\">指定相对路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#specifying-a-relative-route\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bjs7r9rxkutwjdnvl56lgiacz\">要指定相对路由，请使用 <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code> 中的 <code>relativeTo</code> 属性。在组件类中，从 <code>@angular/router</code> 导入 <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3to3xrdpvgzv7hj63okrytb53\">然后在导航方法中使用 <code>relativeTo</code> 参数。在链接参数数组（它包含 <code>items</code>）之后添加一个对象，把该对象的 <code>relativeTo</code> 属性设置为当前的 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>，也就是 <code>this.route</code>。</p>\n<code-example>\n  goToItems() {\n    this.router.navigate(['items'], { relativeTo: this.route });\n  }\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d19iez766q0fk9qzpsyo5wbbt\"><code>navigate()</code>参数配置路由器使用当前路由作为基础来追加\n<code>items</code>。</p>\n\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"32vmbb75tl2t6jne0luifr1g2\"><code>goToItems()</code> 方法会把目标 URI 解释为相对于当前路由的，并导航到 <code>items</code> 路由。</p>\n<h2 id=\"accessing-query-parameters-and-fragments\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cjhpl67y8pn71ai51me94x47\">访问查询参数和片段<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#accessing-query-parameters-and-fragments\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4yydgmyf2ih20co40p8wop36\">有时，应用中的某个特性需要访问路由的部件，比如查询参数或片段（fragment）。本教程的这个阶段使用了一个“英雄之旅”中的列表视图，你可以在其中点击一个英雄来查看详情。路由器使用 <code>id</code> 来显示正确的英雄的详情。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a9p3lfvp2y0ijnfbqxnl79b9a\">首先，在要导航的组件中导入以下成员。</p>\n<code-example header=\"Component import statements (excerpt)\">\n\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9km5lkql8tgnkdar4caw0vin7\">接下来，注入当前路由（ActivatedRoute）服务：</p>\n<code-example header=\"Component (excerpt)\">\n\nconstructor(private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>) {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3idekcxmw3bu8ut9ff1ndsx1b\">配置这个类，让你有一个可观察对象 <code>heroes$</code>、一个用来保存英雄的 <code>id</code> 号的 <code>selectedId</code>，以及 <code>ngOnInit()</code> 中的英雄们，添加下面的代码来获取所选英雄的 <code>id</code>。这个代码片段假设你有一个英雄列表、一个英雄服务、一个能获取你的英雄的函数，以及用来渲染你的列表和细节的 HTML，就像在《英雄之旅》例子中一样。</p>\n<code-example header=\"Component 1 (excerpt)\">\n\nheroes$: Observable&lt;Hero[]&gt;;\nselectedId: number;\nheroes = HEROES;\n\nngOnInit() {\n  this.heroes$ = this.route.paramMap.pipe(\n    switchMap(params =&gt; {\n      this.selectedId = Number(params.get('id'));\n      return this.service.getHeroes();\n    })\n  );\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"64fzmc7ivi3e9ygu3toa90kcg\">接下来，在要导航到的组件中，导入以下成员。</p>\n<code-example header=\"Component 2 (excerpt)\">\n\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a82ep5teyglietuh2h1q83rc7\">在组件类的构造函数中注入 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 和 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>，这样在这个组件中就可以用它们了：</p>\n<code-example header=\"Component 2 (excerpt)\">\n\nhero$: Observable&lt;Hero&gt;;\n\nconstructor(\n  private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>  ) {}\n\nngOnInit() {\n  const heroId = this.route.snapshot.paramMap.get('id');\n  this.hero$ = this.service.getHero(heroId);\n}\n\ngotoItems(hero: Hero) {\n  const heroId = hero ? hero.id : null;\n  // Pass along the hero id if available\n  // so that the HeroList component can select that item.\n  this.router.navigate(['/heroes', { id: heroId }]);\n}\n\n</code-example>\n<p><a id=\"lazy-loading\"></a></p>\n<h2 id=\"lazy-loading\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"506o9p6ll5bmk3b4fpor3jq4e\">惰性加载<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#lazy-loading\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3qkadhstbj3cpvf2a8iwut4l\">您可以将路由配置为延迟加载，这意味着Angular仅在需要时加载路由，而不是在应用程序启动时加载所有路由。 此外，预加载应用程序的部分内容以改善用户体验。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rmo6dm0xq9683ds138qrobsm\">要了解更多有关延迟加载和预加载的信息，请查看专门指南\n<a href=\"guide/lazy-loading-ngmodules\">延迟加载</a>。</p>\n<h2 id=\"preventing-unauthorized-access\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ei2rfgcc8x8hiwt9b2graywc\">防止未经授权的访问<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#preventing-unauthorized-access\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c5qoxeu7cqgnio8r9kvkhnto9\">使用路由守卫来防止用户未经授权就导航到应用的某些部分。Angular 中提供了以下路由守卫：</p>\n<ul>\n<li><a href=\"api/router/CanActivateFn\"><code>canActivate</code></a></li>\n<li><a href=\"api/router/CanActivateChildFn\"><code>canActivateChild</code></a></li>\n<li><a href=\"api/router/CanDeactivateFn\"><code>canDeactivate</code></a></li>\n<li><a href=\"api/router/CanMatchFn\"><code>canMatch</code></a></li>\n<li><a href=\"api/router/ResolveFn\"><code>resolve</code></a></li>\n<li><a href=\"api/router/CanLoadFn\"><code>canLoad</code></a></li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ppq3clpcfvs2b5nokaa1fa9b\">要想使用路由守卫，可以考虑使用<a href=\"api/router/Route#componentless-routes\">无组件路由</a>，因为这对于保护子路由很方便。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2a7u1upe2l2ojpmojzcbgo15c\">为你的守卫创建一个文件：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nng generate guard your-guard\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1hp5y38ugifuqrx6por3mwiqi\">请在守卫文件里添加你要用到的守卫函数。下面的例子使用 <code>canActivateFn</code> 来保护该路由。</p>\n<code-example header=\"guard (excerpt)\">\n\nexport const yourGuardFunction: <a href=\"api/router/CanActivateFn\" class=\"code-anchor\">CanActivateFn</a> = (\n    next: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    state: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>) =&gt; {\n      // your  logic goes here\n  }\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"84s5ffcp2goe2hmvbmpzrn9je\">在你的路由模块中，使用适当的属性在你的\n<code>routes</code>配置中。在这里，\n<code>canActivate</code>告诉路由器调解导航到这个特定路由。\n<code-example header=\"路由配置（摘要）\">\n  { path: '/your-path', component: YourComponent, canActivate: [yourGuardFunction], }\n</code-example></p>\n\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drwp4wqvlr1gesfii5wplz9pl\">关于此可工作范例的更多信息，请参阅<a href=\"guide/router-tutorial-toh#milestone-5-route-guards\">路由导航中关于路由守卫的部分</a>。</p>\n<h2 id=\"link-parameters-array\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9qhfopo4d1pfnp4w8mtuqehr0\">链接参数数组<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#link-parameters-array\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"evbclmqfvqfon90lxyuyum14d\">链接参数数组保存路由导航时所需的成分：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"33wxmaradgce7bffv1e1pek8d\">指向目标组件的那个路由的路径（path）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7gqcsyzzhvrymhyafuxkfkvjj\">必备路由参数和可选路由参数，它们将进入该路由的 URL</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6hraj07krpx0pkgi00zoaww83\">可以把 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令绑定到一个数组，就像这样：</p>\n<code-example>\n&lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/heroes']\"&gt;Heroes&lt;/a&gt;\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"33n81j9lw6irz9n29skso5k27\">在指定路由参数时，使用如下的两元素数组：</p>\n<code-example>\n&lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/hero', hero.id]\"&gt;\n  &lt;span class=\"badge\"&gt;{{ hero.id }}&lt;/span&gt;{{ hero.name }}\n&lt;/a&gt;\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bs1i3madz2neak3wnzoz3pz8n\">可以在对象中提供可选的路由参数，比如 <code>{ foo: 'foo' }</code>：</p>\n<code-example>\n&lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center', { foo: 'foo' }]\"&gt;Crisis Center&lt;/a&gt;\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58l933w6gvk8vtzhqatqmdbp4\">这三个例子涵盖了你在单级路由的应用中所需的一切。不过，在你添加一个像<em>危机中心</em>一样的子路由时，你可以创建新链接数组。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4uf5ltdmqnj19m7ntjplmzv5g\">下面这个最小化 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 例子是基于危机中心指定的<a href=\"guide/router-tutorial-toh#a-crisis-center-with-child-routes\">默认子路由</a>构建的。</p>\n<code-example>\n&lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center']\"&gt;Crisis Center&lt;/a&gt;\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dw3gep3o5uu2nccniutl4eb8l\">查看以下内容：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"14v844p57a6d1hesukcf58zkx\">数组中的第一个条目标记出了父路由（<code>/crisis-center</code>）。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4menlzs1x8a46oaoca0zlry62\">这个父路由没有参数。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1oy2dptjfswqve88cwifxwpti\">没有默认的子路由，因此你得选取一个。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xgix5bu7xu8otfnsngq6zda7\">你决定跳转到 <code>CrisisListComponent</code>，它的路由路径是'/'，但你不用显式的添加它。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94d9ugd7vtavija8vkz4qdfa5\">考虑以下路由器链接，它将从应用的根目录导航到巨龙危机（Dragon Crisis）：</p>\n<code-example>\n&lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center', 1]\"&gt;Dragon Crisis&lt;/a&gt;\n</code-example>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"14v844p57a6d1hesukcf58zkx\">数组中的第一个条目标记出了父路由（<code>/crisis-center</code>）。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4menlzs1x8a46oaoca0zlry62\">这个父路由没有参数。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eyftcw0jps0myf5dovp114rk\">数组中的第二个条目（'/:id'）用来标记出到指定危机的详情页的子路由。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d5o46pycfga8ab4pq9mhi42tf\">详细的子路由需要一个 <code>id</code> 路由参数。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"evo115ml1m7441zrqsgxj811p\">你把<em>巨龙危机</em>的 <code>id</code> 添加为该数组中的第二个条目（<code>1</code>）。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8pu83mo4kqx0h561lh4hz6gl1\">最终生成的路径是 <code>/crisis-center/1</code>。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cjo5k45qqwzgm6yd88zpeyumv\">你也可以把危机中心的路由单独重新定义为 <code>AppComponent</code> 的模板：</p>\n<code-example>\ntemplate: `\n  &lt;h1 class=\"title\"&gt;Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&lt;/h1&gt;\n  &lt;nav&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center']\"&gt;Crisis Center&lt;/a&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center/1', { foo: 'foo' }]\"&gt;Dragon Crisis&lt;/a&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center/2']\"&gt;Shark Crisis&lt;/a&gt;\n  &lt;/nav&gt;\n  &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n`\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ahvg02mj2tn4tyzqccx8a87a\">总之，你可以用一级、两级或多级路由来写应用程序。链接参数数组提供了用来表示任意深度路由的链接参数数组以及任意合法的路由参数序列、必须的路由器参数以及可选的路由参数对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8cje103bc4wo733drju3idhpk\"><a id=\"browser-url-styles\"></a>\n<a id=\"location-strategy\"></a></p>\n<h2 id=\"locationstrategy-and-browser-url-styles\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehca712pc4stio06wtwf6x25k\"><code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> 和浏览器的网址样式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#locationstrategy-and-browser-url-styles\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6s61h5xbvew5jc762pdjcb4hy\">当路由器导航到一个新的组件视图时，它会用该视图的 URL 来更新浏览器的当前地址以及历史。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2cjwk1ch4t2lwszlbl7wu53xb\">现代 HTML 5 浏览器支持<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Working_with_the_History_API#adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a> API，\n这是一项可以改变浏览器的当前地址和历史，却又不会触发服务端页面请求的技术。\n路由器可以合成出一个“自然的”URL，它看起来和那些需要进行页面加载的 URL 没什么区别。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f4dh0kfeiun7dkerxczd3y4je\">下面是危机中心的 URL 在“HTML 5 pushState”风格下的样子：</p>\n<code-example format=\"none\" language=\"http\">\n\nlocalhost:3002/crisis-center\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwqo1nqf1au2vrpcueobugmv7\">老旧的浏览器在当前地址的 URL 变化时总会往服务器发送页面请求……唯一的例外规则是：当这些变化位于“#”（被称为“hash”）后面时不会发送。通过把应用内的路由 URL 拼接在 <code>#</code> 之后，路由器可以获得这条“例外规则”带来的优点。下面是到<em>危机中心</em>路由的“hash URL”。</p>\n<code-example format=\"none\" language=\"http\">\n\nlocalhost:3002/src/#/crisis-center\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9fwmpfqgdxb062iibp38uobih\">路由器通过两种 <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> 提供者来支持所有这些风格：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dycvc6pm27ridqfrosy8bqn88\">提供者</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code><a href=\"api/common/PathLocationStrategy\" class=\"code-anchor\">PathLocationStrategy</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"do0sjf8p9zrdj6d4amndzj1hd\">默认的 \"HTML5 pushState\" 样式。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cy8rdsta6w5a8u4tkxlaqptju\">\"哈希 URL\" 样式。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"50jnrw1n9t7uabt4qqrul7kvh\"><code><a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a></code>函数将\n<code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code>设置为\n<code><a href=\"api/common/PathLocationStrategy\" class=\"code-anchor\">PathLocationStrategy</a></code>，这使其成为默认策略。你还可以在启动过程中切换到\n<code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cwtuqwkrw8iq14w9dqvgs9po\">关于提供者和引导过程的更多信息，请参阅<a href=\"guide/dependency-injection-providers\">依赖注入</a>。</p>\n</div>\n<h2 id=\"choosing-a-routing-strategy\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ej3pzfpo7xmt0kdqp0h9yx5z0\">选择路由策略<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#choosing-a-routing-strategy\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9rr2d8kwrqpjo53y345wa07pn\">你必须在开发项目的早期就选择一种路由策略，因为一旦该应用进入了生产阶段，你网站的访问者就会使用并依赖应用的这些 URL 引用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5yi9kbns1m38wqqt3godx64r2\">几乎所有的 Angular 项目都会使用默认的 HTML 5 风格。它生成的 URL 更易于被用户理解，它也为将来做<strong>服务端渲染</strong>预留了空间。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8t9bg5um8bka6n185ug7sb6nl\">在服务端渲染指定的页面，是一项可以在该应用首次加载时大幅提升响应速度的技术。那些原本需要十秒甚至更长时间加载的应用，可以预先在服务端渲染好，并在少于一秒的时间内完整渲染在用户的设备上。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xoymk6rz6xvdh637yl039ucn\">只有当应用的 URL 看起来像是标准的 Web URL，中间没有 hash（<code>#</code>）时，这个选项才能生效。</p>\n<h2 id=\"base-href\"><code>&lt;base href&gt;</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#base-href\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7iku8985s1o00e0ldn4ua02p\">路由器使用浏览器的 <a href=\"https://developer.mozilla.org/docs/Web/API/History_API/Working_with_the_History_API#adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a> API 进行导航。借助 <code>pushState</code> 你自定义应用中的 URL 路径 <code>localhost:4200/crisis-center</code>，应用内的 URL 和服务器的 URL 没有区别。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c344vyfg5qxgl6s7b2wszhsa2\">现代的 HTML5 浏览器都支持 <code>pushState</code>，这也就是为什么很多人把这种 URL 形式称为 \"HTML 5\" 风格的 URL。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6x3ngchtv99wk9fd7u1u3tx3u\">路由器默认使用 HTML5 风格的导航。\n在 <a href=\"guide/router#browser-url-styles\">LocationStrategy 与浏览器 URL 风格</a>部分，你可以了解为何推荐使用 HTML5 风格的 URL，如何调整其行为，以及必要时如何切换到老式的 hash（<code>#</code>）风格。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"77fp13fk2qmgk7ri9nw8llae4\">你必须在应用的 <code>index.html</code> 中<strong>添加一个 <a href=\"https://developer.mozilla.org/docs/Web/HTML/Element/base\" title=\"base href\"><code>&lt;base href&gt;</code> 元素</a></strong>才能让 <code>pushState</code> 路由正常工作。\n浏览器要用 <code>&lt;base href&gt;</code> 的值为引用 CSS、脚本和图片文件时使用的<em>相对</em> URL 添加前缀。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7gf7xyg0qzoktfhjizt9eyvyb\">请把 <code>&lt;base&gt;</code> 元素添加在 <code>&lt;head&gt;</code> 标签的紧后面。如果应用的根目录是 <code>app</code> 目录，那么就可以像这个应用程序一样，设置 <strong><code>index.html</code></strong> 中的 <code>href</code> 值。代码如下。</p>\n<code-example header=\"src/index.html (base-href)\" path=\"router/src/index.html\" region=\"base-href\">\n&lt;base href=\"/\"&gt;\n\n</code-example>\n<h3 id=\"html5-urls-and-the-base-href\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2kkgb5ctubnqc3ngr7sfds9ml\">HTML5 网址和 <code>&lt;base href&gt;</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#html5-urls-and-the-base-href\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"38shco0l5o43d5z8n1xpn4f9m\">后面的指南中会引用 URL 的不同部分。下图是这些部分所指内容的梗概：</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"none\">\n\nfoo://example.com:8042/over/there?name=ferret#nose\n\\_/   \\______________/\\_________/ \\_________/ \\__/\n |           |            |            |        |\nscheme    authority      path        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>   fragment\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46x69q70e1kpzoywy7du384xu\">由于路由器默认使用 <a href=\"https://developer.mozilla.org/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"Browser history push-state\">HTML5 pushState</a>  风格，所以你<em>必须</em>用一个 <code>&lt;base href&gt;</code> 来配置该策略（Strategy）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9co7qfzg7un54g8axo99xiqdi\">配置该策略的首选方式是往 <code>index.html</code> 的 <code>&lt;head&gt;</code> 中添加一个 <a href=\"https://developer.mozilla.org/docs/Web/HTML/Element/base\" title=\"base href\"><code>&lt;base href&gt;</code> element</a>标签。</p>\n<code-example header=\"src/index.html (base-href)\" path=\"router/src/index.html\" region=\"base-href\">\n&lt;base href=\"/\"&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4uon5zk1acdjc23g9yu4z4oy0\">如果没有该标记，浏览器就可能无法在“深度链接”进入应用时加载资源（图片，CSS，脚本）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2plx9vbry3sg9d8xdw0nzo35k\">有些开发人员可能无法添加 <code>&lt;base&gt;</code> 元素，这可能是因为它们没有访问 <code>&lt;head&gt;</code> 或 <code>index.html</code> 的权限。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"40bkngqtv5m7preip5ei35cai\">它们仍然可以使用 HTML 5 格式的 URL，但要采取如下步骤进行补救：</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3m77urwfq13ywasuq7cxpalha\">用适当的 <code><a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a></code> 值提供（provide）路由器。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3eiiqryiowehbhxm4lzs322vg\">对所有 Web 资源（CSS、图片、脚本和模板 HTML 文件）使用根 URL（高优先度 URL）。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3178c2anupeamlmu0szd5d5bm\"><code>&lt;base href&gt;</code> <code>path</code> 应该以“/”结尾，因为浏览器会忽略 <code>path</code> 中最右边的“ <code>/</code> ”后面的字符</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1cwscz45fqlm9b588pa1m7nzw\">如果 <code>&lt;base href&gt;</code> 包含 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> 部分，则只有页内链接的 <code>path</code> 部分为空并且没有 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> 时，才会使用这里的 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code>。这意味着 <code>&lt;base href&gt;</code> 中的 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> 部分只有在使用 <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> 策略时才有用。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cipsq91exmoe39hetfuhj2l09\">如果页内链接是根 URL（高优先度 URL），则 <code>&lt;base href&gt;</code> 不会使用。在这种方式下，<code><a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a></code> 的优先度将会导致所有由 Angular 创建的链接忽略 <code>&lt;base href&gt;</code>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1uo4h7pbiljj2xdlflt3f9b2d\"><code>&lt;base href&gt;</code> 中的片段（#后面的部分）<em>永远不会</em>被使用</p>\n</li>\n</ul>\n</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bg3ae7iiqnp626r5usqxaam0b\">有关如何使用 <code>&lt;base href&gt;</code> 构建目标 URI 的更完整信息，请参阅 <a href=\"https://tools.ietf.org/html/rfc3986#section-5.2.2\">RFC</a>有关转换引用的部分。</p>\n<p><a id=\"hashlocationstrategy\"></a></p>\n<h3 id=\"hashlocationstrategy\"><code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#hashlocationstrategy\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5r6pv82hiy1r121gl4jv8nz77\">通过为\n<code><a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a></code>函数添加\n<code><a href=\"api/router/withHashLocation\" class=\"code-anchor\">withHashLocation</a></code>特性来使用\n<code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code>在\n<code>ApplicationConfiguration</code>中。</p>\n<code-example>\n  providers: [\n    <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>(appRoutes, <a href=\"api/router/withHashLocation\" class=\"code-anchor\">withHashLocation</a>())\n  ]\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dtmsidtovqp61x6kmw10f2u12\">当使用\n<code>RouterModule.forRoot</code>时，在第二个参数中配置\n<code>useHash: true</code>：\n<code>RouterModule.forRoot(routes, {useHash: true})</code>。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Tue Oct 24 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/router\n - api/router/ActivatedRoute\n - api/router/NavigationBehaviorOptions\n - api/router/NavigationExtras\n - api/router/Route\n - api/router/Router\n - api/router/RouterModule\n - api/router/RouterState\n - api/router/TitleStrategy\n - api/router/UrlCreationOptions\n - guide/ajs-quick-reference\n - guide/architecture\n - guide/architecture-next-steps\n - guide/built-in-directives\n - guide/deployment\n - guide/docs-style-guide\n - guide/example-apps-list\n - guide/glossary\n - guide/hierarchical-dependency-injection\n - guide/lazy-loading-ngmodules\n - guide/module-types\n - guide/npm-packages\n - guide/router-reference\n - guide/router-tutorial\n - guide/router-tutorial-toh\n - guide/routing-overview\n - guide/routing-with-urlmatcher\n - guide/upgrade\n - guide/what-is-angular\n - start/start-routing\n - tutorial/first-app/first-app-lesson-10\n - tutorial/first-app/first-app-lesson-11\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/APP_BASE_HREF\n - api/common/CommonModule\n - api/common/HashLocationStrategy\n - api/common/LocationStrategy\n - api/common/PathLocationStrategy\n - api/core/ApplicationConfig\n - api/core/Component\n - api/core/Injectable\n - api/core/Input\n - api/platform-browser/Title\n - api/router/ActivatedRoute\n - api/router/ActivatedRouteSnapshot\n - api/router/CanActivateChildFn\n - api/router/CanActivateFn\n - api/router/CanDeactivateFn\n - api/router/CanLoadFn\n - api/router/CanMatchFn\n - api/router/NavigationExtras\n - api/router/ParamMap\n - api/router/ResolveFn\n - api/router/Route\n - api/router/Route#componentless-routes\n - api/router/Router\n - api/router/RouterConfigOptions#paramsInheritanceStrategy\n - api/router/RouterLink\n - api/router/RouterLinkActive\n - api/router/RouterOutlet\n - api/router/RouterStateSnapshot\n - api/router/Routes\n - api/router/TitleStrategy\n - api/router/provideRouter\n - api/router/withComponentInputBinding\n - api/router/withHashLocation\n - api/router/withRouterConfig\n - guide/dependency-injection-providers\n - guide/lazy-loading-ngmodules\n - guide/router#404-page-how-to\n - guide/router#accessing-query-parameters-and-fragments\n - guide/router#adding-components-for-routing\n - guide/router#base-href\n - guide/router#browser-url-styles\n - guide/router#choosing-a-routing-strategy\n - guide/router#common-routing-tasks\n - guide/router#defining-a-basic-route\n - guide/router#displaying-a-404-page\n - guide/router#generate-an-application\n - guide/router#getting-route-information\n - guide/router#hashlocationstrategy\n - guide/router#html5-urls-and-the-base-href\n - guide/router#importing-your-new-components\n - guide/router#lazy-loading\n - guide/router#link-parameters-array\n - guide/router#locationstrategy-and-browser-url-styles\n - guide/router#nesting-routes\n - guide/router#preventing-unauthorized-access\n - guide/router#route-order\n - guide/router#setting-the-page-title\n - guide/router#setting-up-redirects\n - guide/router#setting-up-wildcard-routes\n - guide/router#specifying-a-relative-route\n - guide/router#using-relative-paths\n - guide/router#wildcard-route-how-to\n - guide/router-tutorial-toh#a-crisis-center-with-child-routes\n - guide/router-tutorial-toh#milestone-5-route-guards\n - guide/router-tutorial-toh#pathmatch\n - https://developer.mozilla.org/docs/Web/API/History_API#Adding_and_modifying_history_entries\n - https://developer.mozilla.org/docs/Web/API/History_API/Working_with_the_History_API#adding_and_modifying_history_entries\n - https://developer.mozilla.org/docs/Web/HTML/Element/base\n - https://tools.ietf.org/html/rfc3986#section-5.2.2\n-->"}