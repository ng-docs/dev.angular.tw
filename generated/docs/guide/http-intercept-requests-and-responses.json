{"id":"guide/http-intercept-requests-and-responses","title":"HTTP - 拦截请求和响应","contents":"<div class=\"content\">\n  <h1 id=\"http---intercept-requests-and-responses\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qu2936s63e8wdu3wdbxoctvr\">HTTP - 拦截请求和响应<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#http---intercept-requests-and-responses\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4bs9o8fmw0znouur938pwj5h\">借助拦截机制，你可以声明一些<em>拦截器</em>，它们可以检查并转换从应用中发给服务器的 HTTP 请求。这些拦截器还可以在返回应用的途中检查和转换来自服务器的响应。多个拦截器构成了请求/响应处理器的<em>双向</em>链表。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4kdbrs3hb0xyqzcr56fc8jb64\">拦截器可以用一种常规的、标准的方式对每一次 HTTP 的请求/响应任务执行从认证到记日志等很多种<em>隐式</em>任务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csokdkrat6s44ctjnj71qbyn0\">如果没有拦截机制，那么开发人员将不得不对每次 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 调用<em>显式</em>实现这些任务。</p>\n<h2 id=\"write-an-interceptor\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6hs5o0k6qes19lgb31jsmg06x\">编写拦截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#write-an-interceptor\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5zpizc1itoc7ljr0gs6z3kqw7\">要实现拦截器，就要实现一个实现了 <code><a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a></code> 接口中的 <code>intercept()</code> 方法的类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6bc24gponzgvfizq9mbt236x2\">这里是一个什么也不做的 <code>noop</code> 拦截器，它只会不做任何修改的传递这个请求。</p>\n<code-example header=\"app/http-interceptors/noop-interceptor.ts\" path=\"http/src/app/http-interceptors/noop-interceptor.ts\" region=\"noop\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport {\n  <a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>, <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a>, <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>, <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>\n} from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { Observable } from 'rxjs';\n\n/** Pass untouched request through to the next request handler. */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class NoopInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>):\n    Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n    return next.handle(req);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6clzbrgjlgpxs81va2wnwt4nq\"><code>intercept</code> 方法会把请求转换成一个最终返回 HTTP 响应体的 <code>Observable</code>。在这个场景中，每个拦截器都完全能自己处理这个请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ia0zijc8dqplgt85f9qg7xrz\">大多数拦截器拦截都会在传入时检查请求，然后把潜在的请求转发给 <code>next</code> 对象的 <code>handle()</code> 方法，而 <code>next</code> 对象实现了 <a href=\"api/common/http/HttpHandler\"><code>HttpHandler</code></a> 接口。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\nexport abstract class <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a> {\n  abstract handle(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt;;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2d5clr6a8numa4d7sn7x1usn8\">像 <code>intercept()</code> 一样，<code>handle()</code> 方法也会把 HTTP 请求转换成 <a href=\"guide/http-intercept-requests-and-responses#interceptor-events\"><code>HttpEvents</code></a> 组成的 <code>Observable</code>，它最终包含的是来自服务器的响应。\n<code>intercept()</code> 函数可以检查这个可观察对象，并在把它返回给调用者之前修改它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"o97r67c84wufwb59jw67yt5x\">这个 <code>no-op</code> 拦截器，会使用原始的请求调用 <code>next.handle()</code>，并返回它返回的可观察对象，而不做任何后续处理。</p>\n<h2 id=\"the-next-object\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4krdxxez19k3bgjgwbg12i2u3\"><code>next</code> 对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#the-next-object\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c0ra18qxqthwojnp1thndj6vz\"><code>next</code> 对象表示拦截器链表中的下一个拦截器。这个链表中的最后一个 <code>next</code> 对象就是 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的后端处理器（backend handler），它会把请求发给服务器，并接收服务器的响应。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cu6ofdvc2mom3qcf5tnhk2uc2\">大多数拦截器都会调用 <code>next.handle()</code> 以便请求流经下一个拦截器，并最终流向后端处理程序。拦截器<em>可以</em>跳过对 <code>next.handle()</code> 的调用，使调用链短路，并<a href=\"guide/http-interceptor-use-cases#caching\">返回带有人工响应体的自定义 <code>Observable</code></a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xh8lq43pubu6mah38n3dx6hy\">这是一种常见的中间件模式，在像 Express.js 这样的框架中也会找到它。</p>\n<h2 id=\"provide-the-interceptor\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zybw5cnvn25ppp43bnknrzvp\">提供这个拦截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#provide-the-interceptor\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ehcyddepqfu3xlr8e9jqmb8f\"><code>NoopInterceptor</code> 就像 Angular 的 \n<a href=\"guide/dependency-injection\">依赖注入（DI）</a> 系统管理的服务一样。 与其他服务一样，你必须在应用程序使用该拦截器类之前提供它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b94f1pndm095m27ashl2gwhkx\">为其编写一个提供者，如下所示： \n<code-example path=\"http/src/app/http-interceptors/noop-interceptor.ts\" region=\"noop-provider\">\n  import { \n <a href=\"api/core/Provider\" class=\"code-anchor\">提供者</a> } from '@angular/core'; // Http 拦截器多提供者的注入令牌 import { \n <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a> } from '@angular/common/\n <a href=\"api/common/http\" class=\"code-anchor\">http</a>'; /** \n <a href=\"api/core/Provider\" class=\"code-anchor\">提供者</a> for the Noop Interceptor. */ export const noopInterceptorProvider: \n <a href=\"api/core/Provider\" class=\"code-anchor\">提供者</a> = { provide: \n <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: NoopInterceptor, multi: true }; \n</code-example></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6abhf8l5uhzayiyv63lr3qyg8\">注意 <code>multi: true</code> 选项。这个必须的选项会告诉 Angular <code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> 是一个<em>多重提供者</em>的令牌，表示它会注入一个多值的数组，而不是单一的值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"k2kkrztgjbpla0mzwms415hp\">由于拦截器是 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务的（可选）依赖，所以你必须在提供 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的同一个（或其各级父注入器）注入器中提供这些拦截器。那些在 DI 创建完 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> <em>之后</em>再提供的拦截器将会被忽略。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"o33jf569xrigxet104lxxht3\">该应用通过将\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>添加到\n<code>app.config.ts</code>的\n<code><a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a></code>的\n<code>providers</code>数组中，向应用的根注入器提供\n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>。 你也应该在那里提供拦截器。</p>\n<code-example header=\"app.config.ts (excerpt)\" path=\"http/src/app/app.config.ts\" region=\"noop-provider\">\nexport const appConfig: <a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a> = {\n  providers: [\n    <a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a>(<a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>),\n    noopInterceptorProvider,\n  ]\n};\n\n\n</code-example>\n<h2 id=\"providing-many-interceptors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3v9vp5lrrob8bi29306mypid3\">提供多个拦截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#providing-many-interceptors\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bqn94qiaqrsg2l5eftezyzu9o\">很可能你会创建更多的拦截器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ardql3l8rgaltqxtpxs2knkhu\">你可以像为\n<code>NoopInterceptor</code>那样，将每个提供者添加到\n<code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>()</code>的\n<code>providers</code>数组中。 这样做相当啰嗦，而且你很可能会在尝试记住添加每个提供者时出现错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cnrzqeae8upyfcnql7mvb5dh3\">这样做相当冗长，而且你很可能在试图记住添加每个提供者时出现错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"83ga1hxg6efjbtvyo27x4k4lv\">你还必须\n<a href=\"guide/http-intercept-requests-and-responses#interceptor-order\">非常注意提供这些拦截器的顺序</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f01mkp5z9ywrhis8xzst7ik50\">考虑创建一个“集合”文件，将\n<em>所有拦截器提供者</em>收集到一个名为\n<code>httpInterceptorProviders</code>的数组中。</p>\n<code-example header=\"app/http-interceptors/index.ts\" path=\"http/src/app/http-interceptors/index.ts\" region=\"interceptor-providers\">\nimport { <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { AuthInterceptor } from './auth-interceptor';\nimport { CachingInterceptor } from './caching-interceptor';\nimport { EnsureHttpsInterceptor } from './ensure-https-interceptor';\nimport { LoggingInterceptor } from './logging-interceptor';\nimport { NoopInterceptor } from './noop-interceptor';\nimport { TrimNameInterceptor } from './trim-name-interceptor';\nimport { UploadInterceptor } from './upload-interceptor';\n\n/** Array of Http interceptor providers in outside-in order */\nexport const httpInterceptorProviders = [\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: NoopInterceptor, multi: true },\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: EnsureHttpsInterceptor, multi: true },\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: TrimNameInterceptor, multi: true },\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: AuthInterceptor, multi: true },\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: LoggingInterceptor, multi: true },\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: UploadInterceptor, multi: true },\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: CachingInterceptor, multi: true },\n];\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"epbkpfw56juah8krc0a1mjkz6\">这些拦截器在完整的示例代码中定义。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2lek87oenvttp2a4lm98rw19x\">然后像这样将这个数组导入，并将其添加到\n<code>app.config.ts</code>中\n<code><a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a></code>的\n<code>providers</code>中：</p>\n<code-example header=\"main.ts (interceptor providers)\" path=\"http/src/app/app.config.ts\" region=\"interceptor-providers\">\nexport const appConfig: <a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a> = {\n  providers: [\n    <a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a>(<a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>),\n    httpInterceptorProviders,\n  ]\n};\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8x3wx26r1104im7l5bj83w5j\">当你创建新的拦截器时，将它们添加到\n<code>httpInterceptorProviders</code>数组中，就不必再回顾\n<code>main.ts</code>了。</p>\n<h2 id=\"interceptor-order\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6dc909apclh4hqh85pfad2evt\">拦截器的顺序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#interceptor-order\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"860w1uli90lrhavgy17txrdgu\">Angular 会按你提供拦截器的顺序应用它们。比如，考虑一个场景：你想处理 HTTP 请求的身份验证并记录它们，然后再将它们发送到服务器。要完成此任务，你可以提供 <code>AuthInterceptor</code> 服务，然后提供 <code>LoggingInterceptor</code> 服务。发出的请求将从 <code>AuthInterceptor</code> 到 <code>LoggingInterceptor</code>。这些请求的响应则沿相反的方向流动，从 <code>LoggingInterceptor</code> 回到 <code>AuthInterceptor</code>。以下是该过程的直观表示：</p>\n<div class=\"lightbox\">\n<img alt=\"Interceptor in order of HttpClient, AuthInterceptor, AuthInterceptor, HttpBackend, Server, and back in opposite order to show the two-way flow\" src=\"generated/images/guide/http/interceptor-order.svg\" width=\"300\" height=\"522\">\n</div>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tj8gay1z9ubtaj2hjfftodor\">该过程中的最后一个拦截器始终是处理与服务器通信的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 服务。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c17pbvxqxphoz2emus359mil4\">以后你就再也不能修改这些顺序或移除某些拦截器了。如果你需要动态启用或禁用某个拦截器，那就要在那个拦截器中自行实现这个功能。</p>\n<p><a id=\"interceptor-events\"></a></p>\n<h2 id=\"handle-interceptor-events\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7azkawvza7qfzev3rdzcp1rao\">处理拦截器事件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#handle-interceptor-events\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ddu9q0gv2i3jmn86w0ugm6jrv\">大多数 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法都会返回 <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;any&gt;</code> 型的可观察对象。<code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 类本身就是一个事件，它的类型是 <code><a href=\"api/common/http/HttpEventType#Response\" class=\"code-anchor\">HttpEventType.Response</a></code>。但是，单个 HTTP 请求可以生成其它类型的多个事件，包括报告上传和下载进度的事件。<code>HttpInterceptor.intercept()</code> 和 <code>HttpHandler.handle()</code> 会返回 <code><a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;</code> 型的可观察对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72pq5lay0wby1oo04wlvlkdls\">很多拦截器只关心发出的请求，而对 <code>next.handle()</code> 返回的事件流不会做任何修改。但是，有些拦截器需要检查并修改 <code>next.handle()</code> 的响应。上述做法就可以在流中看到所有这些事件。</p>\n<p><a id=\"immutability\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7o1i845frf62lioneiui2puk9\">有充足的理由把它们做成不可变对象：应用可能会重试发送很多次请求之后才能成功，这就意味着这个拦截器链表可能会多次重复处理同一个请求。如果拦截器可以修改原始的请求对象，那么重试阶段的操作就会从修改过的请求开始，而不是原始请求。而这种不可变性，可以确保这些拦截器在每次重试时看到的都是同样的原始请求。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4evz60rmycgfwumdawc2qqsxj\">你的拦截器应该在没有任何修改的情况下返回每一个事件，除非它有令人信服的理由去做。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"px1v2nymqfekqughm2d6caqs\">TypeScript 会阻止你设置 <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 的只读属性。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\n// Typescript disallows the following assignment because req.url is readonly\nreq.url = req.url.replace('<a href=\"api/common/http\" class=\"code-anchor\">http</a>://', 'https://');\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5numu3ngtqwwta2785x84o45i\">如果你必须修改一个请求，先把它克隆一份，修改这个克隆体后再把它传给 <code>next.handle()</code>。你可以在一步中克隆并修改此请求，例子如下。</p>\n<code-example header=\"app/http-interceptors/ensure-https-interceptor.ts (excerpt)\" path=\"http/src/app/http-interceptors/ensure-https-interceptor.ts\" region=\"excerpt\">\n// clone request and replace '<a href=\"api/common/http\" class=\"code-anchor\">http</a>://' with 'https://' at the same time\nconst secureReq = req.clone({\n  url: req.url.replace('<a href=\"api/common/http\" class=\"code-anchor\">http</a>://', 'https://')\n});\n// send the cloned, \"secure\" request to the next handler.\nreturn next.handle(secureReq);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"k5l915790kmeuzl7wyl1rums\">这个 <code>clone()</code> 方法的哈希型参数允许你在复制出克隆体的同时改变该请求的某些特定属性。</p>\n<h3 id=\"modify-a-request-body\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azupmjy8kvmb1zij1ua9fqirw\">修改请求体<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#modify-a-request-body\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"543zhqwz05rbyijnjhiqvsqbj\"><code>readonly</code> 这种赋值保护，无法防范深修改（修改子对象的属性），也不能防范你修改请求体对象中的属性。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\nreq.body.name = req.body.name.trim(); // bad idea!\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"emcrznpvbzk11mceenu2vpdg2\">如果必须修改请求体，请执行以下步骤。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"67r37nqkpta7u2tgb107icw2r\">复制请求体并在副本中进行修改。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ltvzsb35ve31tbt1corkqfur\">使用 <code>clone()</code> 方法克隆这个请求对象。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aminr6j70lk1bjrkhqvchhjja\">用修改过的副本替换被克隆的请求体。</li>\n</ol>\n<code-example header=\"app/http-interceptors/trim-name-interceptor.ts (excerpt)\" path=\"http/src/app/http-interceptors/trim-name-interceptor.ts\" region=\"excerpt\">\n// copy the body and trim whitespace from the name property\nconst newBody = { ...body, name: body.name.trim() };\n// clone request and set its body\nconst newReq = req.clone({ body: newBody });\n// send the cloned request to the next handler.\nreturn next.handle(newReq);\n\n</code-example>\n<h3 id=\"clear-the-request-body-in-a-clone\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ax7inpc5147cwduqzk489d0bf\">清除克隆中的请求正文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#clear-the-request-body-in-a-clone\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekj08ek3crew6lxobe216g7ir\">有时，你需要清除请求体而不是替换它。为此，请将克隆后的请求体设置为 <code>null</code>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ygmhq2b5jw66w2zes4iq3muy\"><strong>提示</strong>：<br>\n如果你把克隆后的请求体设为 <code>undefined</code>，那么 Angular 会认为你想让请求体保持原样。</p>\n</div>\n<code-example format=\"javascript\" language=\"javascript\">\n\nnewReq = req.clone({ … }); // body not mentioned =&gt; preserve original body\nnewReq = req.clone({ body: undefined }); // preserve original body\nnewReq = req.clone({ body: null }); // clear the body\n\n</code-example>\n\n  <div class=\"reviewed\">最后复查时间：Wed Aug 16 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/common/http/HttpHandlerFn\n - api/common/http/HttpInterceptor\n - api/common/http/HttpInterceptorFn\n - guide/http-track-show-request-progress\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/common/http\n - api/common/http/HTTP_INTERCEPTORS\n - api/common/http/HttpBackend\n - api/common/http/HttpClient\n - api/common/http/HttpClientModule\n - api/common/http/HttpEvent\n - api/common/http/HttpEventType#Response\n - api/common/http/HttpHandler\n - api/common/http/HttpInterceptor\n - api/common/http/HttpRequest\n - api/common/http/HttpResponse\n - api/core/ApplicationConfig\n - api/core/Injectable\n - api/core/Provider\n - api/core/importProvidersFrom\n - api/platform-browser/bootstrapApplication\n - guide/dependency-injection\n - guide/http-intercept-requests-and-responses#clear-the-request-body-in-a-clone\n - guide/http-intercept-requests-and-responses#handle-interceptor-events\n - guide/http-intercept-requests-and-responses#http---intercept-requests-and-responses\n - guide/http-intercept-requests-and-responses#interceptor-events\n - guide/http-intercept-requests-and-responses#interceptor-order\n - guide/http-intercept-requests-and-responses#modify-a-request-body\n - guide/http-intercept-requests-and-responses#provide-the-interceptor\n - guide/http-intercept-requests-and-responses#providing-many-interceptors\n - guide/http-intercept-requests-and-responses#the-next-object\n - guide/http-intercept-requests-and-responses#write-an-interceptor\n - guide/http-interceptor-use-cases#caching\n-->"}