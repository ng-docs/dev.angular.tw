{"id":"guide/http-intercept-requests-and-responses","title":"HTTP - 攔截請求和回應","contents":"<div class=\"content\">\n  <h1 id=\"http---intercept-requests-and-responses\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qu2936s63e8wdu3wdbxoctvr\">HTTP - 攔截請求和回應<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#http---intercept-requests-and-responses\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4bs9o8fmw0znouur938pwj5h\">藉助攔截機制，你可以宣告一些<em>攔截器</em>，它們可以檢查並轉換從應用中發給伺服器的 HTTP 請求。這些攔截器還可以在回傳應用的途中檢查和轉換來自伺服器的回應。多個攔截器構成了請求/回應處理器的<em>雙向</em>連結串列。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4kdbrs3hb0xyqzcr56fc8jb64\">攔截器可以用一種常規的、標準的方式對每一次 HTTP 的請求/回應任務執行從認證到記日誌等很多種<em>隱式</em>任務。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csokdkrat6s44ctjnj71qbyn0\">如果沒有攔截機制，那麼開發人員將不得不對每次 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 呼叫<em>顯式</em>實現這些任務。</p>\n<h2 id=\"write-an-interceptor\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6hs5o0k6qes19lgb31jsmg06x\">編寫攔截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#write-an-interceptor\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5zpizc1itoc7ljr0gs6z3kqw7\">要實現攔截器，就要實現一個實現了 <code><a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a></code> 介面中的 <code>intercept()</code> 方法的類別。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6bc24gponzgvfizq9mbt236x2\">這裡是一個什麼也不做的 <code>noop</code> 攔截器，它只會不做任何修改的傳遞這個請求。</p>\n<code-example header=\"app/http-interceptors/noop-interceptor.ts\" path=\"http/src/app/http-interceptors/noop-interceptor.ts\" region=\"noop\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport {\n  <a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>, <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a>, <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>, <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>\n} from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { Observable } from 'rxjs';\n\n/** Pass untouched request through to the next request handler. */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class NoopInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>):\n    Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n    return next.handle(req);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6clzbrgjlgpxs81va2wnwt4nq\"><code>intercept</code> 方法會把請求轉換成一個最終回傳 HTTP 回應體的 <code>Observable</code>。在這個場景中，每個攔截器都完全能自己處理這個請求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ia0zijc8dqplgt85f9qg7xrz\">大多數攔截器攔截都會在傳入時檢查請求，然後把潛在的請求轉發給 <code>next</code> 物件的 <code>handle()</code> 方法，而 <code>next</code> 物件實現了 <a href=\"api/common/http/HttpHandler\"><code>HttpHandler</code></a> 介面。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\nexport abstract class <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a> {\n  abstract handle(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt;;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2d5clr6a8numa4d7sn7x1usn8\">像 <code>intercept()</code> 一樣，<code>handle()</code> 方法也會把 HTTP 請求轉換成 <a href=\"guide/http-intercept-requests-and-responses#interceptor-events\"><code>HttpEvents</code></a> 組成的 <code>Observable</code>，它最終包含的是來自伺服器的回應。\n<code>intercept()</code> 函式可以檢查這個可觀察物件，並在把它回傳給呼叫者之前修改它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"o97r67c84wufwb59jw67yt5x\">這個 <code>no-op</code> 攔截器，會使用原始的請求呼叫 <code>next.handle()</code>，並回傳它回傳的可觀察物件，而不做任何後續處理。</p>\n<h2 id=\"the-next-object\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4krdxxez19k3bgjgwbg12i2u3\"><code>next</code> 物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#the-next-object\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c0ra18qxqthwojnp1thndj6vz\"><code>next</code> 物件表示攔截器連結串列中的下一個攔截器。這個連結串列中的最後一個 <code>next</code> 物件就是 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的後端處理器（backend handler），它會把請求發給伺服器，並接收伺服器的回應。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cu6ofdvc2mom3qcf5tnhk2uc2\">大多數攔截器都會呼叫 <code>next.handle()</code> 以便請求流經下一個攔截器，並最終流向後端處理程式。攔截器<em>可以</em>跳過對 <code>next.handle()</code> 的呼叫，使呼叫鏈短路，並<a href=\"guide/http-interceptor-use-cases#caching\">回傳帶有人工回應體的自定義 <code>Observable</code></a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xh8lq43pubu6mah38n3dx6hy\">這是一種常見的中間件模式，在像 Express.js 這樣的框架中也會找到它。</p>\n<h2 id=\"provide-the-interceptor\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zybw5cnvn25ppp43bnknrzvp\">提供這個攔截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#provide-the-interceptor\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ehcyddepqfu3xlr8e9jqmb8f\"><code>NoopInterceptor</code> 就像 Angular 的 \n<a href=\"guide/dependency-injection\">依賴注入（DI）</a> 系統管理的服務一樣。 與其他服務一樣，你必須在應用程式使用該攔截器類別之前提供它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b94f1pndm095m27ashl2gwhkx\">為其編寫一個提供者，如下所示： \n<code-example path=\"http/src/app/http-interceptors/noop-interceptor.ts\" region=\"noop-provider\">\n  import { \n <a href=\"api/core/Provider\" class=\"code-anchor\">提供者</a> } from '@angular/core'; // Http 攔截器多提供者的注入令牌 import { \n <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a> } from '@angular/common/\n <a href=\"api/common/http\" class=\"code-anchor\">http</a>'; /** \n <a href=\"api/core/Provider\" class=\"code-anchor\">提供者</a> for the Noop Interceptor. */ export const noopInterceptorProvider: \n <a href=\"api/core/Provider\" class=\"code-anchor\">提供者</a> = { provide: \n <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: NoopInterceptor, multi: true }; \n</code-example></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6abhf8l5uhzayiyv63lr3qyg8\">注意 <code>multi: true</code> 選項。這個必須的選項會告訴 Angular <code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> 是一個<em>多重提供者</em>的令牌，表示它會注入一個多值的陣列，而不是單一的值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"k2kkrztgjbpla0mzwms415hp\">由於攔截器是 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務的（可選）依賴，所以你必須在提供 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的同一個（或其各級父注入器）注入器中提供這些攔截器。那些在 DI 建立完 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> <em>之後</em>再提供的攔截器將會被忽略。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"o33jf569xrigxet104lxxht3\">該應用透過將\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>新增到\n<code>app.config.ts</code>的\n<code><a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a></code>的\n<code>providers</code>陣列中，嚮應用的根注入器提供\n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>。 你也應該在那裡提供攔截器。</p>\n<code-example header=\"app.config.ts (excerpt)\" path=\"http/src/app/app.config.ts\" region=\"noop-provider\">\nexport const appConfig: <a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a> = {\n  providers: [\n    <a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a>(<a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>),\n    noopInterceptorProvider,\n  ]\n};\n\n\n</code-example>\n<h2 id=\"providing-many-interceptors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3v9vp5lrrob8bi29306mypid3\">提供多個攔截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#providing-many-interceptors\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bqn94qiaqrsg2l5eftezyzu9o\">很可能你會建立更多的攔截器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ardql3l8rgaltqxtpxs2knkhu\">你可以像為\n<code>NoopInterceptor</code>那樣，將每個提供者新增到\n<code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>()</code>的\n<code>providers</code>陣列中。 這樣做相當囉嗦，而且你很可能會在嘗試記住新增每個提供者時出現錯誤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cnrzqeae8upyfcnql7mvb5dh3\">這樣做相當冗長，而且你很可能在試圖記住新增每個提供者時出現錯誤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"83ga1hxg6efjbtvyo27x4k4lv\">你還必須\n<a href=\"guide/http-intercept-requests-and-responses#interceptor-order\">非常注意提供這些攔截器的順序</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f01mkp5z9ywrhis8xzst7ik50\">考慮建立一個『集合』檔案，將\n<em>所有攔截器提供者</em>收集到一個名為\n<code>httpInterceptorProviders</code>的陣列中。</p>\n<code-example header=\"app/http-interceptors/index.ts\" path=\"http/src/app/http-interceptors/index.ts\" region=\"interceptor-providers\">\nimport { <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { AuthInterceptor } from './auth-interceptor';\nimport { CachingInterceptor } from './caching-interceptor';\nimport { EnsureHttpsInterceptor } from './ensure-https-interceptor';\nimport { LoggingInterceptor } from './logging-interceptor';\nimport { NoopInterceptor } from './noop-interceptor';\nimport { TrimNameInterceptor } from './trim-name-interceptor';\nimport { UploadInterceptor } from './upload-interceptor';\n\n/** Array of Http interceptor providers in outside-in order */\nexport const httpInterceptorProviders = [\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: NoopInterceptor, multi: true },\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: EnsureHttpsInterceptor, multi: true },\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: TrimNameInterceptor, multi: true },\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: AuthInterceptor, multi: true },\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: LoggingInterceptor, multi: true },\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: UploadInterceptor, multi: true },\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: CachingInterceptor, multi: true },\n];\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"epbkpfw56juah8krc0a1mjkz6\">這些攔截器在完整的範例程式碼中定義。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2lek87oenvttp2a4lm98rw19x\">然後像這樣將這個陣列匯入，並將其新增到\n<code>app.config.ts</code>中\n<code><a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a></code>的\n<code>providers</code>中：</p>\n<code-example header=\"main.ts (interceptor providers)\" path=\"http/src/app/app.config.ts\" region=\"interceptor-providers\">\nexport const appConfig: <a href=\"api/core/ApplicationConfig\" class=\"code-anchor\">ApplicationConfig</a> = {\n  providers: [\n    <a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a>(<a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>),\n    httpInterceptorProviders,\n  ]\n};\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8x3wx26r1104im7l5bj83w5j\">當你建立新的攔截器時，將它們新增到\n<code>httpInterceptorProviders</code>陣列中，就不必再回顧\n<code>main.ts</code>了。</p>\n<h2 id=\"interceptor-order\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6dc909apclh4hqh85pfad2evt\">攔截器的順序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#interceptor-order\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"860w1uli90lrhavgy17txrdgu\">Angular 會按你提供攔截器的順序應用它們。比如，考慮一個場景：你想處理 HTTP 請求的身份驗證並記錄它們，然後再將它們傳送到伺服器。要完成此任務，你可以提供 <code>AuthInterceptor</code> 服務，然後提供 <code>LoggingInterceptor</code> 服務。發出的請求將從 <code>AuthInterceptor</code> 到 <code>LoggingInterceptor</code>。這些請求的回應則沿相反的方向流動，從 <code>LoggingInterceptor</code> 回到 <code>AuthInterceptor</code>。以下是該過程的直觀表示：</p>\n<div class=\"lightbox\">\n<img alt=\"Interceptor in order of HttpClient, AuthInterceptor, AuthInterceptor, HttpBackend, Server, and back in opposite order to show the two-way flow\" src=\"generated/images/guide/http/interceptor-order.svg\" width=\"300\" height=\"522\">\n</div>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tj8gay1z9ubtaj2hjfftodor\">該過程中的最後一個攔截器始終是處理與伺服器通訊的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 服務。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c17pbvxqxphoz2emus359mil4\">以後你就再也不能修改這些順序或移除某些攔截器了。如果你需要動態啟用或停用某個攔截器，那就要在那個攔截器中自行實現這個功能。</p>\n<p><a id=\"interceptor-events\"></a></p>\n<h2 id=\"handle-interceptor-events\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7azkawvza7qfzev3rdzcp1rao\">處理攔截器事件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#handle-interceptor-events\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ddu9q0gv2i3jmn86w0ugm6jrv\">大多數 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法都會回傳 <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;any&gt;</code> 型的可觀察物件。<code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 類別本身就是一個事件，它的型別是 <code><a href=\"api/common/http/HttpEventType#Response\" class=\"code-anchor\">HttpEventType.Response</a></code>。但是，單個 HTTP 請求可以生成其它型別的多個事件，包括報告上傳和下載進度的事件。<code>HttpInterceptor.intercept()</code> 和 <code>HttpHandler.handle()</code> 會回傳 <code><a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;</code> 型的可觀察物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72pq5lay0wby1oo04wlvlkdls\">很多攔截器只關心發出的請求，而對 <code>next.handle()</code> 回傳的事件流不會做任何修改。但是，有些攔截器需要檢查並修改 <code>next.handle()</code> 的回應。上述做法就可以在流中看到所有這些事件。</p>\n<p><a id=\"immutability\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7o1i845frf62lioneiui2puk9\">有充足的理由把它們做成不可變物件：應用可能會重試傳送很多次請求之後才能成功，這就意味著這個攔截器連結串列可能會多次重複處理同一個請求。如果攔截器可以修改原始的請求物件，那麼重試階段的操作就會從修改過的請求開始，而不是原始請求。而這種不可變性，可以確保這些攔截器在每次重試時看到的都是同樣的原始請求。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4evz60rmycgfwumdawc2qqsxj\">你的攔截器應該在沒有任何修改的情況下回傳每一個事件，除非它有令人信服的理由去做。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"px1v2nymqfekqughm2d6caqs\">TypeScript 會阻止你設定 <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 的只讀屬性。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\n// Typescript disallows the following assignment because req.url is readonly\nreq.url = req.url.replace('<a href=\"api/common/http\" class=\"code-anchor\">http</a>://', 'https://');\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5numu3ngtqwwta2785x84o45i\">如果你必須修改一個請求，先把它克隆一份，修改這個克隆體後再把它傳給 <code>next.handle()</code>。你可以在一步中克隆並修改此請求，例子如下。</p>\n<code-example header=\"app/http-interceptors/ensure-https-interceptor.ts (excerpt)\" path=\"http/src/app/http-interceptors/ensure-https-interceptor.ts\" region=\"excerpt\">\n// clone request and replace '<a href=\"api/common/http\" class=\"code-anchor\">http</a>://' with 'https://' at the same time\nconst secureReq = req.clone({\n  url: req.url.replace('<a href=\"api/common/http\" class=\"code-anchor\">http</a>://', 'https://')\n});\n// send the cloned, \"secure\" request to the next handler.\nreturn next.handle(secureReq);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"k5l915790kmeuzl7wyl1rums\">這個 <code>clone()</code> 方法的雜湊型引數允許你在複製出克隆體的同時改變該請求的某些特定屬性。</p>\n<h3 id=\"modify-a-request-body\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azupmjy8kvmb1zij1ua9fqirw\">修改請求體<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#modify-a-request-body\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"543zhqwz05rbyijnjhiqvsqbj\"><code>readonly</code> 這種賦值保護，無法防範深修改（修改子物件的屬性），也不能防範你修改請求體物件中的屬性。</p>\n<code-example format=\"javascript\" language=\"javascript\">\n\nreq.body.name = req.body.name.trim(); // bad idea!\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"emcrznpvbzk11mceenu2vpdg2\">如果必須修改請求體，請執行以下步驟。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"67r37nqkpta7u2tgb107icw2r\">複製請求體並在副本中進行修改。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ltvzsb35ve31tbt1corkqfur\">使用 <code>clone()</code> 方法克隆這個請求物件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aminr6j70lk1bjrkhqvchhjja\">用修改過的副本替換被克隆的請求體。</li>\n</ol>\n<code-example header=\"app/http-interceptors/trim-name-interceptor.ts (excerpt)\" path=\"http/src/app/http-interceptors/trim-name-interceptor.ts\" region=\"excerpt\">\n// copy the body and trim whitespace from the name property\nconst newBody = { ...body, name: body.name.trim() };\n// clone request and set its body\nconst newReq = req.clone({ body: newBody });\n// send the cloned request to the next handler.\nreturn next.handle(newReq);\n\n</code-example>\n<h3 id=\"clear-the-request-body-in-a-clone\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ax7inpc5147cwduqzk489d0bf\">清除克隆中的請求正文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#clear-the-request-body-in-a-clone\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekj08ek3crew6lxobe216g7ir\">有時，你需要清除請求體而不是替換它。為此，請將克隆後的請求體設定為 <code>null</code>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ygmhq2b5jw66w2zes4iq3muy\"><strong>提示</strong>：<br>\n如果你把克隆後的請求體設為 <code>undefined</code>，那麼 Angular 會認為你想讓請求體保持原樣。</p>\n</div>\n<code-example format=\"javascript\" language=\"javascript\">\n\nnewReq = req.clone({ … }); // body not mentioned =&gt; preserve original body\nnewReq = req.clone({ body: undefined }); // preserve original body\nnewReq = req.clone({ body: null }); // clear the body\n\n</code-example>\n\n  <div class=\"reviewed\">最後複查時間：Wed Aug 16 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/common/http/HttpHandlerFn\n - api/common/http/HttpInterceptor\n - api/common/http/HttpInterceptorFn\n - guide/http-track-show-request-progress\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/common/http\n - api/common/http/HTTP_INTERCEPTORS\n - api/common/http/HttpBackend\n - api/common/http/HttpClient\n - api/common/http/HttpClientModule\n - api/common/http/HttpEvent\n - api/common/http/HttpEventType#Response\n - api/common/http/HttpHandler\n - api/common/http/HttpInterceptor\n - api/common/http/HttpRequest\n - api/common/http/HttpResponse\n - api/core/ApplicationConfig\n - api/core/Injectable\n - api/core/Provider\n - api/core/importProvidersFrom\n - api/platform-browser/bootstrapApplication\n - guide/dependency-injection\n - guide/http-intercept-requests-and-responses#clear-the-request-body-in-a-clone\n - guide/http-intercept-requests-and-responses#handle-interceptor-events\n - guide/http-intercept-requests-and-responses#http---intercept-requests-and-responses\n - guide/http-intercept-requests-and-responses#interceptor-events\n - guide/http-intercept-requests-and-responses#interceptor-order\n - guide/http-intercept-requests-and-responses#modify-a-request-body\n - guide/http-intercept-requests-and-responses#provide-the-interceptor\n - guide/http-intercept-requests-and-responses#providing-many-interceptors\n - guide/http-intercept-requests-and-responses#the-next-object\n - guide/http-intercept-requests-and-responses#write-an-interceptor\n - guide/http-interceptor-use-cases#caching\n-->"}