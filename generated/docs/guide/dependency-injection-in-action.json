{"id":"guide/dependency-injection-in-action","title":"依赖注入实战","contents":"<div class=\"content\">\n  <h1 id=\"dependency-injection-in-action\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8l3nguqidu25c8b6u8y53odn4\">依赖注入实战<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#dependency-injection-in-action\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aqztnx0rsuqheavltbhth338a\">本章涉及到 Angular 依赖注入（DI）的很多特性。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"81el5yk7yllx1tewd03bnp7o0\">本章包含代码片段的工作实例参阅<live-example></live-example>。</p>\n</div>\n<p><a id=\"multiple-service-instances\"></a></p>\n<h2 id=\"multiple-service-instances-sandboxing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5qv1ogkr4lur5dx4q6zaala9b\">多个服务实例（沙箱式隔离）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#multiple-service-instances-sandboxing\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"p92faeb3htcifaeougp2tfuv\">在组件树的<em>同一个级别</em>上，有时需要一个服务的多个实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wo3iclaudu53fcsf5grdm8rx\">一个用来保存其伴生组件的实例状态的服务就是个好例子。每个组件都需要该服务的单独实例。每个服务有自己的工作状态，与其它组件的服务和状态隔离。这叫做<em>沙箱化</em>，因为每个服务和组件实例都在自己的沙箱里运行。</p>\n<p><a id=\"hero-bios-component\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b4mr1g6pl88n6gtz4vtrigteo\">在这个例子中，<code>HeroBiosComponent</code> 渲染了 <code>HeroBioComponent</code> 的三个实例。</p>\n<code-example header=\"src/app/hero-bios.component.ts\" path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"simple\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-hero-bios',\n  template: `\n    &lt;app-hero-bio [heroId]=\"1\"&gt;&lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"2\"&gt;&lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"3\"&gt;&lt;/app-hero-bio&gt;`,\n  providers: [HeroService],\n  imports: [HeroBioComponent]\n})\nexport class HeroBiosComponent {\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dshb45jvowew7m20pfhy9pea\">每个 <code>HeroBioComponent</code> 都能编辑一个英雄的生平。<code>HeroBioComponent</code> 依赖 <code>HeroCacheService</code> 服务来对该英雄进行读取、缓存和执行其它持久化操作。</p>\n<code-example header=\"src/app/hero-cache.service.ts\" path=\"dependency-injection-in-action/src/app/hero-cache.service.ts\" region=\"service\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroCacheService {\n  hero!: Hero;\n  constructor(private heroService: HeroService) {}\n\n  fetchCachedHero(id: number) {\n    if (!this.hero) {\n      this.hero = this.heroService.getHeroById(id);\n    }\n    return this.hero;\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ammp4exzmlvbdvk67xx0x9md6\">这三个 <code>HeroBioComponent</code> 实例不能共享同一个 <code>HeroCacheService</code> 实例。否则它们会相互冲突，争相把自己的英雄放在缓存里面。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1zetvfrmdrptxrqzayztz7ott\">它们应该通过在自己的元数据（metadata）<code>providers</code> 数组里面列出 <code>HeroCacheService</code>, 这样每个 <code>HeroBioComponent</code> 就能<em>拥有</em>自己独立的 <code>HeroCacheService</code> 实例了。</p>\n<code-example header=\"src/app/hero-bio.component.ts\" path=\"dependency-injection-in-action/src/app/hero-bio.component.ts\" region=\"component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-hero-bio',\n  template: `\n    &lt;h4&gt;{{hero.name}}&lt;/h4&gt;\n    &lt;ng-content&gt;&lt;/ng-content&gt;\n    &lt;<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> cols=\"25\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.description\"&gt;&lt;/<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a>&gt;`,\n  providers: [HeroCacheService],\n  imports: [<a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>]\n})\n\nexport class HeroBioComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>  {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() heroId = 0;\n\n  constructor(private heroCache: HeroCacheService) { }\n\n  ngOnInit() { this.heroCache.fetchCachedHero(this.heroId); }\n\n  get hero() { return this.heroCache.hero; }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c464be7gzfrw69uynuknrj44p\">父组件 <code>HeroBiosComponent</code> 把一个值绑定到 <code>heroId</code>。<code>ngOnInit</code> 把该 <code>id</code> 传递到服务，然后服务获取和缓存英雄。<code>hero</code> 属性的 getter 从服务里面获取缓存的英雄，并在模板里显示它绑定到属性值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"psbk79l3houo8z3e0nt1g0x5\">到<live-example name=\"dependency-injection-in-action\">现场演练</live-example>中找到这个例子，确认三个 <code>HeroBioComponent</code> 实例拥有自己独立的英雄数据缓存。</p>\n<div class=\"lightbox\">\n<img alt=\"Bios\" src=\"generated/images/guide/dependency-injection-in-action/hero-bios.png\" width=\"199\" height=\"317\">\n</div>\n<p><a id=\"qualify-dependency-lookup\"></a></p>\n<h2 id=\"qualify-dependency-lookup-with-parameter-decorators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwhwt0z893wbu84z4thn95soa\">使用参数装饰器来限定依赖查找方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#qualify-dependency-lookup-with-parameter-decorators\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eeh5cmm3bkzwlrfgbgp1huwr1\">当类需要某个依赖项时，该依赖项就会作为参数添加到类的构造函数中。当 Angular 需要实例化该类时，就会调用 DI 框架来提供该依赖。默认情况下，DI 框架会在注入器树中查找一个提供者，从该组件的局部注入器开始，如果需要，则沿着注入器树向上冒泡，直到根注入器。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c1cmlzqvzff6y1pt9rh9fjdd0\">第一个配置过该提供者的注入器就会把依赖（服务实例或值）提供给这个构造函数</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6i0uk41v6vl8htmpf14wyfs8h\">如果在根注入器中也没有找到提供者，则 DI 框架将会抛出一个错误</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2m1j62xp4keojw4egrlche4px\">通过在类的构造函数中对服务参数使用<em>参数装饰器</em>，可以提供一些选项来修改默认的搜索行为。</p>\n<p><a id=\"optional\"></a></p>\n<h3 id=\"make-a-dependency-optional-and-limit-search-with-host\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3upufcdm7hsixvaagizkdnuzh\">用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 来让依赖是可选的，以及使用 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 来限定搜索方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#make-a-dependency-optional-and-limit-search-with-host\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ememduhwg18phqhnq4xdej13i\">依赖可以注册在组件树的任何层级上。当组件请求某个依赖时，Angular 会从该组件的注入器找起，沿着注入器树向上，直到找到了第一个满足要求的提供者。如果没找到依赖，Angular 就会抛出一个错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b20fcp460izuv6zpgglmu1fs1\">某些情况下，你需要限制搜索，或容忍依赖项的缺失。你可以使用组件构造函数参数上的 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 和 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 这两个限定装饰器来修改 Angular 的搜索行为。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"16c6sv4ezkm5ir892ej23fb7a\"><code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 属性装饰器告诉 Angular 当找不到依赖时就返回 null</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"wlyzhlolis3m77ex86o571vd\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 属性装饰器会禁止在<em>宿主组件</em>以上的搜索。宿主组件通常就是请求该依赖的那个组件。不过，当该组件投影进某个<em>父</em>组件时，那个父组件就会变成宿主。下面的例子中介绍了第二种情况。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4lhzhdxcvq04b1dqpg8qu6yct\">如下例所示，这些装饰器可以独立使用，也可以同时使用。这个 <code>HeroBiosAndContactsComponent</code> 是你<a href=\"guide/dependency-injection-in-action#hero-bios-component\">以前</a>见过的那个 <code>HeroBiosComponent</code> 的修改版。</p>\n<code-example header=\"src/app/hero-bios.component.ts (HeroBiosAndContactsComponent)\" path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"hero-bios-and-contacts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-hero-bios-and-contacts',\n  template: `\n    &lt;app-hero-bio [heroId]=\"1\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"2\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"3\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;`,\n  providers: [HeroService],\n  imports: [HeroBioComponent, HeroContactComponent]\n})\nexport class HeroBiosAndContactsComponent {\n  constructor(logger: LoggerService) {\n    logger.logInfo('Creating HeroBiosAndContactsComponent');\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9z1lei5qeso1bcrmfg36ppq84\">注意看模板：</p>\n<code-example header=\"src/app/hero-bios.component.ts\" path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"template\">\ntemplate: `\n  &lt;app-hero-bio [heroId]=\"1\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n  &lt;app-hero-bio [heroId]=\"2\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n  &lt;app-hero-bio [heroId]=\"3\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;`,\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vgqm4urg4zubwjq6zj5y2c3s\">在 <code>&lt;hero-bio&gt;</code> 标签中是一个新的 <code>&lt;hero-contact&gt;</code> 元素。Angular 就会把相应的 <code>HeroContactComponent</code><em>投影</em>或透传（<em>transclude</em>）进 <code>HeroBioComponent</code> 的视图里，将它放在 <code>HeroBioComponent</code> 模板的 <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 标签槽里。</p>\n<code-example header=\"src/app/hero-bio.component.ts (template)\" path=\"dependency-injection-in-action/src/app/hero-bio.component.ts\" region=\"template\">\ntemplate: `\n  &lt;h4&gt;{{hero.name}}&lt;/h4&gt;\n  &lt;ng-content&gt;&lt;/ng-content&gt;\n  &lt;<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> cols=\"25\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.description\"&gt;&lt;/<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a>&gt;`,\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3z25gcxqw3sy4ahiob9xv9r5\">从 <code>HeroContactComponent</code> 获得的英雄电话号码，被投影到上面的英雄描述里，结果如下：</p>\n<div class=\"lightbox\">\n<img alt=\"bio and contact\" src=\"generated/images/guide/dependency-injection-in-action/hero-bio-and-content.png\" width=\"199\" height=\"92\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"afwkalai9y7ygak64ijzltdx6\">这里的 <code>HeroContactComponent</code> 演示了限定型装饰器。</p>\n<code-example header=\"src/app/hero-contact.component.ts\" path=\"dependency-injection-in-action/src/app/hero-contact.component.ts\" region=\"component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-hero-contact',\n  template: `\n  &lt;div&gt;Phone #: {{phoneNumber}}\n  &lt;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hasLogger\"&gt;!!!&lt;/span&gt;&lt;/div&gt;`,\n  imports: [<a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a>]\n})\nexport class HeroContactComponent {\n\n  hasLogger = false;\n\n  constructor(\n      @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() // limit to the host component's instance of the HeroCacheService\n      private heroCache: HeroCacheService,\n\n      @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()     // limit search for logger; hides the application-wide logger\n      @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() // ok if the logger doesn't exist\n      private loggerService?: LoggerService\n  ) {\n    if (loggerService) {\n      this.hasLogger = true;\n      loggerService.logInfo('HeroContactComponent can log!');\n    }\n  }\n\n  get phoneNumber() { return this.heroCache.hero.phone; }\n\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72e5u72l3m47249ne423bb2g7\">注意构造函数的参数。</p>\n<code-example header=\"src/app/hero-contact.component.ts\" path=\"dependency-injection-in-action/src/app/hero-contact.component.ts\" region=\"ctor-params\">\n@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() // limit to the host component's instance of the HeroCacheService\nprivate heroCache: HeroCacheService,\n\n@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()     // limit search for logger; hides the application-wide logger\n@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() // ok if the logger doesn't exist\nprivate loggerService?: LoggerService\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4psg6i24g0da3s2jhscqxfkgb\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 函数是构造函数属性 <code>heroCache</code> 的装饰器，确保从其父组件 <code>HeroBioComponent</code> 得到一个缓存服务。如果该父组件中没有该服务，Angular 就会抛出错误，即使组件树里的再上级有某个组件拥有这个服务，还是会抛出错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9aq5ols63odbtucn0nyuexb1k\">另一个 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 函数是构造函数属性 <code>loggerService</code> 的装饰器。在本应用程序中只有一个在 <code>AppComponent</code> 级提供的 <code>LoggerService</code> 实例。该宿主 <code>HeroBioComponent</code> 没有自己的 <code>LoggerService</code> 提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dl9cqs5ehe7nu5yt2mh2hty8m\">如果没有同时使用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 装饰器的话，Angular 就会抛出错误。当该属性带有 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 标记时，Angular 就会把 <code>loggerService</code> 设置为 null，并继续执行组件而不会抛出错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68h8pa477b3bzl8wc6fdeozzv\">下面是 <code>HeroBiosAndContactsComponent</code> 的执行结果：</p>\n<div class=\"lightbox\">\n<img alt=\"Bios with contact into\" src=\"generated/images/guide/dependency-injection-in-action/hero-bios-and-contacts.png\" width=\"206\" height=\"393\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jimjcye0udkh25l6bguhaac\">如果注释掉 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 装饰器，Angular 就会沿着注入器树往上走，直到在 <code>AppComponent</code> 中找到该日志服务。日志服务的逻辑加了进来，所显示的英雄信息增加了 \"!!!\" 标记，这表明确实找到了日志服务。</p>\n<div class=\"lightbox\">\n<img alt=\"Without @Host\" src=\"generated/images/guide/dependency-injection-in-action/hero-bio-contact-no-host.png\" width=\"199\" height=\"93\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9h5k9fxlkc1l3v3t65w1mx3rl\">如果你恢复 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 装饰器并注释掉 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code>，应用程序在宿主组件级别找不到所需的记录器时会抛出异常。</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nEXCEPTION: No provider for LoggerService! (HeroContactComponent -&gt; LoggerService)\n\n</code-example>\n<h3 id=\"supply-a-custom-provider-with-inject\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5onqbndo89w66n8869wzo7vj2\">使用 <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> 指定自定义提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#supply-a-custom-provider-with-inject\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ezu5vk3qtkorgn2ffqmawbxwa\">自定义提供者让你可以为隐式依赖提供一个具体的实现，比如内置浏览器 API。下面的例子使用 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 来提供 <a href=\"https://developer.mozilla.org/docs/Web/API/Window/localStorage\">localStorage</a>，将其作为 <code>BrowserStorageService</code> 的依赖项。</p>\n<code-example header=\"src/app/storage.service.ts\" path=\"dependency-injection-in-action/src/app/storage.service.ts\">\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>, <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>, <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const BROWSER_STORAGE = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&lt;Storage&gt;('Browser Storage', {\n  providedIn: 'root',\n  factory: () =&gt; localStorage\n});\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class BrowserStorageService {\n  constructor(@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(BROWSER_STORAGE) public storage: Storage) {}\n\n  get(key: string) {\n    return this.storage.getItem(key);\n  }\n\n  set(key: string, value: string) {\n    this.storage.setItem(key, value);\n  }\n\n  remove(key: string) {\n    this.storage.removeItem(key);\n  }\n\n  clear() {\n    this.storage.clear();\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8fwy60ovxmqho45kjkdixfy5\"><code>factory</code> 函数返回 window 对象上的 <code>localStorage</code> 属性。<code><a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> 装饰器修饰一个构造函数参数，用于为某个依赖提供自定义提供者。现在，就可以在测试期间使用 <code>localStorage</code> 的 Mock API 来覆盖这个提供者了，而不必与真实的浏览器 API 进行交互。</p>\n<p><a id=\"skip\"></a></p>\n<h3 id=\"modify-the-provider-search-with-self-and-skipself\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"20z2xqu5vd5a706fkbslcwc8z\">使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> 和 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 来修改提供者的搜索方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#modify-the-provider-search-with-self-and-skipself\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"13wry996izx0r31h76ercxoj6\">注入器也可以通过构造函数的参数装饰器来指定范围。下面的例子就在 <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 类的 <code>providers</code> 中使用浏览器的 <code>sessionStorage</code> API 覆盖了 <code>BROWSER_STORAGE</code> 令牌。同一个 <code>BrowserStorageService</code> 在构造函数中使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> 和 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 装饰器注入了两次，来分别指定由哪个注入器来提供依赖。</p>\n<code-example header=\"src/app/storage.component.ts\" path=\"dependency-injection-in-action/src/app/storage.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/Self\" class=\"code-anchor\">Self</a>, <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a> } from '@angular/core';\nimport { BROWSER_STORAGE, BrowserStorageService } from './storage.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-storage',\n  template: `\n    Open the inspector to see the local/session storage keys:\n\n    &lt;h3&gt;Session Storage&lt;/h3&gt;\n    &lt;button type=\"button\" (click)=\"setSession()\"&gt;Set Session Storage&lt;/button&gt;\n\n    &lt;h3&gt;Local Storage&lt;/h3&gt;\n    &lt;button type=\"button\" (click)=\"setLocal()\"&gt;Set Local Storage&lt;/button&gt;\n  `,\n  providers: [\n    BrowserStorageService,\n    { provide: BROWSER_STORAGE, useFactory: () =&gt; sessionStorage }\n  ]\n})\nexport class StorageComponent {\n\n  constructor(\n    @<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>() private sessionStorageService: BrowserStorageService,\n    @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() private localStorageService: BrowserStorageService,\n  ) { }\n\n  setSession() {\n    this.sessionStorageService.set('hero', 'Dr Nice - Session');\n  }\n\n  setLocal() {\n    this.localStorageService.set('hero', 'Dr Nice - Local');\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"308u53izsxfr9w2t8nrjmu3h2\">使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> 装饰器时，注入器只在该组件的注入器中查找提供者。<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 装饰器可以让你跳过局部注入器，并在注入器树中向上查找，以发现哪个提供者满足该依赖。<code>sessionStorageService</code> 实例使用浏览器的 <code>sessionStorage</code> 来跟 <code>BrowserStorageService</code> 打交道，而 <code>localStorageService</code> 跳过了局部注入器，使用根注入器提供的 <code>BrowserStorageService</code>，它使用浏览器的 <code>localStorage</code> API。</p>\n<p><a id=\"component-element\"></a></p>\n<h2 id=\"inject-the-components-dom-element\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3t3t1k1nae7wrfi1vhavne2s7\">注入组件的 DOM 元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#inject-the-components-dom-element\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4d6n1ulzwy3ot1pj89mrasb6z\">即便开发者极力避免，仍然会有很多视觉效果和第三方工具（比如 jQuery）需要访问 DOM。这会让你不得不访问组件所在的 DOM 元素。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1jwe0utudzqdcewav0bet6y8t\">为了说明这一点，请看<a href=\"guide/attribute-directives\">属性型指令</a>中那个 <code>HighlightDirective</code> 的简化版。</p>\n<code-example header=\"src/app/highlight.directive.ts\" path=\"dependency-injection-in-action/src/app/highlight.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  standalone: true,\n  selector: '[appHighlight]'\n})\nexport class HighlightDirective {\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appHighlight') highlightColor = '';\n\n  private el: HTMLElement;\n\n  constructor(el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) {\n    this.el = el.nativeElement;\n  }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseenter') onMouseEnter() {\n    this.highlight(this.highlightColor || 'cyan');\n  }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseleave') onMouseLeave() {\n    this.highlight('');\n  }\n\n  private highlight(color: string) {\n    this.el.style.backgroundColor = color;\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1jj47y6ut0qhrtc21t40z2ezk\">当用户把鼠标移到 DOM 元素上时，指令将指令所在的元素的背景设置为一个高亮颜色。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ahoqp17jbhfjsfq0kx82qb55a\">Angular 把构造函数参数 <code>el</code> 设置为注入的 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code>，该 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code> 代表了宿主的 DOM 元素，它的 <code>nativeElement</code> 属性把该 DOM 元素暴露给了指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ilxqqjq1srjc4tkpmk7c5n9n\">下面的代码把指令的 <code>appHighlight</code> 属性（Attribute）填加到两个 <code>&lt;div&gt;</code> 标签里，一个没有赋值，一个赋值了颜色。</p>\n<code-example header=\"src/app/app.component.html (highlight)\" path=\"dependency-injection-in-action/src/app/app.component.html\" region=\"highlight\">\n&lt;div id=\"highlight\"  class=\"di-component\"  appHighlight&gt;\n  &lt;h3&gt;Hero Bios and Contacts&lt;/h3&gt;\n  &lt;div appHighlight=\"yellow\"&gt;\n    &lt;app-hero-bios-and-contacts&gt;&lt;/app-hero-bios-and-contacts&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66qwt2c9w8lr9r8ecd72r6lcd\">下图显示了鼠标移到 <code>&lt;hero-bios-and-contacts&gt;</code> 标签上的效果：</p>\n<div class=\"lightbox\">\n<img alt=\"Highlighted bios\" src=\"generated/images/guide/dependency-injection-in-action/highlight.png\" width=\"318\" height=\"196\">\n</div>\n<p><a id=\"defining-providers\"></a></p>\n<h3 id=\"defining-providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76ybfnaadge56y6ve0dh12x3z\">定义提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#defining-providers\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"beyflc6dcfbym7chx4s0ekqvq\">用于实例化类的默认方法不一定总适合用来创建依赖。你可以到<a href=\"guide/dependency-injection-providers\">依赖提供者</a>部分查看其它方法。<code>HeroOfTheMonthComponent</code> 例子示范了一些替代方案，展示了为什么需要它们。它看起来很简单：一些属性和一些由 logger 生成的日志。</p>\n<div class=\"lightbox\">\n<img alt=\"Hero of the month\" src=\"generated/images/guide/dependency-injection-in-action/hero-of-month.png\" width=\"300\" height=\"165\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63lfxoiske9kcj5pudbfrwmzh\">它背后的代码定制了 DI 框架提供依赖项的方法和位置。这个例子阐明了通过<em>提供</em>对象字面量来把对象的定义和 DI 令牌关联起来的另一种方式。</p>\n<code-example header=\"hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"hero-of-the-month\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> } from '@angular/core';\n\nimport { DateLoggerService } from './date-logger.service';\nimport { Hero } from './hero';\nimport { HeroService } from './hero.service';\nimport { LoggerService } from './logger.service';\nimport { MinimalLogger } from './minimal-logger.service';\nimport { RUNNERS_UP,\n         runnersUpFactory } from './runners-up';\nimport { <a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a> } from '@angular/common';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-hero-of-the-month',\n  templateUrl: './hero-of-the-month.component.html',\n  providers: [\n    { provide: Hero,          useValue:    someHero },\n    { provide: TITLE,         useValue:   'Hero of the Month' },\n    { provide: HeroService,   useClass:    HeroService },\n    { provide: LoggerService, useClass:    DateLoggerService },\n    { provide: MinimalLogger, useExisting: LoggerService },\n    { provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] }\n  ],\n  imports: [<a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a>]\n})\nexport class HeroOfTheMonthComponent {\n  logs: string[] = [];\n\n  constructor(\n      logger: MinimalLogger,\n      public heroOfTheMonth: Hero,\n      @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(RUNNERS_UP) public runnersUp: string,\n      @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(TITLE) public title: string)\n  {\n    this.logs = logger.logs;\n    logger.logInfo('starting up');\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vpmaovzsvvte13g8r4227tnk\"><code>providers</code> 数组展示了你可以如何使用其它的键来定义提供者：<code>useValue</code>、<code>useClass</code>、<code>useExisting</code> 或 <code>useFactory</code>。</p>\n<p><a id=\"usevalue\"></a></p>\n<h4 id=\"value-providers-usevalue\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8cl4se2ii5z2n6wpi5is3gka\">值提供者：<code>useValue</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#value-providers-usevalue\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5snm3trrx5rbea3xjnv8qa01z\"><code>useValue</code> 键让你可以为 DI 令牌关联一个固定的值。使用该技巧来进行<em>运行期常量设置</em>，比如网站的基础地址和功能标志等。你也可以在单元测试中使用<em>值提供者</em>，来用一个 Mock 数据来代替一个生产环境下的数据服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7r0jfrcdb1lqfphsw98l9n7ad\"><code>HeroOfTheMonthComponent</code> 例子中有两个<em>值-提供者</em>。</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-value\">\n{ provide: Hero,          useValue:    someHero },\n{ provide: TITLE,         useValue:   'Hero of the Month' },\n\n</code-example>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eqafj6purpxxhzex9waq5wr98\">第一处提供了用于 <code>Hero</code> 令牌的 <code>Hero</code> 类的现有实例，而不是要求注入器使用 <code>new</code> 来创建一个新实例或使用它自己的缓存实例。这里令牌就是这个类本身。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3psscnngkc3llsuum6h2o06pe\">第二处为 <code>TITLE</code> 令牌指定了一个字符串字面量资源。<code>TITLE</code> 提供者的令牌<em>不是一个类</em>，而是一个特别的提供者查询键，名叫<a href=\"guide/dependency-injection-in-action#injection-token\">InjectionToken</a>，表示一个 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 实例。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5sn4cqbbjqdg687lpyilh5nn7\">你可以把 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 用作任何类型的提供者的令牌，但是当依赖是简单类型（比如字符串、数字、函数）时，它会特别有用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dueud62s63f1ot5giq8rq6vqa\">一个<em>值-提供者</em>的值必须在指定之前定义。比如标题字符串就是立即可用的。该例中的 <code>someHero</code> 变量是以前在如下的文件中定义的。你不能使用那些要等以后才能定义其值的变量。</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"some-hero\">\nconst someHero = new Hero(42, 'Magma', 'Had a great month!', '555-555-5555');\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4gjpsc2grhnudu1vhy29wu2v0\">其它类型的提供者都会<em>惰性创建</em>它们的值，也就是说只在需要注入它们的时候才创建。</p>\n<p><a id=\"useclass\"></a></p>\n<h4 id=\"class-providers-useclass\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6rnaughgeubpmvr0mx7e19pe1\">类提供者：<code>useClass</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#class-providers-useclass\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a89oks1bp2b5eh2rq08lqigzd\"><code>useClass</code> 提供的键让你可以创建并返回指定类的新实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2gvg3bsorxbwntjb6ugcx55qf\">你可以使用这类提供者来为公共类或默认类换上一个<em>替代实现</em>。比如，这个替代实现可以实现一种不同的策略来扩展默认类，或在测试环境中模拟真实类的行为。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cr5nnq8va9iia6kgakmdce394\">请看下面 <code>HeroOfTheMonthComponent</code> 里的两个例子：</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-class\">\n{ provide: HeroService,   useClass:    HeroService },\n{ provide: LoggerService, useClass:    DateLoggerService },\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3vf3n5oaa29g3wtuvsqcu5elo\">第一个提供者是<em>展开了语法糖的</em>，是一个典型情况的展开。一般来说，被新建的类（<code>HeroService</code>）同时也是该提供者的注入令牌。通常都选用缩写形式，完整形式可以让细节更明确。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlztq7f1jz8xeybnh3rnv1a4r\">第二个提供者使用 <code>DateLoggerService</code> 来满足 <code>LoggerService</code>。该 <code>LoggerService</code> 在 <code>AppComponent</code> 级别已经被注册。当<em>这个组件</em>要求 <code>LoggerService</code> 的时候，它得到的却是 <code>DateLoggerService</code> 服务的实例。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ct9gybaahx8eyx4zvi2cr6x1\">这个组件及其子组件会得到 <code>DateLoggerService</code> 实例。这个组件树之外的组件得到的仍是 <code>LoggerService</code> 实例。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayo9zjtdualnoh2ltq9g1gfmd\"><code>DateLoggerService</code> 从 <code>LoggerService</code> 继承；它把当前的日期/时间附加到每条信息上。</p>\n<code-example header=\"src/app/date-logger.service.ts\" path=\"dependency-injection-in-action/src/app/date-logger.service.ts\" region=\"date-logger-service\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class DateLoggerService extends LoggerService\n{\n  override logInfo(msg: any)  { super.logInfo(stamp(msg)); }\n  override logDebug(msg: any) { super.logInfo(stamp(msg)); }\n  override logError(msg: any) { super.logError(stamp(msg)); }\n}\n\nfunction stamp(msg: any) { return msg + ' at ' + new Date(); }\n\n</code-example>\n<p><a id=\"useexisting\"></a></p>\n<h4 id=\"alias-providers-useexisting\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7q6tfy4s6w6g4k82txexv7ujt\">别名提供者：<code>useExisting</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#alias-providers-useexisting\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ev6dlop7tr3zrm8bpa87vxiet\"><code>useExisting</code> 提供了一个键，让你可以把一个令牌映射成另一个令牌。实际上，第一个令牌就是第二个令牌所关联的服务的<em>别名</em>，这样就创建了访问同一个服务对象的两种途径。</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-existing\">\n{ provide: MinimalLogger, useExisting: LoggerService },\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b4klvdupggnqroujcd9volagm\">你可以使用别名接口来窄化 API。下面的例子中使用别名就是为了这个目的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8f4on65mcowhnnu7ds5oimddh\">想象 <code>LoggerService</code> 有个很大的 API 接口，远超过现有的三个方法和一个属性。你可能希望把 API 接口收窄到只有两个你确实需要的成员。在这个例子中，<code>MinimalLogger</code><a href=\"guide/dependency-injection-in-action#class-interface\"><em>类-接口</em></a>，就这个 API 成功缩小到了只有两个成员：</p>\n<code-example header=\"src/app/minimal-logger.service.ts\" path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\">\n// Class used as a \"narrowing\" interface that exposes a minimal logger\n// Other members of the actual implementation are invisible\nexport abstract class MinimalLogger {\n  abstract logs: string[];\n  abstract logInfo: (msg: string) =&gt; void;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bxrw8dbvwfu8ogzrl6g48dd1a\">下面的例子在一个简化版的 <code>HeroOfTheMonthComponent</code> 中使用 <code>MinimalLogger</code>。</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts (minimal version)\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.1.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-hero-of-the-month',\n  templateUrl: './hero-of-the-month.component.html',\n  // TODO: move this aliasing, `useExisting` provider to the AppModule\n  providers: [{ provide: MinimalLogger, useExisting: LoggerService }],\n  imports: [<a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a>]\n})\nexport class HeroOfTheMonthComponent {\n  logs: string[] = [];\n  constructor(logger: MinimalLogger) {\n    logger.logInfo('starting up');\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"y2ltkoj6sfpvidx2viekdsss\"><code>HeroOfTheMonthComponent</code> 构造函数的 <code>logger</code> 参数是一个 <code>MinimalLogger</code> 类型，在支持 TypeScript 感知的编辑器里，只能看到它的两个成员 <code>logs</code> 和 <code>logInfo</code>：</p>\n<div class=\"lightbox\">\n<img alt=\"MinimalLogger restricted API\" src=\"generated/images/guide/dependency-injection-in-action/minimal-logger-intellisense.png\" width=\"532\" height=\"60\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cnr0w8rezwm31ohk9ue31qw06\">实际上，Angular 把 <code>logger</code> 参数设置为注入器里 <code>LoggerService</code> 令牌下注册的完整服务，该令牌恰好是<a href=\"guide/dependency-injection-in-action#useclass\">以前提供的那个</a> <code>DateLoggerService</code> 实例。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cy3g2auz0lmukit97nnv1aqeq\">在下面的图片中，显示了日志日期，可以确认这一点：</p>\n<div class=\"lightbox\">\n<img alt=\"DateLoggerService entry\" src=\"generated/images/guide/dependency-injection-in-action/date-logger-entry.png\" width=\"300\" height=\"32\">\n</div>\n</div>\n<p><a id=\"usefactory\"></a></p>\n<h4 id=\"factory-providers-usefactory\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a0hj9kqy1y5pjccv3oz441mp8\">工厂提供者：<code>useFactory</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#factory-providers-usefactory\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a9v8qv17uymjlcy3n5k9dhp3\"><code>useFactory</code> 提供了一个键，让你可以通过调用一个工厂函数来创建依赖实例，如下面的例子所示。</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-factory\">\n{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] }\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9whix3091jca38sju9fvnruq2\">注入器通过调用你用 <code>useFactory</code> 键指定的工厂函数来提供该依赖的值。\n注意，提供者的这种形态还有第三个键 <code>deps</code>，它指定了供 <code>useFactory</code> 函数使用的那些依赖。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"25fybhn8khsrbqsp2h0mjijgo\">使用这项技术，可以用包含了一些<strong><em>依赖服务和本地状态</em></strong>输入的工厂函数来<strong><em>建立一个依赖对象</em></strong>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2dyttcugc4dm1mes27m1lre48\">这个依赖对象（由工厂函数返回的）通常是一个类实例，不过也可以是任何其它东西。在这个例子中，依赖对象是一个表示 \"月度英雄\" 参赛者名称的字符串。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cgjtio63hm9ael1d8wyf72wb\">在这个例子中，局部状态是数字 <code>2</code>，也就是组件应该显示的参赛者数量。该状态的值传给了 <code>runnersUpFactory()</code> 作为参数。<code>runnersUpFactory()</code> 返回了<em>提供者的工厂函数</em>，它可以使用传入的状态值和注入的服务 <code>Hero</code> 和 <code>HeroService</code>。</p>\n<code-example header=\"runners-up.ts (excerpt)\" path=\"dependency-injection-in-action/src/app/runners-up.ts\" region=\"factory-synopsis\">\nexport function runnersUpFactory(take: number) {\n  return (winner: Hero, heroService: HeroService): string =&gt;\n    /* ... */\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aoufavjgghfx9xm1apzyjh6rj\">由 <code>runnersUpFactory()</code> 返回的提供者的工厂函数返回了实际的依赖对象，也就是表示名字的字符串。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1yb21oevcu8hiwesntilnrf9s\">该函数以获胜的 <code>Hero</code> 和 <code>HeroService</code> 作为参数。Angular 从 <code>deps</code> 数组中的两个<em>令牌</em>标识的注入值提供这些参数。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6pajkvz5rf13ib6yg83mtctx\">该函数返回名字的字符串，Angular 可以把它们注入到 <code>HeroOfTheMonthComponent</code> 的 <code>runnersUp</code> 参数中。</p>\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cs122j1dngrusjqamedg2vrsf\">该函数从 <code>HeroService</code> 中接受候选的英雄，从中取 <code>2</code> 个参加竞赛，并把他们的名字串接起来返回。\n参阅 <live-example name=\"dependency-injection-in-action\"></live-example> 查看完整源码。</p>\n</div>\n<p><a id=\"tokens\"></a></p>\n<h2 id=\"provider-token-alternatives-class-interface-and-injectiontoken\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"et37l801p98km6xfnmrmjhv9x\">提供替代令牌：类接口与 'InjectionToken'<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#provider-token-alternatives-class-interface-and-injectiontoken\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dq7s331jllu3voehl4ajeij0d\">当使用类作为令牌，同时也把它作为返回依赖对象或服务的类型时，Angular 依赖注入使用起来最容易。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"769kg72dmzxctp94ldz6x2lof\">但令牌不一定都是类，就算它是一个类，它也不一定都返回类型相同的对象。这是下一节的主题。</p>\n<p><a id=\"class-interface\"></a></p>\n<h3 id=\"class-interface\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7jzrd7ca6zp7a6lhajz4i6g7m\">类-接口<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#class-interface\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9lz1f5rlwc4jvu8pvyzn9y8g5\">前面的<em>月度英雄</em>的例子使用了 <code>MinimalLogger</code> 类作为 <code>LoggerService</code> 提供者的令牌。</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-existing\">\n{ provide: MinimalLogger, useExisting: LoggerService },\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"mt75b63rtsc7v1bai6z1ymc2\">该 <code>MinimalLogger</code> 是一个抽象类。</p>\n<code-example header=\"src/app/minimal-logger.service.ts\" path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\">\n// Class used as a \"narrowing\" interface that exposes a minimal logger\n// Other members of the actual implementation are invisible\nexport abstract class MinimalLogger {\n  abstract logs: string[];\n  abstract logInfo: (msg: string) =&gt; void;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"566z9w4yhxgsbd72nsp3rlgh8\">你通常从一个可扩展的抽象类继承。但这个应用中<em>并没有</em>类会继承 <code>MinimalLogger</code>。<code>LoggerService</code> 和 <code>DateLoggerService</code><em>本可以</em>从 <code>MinimalLogger</code> 中继承。\n它们也可以实现 <code>MinimalLogger</code>，而不用单独定义接口。\n但它们没有。\n<code>MinimalLogger</code> 在这里仅仅被用作一个 \"依赖注入令牌\"。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4rg2fdfaaivfkuarxjm1kw9p\">当你通过这种方式使用类时，它称作<em>类接口</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wpaqco01i39gr0d1qzsavhra\">就像<a href=\"guide/dependency-injection-providers\">配置依赖提供者</a>中提到的那样，接口不是有效的 DI 令牌，因为它是 TypeScript 自己用的，在运行期间不存在。使用这种抽象类接口不但可以获得像接口一样的强类型，而且可以像普通类一样把它用作提供者令牌。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ec8jlrl4hzxwfs1m4g2wdbvd7\">类接口应该<em>只</em>定义允许它的消费者调用的成员。窄的接口有助于解耦该类的具体实现和它的消费者。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ato8aylizm3qdx4xcx8ciayad\">用类作为接口可以让你获得真实 JavaScript 对象中的接口的特性。但是，为了最小化内存开销，该类应该是<em>没有实现</em>的。对于构造函数，<code>MinimalLogger</code> 会转译成未优化过的、预先最小化过的 JavaScript。</p>\n<code-example header=\"src/app/minimal-logger.service.ts\" path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" region=\"minimal-logger-transpiled\">\nvar MinimalLogger = (function () {\n  function MinimalLogger() {}\n  return MinimalLogger;\n}());\nexports(\"MinimalLogger\", MinimalLogger);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4roui91uwe713lm1cqenrnk3m\"><strong>注意</strong>：<br>\n它没有任何成员。无论你添加到类中的成员有多少，它都不会增长大小，因为这些成员只是类型而没有实现。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4n0eb8flseard1p2r2nznx9p2\">你可以再看看 TypeScript 的 <code>MinimalLogger</code> 类，确定一下它是没有实现的。</p>\n</div>\n<p><a id=\"injection-token\"></a></p>\n<h3 id=\"injectiontoken-objects\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3la6dl59jd4j9e17wvcdgpw6h\">'InjectionToken' 对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#injectiontoken-objects\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2idfvd96nuuet0nezzexfyje3\">依赖对象可以是一个简单的值，比如日期，数字和字符串，或者一个无形的对象，比如数组和函数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azl230bpc3gft9p46d6i26mje\">这样的对象没有应用程序接口，所以不能用一个类来表示。更适合表示它们的是：唯一的和符号性的令牌，一个 JavaScript 对象，拥有一个友好的名字，但不会与其它的同名令牌发生冲突。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"apzro2i9xd50k42yorrcm0bo9\"><code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 具有这些特征。在<em>Hero of the Month</em>例子中遇见它们两次，一个是 <em>title</em> 的值，一个是 <em>runnersUp</em> 工厂提供者。</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"provide-injection-token\">\n{ provide: TITLE,         useValue:   'Hero of the Month' },\n{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] }\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cijdcocenascas60kh8bvxi2n\">这样创建 <code>TITLE</code> 令牌：</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"injection-token\">\nimport { <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const TITLE = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&lt;string&gt;('title');\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"an1s4sf7rz1ltvwc16bae0iz2\">类型参数，虽然是可选的，但可以向开发者和开发工具传达类型信息。而且这个令牌的描述信息也可以为开发者提供帮助。</p>\n<p><a id=\"di-inheritance\"></a></p>\n<h2 id=\"inject-into-a-derived-class\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"821i2phse3qbg520ivkvmills\">注入到派生类<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#inject-into-a-derived-class\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"836n3m5w137vasekq86ja7buu\">当编写一个继承自另一个组件的组件时，要格外小心。如果基础组件有依赖注入，必须要在派生类中重新提供和重新注入它们，并将它们通过构造函数传给基类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7frmjnf0dor9ol5z6nfq2wz1t\">在这个刻意生成的例子里，<code>SortedHeroesComponent</code> 继承自 <code>HeroesBaseComponent</code>，显示一个<em>被排序</em>的英雄列表。</p>\n<div class=\"lightbox\">\n<img alt=\"Sorted Heroes\" src=\"generated/images/guide/dependency-injection-in-action/sorted-heroes.png\" width=\"135\" height=\"107\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6m3ljm1gy0tjtcjjfboh81hws\"><code>HeroesBaseComponent</code> 能自己独立运行。它在自己的实例里要求 <code>HeroService</code>，用来得到英雄，并将他们按照数据库返回的顺序显示出来。</p>\n<code-example header=\"src/app/sorted-heroes.component.ts (HeroesBaseComponent)\" path=\"dependency-injection-in-action/src/app/sorted-heroes.component.ts\" region=\"heroes-base\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-unsorted-heroes',\n  template: '&lt;div *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;{{hero.name}}&lt;/div&gt;',\n  providers: [HeroService],\n  imports: [<a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a>]\n})\nexport class HeroesBaseComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private heroService: HeroService) { }\n\n  heroes: Hero[] = [];\n\n  ngOnInit() {\n    this.heroes = this.heroService.getAllHeroes();\n    this.afterGetHeroes();\n  }\n\n  // Post-process heroes in derived class override.\n  protected afterGetHeroes() {}\n\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<h3 id=\"keep-constructors-simple\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4a0i8vye3325qodevhn54xn3y\">让构造函数保持简单<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#keep-constructors-simple\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"67q0e736m2x0lbfqt18kqikby\">构造函数应该只用来初始化变量。这条规则让组件在测试环境中可以放心地构造组件，以免在构造它们时，无意中做出一些非常戏剧化的动作(比如与服务器进行会话)。这就是为什么你要在 <code>ngOnInit</code> 里面调用 <code>HeroService</code>，而不是在构造函数中。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cia7sk8hy6mblyu88lmkv847h\">用户希望看到英雄按字母顺序排序。与其修改原始的组件，不如派生它，新建 <code>SortedHeroesComponent</code>，以便展示英雄之前进行排序。<code>SortedHeroesComponent</code> 让基类来获取英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f22lgr5j2a6qcjqdb5lm8sszs\">可惜，Angular 不能直接在基类里直接注入 <code>HeroService</code>。必须在<em>这个</em>组件里再次提供 <code>HeroService</code>，然后通过构造函数传给基类。</p>\n<code-example header=\"src/app/sorted-heroes.component.ts (SortedHeroesComponent)\" path=\"dependency-injection-in-action/src/app/sorted-heroes.component.ts\" region=\"sorted-heroes\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-sorted-heroes',\n  template: '&lt;div *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;{{hero.name}}&lt;/div&gt;',\n  providers: [HeroService],\n  imports: [<a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a>]\n})\nexport class SortedHeroesComponent extends HeroesBaseComponent {\n  constructor(heroService: HeroService) {\n    super(heroService);\n  }\n\n  protected override afterGetHeroes() {\n    this.heroes = this.heroes.sort((h1, h2) =&gt; h1.name &lt; h2.name ? -1 :\n            (h1.name &gt; h2.name ? 1 : 0));\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cigjlkj25qs6wx4tztekd1rdq\">现在，请注意 <code>afterGetHeroes()</code> 方法。\n你的第一反应是在 <code>SortedHeroesComponent</code> 组件里面建一个 <code>ngOnInit</code> 方法来做排序。但是 Angular 会先调用<em>派生</em>类的 <code>ngOnInit</code>，后调用基类的 <code>ngOnInit</code>，\n所以可能在<em>英雄到达之前</em>就开始排序。这就产生了一个讨厌的错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aj9n8jtipkij4iha98ykumyu8\">覆盖基类的 <code>afterGetHeroes()</code> 方法可以解决这个问题。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"668knfuob4alegihqtv1mso91\">分析上面的这些复杂性是为了强调<em>避免使用组件继承</em>这一点。</p>\n<p><a id=\"forwardref\"></a></p>\n<h2 id=\"resolve-circular-dependencies-with-a-forward-class-reference-forwardref\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"11gq72j5vtisw8kmuionfd7z0\">使用一个前向引用（<em>forwardRef</em>）来解析循环依赖<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#resolve-circular-dependencies-with-a-forward-class-reference-forwardref\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tfha6g3lpqznfc0smwvb3kpj\">在 TypeScript 里面，类声明的顺序是很重要的。如果一个类尚未定义，就不能引用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dcblixupwp0mbu2p8tg5018vp\">这通常不是一个问题，特别是当你遵循<em>一个文件一个类</em>规则的时候。但是有时候循环引用可能不能避免。例如，当一个类 'A' 引用类 'B'，同时 'B' 引用 'A' 的时候，它们中间的某一个必须要先定义。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2njpnjls1tcqzlars90snuzsg\">Angular 的 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> 函数建立一个<em>间接地</em>引用，Angular 可以随后解析。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azqzr09edad4dfx83pb1wb0u7\">这个关于<em>父查找器</em>的例子中全都是没办法打破的循环类引用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dm3dx55i2qdzdbfwu9tra3sia\">当一个类<em>需要引用自身</em>的时候，你面临同样的困境，就像在 <code>AlexComponent</code> 的 <code>providers</code> 数组中遇到的困境一样。该 <code>providers</code> 数组是一个 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 装饰器函数的一个属性，它必须在类定义<em>之前</em>出现。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9yvgifrs30qu50vy118u1gno5\">使用 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a></code> 来打破这种循环：</p>\n<code-example header=\"parent-finder.component.ts (AlexComponent providers)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; AlexComponent) }],\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/Host\n - api/core/SkipSelf\n - errors/NG0200\n - guide/creating-injectable-service\n - guide/dependency-injection\n - guide/dependency-injection-navtree\n - guide/dependency-injection-providers\n - guide/hierarchical-dependency-injection\n-->\n<!-- links from this doc:\n - api/common/NgFor\n - api/common/NgIf\n - api/core/Component\n - api/core/Directive\n - api/core/ElementRef\n - api/core/Host\n - api/core/HostListener\n - api/core/Inject\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/Input\n - api/core/OnInit\n - api/core/Optional\n - api/core/Self\n - api/core/SkipSelf\n - api/core/forwardRef\n - api/core/ng-content\n - api/forms/DefaultValueAccessor\n - api/forms/FormsModule\n - api/forms/NgModel\n - guide/attribute-directives\n - guide/dependency-injection-in-action#alias-providers-useexisting\n - guide/dependency-injection-in-action#class-interface\n - guide/dependency-injection-in-action#class-providers-useclass\n - guide/dependency-injection-in-action#defining-providers\n - guide/dependency-injection-in-action#dependency-injection-in-action\n - guide/dependency-injection-in-action#factory-providers-usefactory\n - guide/dependency-injection-in-action#hero-bios-component\n - guide/dependency-injection-in-action#inject-into-a-derived-class\n - guide/dependency-injection-in-action#inject-the-components-dom-element\n - guide/dependency-injection-in-action#injection-token\n - guide/dependency-injection-in-action#injectiontoken-objects\n - guide/dependency-injection-in-action#keep-constructors-simple\n - guide/dependency-injection-in-action#make-a-dependency-optional-and-limit-search-with-host\n - guide/dependency-injection-in-action#modify-the-provider-search-with-self-and-skipself\n - guide/dependency-injection-in-action#multiple-service-instances-sandboxing\n - guide/dependency-injection-in-action#provider-token-alternatives-class-interface-and-injectiontoken\n - guide/dependency-injection-in-action#qualify-dependency-lookup-with-parameter-decorators\n - guide/dependency-injection-in-action#resolve-circular-dependencies-with-a-forward-class-reference-forwardref\n - guide/dependency-injection-in-action#supply-a-custom-provider-with-inject\n - guide/dependency-injection-in-action#useclass\n - guide/dependency-injection-in-action#value-providers-usevalue\n - guide/dependency-injection-providers\n - https://developer.mozilla.org/docs/Web/API/Window/localStorage\n-->"}