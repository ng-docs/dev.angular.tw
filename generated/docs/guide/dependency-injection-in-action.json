{"id":"guide/dependency-injection-in-action","title":"依賴注入實戰","contents":"<div class=\"content\">\n  <h1 id=\"dependency-injection-in-action\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8l3nguqidu25c8b6u8y53odn4\">依賴注入實戰<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#dependency-injection-in-action\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aqztnx0rsuqheavltbhth338a\">本章涉及到 Angular 依賴注入（DI）的很多屬性。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"81el5yk7yllx1tewd03bnp7o0\">本章包含程式碼片段的工作實例參閱<live-example></live-example>。</p>\n</div>\n<p><a id=\"multiple-service-instances\"></a></p>\n<h2 id=\"multiple-service-instances-sandboxing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5qv1ogkr4lur5dx4q6zaala9b\">多個服務實例（沙箱式隔離）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#multiple-service-instances-sandboxing\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"p92faeb3htcifaeougp2tfuv\">在元件樹的<em>同一個級別</em>上，有時需要一個服務的多個實例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wo3iclaudu53fcsf5grdm8rx\">一個用來儲存其伴生元件的實例狀態的服務就是個好例子。每個元件都需要該服務的單獨實例。每個服務有自己的工作狀態，與其它元件的服務和狀態隔離。這叫做<em>沙箱化</em>，因為每個服務和元件實例都在自己的沙箱裡執行。</p>\n<p><a id=\"hero-bios-component\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b4mr1g6pl88n6gtz4vtrigteo\">在這個例子中，<code>HeroBiosComponent</code> 渲染了 <code>HeroBioComponent</code> 的三個實例。</p>\n<code-example header=\"src/app/hero-bios.component.ts\" path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"simple\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-hero-bios',\n  template: `\n    &lt;app-hero-bio [heroId]=\"1\"&gt;&lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"2\"&gt;&lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"3\"&gt;&lt;/app-hero-bio&gt;`,\n  providers: [HeroService],\n  imports: [HeroBioComponent]\n})\nexport class HeroBiosComponent {\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dshb45jvowew7m20pfhy9pea\">每個 <code>HeroBioComponent</code> 都能編輯一個英雄的生平。<code>HeroBioComponent</code> 依賴 <code>HeroCacheService</code> 服務來對該英雄進行讀取、快取和執行其它持久化操作。</p>\n<code-example header=\"src/app/hero-cache.service.ts\" path=\"dependency-injection-in-action/src/app/hero-cache.service.ts\" region=\"service\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroCacheService {\n  hero!: Hero;\n  constructor(private heroService: HeroService) {}\n\n  fetchCachedHero(id: number) {\n    if (!this.hero) {\n      this.hero = this.heroService.getHeroById(id);\n    }\n    return this.hero;\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ammp4exzmlvbdvk67xx0x9md6\">這三個 <code>HeroBioComponent</code> 實例不能共享同一個 <code>HeroCacheService</code> 實例。否則它們會相互衝突，爭相把自己的英雄放在快取裡面。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1zetvfrmdrptxrqzayztz7ott\">它們應該透過在自己的元資料（metadata）<code>providers</code> 陣列裡面列出 <code>HeroCacheService</code>, 這樣每個 <code>HeroBioComponent</code> 就能<em>擁有</em>自己獨立的 <code>HeroCacheService</code> 實例了。</p>\n<code-example header=\"src/app/hero-bio.component.ts\" path=\"dependency-injection-in-action/src/app/hero-bio.component.ts\" region=\"component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-hero-bio',\n  template: `\n    &lt;h4&gt;{{hero.name}}&lt;/h4&gt;\n    &lt;ng-content&gt;&lt;/ng-content&gt;\n    &lt;<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> cols=\"25\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.description\"&gt;&lt;/<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a>&gt;`,\n  providers: [HeroCacheService],\n  imports: [<a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>]\n})\n\nexport class HeroBioComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>  {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() heroId = 0;\n\n  constructor(private heroCache: HeroCacheService) { }\n\n  ngOnInit() { this.heroCache.fetchCachedHero(this.heroId); }\n\n  get hero() { return this.heroCache.hero; }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c464be7gzfrw69uynuknrj44p\">父元件 <code>HeroBiosComponent</code> 把一個值繫結到 <code>heroId</code>。<code>ngOnInit</code> 把該 <code>id</code> 傳遞到服務，然後服務獲取和緩存英雄。<code>hero</code> 屬性的 getter 從服務裡面獲取快取的英雄，並在範本裡顯示它繫結到屬性值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"psbk79l3houo8z3e0nt1g0x5\">到<live-example name=\"dependency-injection-in-action\">現場演練</live-example>中找到這個例子，確認三個 <code>HeroBioComponent</code> 實例擁有自己獨立的英雄資料快取。</p>\n<div class=\"lightbox\">\n<img alt=\"Bios\" src=\"generated/images/guide/dependency-injection-in-action/hero-bios.png\" width=\"199\" height=\"317\">\n</div>\n<p><a id=\"qualify-dependency-lookup\"></a></p>\n<h2 id=\"qualify-dependency-lookup-with-parameter-decorators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwhwt0z893wbu84z4thn95soa\">使用引數裝飾器來限定依賴查詢方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#qualify-dependency-lookup-with-parameter-decorators\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eeh5cmm3bkzwlrfgbgp1huwr1\">當類別需要某個依賴項時，該依賴項就會作為引數新增到類別的建構式函式中。當 Angular 需要實例化該類別時，就會呼叫 DI 框架來提供該依賴。預設情況下，DI 框架會在注入器樹中查詢一個提供者，從該組件的區域性注入器開始，如果需要，則沿著注入器樹向上冒泡，直到根注入器。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c1cmlzqvzff6y1pt9rh9fjdd0\">第一個設定過該提供者的注入器就會把依賴（服務實例或值）提供給這個建構式函式</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6i0uk41v6vl8htmpf14wyfs8h\">如果在根注入器中也沒有找到提供者，則 DI 框架將會丟擲一個錯誤</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2m1j62xp4keojw4egrlche4px\">透過在類別的建構式函式中對服務引數使用<em>引數裝飾器</em>，可以提供一些選項來修改預設的搜尋行為。</p>\n<p><a id=\"optional\"></a></p>\n<h3 id=\"make-a-dependency-optional-and-limit-search-with-host\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3upufcdm7hsixvaagizkdnuzh\">用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 來讓依賴是可選的，以及使用 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 來限定搜尋方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#make-a-dependency-optional-and-limit-search-with-host\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ememduhwg18phqhnq4xdej13i\">依賴可以註冊在元件樹的任何層級上。當元件請求某個依賴時，Angular 會從該組件的注入器找起，沿著注入器樹向上，直到找到了第一個滿足要求的提供者。如果沒找到依賴，Angular 就會丟擲一個錯誤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b20fcp460izuv6zpgglmu1fs1\">某些情況下，你需要限制搜尋，或容忍依賴項的缺失。你可以使用元件建構式函式引數上的 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 和 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 這兩個限定裝飾器來修改 Angular 的搜尋行為。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"16c6sv4ezkm5ir892ej23fb7a\"><code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 屬性裝飾器告訴 Angular 當找不到依賴時就回傳 null</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"wlyzhlolis3m77ex86o571vd\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 屬性裝飾器會禁止在<em>宿主元件</em>以上的搜尋。宿主元件通常就是請求該依賴的那個元件。不過，當該元件投影進某個<em>父</em>元件時，那個父元件就會變成宿主。下面的例子中介紹了第二種情況。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4lhzhdxcvq04b1dqpg8qu6yct\">如下例所示，這些裝飾器可以獨立使用，也可以同時使用。這個 <code>HeroBiosAndContactsComponent</code> 是你<a href=\"guide/dependency-injection-in-action#hero-bios-component\">以前</a>見過的那個 <code>HeroBiosComponent</code> 的修改版。</p>\n<code-example header=\"src/app/hero-bios.component.ts (HeroBiosAndContactsComponent)\" path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"hero-bios-and-contacts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-hero-bios-and-contacts',\n  template: `\n    &lt;app-hero-bio [heroId]=\"1\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"2\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"3\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;`,\n  providers: [HeroService],\n  imports: [HeroBioComponent, HeroContactComponent]\n})\nexport class HeroBiosAndContactsComponent {\n  constructor(logger: LoggerService) {\n    logger.logInfo('Creating HeroBiosAndContactsComponent');\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9z1lei5qeso1bcrmfg36ppq84\">注意看範本：</p>\n<code-example header=\"src/app/hero-bios.component.ts\" path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"template\">\ntemplate: `\n  &lt;app-hero-bio [heroId]=\"1\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n  &lt;app-hero-bio [heroId]=\"2\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n  &lt;app-hero-bio [heroId]=\"3\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;`,\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vgqm4urg4zubwjq6zj5y2c3s\">在 <code>&lt;hero-bio&gt;</code> 標籤中是一個新的 <code>&lt;hero-contact&gt;</code> 元素。Angular 就會把相應的 <code>HeroContactComponent</code><em>投影</em>或透傳（<em>transclude</em>）進 <code>HeroBioComponent</code> 的檢視裡，將它放在 <code>HeroBioComponent</code> 範本的 <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 標籤槽裡。</p>\n<code-example header=\"src/app/hero-bio.component.ts (template)\" path=\"dependency-injection-in-action/src/app/hero-bio.component.ts\" region=\"template\">\ntemplate: `\n  &lt;h4&gt;{{hero.name}}&lt;/h4&gt;\n  &lt;ng-content&gt;&lt;/ng-content&gt;\n  &lt;<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> cols=\"25\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.description\"&gt;&lt;/<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a>&gt;`,\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3z25gcxqw3sy4ahiob9xv9r5\">從 <code>HeroContactComponent</code> 獲得的英雄電話號碼，被投影到上面的英雄描述裡，結果如下：</p>\n<div class=\"lightbox\">\n<img alt=\"bio and contact\" src=\"generated/images/guide/dependency-injection-in-action/hero-bio-and-content.png\" width=\"199\" height=\"92\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"afwkalai9y7ygak64ijzltdx6\">這裡的 <code>HeroContactComponent</code> 示範了限定型裝飾器。</p>\n<code-example header=\"src/app/hero-contact.component.ts\" path=\"dependency-injection-in-action/src/app/hero-contact.component.ts\" region=\"component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-hero-contact',\n  template: `\n  &lt;div&gt;Phone #: {{phoneNumber}}\n  &lt;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hasLogger\"&gt;!!!&lt;/span&gt;&lt;/div&gt;`,\n  imports: [<a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a>]\n})\nexport class HeroContactComponent {\n\n  hasLogger = false;\n\n  constructor(\n      @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() // limit to the host component's instance of the HeroCacheService\n      private heroCache: HeroCacheService,\n\n      @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()     // limit search for logger; hides the application-wide logger\n      @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() // ok if the logger doesn't exist\n      private loggerService?: LoggerService\n  ) {\n    if (loggerService) {\n      this.hasLogger = true;\n      loggerService.logInfo('HeroContactComponent can log!');\n    }\n  }\n\n  get phoneNumber() { return this.heroCache.hero.phone; }\n\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72e5u72l3m47249ne423bb2g7\">注意建構式函式的引數。</p>\n<code-example header=\"src/app/hero-contact.component.ts\" path=\"dependency-injection-in-action/src/app/hero-contact.component.ts\" region=\"ctor-params\">\n@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() // limit to the host component's instance of the HeroCacheService\nprivate heroCache: HeroCacheService,\n\n@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()     // limit search for logger; hides the application-wide logger\n@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() // ok if the logger doesn't exist\nprivate loggerService?: LoggerService\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4psg6i24g0da3s2jhscqxfkgb\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 函式是建構式函式屬性 <code>heroCache</code> 的裝飾器，確保從其父元件 <code>HeroBioComponent</code> 得到一個快取服務。如果該父元件中沒有該服務，Angular 就會丟擲錯誤，即使元件樹裡的再上級有某個元件擁有這個服務，還是會丟擲錯誤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9aq5ols63odbtucn0nyuexb1k\">另一個 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 函式是建構式函式屬性 <code>loggerService</code> 的裝飾器。在本應用程式中只有一個在 <code>AppComponent</code> 級提供的 <code>LoggerService</code> 實例。該宿主 <code>HeroBioComponent</code> 沒有自己的 <code>LoggerService</code> 提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dl9cqs5ehe7nu5yt2mh2hty8m\">如果沒有同時使用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 裝飾器的話，Angular 就會丟擲錯誤。當該屬性帶有 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 標記時，Angular 就會把 <code>loggerService</code> 設定為 null，並繼續執行元件而不會丟擲錯誤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68h8pa477b3bzl8wc6fdeozzv\">下面是 <code>HeroBiosAndContactsComponent</code> 的執行結果：</p>\n<div class=\"lightbox\">\n<img alt=\"Bios with contact into\" src=\"generated/images/guide/dependency-injection-in-action/hero-bios-and-contacts.png\" width=\"206\" height=\"393\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jimjcye0udkh25l6bguhaac\">如果註解掉 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 裝飾器，Angular 就會沿著注入器樹往上走，直到在 <code>AppComponent</code> 中找到該日誌服務。日誌服務的邏輯加了進來，所顯示的英雄訊息增加了 \"!!!\" 標記，這表明確實找到了日誌服務。</p>\n<div class=\"lightbox\">\n<img alt=\"Without @Host\" src=\"generated/images/guide/dependency-injection-in-action/hero-bio-contact-no-host.png\" width=\"199\" height=\"93\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9h5k9fxlkc1l3v3t65w1mx3rl\">如果你恢復 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 裝飾器並註解掉 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code>，應用程式在宿主元件級別找不到所需的記錄器時會丟擲異常。</p>\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nEXCEPTION: No provider for LoggerService! (HeroContactComponent -&gt; LoggerService)\n\n</code-example>\n<h3 id=\"supply-a-custom-provider-with-inject\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5onqbndo89w66n8869wzo7vj2\">使用 <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> 指定自定義提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#supply-a-custom-provider-with-inject\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ezu5vk3qtkorgn2ffqmawbxwa\">自定義提供者讓你可以為隱式依賴提供一個具體的實現，比如內建瀏覽器 API。下面的例子使用 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 來提供 <a href=\"https://developer.mozilla.org/docs/Web/API/Window/localStorage\">localStorage</a>，將其作為 <code>BrowserStorageService</code> 的依賴項。</p>\n<code-example header=\"src/app/storage.service.ts\" path=\"dependency-injection-in-action/src/app/storage.service.ts\">\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>, <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>, <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const BROWSER_STORAGE = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&lt;Storage&gt;('Browser Storage', {\n  providedIn: 'root',\n  factory: () =&gt; localStorage\n});\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class BrowserStorageService {\n  constructor(@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(BROWSER_STORAGE) public storage: Storage) {}\n\n  get(key: string) {\n    return this.storage.getItem(key);\n  }\n\n  set(key: string, value: string) {\n    this.storage.setItem(key, value);\n  }\n\n  remove(key: string) {\n    this.storage.removeItem(key);\n  }\n\n  clear() {\n    this.storage.clear();\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8fwy60ovxmqho45kjkdixfy5\"><code>factory</code> 函式回傳 window 物件上的 <code>localStorage</code> 屬性。<code><a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> 裝飾器修飾一個建構式函式引數，用於為某個依賴提供自定義提供者。現在，就可以在測試期間使用 <code>localStorage</code> 的 Mock API 來覆蓋這個提供者了，而不必與真實的瀏覽器 API 進行互動。</p>\n<p><a id=\"skip\"></a></p>\n<h3 id=\"modify-the-provider-search-with-self-and-skipself\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"20z2xqu5vd5a706fkbslcwc8z\">使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> 和 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 來修改提供者的搜尋方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#modify-the-provider-search-with-self-and-skipself\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"13wry996izx0r31h76ercxoj6\">注入器也可以透過建構式函式的引數裝飾器來指定範圍。下面的例子就在 <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 類別的 <code>providers</code> 中使用瀏覽器的 <code>sessionStorage</code> API 覆蓋了 <code>BROWSER_STORAGE</code> 令牌。同一個 <code>BrowserStorageService</code> 在建構式函式中使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> 和 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 裝飾器注入了兩次，來分別指定由哪個注入器來提供依賴。</p>\n<code-example header=\"src/app/storage.component.ts\" path=\"dependency-injection-in-action/src/app/storage.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/Self\" class=\"code-anchor\">Self</a>, <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a> } from '@angular/core';\nimport { BROWSER_STORAGE, BrowserStorageService } from './storage.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-storage',\n  template: `\n    Open the inspector to see the local/session storage keys:\n\n    &lt;h3&gt;Session Storage&lt;/h3&gt;\n    &lt;button type=\"button\" (click)=\"setSession()\"&gt;Set Session Storage&lt;/button&gt;\n\n    &lt;h3&gt;Local Storage&lt;/h3&gt;\n    &lt;button type=\"button\" (click)=\"setLocal()\"&gt;Set Local Storage&lt;/button&gt;\n  `,\n  providers: [\n    BrowserStorageService,\n    { provide: BROWSER_STORAGE, useFactory: () =&gt; sessionStorage }\n  ]\n})\nexport class StorageComponent {\n\n  constructor(\n    @<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>() private sessionStorageService: BrowserStorageService,\n    @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() private localStorageService: BrowserStorageService,\n  ) { }\n\n  setSession() {\n    this.sessionStorageService.set('hero', 'Dr Nice - Session');\n  }\n\n  setLocal() {\n    this.localStorageService.set('hero', 'Dr Nice - Local');\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"308u53izsxfr9w2t8nrjmu3h2\">使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> 裝飾器時，注入器只在該組件的注入器中查詢提供者。<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 裝飾器可以讓你跳過區域性注入器，並在注入器樹中向上查詢，以發現哪個提供者滿足該依賴。<code>sessionStorageService</code> 實例使用瀏覽器的 <code>sessionStorage</code> 來跟 <code>BrowserStorageService</code> 打交道，而 <code>localStorageService</code> 跳過了局部注入器，使用根注入器提供的 <code>BrowserStorageService</code>，它使用瀏覽器的 <code>localStorage</code> API。</p>\n<p><a id=\"component-element\"></a></p>\n<h2 id=\"inject-the-components-dom-element\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3t3t1k1nae7wrfi1vhavne2s7\">注入元件的 DOM 元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#inject-the-components-dom-element\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4d6n1ulzwy3ot1pj89mrasb6z\">即便開發者極力避免，仍然會有很多視覺效果和第三方工具（比如 jQuery）需要訪問 DOM。這會讓你不得不訪問元件所在的 DOM 元素。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1jwe0utudzqdcewav0bet6y8t\">為了說明這一點，請看<a href=\"guide/attribute-directives\">屬性型指令</a>中那個 <code>HighlightDirective</code> 的簡化版。</p>\n<code-example header=\"src/app/highlight.directive.ts\" path=\"dependency-injection-in-action/src/app/highlight.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  standalone: true,\n  selector: '[appHighlight]'\n})\nexport class HighlightDirective {\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appHighlight') highlightColor = '';\n\n  private el: HTMLElement;\n\n  constructor(el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) {\n    this.el = el.nativeElement;\n  }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseenter') onMouseEnter() {\n    this.highlight(this.highlightColor || 'cyan');\n  }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseleave') onMouseLeave() {\n    this.highlight('');\n  }\n\n  private highlight(color: string) {\n    this.el.style.backgroundColor = color;\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1jj47y6ut0qhrtc21t40z2ezk\">當用戶把滑鼠移到 DOM 元素上時，指令將指令所在的元素的背景設定為一個高亮顏色。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ahoqp17jbhfjsfq0kx82qb55a\">Angular 把建構式函式引數 <code>el</code> 設定為注入的 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code>，該 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code> 代表了宿主的 DOM 元素，它的 <code>nativeElement</code> 屬性把該 DOM 元素暴露給了指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ilxqqjq1srjc4tkpmk7c5n9n\">下面的程式碼把指令的 <code>appHighlight</code> 屬性（Attribute）填加到兩個 <code>&lt;div&gt;</code> 標籤裡，一個沒有賦值，一個賦值了顏色。</p>\n<code-example header=\"src/app/app.component.html (highlight)\" path=\"dependency-injection-in-action/src/app/app.component.html\" region=\"highlight\">\n&lt;div id=\"highlight\"  class=\"di-component\"  appHighlight&gt;\n  &lt;h3&gt;Hero Bios and Contacts&lt;/h3&gt;\n  &lt;div appHighlight=\"yellow\"&gt;\n    &lt;app-hero-bios-and-contacts&gt;&lt;/app-hero-bios-and-contacts&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66qwt2c9w8lr9r8ecd72r6lcd\">下圖顯示了滑鼠移到 <code>&lt;hero-bios-and-contacts&gt;</code> 標籤上的效果：</p>\n<div class=\"lightbox\">\n<img alt=\"Highlighted bios\" src=\"generated/images/guide/dependency-injection-in-action/highlight.png\" width=\"318\" height=\"196\">\n</div>\n<p><a id=\"defining-providers\"></a></p>\n<h3 id=\"defining-providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76ybfnaadge56y6ve0dh12x3z\">定義提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#defining-providers\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"beyflc6dcfbym7chx4s0ekqvq\">用於實例化類別的預設方法不一定總適合用來建立依賴。你可以到<a href=\"guide/dependency-injection-providers\">依賴提供者</a>部分檢視其它方法。<code>HeroOfTheMonthComponent</code> 例子示範了一些替代方案，展示了為什麼需要它們。它看起來很簡單：一些屬性和一些由 logger 生成的日誌。</p>\n<div class=\"lightbox\">\n<img alt=\"Hero of the month\" src=\"generated/images/guide/dependency-injection-in-action/hero-of-month.png\" width=\"300\" height=\"165\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63lfxoiske9kcj5pudbfrwmzh\">它背後的程式碼定製了 DI 框架提供依賴項的方法和位置。這個例子闡明了透過<em>提供</em>物件字面量來把物件的定義和 DI 令牌關聯起來的另一種方式。</p>\n<code-example header=\"hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"hero-of-the-month\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> } from '@angular/core';\n\nimport { DateLoggerService } from './date-logger.service';\nimport { Hero } from './hero';\nimport { HeroService } from './hero.service';\nimport { LoggerService } from './logger.service';\nimport { MinimalLogger } from './minimal-logger.service';\nimport { RUNNERS_UP,\n         runnersUpFactory } from './runners-up';\nimport { <a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a> } from '@angular/common';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-hero-of-the-month',\n  templateUrl: './hero-of-the-month.component.html',\n  providers: [\n    { provide: Hero,          useValue:    someHero },\n    { provide: TITLE,         useValue:   'Hero of the Month' },\n    { provide: HeroService,   useClass:    HeroService },\n    { provide: LoggerService, useClass:    DateLoggerService },\n    { provide: MinimalLogger, useExisting: LoggerService },\n    { provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] }\n  ],\n  imports: [<a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a>]\n})\nexport class HeroOfTheMonthComponent {\n  logs: string[] = [];\n\n  constructor(\n      logger: MinimalLogger,\n      public heroOfTheMonth: Hero,\n      @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(RUNNERS_UP) public runnersUp: string,\n      @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(TITLE) public title: string)\n  {\n    this.logs = logger.logs;\n    logger.logInfo('starting up');\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vpmaovzsvvte13g8r4227tnk\"><code>providers</code> 陣列展示了你可以如何使用其它的鍵來定義提供者：<code>useValue</code>、<code>useClass</code>、<code>useExisting</code> 或 <code>useFactory</code>。</p>\n<p><a id=\"usevalue\"></a></p>\n<h4 id=\"value-providers-usevalue\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8cl4se2ii5z2n6wpi5is3gka\">值提供者：<code>useValue</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#value-providers-usevalue\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5snm3trrx5rbea3xjnv8qa01z\"><code>useValue</code> 鍵讓你可以為 DI 令牌關聯一個固定的值。使用該技巧來進行<em>執行期常數設定</em>，比如網站的基礎地址和功能標誌等。你也可以在單元測試中使用<em>值提供者</em>，來用一個 Mock 資料來代替一個生產環境下的資料服務。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7r0jfrcdb1lqfphsw98l9n7ad\"><code>HeroOfTheMonthComponent</code> 例子中有兩個<em>值-提供者</em>。</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-value\">\n{ provide: Hero,          useValue:    someHero },\n{ provide: TITLE,         useValue:   'Hero of the Month' },\n\n</code-example>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eqafj6purpxxhzex9waq5wr98\">第一處提供了用於 <code>Hero</code> 令牌的 <code>Hero</code> 類別的現有實例，而不是要求注入器使用 <code>new</code> 來建立一個新實例或使用它自己的快取實例。這裡令牌就是這個類別本身。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3psscnngkc3llsuum6h2o06pe\">第二處為 <code>TITLE</code> 令牌指定了一個字串字面量資源。<code>TITLE</code> 提供者的令牌<em>不是一個類別</em>，而是一個特別的提供者查詢鍵，名叫<a href=\"guide/dependency-injection-in-action#injection-token\">InjectionToken</a>，表示一個 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 實例。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5sn4cqbbjqdg687lpyilh5nn7\">你可以把 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 用作任何型別的提供者的令牌，但是當依賴是簡單型別（比如字串、數字、函式）時，它會特別有用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dueud62s63f1ot5giq8rq6vqa\">一個<em>值-提供者</em>的值必須在指定之前定義。比如標題字串就是立即可用的。該例中的 <code>someHero</code> 變數是以前在如下的檔案中定義的。你不能使用那些要等以後才能定義其值的變數。</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"some-hero\">\nconst someHero = new Hero(42, 'Magma', 'Had a great month!', '555-555-5555');\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4gjpsc2grhnudu1vhy29wu2v0\">其它型別的提供者都會<em>惰性建立</em>它們的值，也就是說只在需要注入它們的時候才建立。</p>\n<p><a id=\"useclass\"></a></p>\n<h4 id=\"class-providers-useclass\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6rnaughgeubpmvr0mx7e19pe1\">類別提供者：<code>useClass</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#class-providers-useclass\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a89oks1bp2b5eh2rq08lqigzd\"><code>useClass</code> 提供的鍵讓你可以建立並回傳指定類別的新實例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2gvg3bsorxbwntjb6ugcx55qf\">你可以使用這類別提供者來為公共類別或預設類別換上一個<em>替代實現</em>。比如，這個替代實現可以實現一種不同的策略來擴充套件預設類別，或在測試環境中模擬真實類別的行為。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cr5nnq8va9iia6kgakmdce394\">請看下面 <code>HeroOfTheMonthComponent</code> 裡的兩個例子：</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-class\">\n{ provide: HeroService,   useClass:    HeroService },\n{ provide: LoggerService, useClass:    DateLoggerService },\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3vf3n5oaa29g3wtuvsqcu5elo\">第一個提供者是<em>展開了語法糖的</em>，是一個典型情況的展開。一般來說，被新建的類別（<code>HeroService</code>）同時也是該提供者的注入令牌。通常都選用縮寫形式，完整形式可以讓細節更明確。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlztq7f1jz8xeybnh3rnv1a4r\">第二個提供者使用 <code>DateLoggerService</code> 來滿足 <code>LoggerService</code>。該 <code>LoggerService</code> 在 <code>AppComponent</code> 級別已經被註冊。當<em>這個元件</em>要求 <code>LoggerService</code> 的時候，它得到的卻是 <code>DateLoggerService</code> 服務的實例。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ct9gybaahx8eyx4zvi2cr6x1\">這個元件及其子元件會得到 <code>DateLoggerService</code> 實例。這個元件樹之外的元件得到的仍是 <code>LoggerService</code> 實例。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayo9zjtdualnoh2ltq9g1gfmd\"><code>DateLoggerService</code> 從 <code>LoggerService</code> 繼承；它把當前的日期/時間附加到每條訊息上。</p>\n<code-example header=\"src/app/date-logger.service.ts\" path=\"dependency-injection-in-action/src/app/date-logger.service.ts\" region=\"date-logger-service\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class DateLoggerService extends LoggerService\n{\n  override logInfo(msg: any)  { super.logInfo(stamp(msg)); }\n  override logDebug(msg: any) { super.logInfo(stamp(msg)); }\n  override logError(msg: any) { super.logError(stamp(msg)); }\n}\n\nfunction stamp(msg: any) { return msg + ' at ' + new Date(); }\n\n</code-example>\n<p><a id=\"useexisting\"></a></p>\n<h4 id=\"alias-providers-useexisting\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7q6tfy4s6w6g4k82txexv7ujt\">別名提供者：<code>useExisting</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#alias-providers-useexisting\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ev6dlop7tr3zrm8bpa87vxiet\"><code>useExisting</code> 提供了一個鍵，讓你可以把一個令牌對映成另一個令牌。實際上，第一個令牌就是第二個令牌所關聯的服務的<em>別名</em>，這樣就建立了訪問同一個服務物件的兩種途徑。</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-existing\">\n{ provide: MinimalLogger, useExisting: LoggerService },\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b4klvdupggnqroujcd9volagm\">你可以使用別名介面來窄化 API。下面的例子中使用別名就是為了這個目的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8f4on65mcowhnnu7ds5oimddh\">想象 <code>LoggerService</code> 有個很大的 API 介面，遠超過現有的三個方法和一個屬性。你可能希望把 API 介面收窄到只有兩個你確實需要的成員。在這個例子中，<code>MinimalLogger</code><a href=\"guide/dependency-injection-in-action#class-interface\"><em>類別-介面</em></a>，就這個 API 成功縮小到了只有兩個成員：</p>\n<code-example header=\"src/app/minimal-logger.service.ts\" path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\">\n// Class used as a \"narrowing\" interface that exposes a minimal logger\n// Other members of the actual implementation are invisible\nexport abstract class MinimalLogger {\n  abstract logs: string[];\n  abstract logInfo: (msg: string) =&gt; void;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bxrw8dbvwfu8ogzrl6g48dd1a\">下面的例子在一個簡化版的 <code>HeroOfTheMonthComponent</code> 中使用 <code>MinimalLogger</code>。</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts (minimal version)\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.1.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-hero-of-the-month',\n  templateUrl: './hero-of-the-month.component.html',\n  // TODO: move this aliasing, `useExisting` provider to the AppModule\n  providers: [{ provide: MinimalLogger, useExisting: LoggerService }],\n  imports: [<a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a>]\n})\nexport class HeroOfTheMonthComponent {\n  logs: string[] = [];\n  constructor(logger: MinimalLogger) {\n    logger.logInfo('starting up');\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"y2ltkoj6sfpvidx2viekdsss\"><code>HeroOfTheMonthComponent</code> 建構式函式的 <code>logger</code> 引數是一個 <code>MinimalLogger</code> 型別，在支援 TypeScript 感知的編輯器裡，只能看到它的兩個成員 <code>logs</code> 和 <code>logInfo</code>：</p>\n<div class=\"lightbox\">\n<img alt=\"MinimalLogger restricted API\" src=\"generated/images/guide/dependency-injection-in-action/minimal-logger-intellisense.png\" width=\"532\" height=\"60\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cnr0w8rezwm31ohk9ue31qw06\">實際上，Angular 把 <code>logger</code> 引數設定為注入器裡 <code>LoggerService</code> 令牌下注冊的完整服務，該令牌恰好是<a href=\"guide/dependency-injection-in-action#useclass\">以前提供的那個</a> <code>DateLoggerService</code> 實例。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cy3g2auz0lmukit97nnv1aqeq\">在下面的圖片中，顯示了日誌日期，可以確認這一點：</p>\n<div class=\"lightbox\">\n<img alt=\"DateLoggerService entry\" src=\"generated/images/guide/dependency-injection-in-action/date-logger-entry.png\" width=\"300\" height=\"32\">\n</div>\n</div>\n<p><a id=\"usefactory\"></a></p>\n<h4 id=\"factory-providers-usefactory\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a0hj9kqy1y5pjccv3oz441mp8\">工廠提供者：<code>useFactory</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#factory-providers-usefactory\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a9v8qv17uymjlcy3n5k9dhp3\"><code>useFactory</code> 提供了一個鍵，讓你可以透過呼叫一個工廠函式來建立依賴實例，如下麵的例子所示。</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-factory\">\n{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] }\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9whix3091jca38sju9fvnruq2\">注入器透過呼叫你用 <code>useFactory</code> 鍵指定的工廠函式來提供該依賴的值。\n注意，提供者的這種形態還有第三個鍵 <code>deps</code>，它指定了供 <code>useFactory</code> 函式使用的那些依賴。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"25fybhn8khsrbqsp2h0mjijgo\">使用這項技術，可以用包含了一些<strong><em>依賴服務和本地狀態</em></strong>輸入的工廠函式來<strong><em>建立一個依賴物件</em></strong>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2dyttcugc4dm1mes27m1lre48\">這個依賴物件（由工廠函式回傳的）通常是一個類別實例，不過也可以是任何其它東西。在這個例子中，依賴物件是一個表示 \"月度英雄\" 參賽者名稱的字串。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cgjtio63hm9ael1d8wyf72wb\">在這個例子中，區域性狀態是數字 <code>2</code>，也就是元件應該顯示的參賽者數量。該狀態的值傳給了 <code>runnersUpFactory()</code> 作為引數。<code>runnersUpFactory()</code> 回傳了<em>提供者的工廠函式</em>，它可以使用傳入的狀態值和注入的服務 <code>Hero</code> 和 <code>HeroService</code>。</p>\n<code-example header=\"runners-up.ts (excerpt)\" path=\"dependency-injection-in-action/src/app/runners-up.ts\" region=\"factory-synopsis\">\nexport function runnersUpFactory(take: number) {\n  return (winner: Hero, heroService: HeroService): string =&gt;\n    /* ... */\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aoufavjgghfx9xm1apzyjh6rj\">由 <code>runnersUpFactory()</code> 回傳的提供者的工廠函式回傳了實際的依賴物件，也就是表示名字的字串。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1yb21oevcu8hiwesntilnrf9s\">該函式以獲勝的 <code>Hero</code> 和 <code>HeroService</code> 作為引數。Angular 從 <code>deps</code> 陣列中的兩個<em>令牌</em>標識的注入值提供這些引數。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6pajkvz5rf13ib6yg83mtctx\">該函式回傳名字的字串，Angular 可以把它們注入到 <code>HeroOfTheMonthComponent</code> 的 <code>runnersUp</code> 引數中。</p>\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cs122j1dngrusjqamedg2vrsf\">該函式從 <code>HeroService</code> 中接受候選的英雄，從中取 <code>2</code> 個參加競賽，並把他們的名字串接起來回傳。\n參閱 <live-example name=\"dependency-injection-in-action\"></live-example> 檢視完整原始碼。</p>\n</div>\n<p><a id=\"tokens\"></a></p>\n<h2 id=\"provider-token-alternatives-class-interface-and-injectiontoken\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"et37l801p98km6xfnmrmjhv9x\">提供替代令牌：類別介面與 'InjectionToken'<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#provider-token-alternatives-class-interface-and-injectiontoken\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dq7s331jllu3voehl4ajeij0d\">當使用類別作為令牌，同時也把它作為回傳依賴物件或服務的型別時，Angular 依賴注入使用起來最容易。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"769kg72dmzxctp94ldz6x2lof\">但令牌不一定都是類別，就算它是一個類別，它也不一定都回傳型別相同的物件。這是下一節的主題。</p>\n<p><a id=\"class-interface\"></a></p>\n<h3 id=\"class-interface\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7jzrd7ca6zp7a6lhajz4i6g7m\">類別-介面<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#class-interface\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9lz1f5rlwc4jvu8pvyzn9y8g5\">前面的<em>月度英雄</em>的例子使用了 <code>MinimalLogger</code> 類別作為 <code>LoggerService</code> 提供者的令牌。</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-existing\">\n{ provide: MinimalLogger, useExisting: LoggerService },\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"mt75b63rtsc7v1bai6z1ymc2\">該 <code>MinimalLogger</code> 是一個抽象類別。</p>\n<code-example header=\"src/app/minimal-logger.service.ts\" path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\">\n// Class used as a \"narrowing\" interface that exposes a minimal logger\n// Other members of the actual implementation are invisible\nexport abstract class MinimalLogger {\n  abstract logs: string[];\n  abstract logInfo: (msg: string) =&gt; void;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"566z9w4yhxgsbd72nsp3rlgh8\">你通常從一個可擴充套件的抽象類別繼承。但這個應用中<em>並沒有</em>類別會繼承 <code>MinimalLogger</code>。<code>LoggerService</code> 和 <code>DateLoggerService</code><em>本可以</em>從 <code>MinimalLogger</code> 中繼承。\n它們也可以實現 <code>MinimalLogger</code>，而不用單獨定義介面。\n但它們沒有。\n<code>MinimalLogger</code> 在這裡僅僅被用作一個 \"依賴注入令牌\"。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4rg2fdfaaivfkuarxjm1kw9p\">當你透過這種方式使用類別時，它稱作<em>類別介面</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wpaqco01i39gr0d1qzsavhra\">就像<a href=\"guide/dependency-injection-providers\">設定依賴提供者</a>中提到的那樣，介面不是有效的 DI 令牌，因為它是 TypeScript 自己用的，在執行期間不存在。使用這種抽象類別介面不但可以獲得像介面一樣的強型別，而且可以像普通類別一樣把它用作提供者令牌。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ec8jlrl4hzxwfs1m4g2wdbvd7\">類別介面應該<em>只</em>定義允許它的消費者呼叫的成員。窄的介面有助於解耦該類別的具體實現和它的消費者。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ato8aylizm3qdx4xcx8ciayad\">用類別作為介面可以讓你獲得真實 JavaScript 物件中的介面的屬性。但是，為了最小化記憶體開銷，該類別應該是<em>沒有實現</em>的。對於建構式函式，<code>MinimalLogger</code> 會轉譯成未最佳化過的、預先最小化過的 JavaScript。</p>\n<code-example header=\"src/app/minimal-logger.service.ts\" path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" region=\"minimal-logger-transpiled\">\nvar MinimalLogger = (function () {\n  function MinimalLogger() {}\n  return MinimalLogger;\n}());\nexports(\"MinimalLogger\", MinimalLogger);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4roui91uwe713lm1cqenrnk3m\"><strong>注意</strong>：<br>\n它沒有任何成員。無論你新增到類別中的成員有多少，它都不會增長大小，因為這些成員只是型別而沒有實現。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4n0eb8flseard1p2r2nznx9p2\">你可以再看看 TypeScript 的 <code>MinimalLogger</code> 類別，確定一下它是沒有實現的。</p>\n</div>\n<p><a id=\"injection-token\"></a></p>\n<h3 id=\"injectiontoken-objects\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3la6dl59jd4j9e17wvcdgpw6h\">'InjectionToken' 物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#injectiontoken-objects\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2idfvd96nuuet0nezzexfyje3\">依賴物件可以是一個簡單的值，比如日期，數字和字串，或者一個無形的物件，比如陣列和函式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azl230bpc3gft9p46d6i26mje\">這樣的物件沒有應用程式介面，所以不能用一個類別來表示。更適合表示它們的是：唯一的和符號性的令牌，一個 JavaScript 物件，擁有一個友好的名字，但不會與其它的同名令牌發生衝突。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"apzro2i9xd50k42yorrcm0bo9\"><code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 具有這些特徵。在<em>Hero of the Month</em>例子中遇見它們兩次，一個是 <em>title</em> 的值，一個是 <em>runnersUp</em> 工廠提供者。</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"provide-injection-token\">\n{ provide: TITLE,         useValue:   'Hero of the Month' },\n{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] }\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cijdcocenascas60kh8bvxi2n\">這樣建立 <code>TITLE</code> 令牌：</p>\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"injection-token\">\nimport { <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const TITLE = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&lt;string&gt;('title');\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"an1s4sf7rz1ltvwc16bae0iz2\">型別引數，雖然是可選的，但可以向開發者和開發工具傳達型別訊息。而且這個令牌的描述訊息也可以為開發者提供幫助。</p>\n<p><a id=\"di-inheritance\"></a></p>\n<h2 id=\"inject-into-a-derived-class\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"821i2phse3qbg520ivkvmills\">注入到衍生類別<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#inject-into-a-derived-class\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"836n3m5w137vasekq86ja7buu\">當編寫一個繼承自另一個元件的元件時，要格外小心。如果基礎元件有依賴注入，必須要在衍生類別中重新提供和重新注入它們，並將它們透過建構式函式傳給基底類別。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7frmjnf0dor9ol5z6nfq2wz1t\">在這個刻意生成的例子裡，<code>SortedHeroesComponent</code> 繼承自 <code>HeroesBaseComponent</code>，顯示一個<em>被排序</em>的英雄清單。</p>\n<div class=\"lightbox\">\n<img alt=\"Sorted Heroes\" src=\"generated/images/guide/dependency-injection-in-action/sorted-heroes.png\" width=\"135\" height=\"107\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6m3ljm1gy0tjtcjjfboh81hws\"><code>HeroesBaseComponent</code> 能自己獨立執行。它在自己的實例裡要求 <code>HeroService</code>，用來得到英雄，並將他們按照資料庫回傳的順序顯示出來。</p>\n<code-example header=\"src/app/sorted-heroes.component.ts (HeroesBaseComponent)\" path=\"dependency-injection-in-action/src/app/sorted-heroes.component.ts\" region=\"heroes-base\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-unsorted-heroes',\n  template: '&lt;div *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;{{hero.name}}&lt;/div&gt;',\n  providers: [HeroService],\n  imports: [<a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a>]\n})\nexport class HeroesBaseComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private heroService: HeroService) { }\n\n  heroes: Hero[] = [];\n\n  ngOnInit() {\n    this.heroes = this.heroService.getAllHeroes();\n    this.afterGetHeroes();\n  }\n\n  // Post-process heroes in derived class override.\n  protected afterGetHeroes() {}\n\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<h3 id=\"keep-constructors-simple\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4a0i8vye3325qodevhn54xn3y\">讓建構式函式保持簡單<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#keep-constructors-simple\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"67q0e736m2x0lbfqt18kqikby\">建構式函式應該只用來初始化變數。這條規則讓元件在測試環境中可以放心地構造元件，以免在構造它們時，無意中做出一些非常戲劇化的動作(比如與伺服器進行會話)。這就是為什麼你要在 <code>ngOnInit</code> 裡面呼叫 <code>HeroService</code>，而不是在建構式函式中。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cia7sk8hy6mblyu88lmkv847h\">使用者希望看到英雄按字母順序排序。與其修改原始的元件，不如派生它，新建 <code>SortedHeroesComponent</code>，以便展示英雄之前進行排序。<code>SortedHeroesComponent</code> 讓基底類別來獲取英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f22lgr5j2a6qcjqdb5lm8sszs\">可惜，Angular 不能直接在基底類別裡直接注入 <code>HeroService</code>。必須在<em>這個</em>元件裡再次提供 <code>HeroService</code>，然後透過建構式函式傳給基底類別。</p>\n<code-example header=\"src/app/sorted-heroes.component.ts (SortedHeroesComponent)\" path=\"dependency-injection-in-action/src/app/sorted-heroes.component.ts\" region=\"sorted-heroes\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-sorted-heroes',\n  template: '&lt;div *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;{{hero.name}}&lt;/div&gt;',\n  providers: [HeroService],\n  imports: [<a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a>]\n})\nexport class SortedHeroesComponent extends HeroesBaseComponent {\n  constructor(heroService: HeroService) {\n    super(heroService);\n  }\n\n  protected override afterGetHeroes() {\n    this.heroes = this.heroes.sort((h1, h2) =&gt; h1.name &lt; h2.name ? -1 :\n            (h1.name &gt; h2.name ? 1 : 0));\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cigjlkj25qs6wx4tztekd1rdq\">現在，請注意 <code>afterGetHeroes()</code> 方法。\n你的第一反應是在 <code>SortedHeroesComponent</code> 元件裡面建一個 <code>ngOnInit</code> 方法來做排序。但是 Angular 會先呼叫<em>派生</em>類別的 <code>ngOnInit</code>，後呼叫基底類別的 <code>ngOnInit</code>，\n所以可能在<em>英雄到達之前</em>就開始排序。這就產生了一個討厭的錯誤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aj9n8jtipkij4iha98ykumyu8\">覆蓋基底類別的 <code>afterGetHeroes()</code> 方法可以解決這個問題。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"668knfuob4alegihqtv1mso91\">分析上面的這些複雜性是為了強調<em>避免使用元件繼承</em>這一點。</p>\n<p><a id=\"forwardref\"></a></p>\n<h2 id=\"resolve-circular-dependencies-with-a-forward-class-reference-forwardref\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"11gq72j5vtisw8kmuionfd7z0\">使用一個前向引用（<em>forwardRef</em>）來解析迴圈依賴<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#resolve-circular-dependencies-with-a-forward-class-reference-forwardref\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tfha6g3lpqznfc0smwvb3kpj\">在 TypeScript 裡面，類別宣告的順序是很重要的。如果一個類別尚未定義，就不能引用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dcblixupwp0mbu2p8tg5018vp\">這通常不是一個問題，特別是當你遵循<em>一個檔案一個類別</em>規則的時候。但是有時候迴圈引用可能不能避免。例如，當一個類別 'A' 引用類別 'B'，同時 'B' 引用 'A' 的時候，它們中間的某一個必須要先定義。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2njpnjls1tcqzlars90snuzsg\">Angular 的 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> 函式建立一個<em>間接地</em>引用，Angular 可以隨後解析。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azqzr09edad4dfx83pb1wb0u7\">這個關於<em>父查詢器</em>的例子中全都是沒辦法打破的迴圈類別引用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dm3dx55i2qdzdbfwu9tra3sia\">當一個類別<em>需要引用自身</em>的時候，你面臨同樣的困境，就像在 <code>AlexComponent</code> 的 <code>providers</code> 陣列中遇到的困境一樣。該 <code>providers</code> 陣列是一個 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 裝飾器函式的一個屬性，它必須在類別定義<em>之前</em>出現。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9yvgifrs30qu50vy118u1gno5\">使用 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a></code> 來打破這種迴圈：</p>\n<code-example header=\"parent-finder.component.ts (AlexComponent providers)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; AlexComponent) }],\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/Host\n - api/core/SkipSelf\n - errors/NG0200\n - guide/creating-injectable-service\n - guide/dependency-injection\n - guide/dependency-injection-navtree\n - guide/dependency-injection-providers\n - guide/hierarchical-dependency-injection\n-->\n<!-- links from this doc:\n - api/common/NgFor\n - api/common/NgIf\n - api/core/Component\n - api/core/Directive\n - api/core/ElementRef\n - api/core/Host\n - api/core/HostListener\n - api/core/Inject\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/Input\n - api/core/OnInit\n - api/core/Optional\n - api/core/Self\n - api/core/SkipSelf\n - api/core/forwardRef\n - api/core/ng-content\n - api/forms/DefaultValueAccessor\n - api/forms/FormsModule\n - api/forms/NgModel\n - guide/attribute-directives\n - guide/dependency-injection-in-action#alias-providers-useexisting\n - guide/dependency-injection-in-action#class-interface\n - guide/dependency-injection-in-action#class-providers-useclass\n - guide/dependency-injection-in-action#defining-providers\n - guide/dependency-injection-in-action#dependency-injection-in-action\n - guide/dependency-injection-in-action#factory-providers-usefactory\n - guide/dependency-injection-in-action#hero-bios-component\n - guide/dependency-injection-in-action#inject-into-a-derived-class\n - guide/dependency-injection-in-action#inject-the-components-dom-element\n - guide/dependency-injection-in-action#injection-token\n - guide/dependency-injection-in-action#injectiontoken-objects\n - guide/dependency-injection-in-action#keep-constructors-simple\n - guide/dependency-injection-in-action#make-a-dependency-optional-and-limit-search-with-host\n - guide/dependency-injection-in-action#modify-the-provider-search-with-self-and-skipself\n - guide/dependency-injection-in-action#multiple-service-instances-sandboxing\n - guide/dependency-injection-in-action#provider-token-alternatives-class-interface-and-injectiontoken\n - guide/dependency-injection-in-action#qualify-dependency-lookup-with-parameter-decorators\n - guide/dependency-injection-in-action#resolve-circular-dependencies-with-a-forward-class-reference-forwardref\n - guide/dependency-injection-in-action#supply-a-custom-provider-with-inject\n - guide/dependency-injection-in-action#useclass\n - guide/dependency-injection-in-action#value-providers-usevalue\n - guide/dependency-injection-providers\n - https://developer.mozilla.org/docs/Web/API/Window/localStorage\n-->"}