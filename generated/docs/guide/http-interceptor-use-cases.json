{"id":"guide/http-interceptor-use-cases","title":"HTTP 拦截器用例","contents":"<div class=\"content\">\n  <h1 id=\"http----interceptor-use-cases\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"fn4ymnzz8jdmcolgy6vznpwq\">HTTP 拦截器用例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#http----interceptor-use-cases\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"axgb8uhitgwap4o7f8tof2nuz\">以下是拦截器的一些常见用法。</p>\n<h2 id=\"set-default-headers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"thvcjoxxz9h4cbommv13wru4\">设置默认标题<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#set-default-headers\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5alexjcmed4a0ao6q33wnl2kf\">应用通常会使用拦截器来设置外发请求的默认请求头。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5parbw7kquw2siprsxz2kf0pa\">该范例应用具有一个 <code>AuthService</code>，它会生成一个认证令牌。在这里，<code>AuthInterceptor</code> 会注入该服务以获取令牌，并对每一个外发的请求添加一个带有该令牌的认证头：</p>\n<code-example header=\"app/http-interceptors/auth-interceptor.ts\" path=\"http/src/app/http-interceptors/auth-interceptor.ts\">\nimport { AuthService } from '../auth.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class AuthInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n\n  constructor(private auth: AuthService) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // Get the auth token from the service.\n    const authToken = this.auth.getAuthorizationToken();\n\n    // Clone the request and replace the original headers with\n    // cloned headers, updated with the authorization.\n    const authReq = req.clone({\n      headers: req.headers.set('Authorization', authToken)\n    });\n\n    // send cloned request with header to the next handler.\n    return next.handle(authReq);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"32brlk9cv5b9i86ur2w5l83xg\">这种在克隆请求的同时设置新请求头的操作太常见了，因此它还有一个快捷方式 <code>setHeaders</code>：</p>\n<code-example path=\"http/src/app/http-interceptors/auth-interceptor.ts\" region=\"set-header-shortcut\">\n// Clone the request and set the new header in one step.\nconst authReq = req.clone({ setHeaders: { Authorization: authToken } });\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f3oqai83t3kpk251hif3bjzoz\">这种可以修改头的拦截器可以用于很多不同的操作，比如：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bmy3wyk05d2kl2h5o7b2ioss3\">认证 / 授权</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cejx62u0zoa1rvza5w0n0eagh\">控制缓存行为。比如 <code>If-Modified-Since</code></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"boavr5z03onajogritmvn7uce\">XSRF 防护</li>\n</ul>\n<h2 id=\"log-request-and-response-pairs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a1f3pe61e4mzvc4vqwz0odyj\">记录请求和响应对<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#log-request-and-response-pairs\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uzieamhlwo794vile1spgfqg\">因为拦截器可以<em>同时</em>处理请求和响应，所以它们也可以对整个 HTTP 操作执行计时和记录日志等任务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3mxcikqltg5jmp4q807bmhlkv\">考虑下面这个 <code>LoggingInterceptor</code>，它捕获请求的发起时间、响应的接收时间，并使用注入的 <code>MessageService</code> 来发送总共花费的时间。</p>\n<code-example header=\"app/http-interceptors/logging-interceptor.ts)\" path=\"http/src/app/http-interceptors/logging-interceptor.ts\" region=\"excerpt\">\nimport { finalize, tap } from 'rxjs';\nimport { MessageService } from '../message.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class LoggingInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private messenger: MessageService) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    const started = Date.now();\n    let ok: string;\n\n    // extend server response observable with logging\n    return next.handle(req)\n      .pipe(\n        tap({\n          // Succeeds when there is a response; ignore other events\n          next: (event) =&gt; (ok = event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a> ? 'succeeded' : ''),\n          // Operation failed; error is an <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>\n          error: (_error) =&gt; (ok = 'failed')\n        }),\n        // Log when response observable either completes or errors\n        finalize(() =&gt; {\n          const elapsed = Date.now() - started;\n          const msg = `${req.method} \"${req.urlWithParams}\"\n             ${ok} in ${elapsed} ms.`;\n          this.messenger.add(msg);\n        })\n      );\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dgw2g41wibqrdjgpqpy9rt3n\">RxJS 的 <code>tap</code> 操作符会捕获请求成功了还是失败了。RxJS 的 <code>finalize</code> 操作符无论在返回成功还是失败时都会调用，然后把结果汇报给 <code>MessageService</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"10lij6woplguwcru7i5c18fu5\">在这个可观察对象的流中，无论是 <code>tap</code> 还是 <code>finalize</code> 接触过的值，都会照常发送给调用者。</p>\n<p><a id=\"custom-json-parser\"></a></p>\n<h2 id=\"custom-json-parsing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"df1hlow6yg9qvqustpt03oiqv\">自定义 JSON 解析<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#custom-json-parsing\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"39txoa0eey4xk54xf0116rm8t\">拦截器可用来以自定义实现替换内置的 JSON 解析。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cgouu0t432jwphy5ttfxr2lnp\">以下示例中的 <code>CustomJsonInterceptor</code> 演示了如何实现此目的。如果截获的请求期望一个 <code>'json'</code> 响应，则将 <code>responseType</code> 更改为 <code>'text'</code> 以禁用内置的 JSON 解析。然后，通过注入的 <code>JsonParser</code> 解析响应。</p>\n<code-example header=\"app/http-interceptors/custom-json-interceptor.ts\" path=\"http/src/app/http-interceptors/custom-json-interceptor.ts\" region=\"custom-json-interceptor\">\n// The JsonParser class acts as a base class for custom parsers and as the DI token.\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport abstract class JsonParser {\n  abstract parse(text: string): any;\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CustomJsonInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private jsonParser: JsonParser) {}\n\n  intercept(httpRequest: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    if (httpRequest.responseType === 'json') {\n      // If the expected response type is JSON then handle it here.\n      return this.handleJsonResponse(httpRequest, next);\n    } else {\n      return next.handle(httpRequest);\n    }\n  }\n\n  private handleJsonResponse(httpRequest: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // Override the responseType to disable the default JSON parsing.\n    httpRequest = httpRequest.clone({responseType: 'text'});\n    // Handle the response using the custom parser.\n    return next.handle(httpRequest).pipe(map(event =&gt; this.parseJsonResponse(event)));\n  }\n\n  private parseJsonResponse(event: <a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;) {\n    if (event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a> &amp;&amp; typeof event.body === 'string') {\n      return event.clone({body: this.jsonParser.parse(event.body)});\n    } else {\n      return event;\n    }\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5kx96x3bezvje2wan4c3zjdk2\">然后，你可以实现自己的自定义 <code>JsonParser</code>。这是一个具有特殊日期接收器的自定义 JsonParser。</p>\n<code-example header=\"app/http-interceptors/custom-json-interceptor.ts\" path=\"http/src/app/http-interceptors/custom-json-interceptor.ts\" region=\"custom-json-parser\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CustomJsonParser implements JsonParser {\n  parse(text: string): any {\n    return JSON.parse(text, dateReviver);\n  }\n}\n\nfunction dateReviver(key: string, value: any) {\n  /* . . . */\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4mu9h62v3kvnkx57ycaqvkr4q\">最后，在同一个 \n<code>httpInterceptorProviders</code> 数组中提供 \n<code>CustomParser</code> 和 \n<code>CustomJsonInterceptor</code>。</p>\n<code-example header=\"app/http-interceptors/index.ts\" path=\"http/src/app/http-interceptors/index.ts\" region=\"custom-json-interceptor\">\n{ provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: CustomJsonInterceptor, multi: true },\n{ provide: JsonParser, useClass: CustomJsonParser },\n\n</code-example>\n<p><a id=\"caching\"></a></p>\n<h2 id=\"cache-requests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bm8lwei12omm45ejsp1fvls2n\">缓存请求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#cache-requests\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"377p789zjj9oszva52u03xe83\">拦截器还可以自行处理这些请求，而不用转发给 <code>next.handle()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3fewx21bxgswboidh65uyp6cq\">比如，你可能会想缓存某些请求和响应，以便提升性能。你可以把这种缓存操作委托给某个拦截器，而不破坏你现有的各个数据服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4l8q3ajsjl2zk8kfsl2nldam5\">下例中的 <code>CachingInterceptor</code> 演示了这种方法。</p>\n<code-example header=\"app/http-interceptors/caching-interceptor.ts)\" path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"v1\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CachingInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private cache: RequestCache) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // continue if not cacheable.\n    if (!isCacheable(req)) { return next.handle(req); }\n\n    const cachedResponse = this.cache.get(req);\n    return cachedResponse ?\n      of(cachedResponse) : sendRequest(req, next, this.cache);\n  }\n}\n\n</code-example>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ewb2euv6gzbtlikfrzg96a346\"><code>isCacheable()</code> 函数用于决定该请求是否允许缓存。在这个例子中，只有发到包搜索 API 的 GET 请求才是可以缓存的。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6yf1x77atwuw382o7a1minwg\">如果该请求是不可缓存的，该拦截器会把该请求转发给链表中的下一个处理器</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8uyi2349lizqt1788ob5lym6n\">如果可缓存的请求在缓存中找到了，该拦截器就会通过 <code>of()</code> 函数返回一个已缓存的响应体的<em>可观察对象</em>，然后绕过 <code>next</code> 处理器（以及所有其它下游拦截器）</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dqvj8uwfj3zxhw6894zg1eo0\">如果可缓存的请求不在缓存中，代码会调用 <code>sendRequest()</code>。这个函数会把请求转发给 <code>next.handle()</code>，它会最终调用服务器并返回来自服务器的响应对象。</p>\n</li>\n</ul>\n<p><a id=\"send-request\"></a></p>\n<code-example path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"send-request\">\n/**\n * Get server response observable by sending request to `next()`.\n * Will add the response to the cache on the way out.\n */\nfunction sendRequest(\n  req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;,\n  next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>,\n  cache: RequestCache): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n  return next.handle(req).pipe(\n    tap(event =&gt; {\n      // There may be other events besides the response.\n      if (event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>) {\n        cache.put(req, event); // Update the cache.\n      }\n    })\n  );\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5tphicahbl2ztkswmr0vbqhgi\">注意 <code>sendRequest()</code> 是如何在返回应用程序的过程中拦截响应的。该方法通过 <code>tap()</code> 操作符来管理响应对象，该操作符的回调函数会把该响应对象添加到缓存中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5rpx4z3ll01wusao6m5ggqdp3\">然后，原始的响应会通过这些拦截器链，原封不动的回到服务器的调用者那里。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63zi0fqs7ce3clzm30o4fvzc1\">数据服务，比如 <code>PackageSearchService</code>，并不知道它们收到的某些 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 请求实际上是从缓存的请求中返回来的。</p>\n</div>\n<p><a id=\"cache-refresh\"></a></p>\n<h2 id=\"use-interceptors-to-request-multiple-values\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4v9t5gm5cv6798mcd9uwaqst4\">使用拦截器请求多个值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#use-interceptors-to-request-multiple-values\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6syzq6dxu9a6w15nmqmvibyr\"><code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 方法通常会返回一个可观察对象，它会发出一个值（数据或错误）。拦截器可以把它改成一个可以发出<a href=\"guide/observables\">多个值</a>的可观察对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2c6ns6i705rwjh89i1y22fd9q\">修改后的 <code>CachingInterceptor</code> 版本可以返回一个立即发出所缓存响应的可观察对象，然后把请求发送到包搜索 API，然后把修改过的搜索结果重新发出一次。</p>\n<code-example path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"intercept-refresh\">\n// cache-then-refresh\nif (req.headers.get('x-refresh')) {\n  const results$ = sendRequest(req, next, this.cache);\n  return cachedResponse ?\n    results$.pipe( startWith(cachedResponse) ) :\n    results$;\n}\n// cache-or-fetch\nreturn cachedResponse ?\n  of(cachedResponse) : sendRequest(req, next, this.cache);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cuwzdq0czvg9jdjp7v9j5f55i\"><em>cache-then-refresh</em> 选项是由一个自定义的 <code>x-refresh</code> 请求头触发的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ccvqplpmwxvnob2wtad95udt\"><code>PackageSearchComponent</code> 中的一个检查框会切换 <code>withRefresh</code> 标识，它是 <code>PackageSearchService.search()</code> 的参数之一。<code>search()</code> 方法创建了自定义的 <code>x-refresh</code> 头，并在调用 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 前把它添加到请求里。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b3d6dtrc1bcblwcg9lzxcphk9\">修改后的 <code>CachingInterceptor</code> 会发起一个服务器请求，而不管有没有缓存的值。\n就像 <a href=\"guide/http-interceptor-use-cases#send-request\">前面</a> 的 <code>sendRequest()</code> 方法一样进行订阅。\n在订阅 <code>results$</code> 可观察对象时，就会发起这个请求。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwxh7dohmpvp9401w7v227lse\">如果没有缓存值，拦截器直接返回 <code>results$</code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6q9wb6g77ttvxy1bk9l6slg7k\">如果有缓存的值，这些代码就会把缓存的响应加入到 <code>result$</code> 的<em>管道</em>中。这会生成一个重组后的 Observable，它会发出两次响应，故此订阅者将会看到一个包含这两个响应的序列。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dn3ednxnx2ffp8uv7xfxhb4bd\">立即发出的已缓存的响应</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ytrb40jttzmd2m0d0i5unrni\">稍后发出来自服务器的响应</li>\n</ul>\n<p><a id=\"report-progress\"></a></p>\n\n  <div class=\"reviewed\">最后复查时间：Tue Nov 08 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/http-intercept-requests-and-responses\n - guide/http-optimize-server-interaction\n-->\n<!-- links from this doc:\n - api/common/http/HTTP_INTERCEPTORS\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/common/http/HttpErrorResponse\n - api/common/http/HttpEvent\n - api/common/http/HttpHandler\n - api/common/http/HttpInterceptor\n - api/common/http/HttpRequest\n - api/common/http/HttpResponse\n - api/core/Injectable\n - guide/http-interceptor-use-cases#cache-requests\n - guide/http-interceptor-use-cases#custom-json-parsing\n - guide/http-interceptor-use-cases#http----interceptor-use-cases\n - guide/http-interceptor-use-cases#log-request-and-response-pairs\n - guide/http-interceptor-use-cases#send-request\n - guide/http-interceptor-use-cases#set-default-headers\n - guide/http-interceptor-use-cases#use-interceptors-to-request-multiple-values\n - guide/observables\n-->"}