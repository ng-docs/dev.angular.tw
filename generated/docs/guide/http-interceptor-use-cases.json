{"id":"guide/http-interceptor-use-cases","title":"HTTP 攔截器用例","contents":"<div class=\"content\">\n  <h1 id=\"http----interceptor-use-cases\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"fn4ymnzz8jdmcolgy6vznpwq\">HTTP 攔截器用例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#http----interceptor-use-cases\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"axgb8uhitgwap4o7f8tof2nuz\">以下是攔截器的一些常見用法。</p>\n<h2 id=\"set-default-headers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"thvcjoxxz9h4cbommv13wru4\">設定預設標題<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#set-default-headers\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5alexjcmed4a0ao6q33wnl2kf\">應用通常會使用攔截器來設定外發請求的預設請求頭。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5parbw7kquw2siprsxz2kf0pa\">該範例應用具有一個 <code>AuthService</code>，它會生成一個認證令牌。在這裡，<code>AuthInterceptor</code> 會注入該服務以獲取令牌，並對每一個外發的請求新增一個帶有該令牌的認證頭：</p>\n<code-example header=\"app/http-interceptors/auth-interceptor.ts\" path=\"http/src/app/http-interceptors/auth-interceptor.ts\">\nimport { AuthService } from '../auth.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class AuthInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n\n  constructor(private auth: AuthService) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // Get the auth token from the service.\n    const authToken = this.auth.getAuthorizationToken();\n\n    // Clone the request and replace the original headers with\n    // cloned headers, updated with the authorization.\n    const authReq = req.clone({\n      headers: req.headers.set('Authorization', authToken)\n    });\n\n    // send cloned request with header to the next handler.\n    return next.handle(authReq);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"32brlk9cv5b9i86ur2w5l83xg\">這種在克隆請求的同時設定新請求頭的操作太常見了，因此它還有一個快捷方式 <code>setHeaders</code>：</p>\n<code-example path=\"http/src/app/http-interceptors/auth-interceptor.ts\" region=\"set-header-shortcut\">\n// Clone the request and set the new header in one step.\nconst authReq = req.clone({ setHeaders: { Authorization: authToken } });\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f3oqai83t3kpk251hif3bjzoz\">這種可以修改頭的攔截器可以用於很多不同的操作，比如：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bmy3wyk05d2kl2h5o7b2ioss3\">認證 / 授權</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cejx62u0zoa1rvza5w0n0eagh\">控制快取行為。比如 <code>If-Modified-Since</code></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"boavr5z03onajogritmvn7uce\">XSRF 防護</li>\n</ul>\n<h2 id=\"log-request-and-response-pairs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a1f3pe61e4mzvc4vqwz0odyj\">記錄請求和回應對<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#log-request-and-response-pairs\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uzieamhlwo794vile1spgfqg\">因為攔截器可以<em>同時</em>處理請求和回應，所以它們也可以對整個 HTTP 操作執行計時和記錄日誌等任務。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3mxcikqltg5jmp4q807bmhlkv\">考慮下面這個 <code>LoggingInterceptor</code>，它捕獲請求的發起時間、回應的接收時間，並使用注入的 <code>MessageService</code> 來發送總共花費的時間。</p>\n<code-example header=\"app/http-interceptors/logging-interceptor.ts)\" path=\"http/src/app/http-interceptors/logging-interceptor.ts\" region=\"excerpt\">\nimport { finalize, tap } from 'rxjs';\nimport { MessageService } from '../message.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class LoggingInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private messenger: MessageService) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    const started = Date.now();\n    let ok: string;\n\n    // extend server response observable with logging\n    return next.handle(req)\n      .pipe(\n        tap({\n          // Succeeds when there is a response; ignore other events\n          next: (event) =&gt; (ok = event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a> ? 'succeeded' : ''),\n          // Operation failed; error is an <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>\n          error: (_error) =&gt; (ok = 'failed')\n        }),\n        // Log when response observable either completes or errors\n        finalize(() =&gt; {\n          const elapsed = Date.now() - started;\n          const msg = `${req.method} \"${req.urlWithParams}\"\n             ${ok} in ${elapsed} ms.`;\n          this.messenger.add(msg);\n        })\n      );\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dgw2g41wibqrdjgpqpy9rt3n\">RxJS 的 <code>tap</code> 運算子會捕獲請求成功了還是失敗了。RxJS 的 <code>finalize</code> 運算子無論在回傳成功還是失敗時都會呼叫，然後把結果彙報給 <code>MessageService</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"10lij6woplguwcru7i5c18fu5\">在這個可觀察物件的流中，無論是 <code>tap</code> 還是 <code>finalize</code> 接觸過的值，都會照常傳送給呼叫者。</p>\n<p><a id=\"custom-json-parser\"></a></p>\n<h2 id=\"custom-json-parsing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"df1hlow6yg9qvqustpt03oiqv\">自定義 JSON 解析<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#custom-json-parsing\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"39txoa0eey4xk54xf0116rm8t\">攔截器可用來以自定義實現替換內建的 JSON 解析。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cgouu0t432jwphy5ttfxr2lnp\">以下範例中的 <code>CustomJsonInterceptor</code> 示範了如何實現此目的。如果截獲的請求期望一個 <code>'json'</code> 回應，則將 <code>responseType</code> 更改為 <code>'text'</code> 以停用內建的 JSON 解析。然後，透過注入的 <code>JsonParser</code> 解析回應。</p>\n<code-example header=\"app/http-interceptors/custom-json-interceptor.ts\" path=\"http/src/app/http-interceptors/custom-json-interceptor.ts\" region=\"custom-json-interceptor\">\n// The JsonParser class acts as a base class for custom parsers and as the DI token.\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport abstract class JsonParser {\n  abstract parse(text: string): any;\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CustomJsonInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private jsonParser: JsonParser) {}\n\n  intercept(httpRequest: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    if (httpRequest.responseType === 'json') {\n      // If the expected response type is JSON then handle it here.\n      return this.handleJsonResponse(httpRequest, next);\n    } else {\n      return next.handle(httpRequest);\n    }\n  }\n\n  private handleJsonResponse(httpRequest: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // Override the responseType to disable the default JSON parsing.\n    httpRequest = httpRequest.clone({responseType: 'text'});\n    // Handle the response using the custom parser.\n    return next.handle(httpRequest).pipe(map(event =&gt; this.parseJsonResponse(event)));\n  }\n\n  private parseJsonResponse(event: <a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;) {\n    if (event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a> &amp;&amp; typeof event.body === 'string') {\n      return event.clone({body: this.jsonParser.parse(event.body)});\n    } else {\n      return event;\n    }\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5kx96x3bezvje2wan4c3zjdk2\">然後，你可以實現自己的自定義 <code>JsonParser</code>。這是一個具有特殊日期接收器的自定義 JsonParser。</p>\n<code-example header=\"app/http-interceptors/custom-json-interceptor.ts\" path=\"http/src/app/http-interceptors/custom-json-interceptor.ts\" region=\"custom-json-parser\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CustomJsonParser implements JsonParser {\n  parse(text: string): any {\n    return JSON.parse(text, dateReviver);\n  }\n}\n\nfunction dateReviver(key: string, value: any) {\n  /* . . . */\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4mu9h62v3kvnkx57ycaqvkr4q\">最後，在同一個 \n<code>httpInterceptorProviders</code> 陣列中提供 \n<code>CustomParser</code> 和 \n<code>CustomJsonInterceptor</code>。</p>\n<code-example header=\"app/http-interceptors/index.ts\" path=\"http/src/app/http-interceptors/index.ts\" region=\"custom-json-interceptor\">\n{ provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: CustomJsonInterceptor, multi: true },\n{ provide: JsonParser, useClass: CustomJsonParser },\n\n</code-example>\n<p><a id=\"caching\"></a></p>\n<h2 id=\"cache-requests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bm8lwei12omm45ejsp1fvls2n\">快取請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#cache-requests\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"377p789zjj9oszva52u03xe83\">攔截器還可以自行處理這些請求，而不用轉發給 <code>next.handle()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3fewx21bxgswboidh65uyp6cq\">比如，你可能會想快取某些請求和回應，以便提升效能。你可以把這種快取操作委託給某個攔截器，而不破壞你現有的各個資料服務。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4l8q3ajsjl2zk8kfsl2nldam5\">下例中的 <code>CachingInterceptor</code> 示範了這種方法。</p>\n<code-example header=\"app/http-interceptors/caching-interceptor.ts)\" path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"v1\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CachingInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private cache: RequestCache) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // continue if not cacheable.\n    if (!isCacheable(req)) { return next.handle(req); }\n\n    const cachedResponse = this.cache.get(req);\n    return cachedResponse ?\n      of(cachedResponse) : sendRequest(req, next, this.cache);\n  }\n}\n\n</code-example>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ewb2euv6gzbtlikfrzg96a346\"><code>isCacheable()</code> 函式用於決定該請求是否允許快取。在這個例子中，只有發到套件搜尋 API 的 GET 請求才是可以快取的。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6yf1x77atwuw382o7a1minwg\">如果該請求是不可快取的，該攔截器會把該請求轉發給連結串列中的下一個處理器</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8uyi2349lizqt1788ob5lym6n\">如果可快取的請求在快取中找到了，該攔截器就會透過 <code>of()</code> 函式回傳一個已快取的回應體的<em>可觀察物件</em>，然後繞過 <code>next</code> 處理器（以及所有其它下游攔截器）</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dqvj8uwfj3zxhw6894zg1eo0\">如果可快取的請求不在快取中，程式碼會呼叫 <code>sendRequest()</code>。這個函式會把請求轉發給 <code>next.handle()</code>，它會最終呼叫伺服器並回傳來自伺服器的回應物件。</p>\n</li>\n</ul>\n<p><a id=\"send-request\"></a></p>\n<code-example path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"send-request\">\n/**\n * Get server response observable by sending request to `next()`.\n * Will add the response to the cache on the way out.\n */\nfunction sendRequest(\n  req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;,\n  next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>,\n  cache: RequestCache): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n  return next.handle(req).pipe(\n    tap(event =&gt; {\n      // There may be other events besides the response.\n      if (event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>) {\n        cache.put(req, event); // Update the cache.\n      }\n    })\n  );\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5tphicahbl2ztkswmr0vbqhgi\">注意 <code>sendRequest()</code> 是如何在回傳應用程式的過程中攔截回應的。該方法透過 <code>tap()</code> 運算子來管理回應物件，該運算子的回呼函式會把該回應物件新增到快取中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5rpx4z3ll01wusao6m5ggqdp3\">然後，原始的回應會通過這些攔截器鏈，原封不動的回到伺服器的呼叫者那裡。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63zi0fqs7ce3clzm30o4fvzc1\">資料服務，比如 <code>PackageSearchService</code>，並不知道它們收到的某些 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 請求實際上是從快取的請求中回傳來的。</p>\n</div>\n<p><a id=\"cache-refresh\"></a></p>\n<h2 id=\"use-interceptors-to-request-multiple-values\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4v9t5gm5cv6798mcd9uwaqst4\">使用攔截器請求多個值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#use-interceptors-to-request-multiple-values\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a6syzq6dxu9a6w15nmqmvibyr\"><code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 方法通常會回傳一個可觀察物件，它會發出一個值（資料或錯誤）。攔截器可以把它改成一個可以發出<a href=\"guide/observables\">多個值</a>的可觀察物件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2c6ns6i705rwjh89i1y22fd9q\">修改後的 <code>CachingInterceptor</code> 版本可以回傳一個立即發出所快取回應的可觀察物件，然後把請求傳送到套件搜尋 API，然後把修改過的搜尋結果重新發出一次。</p>\n<code-example path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"intercept-refresh\">\n// cache-then-refresh\nif (req.headers.get('x-refresh')) {\n  const results$ = sendRequest(req, next, this.cache);\n  return cachedResponse ?\n    results$.pipe( startWith(cachedResponse) ) :\n    results$;\n}\n// cache-or-fetch\nreturn cachedResponse ?\n  of(cachedResponse) : sendRequest(req, next, this.cache);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cuwzdq0czvg9jdjp7v9j5f55i\"><em>cache-then-refresh</em> 選項是由一個自定義的 <code>x-refresh</code> 請求頭觸發的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ccvqplpmwxvnob2wtad95udt\"><code>PackageSearchComponent</code> 中的一個檢查框會切換 <code>withRefresh</code> 標識，它是 <code>PackageSearchService.search()</code> 的引數之一。<code>search()</code> 方法建立了自定義的 <code>x-refresh</code> 頭，並在呼叫 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 前把它新增到請求裡。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b3d6dtrc1bcblwcg9lzxcphk9\">修改後的 <code>CachingInterceptor</code> 會發起一個伺服器請求，而不管有沒有快取的值。\n就像 <a href=\"guide/http-interceptor-use-cases#send-request\">前面</a> 的 <code>sendRequest()</code> 方法一樣進行訂閱。\n在訂閱 <code>results$</code> 可觀察物件時，就會發起這個請求。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwxh7dohmpvp9401w7v227lse\">如果沒有快取值，攔截器直接回傳 <code>results$</code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6q9wb6g77ttvxy1bk9l6slg7k\">如果有快取的值，這些程式碼就會把快取的回應加入到 <code>result$</code> 的<em>通道</em>中。這會生成一個重組後的 Observable，它會發出兩次回應，故此訂閱者將會看到一個包含這兩個回應的序列。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dn3ednxnx2ffp8uv7xfxhb4bd\">立即發出的已快取的回應</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ytrb40jttzmd2m0d0i5unrni\">稍後發出來自伺服器的回應</li>\n</ul>\n<p><a id=\"report-progress\"></a></p>\n\n  <div class=\"reviewed\">最後複查時間：Tue Nov 08 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/http-intercept-requests-and-responses\n - guide/http-optimize-server-interaction\n-->\n<!-- links from this doc:\n - api/common/http/HTTP_INTERCEPTORS\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/common/http/HttpErrorResponse\n - api/common/http/HttpEvent\n - api/common/http/HttpHandler\n - api/common/http/HttpInterceptor\n - api/common/http/HttpRequest\n - api/common/http/HttpResponse\n - api/core/Injectable\n - guide/http-interceptor-use-cases#cache-requests\n - guide/http-interceptor-use-cases#custom-json-parsing\n - guide/http-interceptor-use-cases#http----interceptor-use-cases\n - guide/http-interceptor-use-cases#log-request-and-response-pairs\n - guide/http-interceptor-use-cases#send-request\n - guide/http-interceptor-use-cases#set-default-headers\n - guide/http-interceptor-use-cases#use-interceptors-to-request-multiple-values\n - guide/observables\n-->"}