{"id":"guide/testing-services","title":"測試服務","contents":"<div class=\"content\">\n  <h1 id=\"testing-services\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"chimgir564h319oeuoiq25652\">測試服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-services\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a84796annz6q64lxtl1l3s702\">為了檢查你的服務是否正常工作，你可以專門為它們編寫測試。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jhe3g7pull8hzqtm08p46wf0\">如果你要試驗本指南中所講的應用，請<live-example name=\"testing\" nodownload=\"\">在瀏覽器中執行它</live-example>或<live-example name=\"testing\" downloadonly=\"\">下載並在本地執行它</live-example>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"53qikwqhd0f92oa21yajynco4\">服務往往是最容易進行單元測試的檔案。下面是一些針對 <code>ValueService</code> 的同步和非同步單元測試，甚至不需要 Angular 測試工具的幫助。</p>\n<code-example header=\"app/demo/demo.spec.ts\" path=\"testing/src/app/demo/demo.spec.ts\" region=\"ValueService\">\n// Straight Jasmine testing without Angular's testing support\ndescribe('ValueService', () =&gt; {\n  let service: ValueService;\n  beforeEach(() =&gt; {\n    service = new ValueService();\n  });\n\n  it('#getValue should return real value', () =&gt; {\n    expect(service.getValue()).toBe('real value');\n  });\n\n  it('#getObservableValue should return value from observable', (done: DoneFn) =&gt; {\n    service.getObservableValue().subscribe((value) =&gt; {\n      expect(value).toBe('observable value');\n      done();\n    });\n  });\n\n  it('#getPromiseValue should return value from a promise', (done: DoneFn) =&gt; {\n    service.getPromiseValue().then((value) =&gt; {\n      expect(value).toBe('promise value');\n      done();\n    });\n  });\n});\n\n</code-example>\n<p><a id=\"services-with-dependencies\"></a></p>\n<h2 id=\"services-with-dependencies\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"822bp8h8cqw5y49v2v7at3y3t\">有依賴的服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#services-with-dependencies\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"co7oivmx6lao9k8kbqbzgk3rv\">服務通常依賴於 Angular 在建構式函式中注入的其它服務。在很多情況下，呼叫服務的建構式函式時，很容易手動建立和<em>注入</em>這些依賴。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5e61ib8ge8d0nv26t9l7snckp\"><code>MasterService</code> 就是一個簡單的例子：</p>\n<code-example header=\"app/demo/demo.ts\" path=\"testing/src/app/demo/demo.ts\" region=\"MasterService\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class MasterService {\n  constructor(private valueService: ValueService) {}\n  getValue() {\n    return this.valueService.getValue();\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e732jzduwt4khk20izg6rrvn4\"><code>MasterService</code> 只把它唯一的方法 <code>getValue</code> 委託給了所注入的 <code>ValueService</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ggnkn8lmdqms3j9gc1yxlife\">這裡有幾種測試方法。</p>\n<code-example header=\"app/demo/demo.spec.ts\" path=\"testing/src/app/demo/demo.spec.ts\" region=\"MasterService\">\ndescribe('MasterService without Angular testing support', () =&gt; {\n  let masterService: MasterService;\n\n  it('#getValue should return real value from the real service', () =&gt; {\n    masterService = new MasterService(new ValueService());\n    expect(masterService.getValue()).toBe('real value');\n  });\n\n  it('#getValue should return faked value from a fakeService', () =&gt; {\n    masterService = new MasterService(new FakeValueService());\n    expect(masterService.getValue()).toBe('faked service value');\n  });\n\n  it('#getValue should return faked value from a fake object', () =&gt; {\n    const fake = { getValue: () =&gt; 'fake value' };\n    masterService = new MasterService(fake as ValueService);\n    expect(masterService.getValue()).toBe('fake value');\n  });\n\n  it('#getValue should return stubbed value from a spy', () =&gt; {\n    // create `getValue` spy on an object representing the ValueService\n    const valueServiceSpy = jasmine.createSpyObj('ValueService', ['getValue']);\n\n    // set the value to return when the `getValue` spy is called.\n    const stubValue = 'stub value';\n    valueServiceSpy.getValue.and.returnValue(stubValue);\n\n    masterService = new MasterService(valueServiceSpy);\n\n    expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue);\n    expect(valueServiceSpy.getValue.calls.count())\n      .withContext('spy method was called once')\n      .toBe(1);\n    expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue);\n  });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8mo0rk841y29ljycwdz3c7he0\">第一個測試使用 <code>new</code> 建立了一個 <code>ValueService</code>，並把它傳給了 <code>MasterService</code> 的建構式函式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dh00wa5j9i8tj1tsdmcd2ut5c\">然而，注入真實服務很難工作良好，因為大多數被依賴的服務都很難建立和控制。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"apiy38e10dvhtimfkusoxbts2\">相反，可以模擬依賴、使用仿製品，或者在相關的服務方法上<a href=\"https://jasmine.github.io/tutorials/your_first_suite#section-Spies\">建立一個測試間諜</a>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ayt6bsk0ov0qzhslnv7e0xjo\">我更喜歡用測試間諜，因為它們通常是模擬服務的最佳途徑。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"89in4zne91ap3w70mxfxq63jo\">這些標準的測試技巧非常適合對服務進行單獨測試。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"en2hegrncb618p9tk31py5gwh\">但是，你幾乎總是使用 Angular 依賴注入機制來將服務注入到應用類中，你應該有一些測試來體現這種使用模式。Angular 測試實用工具可以讓你輕鬆調查這些注入服務的行為。</p>\n<h2 id=\"testing-services-with-the-testbed\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"nrke9sl7vhf7oourys4wr46d\">使用 <em>TestBed</em> 測試服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-services-with-the-testbed\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5mn00r1184p8vroz50t9zdhx\">你的應用依靠 Angular 的<a href=\"guide/dependency-injection\">依賴注入（DI）</a>來建立服務。當服務有依賴時，DI 會查詢或建立這些被依賴的服務。如果該被依賴的服務還有自己的依賴，DI 也會查詢或建立它們。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"32owy3s0v5mc9095zq3tdrini\">作為服務的<em>消費者</em>，你不應該關心這些。你不應該關心建構式函式引數的順序或它們是如何建立的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2xrmspmzow54yhlh7spn1fri\">作為服務的<em>測試人員</em>，你至少要考慮第一層的服務依賴，但當你用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 測試實用工具來提供和建立服務時，你<em>可以</em>讓 Angular DI 來建立服務並處理建構式函式的引數順序。</p>\n<p><a id=\"testbed\"></a></p>\n<h2 id=\"angular-testbed\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51munmuq2h6lfqa2500wb1ypg\">Angular \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#angular-testbed\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5prvx5yc8e53cwl0f760ipafd\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>是 Angular 測試工具中最重要的一個。 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 建立一個動態建立的 Angular \n<em>測試</em> 模組，模擬了一個 Angular \n<a href=\"guide/ngmodules\">@NgModule</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4nkuoistl2ermwag4nu3ahqyx\"><code>TestBed.configureTestingModule()</code> 方法接受一個元資料物件，該物件可以具有大多數\n<a href=\"guide/ngmodules\">@NgModule</a>的屬性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cqytnw6gw33y9xdu7dpre6o99\">要測試某個服務，你可以在元資料屬性 <code>providers</code> 中設定一個要測試或模擬的服務陣列。</p>\n<code-example header=\"app/demo/demo.testbed.spec.ts (provide ValueService in beforeEach)\" path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-before-each\">\nlet service: ValueService;\n\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ount23d7ps19jgpxuanot8p6\">將服務類別作為引數呼叫 <code>TestBed.inject()</code>，將它注入到測試中。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9jc2tysupq9s2mtq2l04xkfq9\"><strong>注意</strong>：<br>\n<code>TestBed.get()</code> 已在 Angular 9 中棄用。為了幫助減少重大變更，Angular 引入了一個名為 <code>TestBed.inject()</code> 的新函式，你可以改用它。關於刪除 <code>TestBed.get()</code> 的訊息，請參閱<a href=\"guide/deprecations#index\">棄用索引</a>中的條目。</p>\n</div>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-it\">\nit('should use ValueService', () =&gt; {\n  service = TestBed.inject(ValueService);\n  expect(service.getValue()).toBe('real value');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4th3om6n4lvjw431y4n981nwj\">或者，如果你喜歡把這個服務作為設定程式碼的一部分進行注入，也可以在 <code>beforeEach()</code> 中做。</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-before-each\">\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n  service = TestBed.inject(ValueService);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4z8cgjvz5ruvrypj4nqyjtgtw\">測試帶依賴的服務時，需要在 <code>providers</code> 陣列中提供 mock。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2w2maamnho2eash8h1ya8oeo0\">在下面的例子中，mock 是一個間諜物件。</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-before-each\">\nlet masterService: MasterService;\nlet valueServiceSpy: jasmine.SpyObj&lt;ValueService&gt;;\n\nbeforeEach(() =&gt; {\n  const spy = jasmine.createSpyObj('ValueService', ['getValue']);\n\n  TestBed.configureTestingModule({\n    // Provide both the service-to-test and its (spy) dependency\n    providers: [MasterService, { provide: ValueService, useValue: spy }],\n  });\n  // <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> both the service-to-test and its (spy) dependency\n  masterService = TestBed.inject(MasterService);\n  valueServiceSpy = TestBed.inject(ValueService) as jasmine.SpyObj&lt;ValueService&gt;;\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a74rd5bz78usbo01mfwn1upto\">該測試會像以前一樣使用該間諜。</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-it\">\nit('#getValue should return stubbed value from a spy', () =&gt; {\n  const stubValue = 'stub value';\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n\n  expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue);\n  expect(valueServiceSpy.getValue.calls.count())\n    .withContext('spy method was called once')\n    .toBe(1);\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue);\n});\n\n</code-example>\n<p><a id=\"no-before-each\"></a></p>\n<h2 id=\"testing-without-beforeeach\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8hmp76l0ixeh50wekgin9f0l\">沒有 <code>beforeEach()</code> 的測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-without-beforeeach\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c0phsij223ydaor0voqqalz38\">本指南中的大多數測試套件都會呼叫 <code>beforeEach()</code> 來為每一個 <code>it()</code> 測試設定前置條件，並依賴 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 來建立類別和注入服務。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9lygnlvackt8bw8fym414avy2\">還有另一種測試，它們從不呼叫 <code>beforeEach()</code>，而是更喜歡顯式地建立類，而不是使用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"321ibwe3fxio8vakprsfgxmgk\">你可以用這種風格重寫 <code>MasterService</code> 中的一個測試。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xsq550pzo096tw8x0iyqqhh9\">首先，在 <em>setup</em> 函式中放入可供複用的預備程式碼，而不用 <code>beforeEach()</code>。</p>\n<code-example header=\"app/demo/demo.spec.ts (setup)\" path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup\">\nfunction setup() {\n  const valueServiceSpy = jasmine.createSpyObj('ValueService', ['getValue']);\n  const stubValue = 'stub value';\n  const masterService = new MasterService(valueServiceSpy);\n\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n  return { masterService, stubValue, valueServiceSpy };\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5nsqdtoy065szepduau034ivc\"><code>setup()</code> 函式回傳一個包含測試可能引用的變數（如 <code>masterService</code>）的物件字面量。你並沒有在 <code>describe()</code> 的函式體中定義<em>半全域</em>變數（比如 <code>let masterService: MasterService</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"au1eazpmx9pnhooctuxghzqaf\">然後，每個測試都會在第一行呼叫 <code>setup()</code>，然後繼續執行那些操縱被測主體和斷言期望值的步驟。</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-test\">\nit('#getValue should return stubbed value from a spy', () =&gt; {\n  const { masterService, stubValue, valueServiceSpy } = setup();\n  expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue);\n  expect(valueServiceSpy.getValue.calls.count())\n    .withContext('spy method was called once')\n    .toBe(1);\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"api2eqpklnaahe5ess7kl2c41\">請注意測試如何使用<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\"><em>解構賦值</em></a>來提取它需要的設定變數。</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup-call\">\nconst { masterService, stubValue, valueServiceSpy } = setup();\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aql3iah3951xogduq73aj0n6h\">許多開發人員都覺得這種方法比傳統的 <code>beforeEach()</code> 風格更清晰明瞭。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6cu65iyld4n52x33m0a9qld6i\">雖然這個測試指南遵循傳統的樣式，並且預設的<a href=\"https://github.com/angular/angular-cli\">CLI 原理圖</a>會生成帶有 <code>beforeEach()</code> 和 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的測試檔案，但你可以在自己的專案中採用<em>這種替代方式</em>。</p>\n<h2 id=\"testing-http-services\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8np8ctrbx57ylxl7502b5csrq\">測試 HTTP 服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-http-services\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4a9ne4snja0kzv8q4bfunngml\">向遠端伺服器發起 HTTP 呼叫的資料服務通常會注入並委託給 Angular 的\n<a href=\"guide/http-test-requests\"><code>HttpClient</code></a>服務進行 XHR 呼叫。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aerptm1j9rtmqi4ij0o8ilpiv\">你可以測試一個注入了 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 間諜的資料服務，就像測試所有帶依賴的服務一樣。</p>\n<code-example header=\"app/model/hero.service.spec.ts (tests with spies)\" path=\"testing/src/app/model/hero.service.spec.ts\" region=\"test-with-spies\">\nlet httpClientSpy: jasmine.SpyObj&lt;<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>&gt;;\nlet heroService: HeroService;\n\nbeforeEach(() =&gt; {\n  // TODO: spy on other methods too\n  httpClientSpy = jasmine.createSpyObj('<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>', ['get']);\n  heroService = new HeroService(httpClientSpy);\n});\n\nit('should return expected heroes (<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> called once)', (done: DoneFn) =&gt; {\n  const expectedHeroes: Hero[] = [\n    { id: 1, name: 'A' },\n    { id: 2, name: 'B' },\n  ];\n\n  httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));\n\n  heroService.getHeroes().subscribe({\n    next: (heroes) =&gt; {\n      expect(heroes).withContext('expected heroes').toEqual(expectedHeroes);\n      done();\n    },\n    error: done.fail,\n  });\n  expect(httpClientSpy.get.calls.count()).withContext('one call').toBe(1);\n});\n\nit('should return an error when the server returns a 404', (done: DoneFn) =&gt; {\n  const errorResponse = new <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>({\n    error: 'test 404 error',\n    status: 404,\n    statusText: 'Not Found',\n  });\n\n  httpClientSpy.get.and.returnValue(asyncError(errorResponse));\n\n  heroService.getHeroes().subscribe({\n    next: (heroes) =&gt; done.fail('expected an error, not heroes'),\n    error: (error) =&gt; {\n      expect(error.message).toContain('test 404 error');\n      done();\n    },\n  });\n});\n\n</code-example>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76o3v4700h4o4o1q4zom51scs\"><code>HeroService</code> 方法會回傳 <code>Observables</code>。你必須<em>訂閱</em>一個可觀察物件（a）讓它執行，（b）斷言該方法成功或失敗。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6llv84iojyvbxidelw3fz74b7\"><code>subscribe()</code> 方法會接受成功（<code>next</code>）和失敗（<code>error</code>）回呼。確保你會同時提供<em>這兩個</em>回呼函式，以便捕獲錯誤。如果不這樣做就會產生一個非同步的、沒有被捕獲的可觀察物件的錯誤，測試執行器可能會把它歸因於一個完全不相關的測試。</p>\n</div>\n<h2 id=\"httpclienttestingmodule\"><code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#httpclienttestingmodule\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayt10m1ihlz2l7ampra6e0l5i\">資料服務和 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 之間的擴充套件互動可能比較複雜，並且難以透過間諜進行模擬。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9rqzs5plp4z02ukvw4tve4u5u\"><code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> 可以讓這些測試場景更易於管理。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1kuvpmjaebjp12pn18ysish91\">雖然本指南附帶的\n<em>程式碼範例</em>示範了\n<code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code>，但本頁參考\n<a href=\"guide/http-test-requests\">Http 指南</a>，其中詳細介紹瞭如何使用\n<code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code>進行測試。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/testing\n - guide/testing-components-basics\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpErrorResponse\n - api/common/http/testing/HttpClientTestingModule\n - api/core/Inject\n - api/core/Injectable\n - api/core/testing/TestBed\n - guide/dependency-injection\n - guide/deprecations#index\n - guide/http-test-requests\n - guide/ngmodules\n - guide/testing-services#angular-testbed\n - guide/testing-services#httpclienttestingmodule\n - guide/testing-services#services-with-dependencies\n - guide/testing-services#testing-http-services\n - guide/testing-services#testing-services\n - guide/testing-services#testing-services-with-the-testbed\n - guide/testing-services#testing-without-beforeeach\n - https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\n - https://github.com/angular/angular-cli\n - https://jasmine.github.io/tutorials/your_first_suite#section-Spies\n-->"}