{"id":"guide/testing-services","title":"测试服务","contents":"<div class=\"content\">\n  <h1 id=\"testing-services\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"chimgir564h319oeuoiq25652\">测试服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-services\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a84796annz6q64lxtl1l3s702\">为了检查你的服务是否正常工作，你可以专门为它们编写测试。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jhe3g7pull8hzqtm08p46wf0\">如果你要试验本指南中所讲的应用，请<live-example name=\"testing\" nodownload=\"\">在浏览器中运行它</live-example>或<live-example name=\"testing\" downloadonly=\"\">下载并在本地运行它</live-example>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"53qikwqhd0f92oa21yajynco4\">服务往往是最容易进行单元测试的文件。下面是一些针对 <code>ValueService</code> 的同步和异步单元测试，甚至不需要 Angular 测试工具的帮助。</p>\n<code-example header=\"app/demo/demo.spec.ts\" path=\"testing/src/app/demo/demo.spec.ts\" region=\"ValueService\">\n// Straight Jasmine testing without Angular's testing support\ndescribe('ValueService', () =&gt; {\n  let service: ValueService;\n  beforeEach(() =&gt; {\n    service = new ValueService();\n  });\n\n  it('#getValue should return real value', () =&gt; {\n    expect(service.getValue()).toBe('real value');\n  });\n\n  it('#getObservableValue should return value from observable', (done: DoneFn) =&gt; {\n    service.getObservableValue().subscribe((value) =&gt; {\n      expect(value).toBe('observable value');\n      done();\n    });\n  });\n\n  it('#getPromiseValue should return value from a promise', (done: DoneFn) =&gt; {\n    service.getPromiseValue().then((value) =&gt; {\n      expect(value).toBe('promise value');\n      done();\n    });\n  });\n});\n\n</code-example>\n<p><a id=\"services-with-dependencies\"></a></p>\n<h2 id=\"services-with-dependencies\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"822bp8h8cqw5y49v2v7at3y3t\">有依赖的服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#services-with-dependencies\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"co7oivmx6lao9k8kbqbzgk3rv\">服务通常依赖于 Angular 在构造函数中注入的其它服务。在很多情况下，调用服务的构造函数时，很容易手动创建和<em>注入</em>这些依赖。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5e61ib8ge8d0nv26t9l7snckp\"><code>MasterService</code> 就是一个简单的例子：</p>\n<code-example header=\"app/demo/demo.ts\" path=\"testing/src/app/demo/demo.ts\" region=\"MasterService\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class MasterService {\n  constructor(private valueService: ValueService) {}\n  getValue() {\n    return this.valueService.getValue();\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e732jzduwt4khk20izg6rrvn4\"><code>MasterService</code> 只把它唯一的方法 <code>getValue</code> 委托给了所注入的 <code>ValueService</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ggnkn8lmdqms3j9gc1yxlife\">这里有几种测试方法。</p>\n<code-example header=\"app/demo/demo.spec.ts\" path=\"testing/src/app/demo/demo.spec.ts\" region=\"MasterService\">\ndescribe('MasterService without Angular testing support', () =&gt; {\n  let masterService: MasterService;\n\n  it('#getValue should return real value from the real service', () =&gt; {\n    masterService = new MasterService(new ValueService());\n    expect(masterService.getValue()).toBe('real value');\n  });\n\n  it('#getValue should return faked value from a fakeService', () =&gt; {\n    masterService = new MasterService(new FakeValueService());\n    expect(masterService.getValue()).toBe('faked service value');\n  });\n\n  it('#getValue should return faked value from a fake object', () =&gt; {\n    const fake = { getValue: () =&gt; 'fake value' };\n    masterService = new MasterService(fake as ValueService);\n    expect(masterService.getValue()).toBe('fake value');\n  });\n\n  it('#getValue should return stubbed value from a spy', () =&gt; {\n    // create `getValue` spy on an object representing the ValueService\n    const valueServiceSpy = jasmine.createSpyObj('ValueService', ['getValue']);\n\n    // set the value to return when the `getValue` spy is called.\n    const stubValue = 'stub value';\n    valueServiceSpy.getValue.and.returnValue(stubValue);\n\n    masterService = new MasterService(valueServiceSpy);\n\n    expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue);\n    expect(valueServiceSpy.getValue.calls.count())\n      .withContext('spy method was called once')\n      .toBe(1);\n    expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue);\n  });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8mo0rk841y29ljycwdz3c7he0\">第一个测试使用 <code>new</code> 创建了一个 <code>ValueService</code>，并把它传给了 <code>MasterService</code> 的构造函数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dh00wa5j9i8tj1tsdmcd2ut5c\">然而，注入真实服务很难工作良好，因为大多数被依赖的服务都很难创建和控制。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"apiy38e10dvhtimfkusoxbts2\">相反，可以模拟依赖、使用仿制品，或者在相关的服务方法上<a href=\"https://jasmine.github.io/tutorials/your_first_suite#section-Spies\">创建一个测试间谍</a>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ayt6bsk0ov0qzhslnv7e0xjo\">我更喜欢用测试间谍，因为它们通常是模拟服务的最佳途径。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"89in4zne91ap3w70mxfxq63jo\">这些标准的测试技巧非常适合对服务进行单独测试。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"en2hegrncb618p9tk31py5gwh\">但是，你几乎总是使用 Angular 依赖注入机制来将服务注入到应用类中，你应该有一些测试来体现这种使用模式。Angular 测试实用工具可以让你轻松调查这些注入服务的行为。</p>\n<h2 id=\"testing-services-with-the-testbed\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"nrke9sl7vhf7oourys4wr46d\">使用 <em>TestBed</em> 测试服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-services-with-the-testbed\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5mn00r1184p8vroz50t9zdhx\">你的应用依靠 Angular 的<a href=\"guide/dependency-injection\">依赖注入（DI）</a>来创建服务。当服务有依赖时，DI 会查找或创建这些被依赖的服务。如果该被依赖的服务还有自己的依赖，DI 也会查找或创建它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"32owy3s0v5mc9095zq3tdrini\">作为服务的<em>消费者</em>，你不应该关心这些。你不应该关心构造函数参数的顺序或它们是如何创建的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2xrmspmzow54yhlh7spn1fri\">作为服务的<em>测试人员</em>，你至少要考虑第一层的服务依赖，但当你用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 测试实用工具来提供和创建服务时，你<em>可以</em>让 Angular DI 来创建服务并处理构造函数的参数顺序。</p>\n<p><a id=\"testbed\"></a></p>\n<h2 id=\"angular-testbed\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51munmuq2h6lfqa2500wb1ypg\">Angular \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#angular-testbed\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5prvx5yc8e53cwl0f760ipafd\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>是 Angular 测试工具中最重要的一个。 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 创建一个动态构建的 Angular \n<em>测试</em> 模块，模拟了一个 Angular \n<a href=\"guide/ngmodules\">@NgModule</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4nkuoistl2ermwag4nu3ahqyx\"><code>TestBed.configureTestingModule()</code> 方法接受一个元数据对象，该对象可以具有大多数\n<a href=\"guide/ngmodules\">@NgModule</a>的属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cqytnw6gw33y9xdu7dpre6o99\">要测试某个服务，你可以在元数据属性 <code>providers</code> 中设置一个要测试或模拟的服务数组。</p>\n<code-example header=\"app/demo/demo.testbed.spec.ts (provide ValueService in beforeEach)\" path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-before-each\">\nlet service: ValueService;\n\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ount23d7ps19jgpxuanot8p6\">将服务类作为参数调用 <code>TestBed.inject()</code>，将它注入到测试中。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9jc2tysupq9s2mtq2l04xkfq9\"><strong>注意</strong>：<br>\n<code>TestBed.get()</code> 已在 Angular 9 中弃用。为了帮助减少重大变更，Angular 引入了一个名为 <code>TestBed.inject()</code> 的新函数，你可以改用它。关于删除 <code>TestBed.get()</code> 的信息，请参阅<a href=\"guide/deprecations#index\">弃用索引</a>中的条目。</p>\n</div>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-it\">\nit('should use ValueService', () =&gt; {\n  service = TestBed.inject(ValueService);\n  expect(service.getValue()).toBe('real value');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4th3om6n4lvjw431y4n981nwj\">或者，如果你喜欢把这个服务作为设置代码的一部分进行注入，也可以在 <code>beforeEach()</code> 中做。</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-before-each\">\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n  service = TestBed.inject(ValueService);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4z8cgjvz5ruvrypj4nqyjtgtw\">测试带依赖的服务时，需要在 <code>providers</code> 数组中提供 mock。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2w2maamnho2eash8h1ya8oeo0\">在下面的例子中，mock 是一个间谍对象。</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-before-each\">\nlet masterService: MasterService;\nlet valueServiceSpy: jasmine.SpyObj&lt;ValueService&gt;;\n\nbeforeEach(() =&gt; {\n  const spy = jasmine.createSpyObj('ValueService', ['getValue']);\n\n  TestBed.configureTestingModule({\n    // Provide both the service-to-test and its (spy) dependency\n    providers: [MasterService, { provide: ValueService, useValue: spy }],\n  });\n  // <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> both the service-to-test and its (spy) dependency\n  masterService = TestBed.inject(MasterService);\n  valueServiceSpy = TestBed.inject(ValueService) as jasmine.SpyObj&lt;ValueService&gt;;\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a74rd5bz78usbo01mfwn1upto\">该测试会像以前一样使用该间谍。</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-it\">\nit('#getValue should return stubbed value from a spy', () =&gt; {\n  const stubValue = 'stub value';\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n\n  expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue);\n  expect(valueServiceSpy.getValue.calls.count())\n    .withContext('spy method was called once')\n    .toBe(1);\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue);\n});\n\n</code-example>\n<p><a id=\"no-before-each\"></a></p>\n<h2 id=\"testing-without-beforeeach\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8hmp76l0ixeh50wekgin9f0l\">没有 <code>beforeEach()</code> 的测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-without-beforeeach\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c0phsij223ydaor0voqqalz38\">本指南中的大多数测试套件都会调用 <code>beforeEach()</code> 来为每一个 <code>it()</code> 测试设置前置条件，并依赖 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 来创建类和注入服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9lygnlvackt8bw8fym414avy2\">还有另一种测试，它们从不调用 <code>beforeEach()</code>，而是更喜欢显式地创建类，而不是使用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"321ibwe3fxio8vakprsfgxmgk\">你可以用这种风格重写 <code>MasterService</code> 中的一个测试。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xsq550pzo096tw8x0iyqqhh9\">首先，在 <em>setup</em> 函数中放入可供复用的预备代码，而不用 <code>beforeEach()</code>。</p>\n<code-example header=\"app/demo/demo.spec.ts (setup)\" path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup\">\nfunction setup() {\n  const valueServiceSpy = jasmine.createSpyObj('ValueService', ['getValue']);\n  const stubValue = 'stub value';\n  const masterService = new MasterService(valueServiceSpy);\n\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n  return { masterService, stubValue, valueServiceSpy };\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5nsqdtoy065szepduau034ivc\"><code>setup()</code> 函数返回一个包含测试可能引用的变量（如 <code>masterService</code>）的对象字面量。你并没有在 <code>describe()</code> 的函数体中定义<em>半全局</em>变量（比如 <code>let masterService: MasterService</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"au1eazpmx9pnhooctuxghzqaf\">然后，每个测试都会在第一行调用 <code>setup()</code>，然后继续执行那些操纵被测主体和断言期望值的步骤。</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-test\">\nit('#getValue should return stubbed value from a spy', () =&gt; {\n  const { masterService, stubValue, valueServiceSpy } = setup();\n  expect(masterService.getValue()).withContext('service returned stub value').toBe(stubValue);\n  expect(valueServiceSpy.getValue.calls.count())\n    .withContext('spy method was called once')\n    .toBe(1);\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue).toBe(stubValue);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"api2eqpklnaahe5ess7kl2c41\">请注意测试如何使用<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\"><em>解构赋值</em></a>来提取它需要的设置变量。</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup-call\">\nconst { masterService, stubValue, valueServiceSpy } = setup();\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aql3iah3951xogduq73aj0n6h\">许多开发人员都觉得这种方法比传统的 <code>beforeEach()</code> 风格更清晰明了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6cu65iyld4n52x33m0a9qld6i\">虽然这个测试指南遵循传统的样式，并且默认的<a href=\"https://github.com/angular/angular-cli\">CLI 原理图</a>会生成带有 <code>beforeEach()</code> 和 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的测试文件，但你可以在自己的项目中采用<em>这种替代方式</em>。</p>\n<h2 id=\"testing-http-services\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8np8ctrbx57ylxl7502b5csrq\">测试 HTTP 服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-http-services\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4a9ne4snja0kzv8q4bfunngml\">向远程服务器发起 HTTP 调用的数据服务通常会注入并委托给 Angular 的\n<a href=\"guide/http-test-requests\"><code>HttpClient</code></a>服务进行 XHR 调用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aerptm1j9rtmqi4ij0o8ilpiv\">你可以测试一个注入了 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 间谍的数据服务，就像测试所有带依赖的服务一样。</p>\n<code-example header=\"app/model/hero.service.spec.ts (tests with spies)\" path=\"testing/src/app/model/hero.service.spec.ts\" region=\"test-with-spies\">\nlet httpClientSpy: jasmine.SpyObj&lt;<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>&gt;;\nlet heroService: HeroService;\n\nbeforeEach(() =&gt; {\n  // TODO: spy on other methods too\n  httpClientSpy = jasmine.createSpyObj('<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>', ['get']);\n  heroService = new HeroService(httpClientSpy);\n});\n\nit('should return expected heroes (<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> called once)', (done: DoneFn) =&gt; {\n  const expectedHeroes: Hero[] = [\n    { id: 1, name: 'A' },\n    { id: 2, name: 'B' },\n  ];\n\n  httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));\n\n  heroService.getHeroes().subscribe({\n    next: (heroes) =&gt; {\n      expect(heroes).withContext('expected heroes').toEqual(expectedHeroes);\n      done();\n    },\n    error: done.fail,\n  });\n  expect(httpClientSpy.get.calls.count()).withContext('one call').toBe(1);\n});\n\nit('should return an error when the server returns a 404', (done: DoneFn) =&gt; {\n  const errorResponse = new <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>({\n    error: 'test 404 error',\n    status: 404,\n    statusText: 'Not Found',\n  });\n\n  httpClientSpy.get.and.returnValue(asyncError(errorResponse));\n\n  heroService.getHeroes().subscribe({\n    next: (heroes) =&gt; done.fail('expected an error, not heroes'),\n    error: (error) =&gt; {\n      expect(error.message).toContain('test 404 error');\n      done();\n    },\n  });\n});\n\n</code-example>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76o3v4700h4o4o1q4zom51scs\"><code>HeroService</code> 方法会返回 <code>Observables</code>。你必须<em>订阅</em>一个可观察对象（a）让它执行，（b）断言该方法成功或失败。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6llv84iojyvbxidelw3fz74b7\"><code>subscribe()</code> 方法会接受成功（<code>next</code>）和失败（<code>error</code>）回调。确保你会同时提供<em>这两个</em>回调函数，以便捕获错误。如果不这样做就会产生一个异步的、没有被捕获的可观察对象的错误，测试运行器可能会把它归因于一个完全不相关的测试。</p>\n</div>\n<h2 id=\"httpclienttestingmodule\"><code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#httpclienttestingmodule\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayt10m1ihlz2l7ampra6e0l5i\">数据服务和 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 之间的扩展交互可能比较复杂，并且难以通过间谍进行模拟。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9rqzs5plp4z02ukvw4tve4u5u\"><code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> 可以让这些测试场景更易于管理。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1kuvpmjaebjp12pn18ysish91\">虽然本指南附带的\n<em>代码示例</em>演示了\n<code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code>，但本页参考\n<a href=\"guide/http-test-requests\">Http 指南</a>，其中详细介绍了如何使用\n<code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code>进行测试。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/testing\n - guide/testing-components-basics\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpErrorResponse\n - api/common/http/testing/HttpClientTestingModule\n - api/core/Inject\n - api/core/Injectable\n - api/core/testing/TestBed\n - guide/dependency-injection\n - guide/deprecations#index\n - guide/http-test-requests\n - guide/ngmodules\n - guide/testing-services#angular-testbed\n - guide/testing-services#httpclienttestingmodule\n - guide/testing-services#services-with-dependencies\n - guide/testing-services#testing-http-services\n - guide/testing-services#testing-services\n - guide/testing-services#testing-services-with-the-testbed\n - guide/testing-services#testing-without-beforeeach\n - https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\n - https://github.com/angular/angular-cli\n - https://jasmine.github.io/tutorials/your_first_suite#section-Spies\n-->"}