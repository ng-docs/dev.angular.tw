{"id":"guide/lifecycle-hooks","title":"组件的生命周期","contents":"<div class=\"content\">\n  <h1 id=\"component-lifecycle\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7g5hf0fg0q0hx9vnyvcduoict\">组件的生命周期<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#component-lifecycle\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wfcckhu81zlchlgkk0kyr29g\">当 Angular 实例化组件类并渲染组件视图及其子视图时，组件实例的生命周期就开始了。生命周期一直伴随着变更检测，Angular 会检查数据绑定属性何时发生变化，并按需更新视图和组件实例。当 Angular 销毁组件实例并从 DOM 中移除它渲染的模板时，生命周期就结束了。当 Angular 在执行过程中创建、更新和销毁实例时，指令就有了类似的生命周期。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6pxd2x5tv70hvd1p6si3lechp\">你的应用可以使用<a href=\"guide/glossary#lifecycle-hook\" title=\"生命周期钩子的定义\">生命周期钩子方法</a>来触发组件或指令生命周期中的关键事件，以初始化新实例，需要时启动变更检测，在变更检测过程中响应更新，并在删除实例之前进行清理。</p>\n<h2 id=\"prerequisites\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e44b21uig1fakj5vcfuvz1bdu\">前提条件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#prerequisites\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7g00f4jbt1swncxxo5d58oi1d\">在使用生命周期钩子之前，你应该对这些内容有一个基本的了解：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4kxg9gf8rteais2gfxshcfbnk\"><a href=\"https://www.typescriptlang.org\">TypeScript 编程</a></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e8kyykihcbhps1v0kmxmfi5fn\">Angular 应用设计基础，就像 <a href=\"guide/architecture\" title=\"基础应用设计概念简介\">Angular 的基本概念</a>中所讲的那样</li>\n</ul>\n<p><a id=\"hooks-overview\"></a></p>\n<h2 id=\"responding-to-lifecycle-events\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b8ctc2hy0ncwxbriyaqibhsej\">响应生命周期事件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#responding-to-lifecycle-events\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8n9nasj9ps2di2w43h1fodzt4\">可以通过实现一个或多个 Angular <code>core</code> 库中定义的<em>生命周期钩子</em>接口来响应组件或指令生命周期中的事件。这些钩子让你有机会在适当的时候对组件或指令实例进行操作，比如 Angular 创建、更新或销毁这个实例时。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e1y5gom73mx720r0yjo9ti36c\">每个接口都有唯一的一个钩子方法，它们的名字是由接口名再加上 <code>ng</code> 前缀构成的。比如，<code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code> 接口的钩子方法叫做 <code>ngOnInit()</code>。如果你在组件或指令类中实现了这个方法，Angular 就会在首次检查完组件或指令的输入属性后，紧接着调用它。</p>\n<code-example header=\"peek-a-boo.directive.ts (excerpt)\" path=\"lifecycle-hooks/src/app/peek-a-boo.directive.ts\" region=\"ngOnInit\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[appPeekABoo]'})\nexport class PeekABooDirective implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private logger: LoggerService) { }\n\n  // implement <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>'s `ngOnInit` method\n  ngOnInit() {\n    this.logIt('<a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>');\n  }\n\n  logIt(msg: string) {\n    this.logger.log(`#${nextId++} ${msg}`);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59dq14yow704f5uo9to33g7hk\">你不必实现所有生命周期钩子，只要实现你需要的那些就可以了。</p>\n<p><a id=\"hooks-purpose-timing\"></a></p>\n<h3 id=\"lifecycle-event-sequence\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d4ry624uhegkrysxou9nrerjv\">生命周期的顺序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#lifecycle-event-sequence\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amdcljoqaao55bhsqhatzt05i\">当你的应用通过调用构造函数来实例化一个组件或指令时，Angular 就会调用那个在该实例生命周期的适当位置实现了的那些钩子方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vjf2u2aaogiw86gw6d7p965u\">Angular 会按以下顺序执行钩子方法。可以用它来执行以下类型的操作。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7meayzvxwosvigobkjnd9pbez\">钩子方法</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"297niinze7mn1fnajtyjcs0tb\">目的</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cj7znh1id1lxn0eajb87upoqv\">时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>ngOnChanges()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1t7gpladr3tl57y1ovzvd636x\">在 Angular 设置或重置数据绑定的输入属性时做出响应。该方法接收一个当前和先前属性值的 \n<code><a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a></code> 对象。\n<br>\n<div class=\"alert is-helpful\"> \n <strong>注意</strong>:\n <br> 这经常发生，因此这里执行的任何操作都会显著影响性能。 \n</div> 详细信息请参阅本文档中的 \n<a href=\"guide/lifecycle-hooks#onchanges\">使用变更检测钩子</a>。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"k9teek447tb27mmajmt9hm7f\">在组件存在绑定输入时，或者一个或多个数据绑定的输入属性发生变化时调用。 \n<br>\n<div class=\"alert is-helpful\"> \n <strong>注意</strong>:\n <br> 如果你的组件没有输入，或者在不提供任何输入的情况下使用它，框架将不会调用 \n <code>ngOnChanges()</code>。 \n</div></td>\n</tr>\n<tr>\n<td align=\"left\"><code>ngOnInit()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4dmimkopqecakh93x4bgpudhu\">在 Angular 首次显示数据绑定属性并设置指令或组件的输入属性后初始化指令或组件。 详细信息请参阅本文档中的 \n<a href=\"guide/lifecycle-hooks#oninit\">初始化组件或指令</a>。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"r3z0bbamm2zitrr2ul86y78b\">在第一次 \n<code>ngOnChanges()</code> 之后调用一次。 即使在没有模板绑定输入的情况下仍会调用 \n<code>ngOnInit()</code>（当没有模板绑定输入时）。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ngDoCheck()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rikwyzvg5x9e5w40f8nt67rn\">检测并处理 Angular 无法或不会自行检测的更改。 详细信息和示例请参阅本文档中的 \n<a href=\"guide/lifecycle-hooks#docheck\">定义自定义变更检测</a>。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3vqqkpm7ax2jyglaxs79wb6yk\">在每次变更检测运行后立即在每次变更检测运行后调用 \n<code>ngOnChanges()</code> 之后立即调用一次。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ngAfterContentInit()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e1o9uwean4rk83y72nvnz4fbp\">在 Angular 投影外部内容到组件的视图或指令所在的视图后做出响应。 详细信息和示例请参阅本文档中的 \n<a href=\"guide/lifecycle-hooks#aftercontent\">响应内容变更</a>。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"98e609nnql62cn1v3zo9c41m\">在第一次 \n<code>ngDoCheck()</code> 之后调用一次。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ngAfterContentChecked()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yvsaefptunc6mdcgf9iqfq6w\">在 Angular 检查投影到指令或组件的内容后做出响应。 详细信息和示例请参阅本文档中的 \n<a href=\"guide/lifecycle-hooks#aftercontent\">响应投影内容变更</a>。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7di49ouxzhbp6y588dsj7ty07\">在 \n<code>ngAfterContentInit()</code> 和每次 \n<code>ngDoCheck()</code> 之后调用。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ngAfterViewInit()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4n9pmaesrqb0vq5btijuz6fwb\">在 Angular 初始化组件的视图和子视图，或包含指令的视图后做出响应。 详细信息和示例请参阅本文档中的 \n<a href=\"guide/lifecycle-hooks#afterview\">响应视图变更</a>。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"emk5qvdenhbuquzuj31hh87yb\">在第一次 \n<code>ngAfterContentChecked()</code> 之后调用一次。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ngAfterViewChecked()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"g1mx4ykopolhlya7xr3nfb4m\">在 Angular 检查组件的视图和子视图，或包含该指令的视图后作出响应。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b1oc13yqiuak53alkjhf9ehue\">在 \n<code>ngAfterViewInit()</code> 之后以及每次 \n<code>ngAfterContentChecked()</code> 之后调用。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ngOnDestroy()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"15n05ugv58exvtpen8kexsv4k\">在 Angular 销毁指令或组件之前进行清理。取消订阅 Observables 和分离事件处理程序以避免内存泄漏。请参阅本文档中的\n<a href=\"guide/lifecycle-hooks#ondestroy\">实例销毁时的清理</a>以了解详细信息。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"13z1f8wrdkpebtr1nc3myil7f\">在 Angular 销毁指令或组件之前立即调用。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"the-sample\"></a></p>\n<h3 id=\"lifecycle-example-set\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"sn8ut5w7x12xuvnmu0cvpt1y\">生命周期范例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#lifecycle-example-set\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehmer0yqa5t1wtb0ny9u6s94s\"><live-example></live-example>通过在受控于根组件 <code>AppComponent</code> 的一些组件上进行的一系列练习，演示了生命周期钩子的运作方式。\n每一个例子中，<em>父</em>组件都扮演了<em>子</em>组件测试台的角色，以展示出一个或多个生命周期钩子方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccmqoky8tllt46i33bechu9rw\">下表列出了这些练习及其简介。范例代码也用来阐明后续各节的一些特定任务。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2n8tguxhs6hbmqbwyqfclvff1\">组件</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c6b4dqji8g3couz8zosakqqgk\"><a href=\"guide/lifecycle-hooks#peek-a-boo\">Peek-a-boo</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"573ungzuy0a53pfyam6t1mxgc\">演示每个生命周期钩子。每个钩子方法都会写入到屏幕日志中。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2he98cfkkhpq2ct49j5t3knjp\"><a href=\"guide/lifecycle-hooks#spy\">Spy</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1yj71ukmqemwgxlzuouezgrdn\">展示如何使用自定义指令与生命周期钩子。 \n<code>SpyDirective</code> 实现了 \n<code>ngOnInit()</code> 和 \n<code>ngOnDestroy()</code> 钩子，并使用它们来监视并报告元素何时进入或退出当前视图。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"guide/lifecycle-hooks#onchanges\">OnChanges</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xebydcjqegxp14hatxs37gja\">演示 Angular 如何在每次组件输入属性发生变化时调用 \n<code>ngOnChanges()</code> 钩子，并展示如何解释传递给钩子方法的 \n<code>changes</code> 对象。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"guide/lifecycle-hooks#docheck\">DoCheck</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8na6xzebxtkjoy69qoyyzgcwt\">使用自定义变更检测实现 \n<code>ngDoCheck()</code> 方法。观察钩子将变更记录到日志中，以查看 Angular 调用此钩子的频率。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"guide/lifecycle-hooks#afterview\">AfterView</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"achn29ramtpho23cnw1mr22r9\">展示 Angular 所谓的 \n<a href=\"guide/glossary#view\" title=\"视图的定义\">视图</a>。演示了 \n<code>ngAfterViewInit()</code> 和 \n<code>ngAfterViewChecked()</code> 钩子。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"guide/lifecycle-hooks#aftercontent\">AfterContent</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dy1qima15qbhly9t14h2rhc62\">展示如何将外部内容投影到组件中，并如何区分投影内容和组件的视图子元素。演示了 \n<code>ngAfterContentInit()</code> 和 \n<code>ngAfterContentChecked()</code> 钩子。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9bxzrkke6h921x8z30wajz5bl\"><a href=\"guide/lifecycle-hooks#counter\">Counter</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"966t3a4220w76lwy8luareuyo\">演示组件和指令的组合，每个都有自己的钩子。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"oninit\"></a></p>\n<h2 id=\"initializing-a-component-or-directive\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24w9cjili1yxbl8qihu75k9gj\">初始化组件或指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#initializing-a-component-or-directive\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6mzvukois96kw0bxq0v58pd49\">使用 <code>ngOnInit()</code> 方法执行以下初始化任务。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhrozcakggm6j1qyljz22xrm7\">初始化任务</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"705czlpv28ckkp80bqwl79d58\">在构造函数之外执行复杂的初始化操作</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3gte906cb9xacbls6lci9oyhb\">组件应该便宜且安全地构造。例如，不应在组件构造函数中获取数据。不必担心新组件在测试时或在决定显示之前尝试联系远程服务器。 \n<br> \n<code>ngOnInit()</code> 是组件获取初始数据的好地方。例如，请参阅 \n<a href=\"tutorial/tour-of-heroes/toh-pt4#oninit\">英雄之旅教程</a>。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5364fbm7h2fgji17nb4xnu35a\">在 Angular 设置输入属性后设置组件</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"388itl276614422y5t36do6vx\">构造函数应该只设置初始本地变量为简单值。 \n<br> 请记住，指令的数据绑定输入属性直到\n<strong>构造后</strong>才设置。如果需要根据这些属性初始化指令，请在 \n<code>ngOnInit()</code> 运行时设置它们。 \n<div class=\"alert is-helpful\"> \n <code>ngOnChanges()</code> 方法是访问这些属性的第一个机会。Angular 在调用 \n <code>ngOnInit()</code> 之前调用 \n <code>ngOnChanges()</code>，之后也多次调用。它只调用 \n <code>ngOnInit()</code> 一次。\n</div></td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"ondestroy\"></a></p>\n<h2 id=\"cleaning-up-on-instance-destruction\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8eq74guq569ejg2gl244gcu75\">在实例销毁时进行清理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#cleaning-up-on-instance-destruction\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayfy65ojzaumant3pq97ca7nu\">Angular 提供了几种方法以便在实例被销毁时进行清理。</p>\n<h3 id=\"ngondestroy\"><code>ngOnDestroy</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#ngondestroy\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"229regly2pmxh3zpcd6969tln\">你可以把清理逻辑放进 <code>ngOnDestroy()</code> 中，这个逻辑就必然会在 Angular 销毁该指令之前运行。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9stsqv51iu9x8mfsp1jqgvbu0\">这里是释放资源的地方，这些资源不会自动被垃圾回收。如果你不这样做，就存在内存泄漏的风险。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ctk7u96f0pzeu2qnnggoalspx\">取消订阅可观察对象和 DOM 事件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9c4e3yf6yzf0d2nzfzo1l84wi\">停止 interval 计时器。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"85j72sl06b1koz90ifhbo5jx9\">反注册该指令在全局或应用服务中注册过的所有回调。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f2warbxie6mflmnj097bi8kql\"><code>ngOnDestroy()</code> 方法也可以用来通知应用程序的其它部分，该组件即将消失。</p>\n<h3 id=\"destroyref\">DestroyRef<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#destroyref\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44afjldyf0zt3cimjvp763g9h\">除了 \n<code>ngOnDestroy()</code> 之外，你还可以注入 Angular 的 \n<code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code> 并注册回调函数以在封闭上下文被销毁时调用。这对于构建需要清理的可重用工具非常有用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"79d32vafbr4xf96yn9eryy3gp\">使用 <code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code> 注册回调：</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>(...)\nclass Counter {\n  count = 0;\n  constructor() {\n    // Start a timer to increment the counter every second.\n    const id = setInterval(() =&gt; this.count++, 1000);\n\n    // Stop the timer when the component is destroyed.\n    const destroyRef = inject(<a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a>);\n    destroyRef.onDestroy(() =&gt; clearInterval(id));\n  }\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9goltcp9pupqllug20g0p2f6u\">与 <code>ngOnDestroy</code> 一样，<code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code> 可以在任何 Angular 服务、指令、组件或管道中使用。</p>\n<h3 id=\"takeuntildestroyed\"><code><a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#takeuntildestroyed\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bg0rg3s63hjyqrd8riyljyj8r\"><code><a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a></code> 函数已经提供了<a href=\"/guide/releases#developer-preview\">开发者预览版</a>。你已经可以尝试使用了，但在稳定之前可能会发生变化。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aav8skvu4s0jftgt0e8gz88te\">在组件或指令中使用 RxJS Observables 时，你可能希望在组件或指令被销毁时完成（complete）任何可观察对象。Angular 的 <code>@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a></code> 包提供了一个操作符 <code><a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a></code> 来简化这个常见任务：</p>\n<code-example language=\"ts\">\ndata$ = http.get('...').pipe(<a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a>());\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"25zejapbe3q14razvq3at1u2f\">默认情况下，必须在\n<strong>注入上下文</strong>中调用\n<code><a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a></code>，以便它可以访问\n<code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code>。如果没有可用的注入上下文，你可以显式提供一个\n<code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code>。</p>\n<h2 id=\"reading-and-writing-the-dom\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d4jk2eiprxn5ulq33puutc40e\">读取和写入 DOM<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#reading-and-writing-the-dom\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"clnf3uz9ynmfwudtpm4m53v7i\">有时需要使用仅限浏览器的 API 手动读取或写入 DOM。这可以在上述\n<a href=\"guide/lifecycle-hooks#lifecycle-event-sequence\">生命周期事件</a>中进行挑战，因为它们将在\n<a href=\"guide/glossary#server-side-rendering\">服务器端渲染和预渲染</a>期间运行。为此，Angular 提供了\n<code><a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a></code>和\n<code><a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a></code>。这些函数可以无条件使用，但只对浏览器产生影响。这两个函数都接受一个回调函数，在下一个\n<a href=\"/guide/glossary#change-detection\">变更检测</a>周期（包括任何嵌套周期）完成后运行。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3juj388t6quzlt7txiixfmher\"><code><a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a></code>和\n<code><a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a></code>可用于\n<a href=\"/guide/releases#developer-preview\">开发者预览</a>。它们已准备好供您尝试，但在稳定之前可能会发生变化。</p>\n</div>\n<table>\n<thead>\n<tr>\n<th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7y4o0j30ltpz4br769esy6uld\">函数</th>\n<th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"297niinze7mn1fnajtyjcs0tb\">目的</th>\n<th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cj7znh1id1lxn0eajb87upoqv\">时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code><a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a></code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51xu7s6q1ubp75qnlrkhxl53c\">执行一次性初始化，或观察 DOM 的单个特定更改。\n<br> \n<div class=\"alert is-helpful\">\n 作为一个经验法则，如果需要手动读取或写入诸如大小或位置等布局数据，应该使用\n <code><a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a></code>。请参阅本文档中的\n <a href=\"guide/lifecycle-hooks#one-time-initialization\">一次性初始化</a>中的详细信息。\n</div></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"esk8gd97tpm01qkzbf9tcv0we\"><em>一次</em>在下一个变更检测周期之后。</td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a></code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6hyfr1i3a73tsejsh3u37c5rl\">与 DOM 同步状态。请参阅本文档中的\n<a href=\"guide/lifecycle-hooks#handling-synchronization\">处理同步</a>的详细信息。</td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9qz8l2dkjy4m8ge10tk17pvon\">在\n<em>每次</em>后续变更检测周期之后。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"one-time-initialization\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"594fhujtfrfn3uuwexappshlc\">一次性初始化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#one-time-initialization\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4q4eut2maxhshdbu4tcqhabxs\">通常，您会希望使用\n<code><a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a></code>执行任何一次性初始化，例如用于第三方库或仅限浏览器的 API。</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-chart-cmp',\n  template: `&lt;div #chart&gt;{{ ... }}&lt;/div&gt;`,\n})\nexport class MyChartCmp {\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('chart') chartRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n  chart: MyChart|null;\n\n  constructor() {\n    <a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a>(() =&gt; {\n      this.chart = new MyChart(this.chartRef.nativeElement);\n    }, {phase: <a href=\"api/core/AfterRenderPhase#Write\" class=\"code-anchor\">AfterRenderPhase.Write</a>});\n  }\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"867qhurb6zhrenymh8dxn7r00\">与其尝试使用\n<code><a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a></code>重新创建它们的行为，您应该尽可能使用内置浏览器 API，如\n<code>ResizeObserver</code>和\n<code>IntersectionObserver</code>。您可以使用\n<code><a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a></code>安全地在仅限浏览器上初始化这些 API。</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-cmp',\n  template: `&lt;span #content&gt;{{ ... }}&lt;/span&gt;`,\n})\nexport class MyComponent {\n  resizeObserver: ResizeObserver|null = null;\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('content') contentRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n  constructor() {\n    <a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a>(() =&gt; {\n      this.resizeObserver = new ResizeObserver(() =&gt; {\n        console.log('Content was resized');\n      });\n\n      this.resizeObserver.observe(this.contentRef.nativeElement);\n    }, {phase: <a href=\"api/core/AfterRenderPhase#Write\" class=\"code-anchor\">AfterRenderPhase.Write</a>});\n  }\n\n  ngOnDestroy() {\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n  }\n}\n</code-example>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ecapeficemb750w2z1p8a6usx\">作为一个经验法则，\n<code><a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a></code>应用于观察\n<em>离散</em>的 DOM 更改，例如元素创建或删除。对于频繁更改的数据，如大小或位置，通常应优先使用\n<code><a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a></code>。</p>\n</div>\n<h3 id=\"handling-synchronization\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"evtmwvaxioxx8da26ysx0ahk4\">处理同步<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#handling-synchronization\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7xcbgeouxbrebjant26yymbx5\">当浏览器没有提供更好的 API 来执行此操作时，您可以使用\n<code><a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a></code>在 Angular 完成变异后执行任何额外的读取或写入到 DOM。</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-cmp',\n  template: `&lt;span #content&gt;{{ ... }}&lt;/span&gt;`,\n})\nexport class MyComponent {\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('content') contentRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n  constructor() {\n    <a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a>(() =&gt; {\n      const elem = this.contentRef.nativeElement;\n      console.log(`content position: (${elem.offsetLeft}, ${elem.offsetTop})`);\n    }, {phase: <a href=\"api/core/AfterRenderPhase#Read\" class=\"code-anchor\">AfterRenderPhase.Read</a>});\n  }\n}\n</code-example>\n<h2 id=\"general-examples\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3k1o81ep54kexdexj7ny1t1s1\">一般性例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#general-examples\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4okxtriod5s1r2xwnjvw8oof0\">下面的例子展示了各个生命周期事件的调用顺序和相对频率，以及如何在组件和指令中单独使用或同时使用这些钩子。</p>\n<p><a id=\"peek-a-boo\"></a></p>\n<h3 id=\"sequence-and-frequency-of-all-lifecycle-events\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4tisv73xm1prw7eh89641ede\">所有生命周期事件的顺序和频率<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#sequence-and-frequency-of-all-lifecycle-events\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6j6cfd4nv3x33w10in1u95g0\">为了展示 Angular 如何以预期的顺序调用钩子，<code>PeekABooComponent</code> 演示了一个组件中的所有钩子。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1g79u97vaeon6i1h5vdpfqpub\">实际上，你很少会（几乎永远不会）像这个演示中一样实现所有这些接口。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b9qwxhy1lj99ghu7kgtnomh5k\">下列快照反映了用户单击 <em>Create...</em> 按钮，然后单击 <em>Destroy...</em> 按钮后的日志状态。</p>\n<div class=\"lightbox\">\n<img alt=\"Peek-a-boo\" src=\"generated/images/guide/lifecycle-hooks/peek-a-boo.png\" width=\"425\" height=\"564\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bjqp72n82i55op40fykbauore\">日志信息的日志和所规定的钩子调用顺序是一致的：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3d477lrj4852rqwgi695t2yti\">钩子顺序</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a19pg7pci5ez9cbbpv4165fhh\">日志消息</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"><code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\"><code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\"><code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\"><code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\"><code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\"><code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\"><code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\"><code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\"><code><a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a></code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8fbd7ldqaphakhotkl3havmvv\">注意，该日志确认了在创建期间那些输入属性(这里是 <code>name</code> 属性)没有被赋值。这些输入属性要等到 <code>onInit()</code> 中才可用，以便做进一步的初始化。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"30352mjbfo183wrmgd6c4zgvu\">如果用户点击<em>Update Hero</em>按钮，就会看到另一个 <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> 和至少两组 <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code>、<code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code> 和 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code> 钩子。注意，这三种钩子被触发了<em>很多次</em>，所以让它们的逻辑尽可能保持精简是非常重要的！。</p>\n<p><a id=\"spy\"></a></p>\n<h3 id=\"use-directives-to-watch-the-dom\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wbj4itjurqlth2k79ar0q8nb\">使用指令来监视 DOM<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#use-directives-to-watch-the-dom\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dfoxw1yzs4tuj2ocsgxv99ouu\">这个 <code>Spy</code> 例子演示了如何在指令和组件中使用钩子方法。<code>SpyDirective</code> 实现了两个钩子 <code>ngOnInit()</code> 和 <code>ngOnDestroy()</code>，以便发现被监视的元素什么时候位于当前视图中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d0xkgn7udw7zj31w1gua8bs0p\">这个模板将 <code>SpyDirective</code> 应用到由父组件 <code>SpyComponent</code> 管理的 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 内的 <code>&lt;div&gt;</code> 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"antx086u3fv2gviiuakpcbmkr\">该例子不执行任何初始化或清理工作。它只是通过记录指令本身的实例化时间和销毁时间来跟踪元素在视图中的出现和消失。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54nthuzgrr6ics2eigawsf6pt\">像这样的间谍指令可以深入了解你无法直接修改的 DOM 对象。你无法触及内置 <code>&lt;div&gt;</code> 的实现，也无法修改第三方组件。但你有了一个选项来用指令监视这些元素。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ynpni2cgw6kn45b20jv426hf\">这个指令定义了 <code>ngOnInit()</code> 和 <code>ngOnDestroy()</code> 钩子，它通过一个注入进来的 <code>LoggerService</code> 把消息记录到父组件中去。</p>\n<code-example header=\"src/app/spy.directive.ts\" path=\"lifecycle-hooks/src/app/spy.directive.ts\" region=\"spy-directive\">\nlet nextId = 1;\n\n// Spy on any element to which it is applied.\n// Usage: &lt;div appSpy&gt;...&lt;/div&gt;\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[appSpy]'})\nexport class SpyDirective implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n  private id = nextId++;\n\n  constructor(private logger: LoggerService) { }\n\n  ngOnInit() {\n    this.logger.log(`Spy #${this.id} onInit`);\n  }\n\n  ngOnDestroy() {\n    this.logger.log(`Spy #${this.id} onDestroy`);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7snhf2jnva9a9mg8k63y0d5vn\">你可以把这个侦探指令写到任何内置元素或组件元素上，以观察它何时被初始化和销毁。\n下面是把它附加到用来重复显示英雄数据的这个 <code>&lt;p&gt;</code> 上。</p>\n<code-example header=\"src/app/spy.component.html\" path=\"lifecycle-hooks/src/app/spy.component.html\" region=\"template\">\n&lt;p *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" appSpy&gt;\n  {{hero}}\n&lt;/p&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3uveikt19e3onw9jlj27xgjnc\">每个“侦探”的创建和销毁都可以标出英雄所在的那个 <code>&lt;p&gt;</code> 元素的出现和消失。\n添加一个英雄就会产生一个新的英雄 <code>&lt;p&gt;</code> 元素。侦探的 <code>ngOnInit()</code> 记录下了这个事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cfo0pu8j1fbtamvpb82owgxml\"><em>Reset</em> 按钮清除了这个 <code>heroes</code> 列表。\nAngular 从 DOM 中移除了所有英雄的 <code>&lt;p&gt;</code> 元素，并且同时销毁了附加在这些 <code>&lt;p&gt;</code> 元素上的侦探指令。\n侦探的 <code>ngOnDestroy()</code> 方法汇报了它自己的临终时刻。</p>\n<p><a id=\"counter\"></a></p>\n<h3 id=\"use-component-and-directive-hooks-together\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"11w563yxe95kwdt9vqnpg1502\">同时使用组件和指令的钩子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#use-component-and-directive-hooks-together\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3okbg87j95ngfjhhew7d8bkq1\">在这个例子中，<code>CounterComponent</code> 使用了 <code>ngOnChanges()</code> 方法，以便在每次父组件递增其输入属性 <code>counter</code> 时记录一次变更。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3yzi6lifj9jhzo2e6mxdml4s\">这个例子将前例中的 <code>SpyDirective</code> 用于 <code>CounterComponent</code> 的日志，以便监视这些日志条目的创建和销毁。</p>\n<p><a id=\"onchanges\"></a></p>\n<h2 id=\"using-change-detection-hooks\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e8joowe7q3ufgwgkamgsvhbjw\">使用变更检测钩子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#using-change-detection-hooks\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ch92f06xrdhp2n6ny9dn0nl3v\">一旦检测到该组件或指令的<strong><em>输入属性</em></strong>发生了变化，Angular 就会调用它的 <code>ngOnChanges()</code> 方法。这个 <em>onChanges</em> 范例通过监控 <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a>()</code> 钩子演示了这一点。</p>\n<code-example header=\"on-changes.component.ts (excerpt)\" path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"ng-on-changes\">\nngOnChanges(changes: <a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a>) {\n  for (const propName in changes) {\n    const chng = changes[propName];\n    const cur  = JSON.stringify(chng.currentValue);\n    const prev = JSON.stringify(chng.previousValue);\n    this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qim3gio6s0f9h3wqq574wvqh\"><code>ngOnChanges()</code> 方法获取了一个对象，它把每个发生变化的属性名都映射到了一个<a href=\"api/core/SimpleChange\">SimpleChange</a>对象，该对象中有属性的当前值和前一个值。这个钩子会在这些发生了变化的属性上进行迭代，并记录它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92iwc37tdskh80iweu8n2wnnh\">这个例子中的 <code>OnChangesComponent</code> 组件有两个输入属性：<code>hero</code> 和 <code>power</code>。</p>\n<code-example header=\"src/app/on-changes.component.ts\" path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"inputs\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() power = '';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"435j3xl33809o3ch8o2o0z2rv\">宿主 <code>OnChangesParentComponent</code> 绑定了它们，就像这样。</p>\n<code-example header=\"src/app/on-changes-parent.component.html\" path=\"lifecycle-hooks/src/app/on-changes-parent.component.html\" region=\"on-changes\">\n&lt;on-changes [hero]=\"hero\" [power]=\"power\"&gt;&lt;/on-changes&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cnr0y8l44obycqgjo6odcdm7j\">下面是此例子中的当用户做出更改时的操作演示。</p>\n<div class=\"lightbox\">\n<img alt=\"OnChanges\" src=\"generated/images/guide/lifecycle-hooks/on-changes-anim.gif\" width=\"632\" height=\"512\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8zjpqmxf0chtxnii7dir372gp\">日志条目把 <em>power</em> 属性的变化显示为字符串。但请注意，<code>ngOnChanges()</code> 方法不会捕获对 <code>hero.name</code> 更改。这是因为只有当输入属性的值发生变化时，Angular 才会调用该钩子。在这种情况下，<code>hero</code> 是输入属性，<code>hero</code> 属性的值是<em>对 hero 对象</em>的<em>引用</em>。当它自己的 <code>name</code> 属性的值发生变化时，对象引用并没有改变。</p>\n<p><a id=\"afterview\"></a></p>\n<h3 id=\"responding-to-view-changes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"42nqn4m8yo9p9zonxvsbve50k\">响应视图的变更<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#responding-to-view-changes\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"es4ac45niwuz8oaqzar8w722l\">当 Angular 在变更检测期间遍历<a href=\"guide/glossary#view-hierarchy\" title=\"视图层次结构定义的定义\">视图树</a>时，需要确保子组件中的某个变更不会尝试更改其父组件中的属性。因为<a href=\"guide/glossary#unidirectional-data-flow\" title=\"定义\">单向数据流</a>的工作原理就是这样的，这样的更改将无法正常渲染。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9c4junlskbde2dj155nvb70hq\">如果你需要做一个与预期数据流反方向的修改，就必须触发一个新的变更检测周期，以允许渲染这种变更。这些例子说明了如何安全地做出这些改变。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5hn0ngy11rw5wda80xo4vrfl7\"><em>AfterView</em> 例子展示了 <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>()</code> 和 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code> 钩子，Angular 会在每次创建了组件的子视图后调用它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b6uyi1er1keu8ffbvoef99wzh\">下面是一个子视图，它用来把英雄的名字显示在一个 <code>&lt;input&gt;</code> 中：</p>\n<code-example header=\"ChildViewComponent\" path=\"lifecycle-hooks/src/app/child-view.component.ts\" region=\"child-view\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-child-view',\n  template: `\n    &lt;label for=\"hero-name\"&gt;Hero name: &lt;/label&gt;\n    &lt;input type=\"text\" id=\"hero-name\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\"&gt;\n  `\n})\nexport class ChildViewComponent {\n  hero = 'Magneta';\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9efj1fvgzgxc3j34gthgaw71d\"><code>AfterViewComponent</code> 把这个子视图显示<em>在它的模板中</em>：</p>\n<code-example header=\"AfterViewComponent (template)\" path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"template\">\ntemplate: `\n  &lt;div&gt;child view begins&lt;/div&gt;\n    &lt;app-child-view&gt;&lt;/app-child-view&gt;\n  &lt;div&gt;child view ends&lt;/div&gt;\n`\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2w9z44misx27o964k8m09od3y\">以下钩子根据\n<em>子视图内部</em>的变化值采取行动，只能通过使用用\n<a href=\"api/core/ViewChild\">@ViewChild</a>装饰的属性查询子视图来访问。</p>\n<code-example header=\"AfterViewComponent (class excerpts)\" path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"hooks\">\nexport class AfterViewComponent implements  <a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>, <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a> {\n  private prevHero = '';\n\n  // <a href=\"api/core/Query\" class=\"code-anchor\">Query</a> for a VIEW child of type `ChildViewComponent`\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>(ChildViewComponent) <a href=\"api/core/viewChild\" class=\"code-anchor\">viewChild</a>!: ChildViewComponent;\n\n  ngAfterViewInit() {\n    // <a href=\"api/core/viewChild\" class=\"code-anchor\">viewChild</a> is set after the view has been initialized\n    this.logIt('<a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>');\n    this.doSomething();\n  }\n\n  ngAfterViewChecked() {\n    // <a href=\"api/core/viewChild\" class=\"code-anchor\">viewChild</a> is updated after the view has been checked\n    if (this.prevHero === this.viewChild.hero) {\n      this.logIt('<a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a> (no change)');\n    } else {\n      this.prevHero = this.viewChild.hero;\n      this.logIt('<a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<p><a id=\"wait-a-tick\"></a></p>\n<h4 id=\"wait-before-updating-the-view\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6lpgkvphjobc8qqb9zns6pwkl\">在更新视图之前等待<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#wait-before-updating-the-view\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xy1mnbtm9azaiaucx7umgcr7\">在这个例子中，当英雄名字超过 10 个字符时，<code>doSomething()</code> 方法会更新屏幕，但在更新 <code>comment</code> 之前会等一个节拍（tick）。</p>\n<code-example header=\"AfterViewComponent (doSomething)\" path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"do-something\">\n// This surrogate for real business logic sets the `comment`\nprivate doSomething() {\n  const c = this.viewChild.hero.length &gt; 10 ? \"That's a long name\" : '';\n  if (c !== this.comment) {\n    // Wait a <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> because the component's view has already been checked\n    this.logger.tick_then(() =&gt; this.comment = c);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3f8v9i3x1zr1jtl3j4tzsq7w\">在组件的视图合成完之后，就会触发 <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>()</code> 和 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code> 钩子。如果你修改了这段代码，让这个钩子立即修改该组件的数据绑定属性 <code>comment</code>，你就会发现 Angular 抛出一个错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"31pnk3z0p0e57tzkgmi9bzfs3\"><code>LoggerService.tick_then()</code> 语句把日志的更新工作推迟了一个浏览器 JavaScript 周期，也就触发了一个新的变更检测周期。</p>\n<h4 id=\"write-lean-hook-methods-to-avoid-performance-problems\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8r37phv9f0pnqird3ptn7g7ry\">编写精简的钩子方法来避免性能问题<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#write-lean-hook-methods-to-avoid-performance-problems\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bqtpoimw50wpg5qossxwuddb1\">当你运行 <em>AfterView</em> 范例时，请注意当没有发生任何需要注意的变化时，Angular 仍然会频繁的调用 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code>。要非常小心你放到这些方法中的逻辑或计算量。</p>\n<div class=\"lightbox\">\n<img alt=\"AfterView\" src=\"generated/images/guide/lifecycle-hooks/after-view-anim.gif\" width=\"520\" height=\"532\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"93e2cdn8dqhzz1derflkb8yj5\"><a id=\"aftercontent\"></a>\n<a id=\"aftercontent-hooks\"></a></p>\n<p><a id=\"content-projection\"></a></p>\n<h3 id=\"responding-to-projected-content-changes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dr0l954flfvu3dzjk6zdmzmy\">响应被投影内容的变更<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#responding-to-projected-content-changes\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ujsa55hjme25bupiqdwuf6n9\"><em>内容投影</em>是从组件外部导入 HTML 内容，并把它插入在组件模板中指定位置上的一种途径。可以在目标中通过查找下列结构来认出内容投影。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9sz9nsit23cy2j9wnyrlw0e54\">元素标签中间的 HTML</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"evcq2ak72s27iug45xbwdce9g\">组件模板中的 <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 标签</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1cvif0kxq0q5ys0bfjgwjbjbm\">AngularJS 的开发者把这种技术叫做 <em>transclusion</em>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5t7hpc5ldogaehlynd6br7kbi\">这个 <em>AfterContent</em> 例子探索了 <code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a>()</code> 和 <code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>()</code> 钩子。Angular 会在把外部内容投影进该组件时调用它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"swi9qu356wbtfgoiuf7zqr7n\">对比<a href=\"guide/lifecycle-hooks#afterview\">前面的 AfterView</a> 例子考虑这个变化。\n这次不再通过模板来把子视图包含进来，而是改为从 <code>AfterContentComponent</code> 的父组件中导入它。下面是父组件的模板：</p>\n<code-example header=\"AfterContentParentComponent (template excerpt)\" path=\"lifecycle-hooks/src/app/after-content-parent.component.ts\" region=\"parent-template\">\n`&lt;after-content&gt;\n  &lt;app-child&gt;&lt;/app-child&gt;\n&lt;/after-content&gt;`\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76sgobagwqmw3jwssar70xik0\">注意，<code>&lt;app-child&gt;</code> 标签被包含在 <code>&lt;after-content&gt;</code> 标签中。永远不要在组件标签的内部放任何内容 —— <em>除非你想把这些内容投影进这个组件中</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66o5vqpk16oh4r5o5fy2e6kha\">现在来看该组件的模板。</p>\n<code-example header=\"AfterContentComponent (template)\" path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"template\">\ntemplate: `\n  &lt;div&gt;projected content begins&lt;/div&gt;\n    &lt;ng-content&gt;&lt;/ng-content&gt;\n  &lt;div&gt;projected content ends&lt;/div&gt;\n`\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"hxwrnd14yu1ryjy0t9cjm3o4\"><code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 标签是外来内容的<em>占位符</em>。它告诉 Angular 在哪里插入这些外来内容。在这里，被投影进去的内容就是来自父组件的 <code>&lt;app-child&gt;</code> 标签。</p>\n<div class=\"lightbox\">\n<img alt=\"Projected Content\" src=\"generated/images/guide/lifecycle-hooks/projected-child-view.png\" width=\"230\" height=\"89\">\n</div>\n<h4 id=\"using-aftercontent-hooks\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wq7ihuir4dtp597sw9yyobh\">使用 AfterContent 钩子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#using-aftercontent-hooks\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"iljw1k4lbqmcyx53xu0vd0vi\"><em>AfterContent</em> 钩子和 <em>AfterView</em> 相似。关键的不同点是子组件的类型不同。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4u7okexsomf0bkh12wpl110ih\"><em>AfterView</em> 钩子所关心的是 <code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code>，这些子组件的元素标签会出现在该组件的模板<em>里面</em></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3z7vejifu9i6nyyz7aw6rkcby\"><em>AfterContent</em> 钩子所关心的是 <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code>，这些子组件被 Angular 投影进该组件中</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"djoey09aco5agg154bghlceyr\">以下\n<em>AfterContent</em>钩子根据\n<em>内容子级</em>中的更改值采取行动，只能通过使用用\n<a href=\"api/core/ContentChild\">@ContentChild</a>装饰的属性查询它们来访问。</p>\n<code-example header=\"AfterContentComponent (class excerpts)\" path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"hooks\">\nexport class AfterContentComponent implements <a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>, <a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a> {\n  private prevHero = '';\n  comment = '';\n\n  // <a href=\"api/core/Query\" class=\"code-anchor\">Query</a> for a CONTENT child of type `ChildComponent`\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(ChildComponent) <a href=\"api/core/contentChild\" class=\"code-anchor\">contentChild</a>!: ChildComponent;\n\n  ngAfterContentInit() {\n    // <a href=\"api/core/contentChild\" class=\"code-anchor\">contentChild</a> is set after the content has been initialized\n    this.logIt('<a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a>');\n    this.doSomething();\n  }\n\n  ngAfterContentChecked() {\n    // <a href=\"api/core/contentChild\" class=\"code-anchor\">contentChild</a> is updated after the content has been checked\n    if (this.prevHero === this.contentChild.hero) {\n      this.logIt('<a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a> (no change)');\n    } else {\n      this.prevHero = this.contentChild.hero;\n      this.logIt('<a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<p><a id=\"no-unidirectional-flow-worries\"></a></p>\n<div class=\"callout is-helpful\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24fjxafhu79hn831jof0neyqo\">不需要等待内容更新</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1rbnj7dazw1jlkqtvc87t01uk\">该组件的 <code>doSomething()</code> 方法会立即更新该组件的数据绑定属性 <code>comment</code>。而无需<a href=\"guide/lifecycle-hooks#wait-a-tick\" title=\"延迟更新\">延迟更新以确保正确渲染</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d403zy5w7m6r8dk0vvgz3gxfl\">Angular 在调用 <em>AfterView</em> 钩子之前，就已调用完所有的 <em>AfterContent</em> 钩子。在完成该组件视图的合成<em>之前</em>，Angular 就已经完成了所投影内容的合成工作。<code>AfterContent...</code> 和 <code>AfterView...</code> 钩子之间有一个小的时间窗，允许你修改宿主视图。</p>\n</div>\n<p><a id=\"docheck\"></a></p>\n<h2 id=\"defining-custom-change-detection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aeske5cmve2h7h8o4yl9u3tg\">自定义变更检测逻辑<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#defining-custom-change-detection\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2fgk7yfx7pmdjpsa6b701e4uw\">要监控 <code>ngOnChanges()</code> 无法捕获的变更，你可以实现自己的变更检查逻辑，比如 <em>DoCheck</em> 的例子。这个例子展示了你如何使用 <code>ngDoCheck()</code> 钩子来检测和处理 Angular 自己没有捕捉到的变化。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f5ehfkc37tlvv8vkfs90i7bul\"><em>DoCheck</em> 范例使用下面的 <code>ngDoCheck()</code> 钩子扩展了 <em>OnChanges</em> 范例：</p>\n<code-example header=\"DoCheckComponent (ngDoCheck)\" path=\"lifecycle-hooks/src/app/do-check.component.ts\" region=\"ng-do-check\">\nngDoCheck() {\n\n  if (this.hero.name !== this.oldHeroName) {\n    this.changeDetected = true;\n    this.changeLog.push(`<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>: Hero name changed to \"${this.hero.name}\" from \"${this.oldHeroName}\"`);\n    this.oldHeroName = this.hero.name;\n  }\n\n  if (this.power !== this.oldPower) {\n    this.changeDetected = true;\n    this.changeLog.push(`<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>: Power changed to \"${this.power}\" from \"${this.oldPower}\"`);\n    this.oldPower = this.power;\n  }\n\n  if (this.changeDetected) {\n      this.noChangeCount = 0;\n  } else {\n      // log that hook was called when there was no relevant change.\n      const count = this.noChangeCount += 1;\n      const noChangeMsg = `<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a> called ${count}x when no change to hero or power`;\n      if (count === 1) {\n        // add new \"no change\" message\n        this.changeLog.push(noChangeMsg);\n      } else {\n        // update last \"no change\" message\n        this.changeLog[this.changeLog.length - 1] = noChangeMsg;\n      }\n  }\n\n  this.changeDetected = false;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cid4jjw2qovxouq5yku6eeu1i\">这段代码会检查某些<em>感兴趣的值</em>，捕获并把它们当前的状态和之前的进行比较。当 <code>hero</code> 或 <code>power</code> 没有实质性变化时，它就会在日志中写一条特殊的信息，这样你就能看到 <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>()</code> 被调用的频率。其结果很有启发性。</p>\n<div class=\"lightbox\">\n<img alt=\"DoCheck\" src=\"generated/images/guide/lifecycle-hooks/do-check-anim.gif\" width=\"632\" height=\"588\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8mw2993sp4ejnc2aj211hxjf9\">虽然 <code>ngDoCheck()</code> 钩子可以检测出英雄的 <code>name</code> 何时发生了变化，但却非常昂贵。无论变化发生在何处，<em>每个</em>变化检测周期<em>都会</em>以很大的频率调用这个钩子。在用户可以执行任何操作之前，本例中已经调用了二十多次。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7va3zb8hcjjnmwp2jxgxtsat3\">这些初始化检查大部分都是由 Angular 首次<em>在页面的其它地方</em>渲染<em>不相关的数据</em>触发的。只要把光标移动到另一个 <code>&lt;input&gt;</code> 就会触发一次调用。其中的少数调用揭示了相关数据的实际变化情况。如果使用这个钩子，那么你的实现必须非常轻量级，否则会损害用户体验。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/AfterContentChecked\n - api/core/AfterContentInit\n - api/core/AfterViewChecked\n - api/core/AfterViewInit\n - api/core/ChangeDetectorRef\n - api/core/Component\n - api/core/Directive\n - api/core/DoCheck\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - errors/NG0100\n - guide/architecture-components\n - guide/architecture-next-steps\n - guide/component-interaction\n - guide/example-apps-list\n - guide/glossary\n - guide/inputs-outputs\n - guide/lightweight-injection-tokens\n - guide/module-types\n - guide/testing-components-basics\n - guide/testing-components-scenarios\n - guide/upgrade\n - tutorial/tour-of-heroes/toh-pt4\n - tutorial/tour-of-heroes/toh-pt5\n-->\n<!-- links from this doc:\n - /guide/dependency-injection-context\n - /guide/glossary#change-detection\n - /guide/releases#developer-preview\n - api/common/NgFor\n - api/core/AfterContentChecked\n - api/core/AfterContentInit\n - api/core/AfterRenderPhase#Read\n - api/core/AfterRenderPhase#Write\n - api/core/AfterViewChecked\n - api/core/AfterViewInit\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/DestroyRef\n - api/core/Directive\n - api/core/DoCheck\n - api/core/ElementRef\n - api/core/Input\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - api/core/Query\n - api/core/SimpleChange\n - api/core/SimpleChanges\n - api/core/ViewChild\n - api/core/ViewChildren\n - api/core/afterNextRender\n - api/core/afterRender\n - api/core/contentChild\n - api/core/ng-content\n - api/core/rxjs-interop\n - api/core/rxjs-interop/takeUntilDestroyed\n - api/core/testing/tick\n - api/core/viewChild\n - api/forms/NgModel\n - guide/architecture\n - guide/glossary#lifecycle-hook\n - guide/glossary#server-side-rendering\n - guide/glossary#unidirectional-data-flow\n - guide/glossary#view\n - guide/glossary#view-hierarchy\n - guide/lifecycle-hooks#aftercontent\n - guide/lifecycle-hooks#afterview\n - guide/lifecycle-hooks#cleaning-up-on-instance-destruction\n - guide/lifecycle-hooks#component-lifecycle\n - guide/lifecycle-hooks#counter\n - guide/lifecycle-hooks#defining-custom-change-detection\n - guide/lifecycle-hooks#destroyref\n - guide/lifecycle-hooks#docheck\n - guide/lifecycle-hooks#general-examples\n - guide/lifecycle-hooks#handling-synchronization\n - guide/lifecycle-hooks#initializing-a-component-or-directive\n - guide/lifecycle-hooks#lifecycle-event-sequence\n - guide/lifecycle-hooks#lifecycle-example-set\n - guide/lifecycle-hooks#ngondestroy\n - guide/lifecycle-hooks#onchanges\n - guide/lifecycle-hooks#ondestroy\n - guide/lifecycle-hooks#one-time-initialization\n - guide/lifecycle-hooks#oninit\n - guide/lifecycle-hooks#peek-a-boo\n - guide/lifecycle-hooks#prerequisites\n - guide/lifecycle-hooks#reading-and-writing-the-dom\n - guide/lifecycle-hooks#responding-to-lifecycle-events\n - guide/lifecycle-hooks#responding-to-projected-content-changes\n - guide/lifecycle-hooks#responding-to-view-changes\n - guide/lifecycle-hooks#sequence-and-frequency-of-all-lifecycle-events\n - guide/lifecycle-hooks#spy\n - guide/lifecycle-hooks#takeuntildestroyed\n - guide/lifecycle-hooks#use-component-and-directive-hooks-together\n - guide/lifecycle-hooks#use-directives-to-watch-the-dom\n - guide/lifecycle-hooks#using-aftercontent-hooks\n - guide/lifecycle-hooks#using-change-detection-hooks\n - guide/lifecycle-hooks#wait-a-tick\n - guide/lifecycle-hooks#wait-before-updating-the-view\n - guide/lifecycle-hooks#write-lean-hook-methods-to-avoid-performance-problems\n - tutorial/tour-of-heroes/toh-pt4#oninit\n - https://www.typescriptlang.org\n-->"}