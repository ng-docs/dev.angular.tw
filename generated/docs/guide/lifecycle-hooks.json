{"id":"guide/lifecycle-hooks","title":"元件的生命週期","contents":"<div class=\"content\">\n  <h1 id=\"component-lifecycle\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7g5hf0fg0q0hx9vnyvcduoict\">元件的生命週期<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#component-lifecycle\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wfcckhu81zlchlgkk0kyr29g\">當 Angular 實例化元件類別並渲染元件檢視及其子檢視時，元件實例的生命週期就開始了。生命週期一直伴隨著變更檢測，Angular 會檢查資料繫結屬性何時發生變化，並按需更新檢視和元件實例。當 Angular 銷燬元件實例並從 DOM 中移除它渲染的範本時，生命週期就結束了。當 Angular 在執行過程中建立、更新和銷燬實例時，指令就有了類似的生命週期。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6pxd2x5tv70hvd1p6si3lechp\">你的應用可以使用<a href=\"guide/glossary#lifecycle-hook\" title=\"生命週期鉤子的定義\">生命週期鉤子方法</a>來觸發元件或指令生命週期中的關鍵事件，以初始化新實例，需要時啟動變更檢測，在變更檢測過程中回應更新，並在刪除實例之前進行清理。</p>\n<h2 id=\"prerequisites\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e44b21uig1fakj5vcfuvz1bdu\">前提條件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#prerequisites\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7g00f4jbt1swncxxo5d58oi1d\">在使用生命週期鉤子之前，你應該對這些內容有一個基本的瞭解：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4kxg9gf8rteais2gfxshcfbnk\"><a href=\"https://www.typescriptlang.org\">TypeScript 程式設計</a></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e8kyykihcbhps1v0kmxmfi5fn\">Angular 應用設計基礎，就像 <a href=\"guide/architecture\" title=\"基礎應用設計概念簡介\">Angular 的基本概念</a>中所講的那樣</li>\n</ul>\n<p><a id=\"hooks-overview\"></a></p>\n<h2 id=\"responding-to-lifecycle-events\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b8ctc2hy0ncwxbriyaqibhsej\">回應生命週期事件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#responding-to-lifecycle-events\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8n9nasj9ps2di2w43h1fodzt4\">可以透過實現一個或多個 Angular <code>core</code> 函式庫中定義的<em>生命週期鉤子</em>介面來回應元件或指令生命週期中的事件。這些鉤子讓你有機會在適當的時候對元件或指令實例進行操作，比如 Angular 建立、更新或銷燬這個實例時。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e1y5gom73mx720r0yjo9ti36c\">每個介面都有唯一的一個鉤子方法，它們的名字是由介面名再加上 <code>ng</code> 字首構成的。比如，<code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code> 介面的鉤子方法叫做 <code>ngOnInit()</code>。如果你在元件或指令類別中實現了這個方法，Angular 就會在首次檢查完元件或指令的輸入屬性後，緊接著呼叫它。</p>\n<code-example header=\"peek-a-boo.directive.ts (excerpt)\" path=\"lifecycle-hooks/src/app/peek-a-boo.directive.ts\" region=\"ngOnInit\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[appPeekABoo]'})\nexport class PeekABooDirective implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private logger: LoggerService) { }\n\n  // implement <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>'s `ngOnInit` method\n  ngOnInit() {\n    this.logIt('<a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>');\n  }\n\n  logIt(msg: string) {\n    this.logger.log(`#${nextId++} ${msg}`);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59dq14yow704f5uo9to33g7hk\">你不必實現所有生命週期鉤子，只要實現你需要的那些就可以了。</p>\n<p><a id=\"hooks-purpose-timing\"></a></p>\n<h3 id=\"lifecycle-event-sequence\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d4ry624uhegkrysxou9nrerjv\">生命週期的順序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#lifecycle-event-sequence\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amdcljoqaao55bhsqhatzt05i\">當你的應用透過呼叫建構式函式來實例化一個元件或指令時，Angular 就會呼叫那個在該實例生命週期的適當位置實現了的那些鉤子方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vjf2u2aaogiw86gw6d7p965u\">Angular 會按以下順序執行鉤子方法。可以用它來執行以下型別的操作。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7meayzvxwosvigobkjnd9pbez\">鉤子方法</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"297niinze7mn1fnajtyjcs0tb\">目的</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cj7znh1id1lxn0eajb87upoqv\">時間</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>ngOnChanges()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1t7gpladr3tl57y1ovzvd636x\">在 Angular 設定或重置資料繫結的輸入屬性時做出回應。該方法接收一個當前和先前屬性值的 \n<code><a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a></code> 物件。\n<br>\n<div class=\"alert is-helpful\"> \n <strong>注意</strong>:\n <br> 這經常發生，因此這裡執行的任何操作都會顯著影響效能。 \n</div> 詳細訊息請參閱本文件中的 \n<a href=\"guide/lifecycle-hooks#onchanges\">使用變更檢測鉤子</a>。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"k9teek447tb27mmajmt9hm7f\">在元件存在繫結輸入時，或者一個或多個資料繫結的輸入屬性發生變化時調用。 \n<br>\n<div class=\"alert is-helpful\"> \n <strong>注意</strong>:\n <br> 如果你的元件沒有輸入，或者在不提供任何輸入的情況下使用它，框架將不會呼叫 \n <code>ngOnChanges()</code>。 \n</div></td>\n</tr>\n<tr>\n<td align=\"left\"><code>ngOnInit()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4dmimkopqecakh93x4bgpudhu\">在 Angular 首次顯示資料繫結屬性並設定指令或元件的輸入屬性後初始化指令或元件。 詳細訊息請參閱本文件中的 \n<a href=\"guide/lifecycle-hooks#oninit\">初始化元件或指令</a>。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"r3z0bbamm2zitrr2ul86y78b\">在第一次 \n<code>ngOnChanges()</code> 之後呼叫一次。 即使在沒有範本繫結輸入的情況下仍會呼叫 \n<code>ngOnInit()</code>（當沒有範本繫結輸入時）。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ngDoCheck()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rikwyzvg5x9e5w40f8nt67rn\">檢測並處理 Angular 無法或不會自行檢測的更改。 詳細訊息和範例請參閱本文件中的 \n<a href=\"guide/lifecycle-hooks#docheck\">定義自定義變更檢測</a>。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3vqqkpm7ax2jyglaxs79wb6yk\">在每次變更檢測執行後立即在每次變更檢測執行後呼叫 \n<code>ngOnChanges()</code> 之後立即呼叫一次。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ngAfterContentInit()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e1o9uwean4rk83y72nvnz4fbp\">在 Angular 投影外部內容到元件的檢視或指令所在的檢視後做出回應。 詳細訊息和範例請參閱本文件中的 \n<a href=\"guide/lifecycle-hooks#aftercontent\">回應內容變更</a>。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"98e609nnql62cn1v3zo9c41m\">在第一次 \n<code>ngDoCheck()</code> 之後呼叫一次。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ngAfterContentChecked()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yvsaefptunc6mdcgf9iqfq6w\">在 Angular 檢查投影到指令或元件的內容後做出回應。 詳細訊息和範例請參閱本文件中的 \n<a href=\"guide/lifecycle-hooks#aftercontent\">回應投影內容變更</a>。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7di49ouxzhbp6y588dsj7ty07\">在 \n<code>ngAfterContentInit()</code> 和每次 \n<code>ngDoCheck()</code> 之後呼叫。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ngAfterViewInit()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4n9pmaesrqb0vq5btijuz6fwb\">在 Angular 初始化元件的檢視和子檢視，或包含指令的檢視後做出回應。 詳細訊息和範例請參閱本文件中的 \n<a href=\"guide/lifecycle-hooks#afterview\">回應檢視變更</a>。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"emk5qvdenhbuquzuj31hh87yb\">在第一次 \n<code>ngAfterContentChecked()</code> 之後呼叫一次。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ngAfterViewChecked()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"g1mx4ykopolhlya7xr3nfb4m\">在 Angular 檢查元件的檢視和子檢視，或包含該指令的檢視後作出回應。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b1oc13yqiuak53alkjhf9ehue\">在 \n<code>ngAfterViewInit()</code> 之後以及每次 \n<code>ngAfterContentChecked()</code> 之後呼叫。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ngOnDestroy()</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"15n05ugv58exvtpen8kexsv4k\">在 Angular 銷燬指令或元件之前進行清理。取消訂閱 Observables 和分離事件處理程式以避免記憶體洩漏。請參閱本文件中的\n<a href=\"guide/lifecycle-hooks#ondestroy\">實例銷燬時的清理</a>以瞭解詳細訊息。</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"13z1f8wrdkpebtr1nc3myil7f\">在 Angular 銷燬指令或元件之前立即呼叫。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"the-sample\"></a></p>\n<h3 id=\"lifecycle-example-set\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"sn8ut5w7x12xuvnmu0cvpt1y\">生命週期範例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#lifecycle-example-set\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehmer0yqa5t1wtb0ny9u6s94s\"><live-example></live-example>透過在受控於根元件 <code>AppComponent</code> 的一些元件上進行的一系列練習，示範了生命週期鉤子的運作方式。\n每一個例子中，<em>父</em>元件都扮演了<em>子</em>元件測試台的角色，以展示出一個或多個生命週期鉤子方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccmqoky8tllt46i33bechu9rw\">下表列出了這些練習及其簡介。範例程式碼也用來闡明後續各節的一些特定任務。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2n8tguxhs6hbmqbwyqfclvff1\">元件</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c6b4dqji8g3couz8zosakqqgk\"><a href=\"guide/lifecycle-hooks#peek-a-boo\">Peek-a-boo</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"573ungzuy0a53pfyam6t1mxgc\">示範每個生命週期鉤子。每個鉤子方法都會寫入到螢幕日誌中。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2he98cfkkhpq2ct49j5t3knjp\"><a href=\"guide/lifecycle-hooks#spy\">Spy</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1yj71ukmqemwgxlzuouezgrdn\">展示如何使用自定義指令與生命週期鉤子。 \n<code>SpyDirective</code> 實現了 \n<code>ngOnInit()</code> 和 \n<code>ngOnDestroy()</code> 鉤子，並使用它們來監視並報告元素何時進入或退出當前檢視。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"guide/lifecycle-hooks#onchanges\">OnChanges</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xebydcjqegxp14hatxs37gja\">示範 Angular 如何在每次元件輸入屬性發生變化時調用 \n<code>ngOnChanges()</code> 鉤子，並展示如何解釋傳遞給鉤子方法的 \n<code>changes</code> 物件。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"guide/lifecycle-hooks#docheck\">DoCheck</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8na6xzebxtkjoy69qoyyzgcwt\">使用自定義變更檢測實現 \n<code>ngDoCheck()</code> 方法。觀察鉤子將變更記錄到日誌中，以檢視 Angular 呼叫此鉤子的頻率。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"guide/lifecycle-hooks#afterview\">AfterView</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"achn29ramtpho23cnw1mr22r9\">展示 Angular 所謂的 \n<a href=\"guide/glossary#view\" title=\"檢視的定義\">檢視</a>。示範了 \n<code>ngAfterViewInit()</code> 和 \n<code>ngAfterViewChecked()</code> 鉤子。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"guide/lifecycle-hooks#aftercontent\">AfterContent</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dy1qima15qbhly9t14h2rhc62\">展示如何將外部內容投影到元件中，並如何區分投影內容和元件的檢視子元素。示範了 \n<code>ngAfterContentInit()</code> 和 \n<code>ngAfterContentChecked()</code> 鉤子。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9bxzrkke6h921x8z30wajz5bl\"><a href=\"guide/lifecycle-hooks#counter\">Counter</a></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"966t3a4220w76lwy8luareuyo\">示範元件和指令的組合，每個都有自己的鉤子。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"oninit\"></a></p>\n<h2 id=\"initializing-a-component-or-directive\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24w9cjili1yxbl8qihu75k9gj\">初始化元件或指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#initializing-a-component-or-directive\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6mzvukois96kw0bxq0v58pd49\">使用 <code>ngOnInit()</code> 方法執行以下初始化任務。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhrozcakggm6j1qyljz22xrm7\">初始化任務</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">詳情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"705czlpv28ckkp80bqwl79d58\">在建構式函式之外執行複雜的初始化操作</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3gte906cb9xacbls6lci9oyhb\">元件應該便宜且安全地構造。例如，不應在元件建構式函式中獲取資料。不必擔心新元件在測試時或在決定顯示之前嘗試聯絡遠端伺服器。 \n<br> \n<code>ngOnInit()</code> 是元件獲取初始資料的好地方。例如，請參閱 \n<a href=\"tutorial/tour-of-heroes/toh-pt4#oninit\">英雄之旅教學課程</a>。</td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5364fbm7h2fgji17nb4xnu35a\">在 Angular 設定輸入屬性後設置元件</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"388itl276614422y5t36do6vx\">建構式函式應該只設置初始本地變數為簡單值。 \n<br> 請記住，指令的資料繫結輸入屬性直到\n<strong>構造後</strong>才設定。如果需要根據這些屬性初始化指令，請在 \n<code>ngOnInit()</code> 執行時設定它們。 \n<div class=\"alert is-helpful\"> \n <code>ngOnChanges()</code> 方法是訪問這些屬性的第一個機會。Angular 在呼叫 \n <code>ngOnInit()</code> 之前呼叫 \n <code>ngOnChanges()</code>，之後也多次呼叫。它只調用 \n <code>ngOnInit()</code> 一次。\n</div></td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"ondestroy\"></a></p>\n<h2 id=\"cleaning-up-on-instance-destruction\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8eq74guq569ejg2gl244gcu75\">在實例銷燬時進行清理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#cleaning-up-on-instance-destruction\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayfy65ojzaumant3pq97ca7nu\">Angular 提供了幾種方法以便在實例被銷燬時進行清理。</p>\n<h3 id=\"ngondestroy\"><code>ngOnDestroy</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#ngondestroy\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"229regly2pmxh3zpcd6969tln\">你可以把清理邏輯放進 <code>ngOnDestroy()</code> 中，這個邏輯就必然會在 Angular 銷燬該指令之前執行。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9stsqv51iu9x8mfsp1jqgvbu0\">這裡是釋放資源的地方，這些資源不會自動被垃圾回收。如果你不這樣做，就存在記憶體洩漏的風險。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ctk7u96f0pzeu2qnnggoalspx\">取消訂閱可觀察物件和 DOM 事件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9c4e3yf6yzf0d2nzfzo1l84wi\">停止 interval 計時器。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"85j72sl06b1koz90ifhbo5jx9\">反註冊該指令在全域或應用服務中註冊過的所有回呼。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f2warbxie6mflmnj097bi8kql\"><code>ngOnDestroy()</code> 方法也可以用來通知應用程式的其它部分，該組件即將消失。</p>\n<h3 id=\"destroyref\">DestroyRef<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#destroyref\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44afjldyf0zt3cimjvp763g9h\">除了 \n<code>ngOnDestroy()</code> 之外，你還可以注入 Angular 的 \n<code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code> 並註冊回呼函式以在封閉上下文被銷燬時調用。這對於建立需要清理的可重用工具非常有用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"79d32vafbr4xf96yn9eryy3gp\">使用 <code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code> 註冊回呼：</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>(...)\nclass Counter {\n  count = 0;\n  constructor() {\n    // Start a timer to increment the counter every second.\n    const id = setInterval(() =&gt; this.count++, 1000);\n\n    // Stop the timer when the component is destroyed.\n    const destroyRef = inject(<a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a>);\n    destroyRef.onDestroy(() =&gt; clearInterval(id));\n  }\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9goltcp9pupqllug20g0p2f6u\">與 <code>ngOnDestroy</code> 一樣，<code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code> 可以在任何 Angular 服務、指令、元件或通道中使用。</p>\n<h3 id=\"takeuntildestroyed\"><code><a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#takeuntildestroyed\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bg0rg3s63hjyqrd8riyljyj8r\"><code><a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a></code> 函式已經提供了<a href=\"/guide/releases#developer-preview\">開發者預覽版</a>。你已經可以嘗試使用了，但在穩定之前可能會發生變化。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aav8skvu4s0jftgt0e8gz88te\">在元件或指令中使用 RxJS Observables 時，你可能希望在元件或指令被銷燬時完成（complete）任何可觀察物件。Angular 的 <code>@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a></code> 套件提供了一個運算子 <code><a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a></code> 來簡化這個常見任務：</p>\n<code-example language=\"ts\">\ndata$ = http.get('...').pipe(<a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a>());\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"25zejapbe3q14razvq3at1u2f\">預設情況下，必須在\n<strong>注入上下文</strong>中呼叫\n<code><a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a></code>，以便它可以訪問\n<code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code>。如果沒有可用的注入上下文，你可以顯式提供一個\n<code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code>。</p>\n<h2 id=\"reading-and-writing-the-dom\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d4jk2eiprxn5ulq33puutc40e\">讀取和寫入 DOM<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#reading-and-writing-the-dom\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"clnf3uz9ynmfwudtpm4m53v7i\">有時需要使用僅限瀏覽器的 API 手動讀取或寫入 DOM。這可以在上述\n<a href=\"guide/lifecycle-hooks#lifecycle-event-sequence\">生命週期事件</a>中進行挑戰，因為它們將在\n<a href=\"guide/glossary#server-side-rendering\">伺服器端渲染和預渲染</a>期間執行。為此，Angular 提供了\n<code><a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a></code>和\n<code><a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a></code>。這些函式可以無條件使用，但只對瀏覽器產生影響。這兩個函式都接受一個回呼函式，在下一個\n<a href=\"/guide/glossary#change-detection\">變更檢測</a>週期（包括任何巢狀週期）完成後執行。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3juj388t6quzlt7txiixfmher\"><code><a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a></code>和\n<code><a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a></code>可用於\n<a href=\"/guide/releases#developer-preview\">開發者預覽</a>。它們已準備好供您嘗試，但在穩定之前可能會發生變化。</p>\n</div>\n<table>\n<thead>\n<tr>\n<th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7y4o0j30ltpz4br769esy6uld\">函式</th>\n<th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"297niinze7mn1fnajtyjcs0tb\">目的</th>\n<th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cj7znh1id1lxn0eajb87upoqv\">時間</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code><a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a></code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51xu7s6q1ubp75qnlrkhxl53c\">執行一次性初始化，或觀察 DOM 的單個特定更改。\n<br> \n<div class=\"alert is-helpful\">\n 作為一個經驗法則，如果需要手動讀取或寫入諸如大小或位置等佈局資料，應該使用\n <code><a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a></code>。請參閱本文件中的\n <a href=\"guide/lifecycle-hooks#one-time-initialization\">一次性初始化</a>中的詳細訊息。\n</div></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"esk8gd97tpm01qkzbf9tcv0we\"><em>一次</em>在下一個變更檢測週期之後。</td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a></code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6hyfr1i3a73tsejsh3u37c5rl\">與 DOM 同步狀態。請參閱本文件中的\n<a href=\"guide/lifecycle-hooks#handling-synchronization\">處理同步</a>的詳細訊息。</td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9qz8l2dkjy4m8ge10tk17pvon\">在\n<em>每次</em>後續變更檢測週期之後。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"one-time-initialization\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"594fhujtfrfn3uuwexappshlc\">一次性初始化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#one-time-initialization\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4q4eut2maxhshdbu4tcqhabxs\">通常，您會希望使用\n<code><a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a></code>執行任何一次性初始化，例如用於第三方函式庫或僅限瀏覽器的 API。</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-chart-cmp',\n  template: `&lt;div #chart&gt;{{ ... }}&lt;/div&gt;`,\n})\nexport class MyChartCmp {\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('chart') chartRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n  chart: MyChart|null;\n\n  constructor() {\n    <a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a>(() =&gt; {\n      this.chart = new MyChart(this.chartRef.nativeElement);\n    }, {phase: <a href=\"api/core/AfterRenderPhase#Write\" class=\"code-anchor\">AfterRenderPhase.Write</a>});\n  }\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"867qhurb6zhrenymh8dxn7r00\">與其嘗試使用\n<code><a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a></code>重新建立它們的行為，您應該儘可能使用內建瀏覽器 API，如\n<code>ResizeObserver</code>和\n<code>IntersectionObserver</code>。您可以使用\n<code><a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a></code>安全地在僅限瀏覽器上初始化這些 API。</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-cmp',\n  template: `&lt;span #content&gt;{{ ... }}&lt;/span&gt;`,\n})\nexport class MyComponent {\n  resizeObserver: ResizeObserver|null = null;\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('content') contentRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n  constructor() {\n    <a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a>(() =&gt; {\n      this.resizeObserver = new ResizeObserver(() =&gt; {\n        console.log('Content was resized');\n      });\n\n      this.resizeObserver.observe(this.contentRef.nativeElement);\n    }, {phase: <a href=\"api/core/AfterRenderPhase#Write\" class=\"code-anchor\">AfterRenderPhase.Write</a>});\n  }\n\n  ngOnDestroy() {\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n  }\n}\n</code-example>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ecapeficemb750w2z1p8a6usx\">作為一個經驗法則，\n<code><a href=\"api/core/afterNextRender\" class=\"code-anchor\">afterNextRender</a></code>應用於觀察\n<em>離散</em>的 DOM 更改，例如元素建立或刪除。對於頻繁更改的資料，如大小或位置，通常應優先使用\n<code><a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a></code>。</p>\n</div>\n<h3 id=\"handling-synchronization\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"evtmwvaxioxx8da26ysx0ahk4\">處理同步<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#handling-synchronization\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7xcbgeouxbrebjant26yymbx5\">當瀏覽器沒有提供更好的 API 來執行此操作時，您可以使用\n<code><a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a></code>在 Angular 完成變異後執行任何額外的讀取或寫入到 DOM。</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-cmp',\n  template: `&lt;span #content&gt;{{ ... }}&lt;/span&gt;`,\n})\nexport class MyComponent {\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('content') contentRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n  constructor() {\n    <a href=\"api/core/afterRender\" class=\"code-anchor\">afterRender</a>(() =&gt; {\n      const elem = this.contentRef.nativeElement;\n      console.log(`content position: (${elem.offsetLeft}, ${elem.offsetTop})`);\n    }, {phase: <a href=\"api/core/AfterRenderPhase#Read\" class=\"code-anchor\">AfterRenderPhase.Read</a>});\n  }\n}\n</code-example>\n<h2 id=\"general-examples\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3k1o81ep54kexdexj7ny1t1s1\">一般性例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#general-examples\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4okxtriod5s1r2xwnjvw8oof0\">下面的例子展示了各個生命週期事件的呼叫順序和相對頻率，以及如何在元件和指令中單獨使用或同時使用這些鉤子。</p>\n<p><a id=\"peek-a-boo\"></a></p>\n<h3 id=\"sequence-and-frequency-of-all-lifecycle-events\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4tisv73xm1prw7eh89641ede\">所有生命週期事件的順序和頻率<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#sequence-and-frequency-of-all-lifecycle-events\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6j6cfd4nv3x33w10in1u95g0\">為了展示 Angular 如何以預期的順序呼叫鉤子，<code>PeekABooComponent</code> 示範了一個元件中的所有鉤子。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1g79u97vaeon6i1h5vdpfqpub\">實際上，你很少會（幾乎永遠不會）像這個示範中一樣實現所有這些介面。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b9qwxhy1lj99ghu7kgtnomh5k\">下列快照反映了使用者單擊 <em>Create...</em> 按鈕，然後單擊 <em>Destroy...</em> 按鈕後的日誌狀態。</p>\n<div class=\"lightbox\">\n<img alt=\"Peek-a-boo\" src=\"generated/images/guide/lifecycle-hooks/peek-a-boo.png\" width=\"425\" height=\"564\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bjqp72n82i55op40fykbauore\">日誌訊息的日誌和所規定的鉤子呼叫順序是一致的：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3d477lrj4852rqwgi695t2yti\">鉤子順序</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a19pg7pci5ez9cbbpv4165fhh\">日誌訊息</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"><code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\"><code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\"><code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\"><code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\"><code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\"><code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\"><code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\"><code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\"><code><a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a></code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8fbd7ldqaphakhotkl3havmvv\">注意，該日誌確認了在建立期間那些輸入屬性(這裡是 <code>name</code> 屬性)沒有被賦值。這些輸入屬性要等到 <code>onInit()</code> 中才可用，以便做進一步的初始化。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"30352mjbfo183wrmgd6c4zgvu\">如果使用者點選<em>Update Hero</em>按鈕，就會看到另一個 <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> 和至少兩組 <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code>、<code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code> 和 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code> 鉤子。注意，這三種鉤子被觸發了<em>很多次</em>，所以讓它們的邏輯儘可能保持精簡是非常重要的！。</p>\n<p><a id=\"spy\"></a></p>\n<h3 id=\"use-directives-to-watch-the-dom\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wbj4itjurqlth2k79ar0q8nb\">使用指令來監視 DOM<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#use-directives-to-watch-the-dom\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dfoxw1yzs4tuj2ocsgxv99ouu\">這個 <code>Spy</code> 例子示範了如何在指令和元件中使用鉤子方法。<code>SpyDirective</code> 實現了兩個鉤子 <code>ngOnInit()</code> 和 <code>ngOnDestroy()</code>，以便發現被監視的元素什麼時候位於當前檢視中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d0xkgn7udw7zj31w1gua8bs0p\">這個範本將 <code>SpyDirective</code> 應用到由父元件 <code>SpyComponent</code> 管理的 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 內的 <code>&lt;div&gt;</code> 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"antx086u3fv2gviiuakpcbmkr\">該例子不執行任何初始化或清理工作。它只是透過記錄指令本身的實例化時間和銷燬時間來跟蹤元素在檢視中的出現和消失。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54nthuzgrr6ics2eigawsf6pt\">像這樣的間諜指令可以深入瞭解你無法直接修改的 DOM 物件。你無法觸及內建 <code>&lt;div&gt;</code> 的實現，也無法修改第三方元件。但你有了一個選項來用指令監視這些元素。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ynpni2cgw6kn45b20jv426hf\">這個指令定義了 <code>ngOnInit()</code> 和 <code>ngOnDestroy()</code> 鉤子，它透過一個注入進來的 <code>LoggerService</code> 把訊息記錄到父元件中去。</p>\n<code-example header=\"src/app/spy.directive.ts\" path=\"lifecycle-hooks/src/app/spy.directive.ts\" region=\"spy-directive\">\nlet nextId = 1;\n\n// Spy on any element to which it is applied.\n// Usage: &lt;div appSpy&gt;...&lt;/div&gt;\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[appSpy]'})\nexport class SpyDirective implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n  private id = nextId++;\n\n  constructor(private logger: LoggerService) { }\n\n  ngOnInit() {\n    this.logger.log(`Spy #${this.id} onInit`);\n  }\n\n  ngOnDestroy() {\n    this.logger.log(`Spy #${this.id} onDestroy`);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7snhf2jnva9a9mg8k63y0d5vn\">你可以把這個偵探指令寫到任何內建元素或元件元素上，以觀察它何時被初始化和銷燬。\n下面是把它附加到用來重複顯示英雄資料的這個 <code>&lt;p&gt;</code> 上。</p>\n<code-example header=\"src/app/spy.component.html\" path=\"lifecycle-hooks/src/app/spy.component.html\" region=\"template\">\n&lt;p *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" appSpy&gt;\n  {{hero}}\n&lt;/p&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3uveikt19e3onw9jlj27xgjnc\">每個『偵探』的建立和銷燬都可以標出英雄所在的那個 <code>&lt;p&gt;</code> 元素的出現和消失。\n新增一個英雄就會產生一個新的英雄 <code>&lt;p&gt;</code> 元素。偵探的 <code>ngOnInit()</code> 記錄下了這個事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cfo0pu8j1fbtamvpb82owgxml\"><em>Reset</em> 按鈕清除了這個 <code>heroes</code> 清單。\nAngular 從 DOM 中移除了所有英雄的 <code>&lt;p&gt;</code> 元素，並且同時銷燬了附加在這些 <code>&lt;p&gt;</code> 元素上的偵探指令。\n偵探的 <code>ngOnDestroy()</code> 方法彙報了它自己的臨終時刻。</p>\n<p><a id=\"counter\"></a></p>\n<h3 id=\"use-component-and-directive-hooks-together\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"11w563yxe95kwdt9vqnpg1502\">同時使用元件和指令的鉤子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#use-component-and-directive-hooks-together\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3okbg87j95ngfjhhew7d8bkq1\">在這個例子中，<code>CounterComponent</code> 使用了 <code>ngOnChanges()</code> 方法，以便在每次父元件遞增其輸入屬性 <code>counter</code> 時記錄一次變更。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3yzi6lifj9jhzo2e6mxdml4s\">這個例子將前例中的 <code>SpyDirective</code> 用於 <code>CounterComponent</code> 的日誌，以便監視這些日誌條目的建立和銷燬。</p>\n<p><a id=\"onchanges\"></a></p>\n<h2 id=\"using-change-detection-hooks\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e8joowe7q3ufgwgkamgsvhbjw\">使用變更檢測鉤子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#using-change-detection-hooks\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ch92f06xrdhp2n6ny9dn0nl3v\">一旦檢測到該組件或指令的<strong><em>輸入屬性</em></strong>發生了變化，Angular 就會呼叫它的 <code>ngOnChanges()</code> 方法。這個 <em>onChanges</em> 範例透過監控 <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a>()</code> 鉤子示範了這一點。</p>\n<code-example header=\"on-changes.component.ts (excerpt)\" path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"ng-on-changes\">\nngOnChanges(changes: <a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a>) {\n  for (const propName in changes) {\n    const chng = changes[propName];\n    const cur  = JSON.stringify(chng.currentValue);\n    const prev = JSON.stringify(chng.previousValue);\n    this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qim3gio6s0f9h3wqq574wvqh\"><code>ngOnChanges()</code> 方法獲取了一個物件，它把每個發生變化的屬性名都對映到了一個<a href=\"api/core/SimpleChange\">SimpleChange</a>物件，該物件中有屬性的當前值和前一個值。這個鉤子會在這些發生了變化的屬性上進行迭代，並記錄它們。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92iwc37tdskh80iweu8n2wnnh\">這個例子中的 <code>OnChangesComponent</code> 元件有兩個輸入屬性：<code>hero</code> 和 <code>power</code>。</p>\n<code-example header=\"src/app/on-changes.component.ts\" path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"inputs\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() power = '';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"435j3xl33809o3ch8o2o0z2rv\">宿主 <code>OnChangesParentComponent</code> 繫結了它們，就像這樣。</p>\n<code-example header=\"src/app/on-changes-parent.component.html\" path=\"lifecycle-hooks/src/app/on-changes-parent.component.html\" region=\"on-changes\">\n&lt;on-changes [hero]=\"hero\" [power]=\"power\"&gt;&lt;/on-changes&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cnr0y8l44obycqgjo6odcdm7j\">下面是此例子中的當用戶做出更改時的操作示範。</p>\n<div class=\"lightbox\">\n<img alt=\"OnChanges\" src=\"generated/images/guide/lifecycle-hooks/on-changes-anim.gif\" width=\"632\" height=\"512\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8zjpqmxf0chtxnii7dir372gp\">日誌條目把 <em>power</em> 屬性的變化顯示為字串。但請注意，<code>ngOnChanges()</code> 方法不會捕獲對 <code>hero.name</code> 更改。這是因為只有當輸入屬性的值發生變化時，Angular 才會呼叫該鉤子。在這種情況下，<code>hero</code> 是輸入屬性，<code>hero</code> 屬性的值是<em>對 hero 物件</em>的<em>引用</em>。當它自己的 <code>name</code> 屬性的值發生變化時，物件引用並沒有改變。</p>\n<p><a id=\"afterview\"></a></p>\n<h3 id=\"responding-to-view-changes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"42nqn4m8yo9p9zonxvsbve50k\">回應檢視的變更<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#responding-to-view-changes\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"es4ac45niwuz8oaqzar8w722l\">當 Angular 在變更檢測期間遍歷<a href=\"guide/glossary#view-hierarchy\" title=\"檢視層次結構定義的定義\">檢視樹</a>時，需要確保子元件中的某個變更不會嘗試更改其父元件中的屬性。因為<a href=\"guide/glossary#unidirectional-data-flow\" title=\"定義\">單向資料流</a>的工作原理就是這樣的，這樣的更改將無法正常渲染。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9c4junlskbde2dj155nvb70hq\">如果你需要做一個與預期資料流反方向的修改，就必須觸發一個新的變更檢測週期，以允許渲染這種變更。這些例子說明了如何安全地做出這些改變。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5hn0ngy11rw5wda80xo4vrfl7\"><em>AfterView</em> 例子展示了 <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>()</code> 和 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code> 鉤子，Angular 會在每次建立了元件的子檢視後呼叫它們。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b6uyi1er1keu8ffbvoef99wzh\">下面是一個子檢視，它用來把英雄的名字顯示在一個 <code>&lt;input&gt;</code> 中：</p>\n<code-example header=\"ChildViewComponent\" path=\"lifecycle-hooks/src/app/child-view.component.ts\" region=\"child-view\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-child-view',\n  template: `\n    &lt;label for=\"hero-name\"&gt;Hero name: &lt;/label&gt;\n    &lt;input type=\"text\" id=\"hero-name\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\"&gt;\n  `\n})\nexport class ChildViewComponent {\n  hero = 'Magneta';\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9efj1fvgzgxc3j34gthgaw71d\"><code>AfterViewComponent</code> 把這個子檢視顯示<em>在它的範本中</em>：</p>\n<code-example header=\"AfterViewComponent (template)\" path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"template\">\ntemplate: `\n  &lt;div&gt;child view begins&lt;/div&gt;\n    &lt;app-child-view&gt;&lt;/app-child-view&gt;\n  &lt;div&gt;child view ends&lt;/div&gt;\n`\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2w9z44misx27o964k8m09od3y\">以下鉤子根據\n<em>子檢視內部</em>的變化值採取行動，只能透過使用用\n<a href=\"api/core/ViewChild\">@ViewChild</a>裝飾的屬性查詢子檢視來訪問。</p>\n<code-example header=\"AfterViewComponent (class excerpts)\" path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"hooks\">\nexport class AfterViewComponent implements  <a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>, <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a> {\n  private prevHero = '';\n\n  // <a href=\"api/core/Query\" class=\"code-anchor\">Query</a> for a VIEW child of type `ChildViewComponent`\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>(ChildViewComponent) <a href=\"api/core/viewChild\" class=\"code-anchor\">viewChild</a>!: ChildViewComponent;\n\n  ngAfterViewInit() {\n    // <a href=\"api/core/viewChild\" class=\"code-anchor\">viewChild</a> is set after the view has been initialized\n    this.logIt('<a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>');\n    this.doSomething();\n  }\n\n  ngAfterViewChecked() {\n    // <a href=\"api/core/viewChild\" class=\"code-anchor\">viewChild</a> is updated after the view has been checked\n    if (this.prevHero === this.viewChild.hero) {\n      this.logIt('<a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a> (no change)');\n    } else {\n      this.prevHero = this.viewChild.hero;\n      this.logIt('<a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<p><a id=\"wait-a-tick\"></a></p>\n<h4 id=\"wait-before-updating-the-view\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6lpgkvphjobc8qqb9zns6pwkl\">在更新檢視之前等待<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#wait-before-updating-the-view\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xy1mnbtm9azaiaucx7umgcr7\">在這個例子中，當英雄名字超過 10 個字元時，<code>doSomething()</code> 方法會更新螢幕，但在更新 <code>comment</code> 之前會等一個節拍（tick）。</p>\n<code-example header=\"AfterViewComponent (doSomething)\" path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"do-something\">\n// This surrogate for real business logic sets the `comment`\nprivate doSomething() {\n  const c = this.viewChild.hero.length &gt; 10 ? \"That's a long name\" : '';\n  if (c !== this.comment) {\n    // Wait a <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> because the component's view has already been checked\n    this.logger.tick_then(() =&gt; this.comment = c);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3f8v9i3x1zr1jtl3j4tzsq7w\">在元件的檢視合成完之後，就會觸發 <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>()</code> 和 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code> 鉤子。如果你修改了這段程式碼，讓這個鉤子立即修改該組件的資料繫結屬性 <code>comment</code>，你就會發現 Angular 丟擲一個錯誤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"31pnk3z0p0e57tzkgmi9bzfs3\"><code>LoggerService.tick_then()</code> 語句把日誌的更新工作推遲了一個瀏覽器 JavaScript 週期，也就觸發了一個新的變更檢測週期。</p>\n<h4 id=\"write-lean-hook-methods-to-avoid-performance-problems\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8r37phv9f0pnqird3ptn7g7ry\">編寫精簡的鉤子方法來避免效能問題<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#write-lean-hook-methods-to-avoid-performance-problems\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bqtpoimw50wpg5qossxwuddb1\">當你執行 <em>AfterView</em> 範例時，請注意當沒有發生任何需要注意的變化時，Angular 仍然會頻繁的呼叫 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code>。要非常小心你放到這些方法中的邏輯或計算量。</p>\n<div class=\"lightbox\">\n<img alt=\"AfterView\" src=\"generated/images/guide/lifecycle-hooks/after-view-anim.gif\" width=\"520\" height=\"532\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"93e2cdn8dqhzz1derflkb8yj5\"><a id=\"aftercontent\"></a>\n<a id=\"aftercontent-hooks\"></a></p>\n<p><a id=\"content-projection\"></a></p>\n<h3 id=\"responding-to-projected-content-changes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dr0l954flfvu3dzjk6zdmzmy\">回應被投影內容的變更<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#responding-to-projected-content-changes\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ujsa55hjme25bupiqdwuf6n9\"><em>內容投影</em>是從元件外部匯入 HTML 內容，並把它插入在元件範本中指定位置上的一種途徑。可以在目標中透過查詢下列結構來認出內容投影。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9sz9nsit23cy2j9wnyrlw0e54\">元素標籤中間的 HTML</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"evcq2ak72s27iug45xbwdce9g\">元件範本中的 <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 標籤</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1cvif0kxq0q5ys0bfjgwjbjbm\">AngularJS 的開發者把這種技術叫做 <em>transclusion</em>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5t7hpc5ldogaehlynd6br7kbi\">這個 <em>AfterContent</em> 例子探索了 <code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a>()</code> 和 <code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>()</code> 鉤子。Angular 會在把外部內容投影進該組件時調用它們。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"swi9qu356wbtfgoiuf7zqr7n\">對比<a href=\"guide/lifecycle-hooks#afterview\">前面的 AfterView</a> 例子考慮這個變化。\n這次不再透過範本來把子檢視包含進來，而是改為從 <code>AfterContentComponent</code> 的父元件中匯入它。下面是父元件的範本：</p>\n<code-example header=\"AfterContentParentComponent (template excerpt)\" path=\"lifecycle-hooks/src/app/after-content-parent.component.ts\" region=\"parent-template\">\n`&lt;after-content&gt;\n  &lt;app-child&gt;&lt;/app-child&gt;\n&lt;/after-content&gt;`\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76sgobagwqmw3jwssar70xik0\">注意，<code>&lt;app-child&gt;</code> 標籤被包含在 <code>&lt;after-content&gt;</code> 標籤中。永遠不要在元件標籤的內部放任何內容 —— <em>除非你想把這些內容投影進這個元件中</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66o5vqpk16oh4r5o5fy2e6kha\">現在來看該組件的範本。</p>\n<code-example header=\"AfterContentComponent (template)\" path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"template\">\ntemplate: `\n  &lt;div&gt;projected content begins&lt;/div&gt;\n    &lt;ng-content&gt;&lt;/ng-content&gt;\n  &lt;div&gt;projected content ends&lt;/div&gt;\n`\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"hxwrnd14yu1ryjy0t9cjm3o4\"><code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 標籤是外來內容的<em>佔位符</em>。它告訴 Angular 在哪裡插入這些外來內容。在這裡，被投影進去的內容就是來自父元件的 <code>&lt;app-child&gt;</code> 標籤。</p>\n<div class=\"lightbox\">\n<img alt=\"Projected Content\" src=\"generated/images/guide/lifecycle-hooks/projected-child-view.png\" width=\"230\" height=\"89\">\n</div>\n<h4 id=\"using-aftercontent-hooks\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wq7ihuir4dtp597sw9yyobh\">使用 AfterContent 鉤子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#using-aftercontent-hooks\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"iljw1k4lbqmcyx53xu0vd0vi\"><em>AfterContent</em> 鉤子和 <em>AfterView</em> 相似。關鍵的不同點是子元件的型別不同。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4u7okexsomf0bkh12wpl110ih\"><em>AfterView</em> 鉤子所關心的是 <code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code>，這些子元件的元素標籤會出現在該組件的範本<em>裡面</em></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3z7vejifu9i6nyyz7aw6rkcby\"><em>AfterContent</em> 鉤子所關心的是 <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code>，這些子元件被 Angular 投影進該組件中</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"djoey09aco5agg154bghlceyr\">以下\n<em>AfterContent</em>鉤子根據\n<em>內容子級</em>中的更改值採取行動，只能透過使用用\n<a href=\"api/core/ContentChild\">@ContentChild</a>裝飾的屬性查詢它們來訪問。</p>\n<code-example header=\"AfterContentComponent (class excerpts)\" path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"hooks\">\nexport class AfterContentComponent implements <a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>, <a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a> {\n  private prevHero = '';\n  comment = '';\n\n  // <a href=\"api/core/Query\" class=\"code-anchor\">Query</a> for a CONTENT child of type `ChildComponent`\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(ChildComponent) <a href=\"api/core/contentChild\" class=\"code-anchor\">contentChild</a>!: ChildComponent;\n\n  ngAfterContentInit() {\n    // <a href=\"api/core/contentChild\" class=\"code-anchor\">contentChild</a> is set after the content has been initialized\n    this.logIt('<a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a>');\n    this.doSomething();\n  }\n\n  ngAfterContentChecked() {\n    // <a href=\"api/core/contentChild\" class=\"code-anchor\">contentChild</a> is updated after the content has been checked\n    if (this.prevHero === this.contentChild.hero) {\n      this.logIt('<a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a> (no change)');\n    } else {\n      this.prevHero = this.contentChild.hero;\n      this.logIt('<a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<p><a id=\"no-unidirectional-flow-worries\"></a></p>\n<div class=\"callout is-helpful\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24fjxafhu79hn831jof0neyqo\">不需要等待內容更新</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1rbnj7dazw1jlkqtvc87t01uk\">該組件的 <code>doSomething()</code> 方法會立即更新該組件的資料繫結屬性 <code>comment</code>。而無需<a href=\"guide/lifecycle-hooks#wait-a-tick\" title=\"延遲更新\">延遲更新以確保正確渲染</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d403zy5w7m6r8dk0vvgz3gxfl\">Angular 在呼叫 <em>AfterView</em> 鉤子之前，就已呼叫完所有的 <em>AfterContent</em> 鉤子。在完成該組件檢視的合成<em>之前</em>，Angular 就已經完成了所投影內容的合成工作。<code>AfterContent...</code> 和 <code>AfterView...</code> 鉤子之間有一個小的時間窗，允許你修改宿主檢視。</p>\n</div>\n<p><a id=\"docheck\"></a></p>\n<h2 id=\"defining-custom-change-detection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aeske5cmve2h7h8o4yl9u3tg\">自定義變更檢測邏輯<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#defining-custom-change-detection\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2fgk7yfx7pmdjpsa6b701e4uw\">要監控 <code>ngOnChanges()</code> 無法捕獲的變更，你可以實現自己的變更檢查邏輯，比如 <em>DoCheck</em> 的例子。這個例子展示了你如何使用 <code>ngDoCheck()</code> 鉤子來檢測和處理 Angular 自己沒有捕捉到的變化。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f5ehfkc37tlvv8vkfs90i7bul\"><em>DoCheck</em> 範例使用下面的 <code>ngDoCheck()</code> 鉤子擴充套件了 <em>OnChanges</em> 範例：</p>\n<code-example header=\"DoCheckComponent (ngDoCheck)\" path=\"lifecycle-hooks/src/app/do-check.component.ts\" region=\"ng-do-check\">\nngDoCheck() {\n\n  if (this.hero.name !== this.oldHeroName) {\n    this.changeDetected = true;\n    this.changeLog.push(`<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>: Hero name changed to \"${this.hero.name}\" from \"${this.oldHeroName}\"`);\n    this.oldHeroName = this.hero.name;\n  }\n\n  if (this.power !== this.oldPower) {\n    this.changeDetected = true;\n    this.changeLog.push(`<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>: Power changed to \"${this.power}\" from \"${this.oldPower}\"`);\n    this.oldPower = this.power;\n  }\n\n  if (this.changeDetected) {\n      this.noChangeCount = 0;\n  } else {\n      // log that hook was called when there was no relevant change.\n      const count = this.noChangeCount += 1;\n      const noChangeMsg = `<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a> called ${count}x when no change to hero or power`;\n      if (count === 1) {\n        // add new \"no change\" message\n        this.changeLog.push(noChangeMsg);\n      } else {\n        // update last \"no change\" message\n        this.changeLog[this.changeLog.length - 1] = noChangeMsg;\n      }\n  }\n\n  this.changeDetected = false;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cid4jjw2qovxouq5yku6eeu1i\">這段程式碼會檢查某些<em>感興趣的值</em>，捕獲並把它們當前的狀態和之前的進行比較。當 <code>hero</code> 或 <code>power</code> 沒有實質性變化時，它就會在日誌中寫一條特殊的訊息，這樣你就能看到 <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>()</code> 被呼叫的頻率。其結果很有啟發性。</p>\n<div class=\"lightbox\">\n<img alt=\"DoCheck\" src=\"generated/images/guide/lifecycle-hooks/do-check-anim.gif\" width=\"632\" height=\"588\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8mw2993sp4ejnc2aj211hxjf9\">雖然 <code>ngDoCheck()</code> 鉤子可以檢測出英雄的 <code>name</code> 何時發生了變化，但卻非常昂貴。無論變化發生在何處，<em>每個</em>變化檢測週期<em>都會</em>以很大的頻率呼叫這個鉤子。在使用者可以執行任何操作之前，本例中已經呼叫了二十多次。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7va3zb8hcjjnmwp2jxgxtsat3\">這些初始化檢查大部分都是由 Angular 首次<em>在頁面的其它地方</em>渲染<em>不相關的資料</em>觸發的。只要把游標移動到另一個 <code>&lt;input&gt;</code> 就會觸發一次呼叫。其中的少數呼叫揭示了相關資料的實際變化情況。如果使用這個鉤子，那麼你的實現必須非常輕量級，否則會損害使用者體驗。</p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/AfterContentChecked\n - api/core/AfterContentInit\n - api/core/AfterViewChecked\n - api/core/AfterViewInit\n - api/core/ChangeDetectorRef\n - api/core/Component\n - api/core/Directive\n - api/core/DoCheck\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - errors/NG0100\n - guide/architecture-components\n - guide/architecture-next-steps\n - guide/component-interaction\n - guide/example-apps-list\n - guide/glossary\n - guide/inputs-outputs\n - guide/lightweight-injection-tokens\n - guide/module-types\n - guide/testing-components-basics\n - guide/testing-components-scenarios\n - guide/upgrade\n - tutorial/tour-of-heroes/toh-pt4\n - tutorial/tour-of-heroes/toh-pt5\n-->\n<!-- links from this doc:\n - /guide/dependency-injection-context\n - /guide/glossary#change-detection\n - /guide/releases#developer-preview\n - api/common/NgFor\n - api/core/AfterContentChecked\n - api/core/AfterContentInit\n - api/core/AfterRenderPhase#Read\n - api/core/AfterRenderPhase#Write\n - api/core/AfterViewChecked\n - api/core/AfterViewInit\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/DestroyRef\n - api/core/Directive\n - api/core/DoCheck\n - api/core/ElementRef\n - api/core/Input\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - api/core/Query\n - api/core/SimpleChange\n - api/core/SimpleChanges\n - api/core/ViewChild\n - api/core/ViewChildren\n - api/core/afterNextRender\n - api/core/afterRender\n - api/core/contentChild\n - api/core/ng-content\n - api/core/rxjs-interop\n - api/core/rxjs-interop/takeUntilDestroyed\n - api/core/testing/tick\n - api/core/viewChild\n - api/forms/NgModel\n - guide/architecture\n - guide/glossary#lifecycle-hook\n - guide/glossary#server-side-rendering\n - guide/glossary#unidirectional-data-flow\n - guide/glossary#view\n - guide/glossary#view-hierarchy\n - guide/lifecycle-hooks#aftercontent\n - guide/lifecycle-hooks#afterview\n - guide/lifecycle-hooks#cleaning-up-on-instance-destruction\n - guide/lifecycle-hooks#component-lifecycle\n - guide/lifecycle-hooks#counter\n - guide/lifecycle-hooks#defining-custom-change-detection\n - guide/lifecycle-hooks#destroyref\n - guide/lifecycle-hooks#docheck\n - guide/lifecycle-hooks#general-examples\n - guide/lifecycle-hooks#handling-synchronization\n - guide/lifecycle-hooks#initializing-a-component-or-directive\n - guide/lifecycle-hooks#lifecycle-event-sequence\n - guide/lifecycle-hooks#lifecycle-example-set\n - guide/lifecycle-hooks#ngondestroy\n - guide/lifecycle-hooks#onchanges\n - guide/lifecycle-hooks#ondestroy\n - guide/lifecycle-hooks#one-time-initialization\n - guide/lifecycle-hooks#oninit\n - guide/lifecycle-hooks#peek-a-boo\n - guide/lifecycle-hooks#prerequisites\n - guide/lifecycle-hooks#reading-and-writing-the-dom\n - guide/lifecycle-hooks#responding-to-lifecycle-events\n - guide/lifecycle-hooks#responding-to-projected-content-changes\n - guide/lifecycle-hooks#responding-to-view-changes\n - guide/lifecycle-hooks#sequence-and-frequency-of-all-lifecycle-events\n - guide/lifecycle-hooks#spy\n - guide/lifecycle-hooks#takeuntildestroyed\n - guide/lifecycle-hooks#use-component-and-directive-hooks-together\n - guide/lifecycle-hooks#use-directives-to-watch-the-dom\n - guide/lifecycle-hooks#using-aftercontent-hooks\n - guide/lifecycle-hooks#using-change-detection-hooks\n - guide/lifecycle-hooks#wait-a-tick\n - guide/lifecycle-hooks#wait-before-updating-the-view\n - guide/lifecycle-hooks#write-lean-hook-methods-to-avoid-performance-problems\n - tutorial/tour-of-heroes/toh-pt4#oninit\n - https://www.typescriptlang.org\n-->"}