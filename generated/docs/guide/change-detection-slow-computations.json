{"id":"guide/change-detection-slow-computations","title":"慢速計算","contents":"<div class=\"content\">\n  <h1 id=\"slow-computations\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46nwxhp9bfeht5mrnkql4db2w\">慢速計算<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-slow-computations#slow-computations\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1180ozhlp6vd7te5glma5qyp5\">在每個變更檢測週期上，Angular 都會同步進行：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"82obpyqzu55odmo9ltg07w34z\">除非另有指定，否則會根據每個元件的檢測策略估算所有元件中的所有範本表示式</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"emchxpu960hm1q1j83465lfnc\">執行 <code>ngDoCheck</code> 、 <code>ngAfterContentChecked</code> 、 <code>ngAfterViewChecked</code> 和 <code>ngOnChanges</code> 生命週期鉤子。範本中的單個慢速計算或生命週期鉤子可能會減慢整個變更檢測過程，因為 Angular 會按順序執行計算。</li>\n</ul>\n<h2 id=\"identifying-slow-computations\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b7d9u2s58lmecfijivizvzig7\">識別慢速計算<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-slow-computations#identifying-slow-computations\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6zrqp5di8vj8ovogi949606qq\">你可以用 Angular DevTools 的分析器來識別繁重的計算。在效能時間線中，單擊一個欄以預覽特定的變更檢測週期。這將顯示一個條形圖，該圖顯示了框架在每個元件的變更檢測上花了多長時間。當你點選一個元件時，你可以預覽 Angular 花了多長時間來評估其範本和生命週期鉤子。</p>\n<div class=\"lightbox\">\n  <img alt=\"Angular DevTools profiler preview showing slow computation\" src=\"generated/images/guide/change-detection/slow-computations.png\" width=\"1600\" height=\"887\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ariemsappqdbngn771ssrvs2u\">比如，在上面的螢幕截圖中，選擇了所記錄的第二個變更檢測週期，其中 Angular 在這個週期花費了超過 573 毫秒，大部分時間都花在了 <code>EmployeeListComponent</code> 上。在詳細訊息面板中，你可以看到 Angular 花了超過 297 毫秒的時間來估算 <code>EmployeeListComponent</code> 的範本。</p>\n<h2 id=\"optimizing-slow-computations\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e3xngsvupmbhjkcxu8wumb4yd\">最佳化慢速計算<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-slow-computations#optimizing-slow-computations\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4e9n42x2k9dztwd2xdjkjeqgc\">有幾種技術可以消除慢速計算：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eymeayltqvrha9nxoympfqhmj\"><strong>最佳化底層演算法</strong>。這是推薦的方法。如果你可以加快導致問題的演算法的速度，則可以加快整個變更檢測機制。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56w6cyey9vxhwc0tro2gn7d2l\"><strong>使用純通道快取</strong>。你可以將繁重的計算移到一個\n<a href=\"api/core/Pipe#pure\">純通道</a>中。Angular 僅在其輸入發生變化時（與上次 Angular 呼叫它時相比）重新評估純通道。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2yb2tainp9sqh1w9pnuxx3zs8\"><strong>使用記憶化（memoization）</strong>。<a href=\"https://en.wikipedia.org/wiki/Memoization\">記憶化</a>是一種與純通道類似的技術，不同之處在於純通道僅保留計算中的最後一個結果，而記憶化可以儲存多個結果。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"75xkobgrtk7mxqep03ydh40hb\"><strong>避免在生命週期鉤子中觸發重繪/迴流</strong>。某些<a href=\"https://web.dev/avoid-large-complex-layouts-and-layout-thrashing/\">操作</a>會導致瀏覽器同步重新計算頁面佈局或重新渲染它。由於迴流和重繪通常很慢，因此你要避免在每個變更檢測週期中都執行它們。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5fzwtxe74sln4xo4wl8unjzf\">純通道和記憶化有不同的權衡。與記憶化相比，純通道是 Angular 的內建概念，記憶化是一種用於快取函式結果的通用軟體工程實踐。如果你使用不同的引數頻繁呼叫繁重的計算，則記憶化的記憶體開銷可能會很大。</p>\n\n  <div class=\"reviewed\">最後複查時間：Mon Aug 14 2023</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/core/Pipe#pure\n - guide/change-detection-slow-computations#identifying-slow-computations\n - guide/change-detection-slow-computations#optimizing-slow-computations\n - guide/change-detection-slow-computations#slow-computations\n - https://en.wikipedia.org/wiki/Memoization\n - https://web.dev/avoid-large-complex-layouts-and-layout-thrashing/\n-->"}