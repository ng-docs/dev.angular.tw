{"id":"guide/change-detection-slow-computations","title":"慢速计算","contents":"<div class=\"content\">\n  <h1 id=\"slow-computations\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46nwxhp9bfeht5mrnkql4db2w\">慢速计算<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-slow-computations#slow-computations\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1180ozhlp6vd7te5glma5qyp5\">在每个变更检测周期上，Angular 都会同步进行：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"82obpyqzu55odmo9ltg07w34z\">除非另有指定，否则会根据每个组件的检测策略估算所有组件中的所有模板表达式</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"emchxpu960hm1q1j83465lfnc\">执行 <code>ngDoCheck</code> 、 <code>ngAfterContentChecked</code> 、 <code>ngAfterViewChecked</code> 和 <code>ngOnChanges</code> 生命周期钩子。模板中的单个慢速计算或生命周期钩子可能会减慢整个变更检测过程，因为 Angular 会按顺序运行计算。</li>\n</ul>\n<h2 id=\"identifying-slow-computations\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b7d9u2s58lmecfijivizvzig7\">识别慢速计算<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-slow-computations#identifying-slow-computations\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6zrqp5di8vj8ovogi949606qq\">你可以用 Angular DevTools 的分析器来识别繁重的计算。在性能时间线中，单击一个栏以预览特定的变更检测周期。这将显示一个条形图，该图显示了框架在每个组件的变更检测上花了多长时间。当你点击一个组件时，你可以预览 Angular 花了多长时间来评估其模板和生命周期钩子。</p>\n<div class=\"lightbox\">\n  <img alt=\"Angular DevTools profiler preview showing slow computation\" src=\"generated/images/guide/change-detection/slow-computations.png\" width=\"1600\" height=\"887\">\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ariemsappqdbngn771ssrvs2u\">比如，在上面的屏幕截图中，选择了所记录的第二个变更检测周期，其中 Angular 在这个周期花费了超过 573 毫秒，大部分时间都花在了 <code>EmployeeListComponent</code> 上。在详细信息面板中，你可以看到 Angular 花了超过 297 毫秒的时间来估算 <code>EmployeeListComponent</code> 的模板。</p>\n<h2 id=\"optimizing-slow-computations\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e3xngsvupmbhjkcxu8wumb4yd\">优化慢速计算<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-slow-computations#optimizing-slow-computations\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4e9n42x2k9dztwd2xdjkjeqgc\">有几种技术可以消除慢速计算：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eymeayltqvrha9nxoympfqhmj\"><strong>优化底层算法</strong>。这是推荐的方法。如果你可以加快导致问题的算法的速度，则可以加快整个变更检测机制。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56w6cyey9vxhwc0tro2gn7d2l\"><strong>使用纯管道缓存</strong>。你可以将繁重的计算移到一个\n<a href=\"api/core/Pipe#pure\">纯管道</a>中。Angular 仅在其输入发生变化时（与上次 Angular 调用它时相比）重新评估纯管道。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2yb2tainp9sqh1w9pnuxx3zs8\"><strong>使用记忆化（memoization）</strong>。<a href=\"https://en.wikipedia.org/wiki/Memoization\">记忆化</a>是一种与纯管道类似的技术，不同之处在于纯管道仅保留计算中的最后一个结果，而记忆化可以存储多个结果。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"75xkobgrtk7mxqep03ydh40hb\"><strong>避免在生命周期钩子中触发重绘/回流</strong>。某些<a href=\"https://web.dev/avoid-large-complex-layouts-and-layout-thrashing/\">操作</a>会导致浏览器同步重新计算页面布局或重新渲染它。由于回流和重绘通常很慢，因此你要避免在每个变更检测周期中都执行它们。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5fzwtxe74sln4xo4wl8unjzf\">纯管道和记忆化有不同的权衡。与记忆化相比，纯管道是 Angular 的内置概念，记忆化是一种用于缓存函数结果的通用软件工程实践。如果你使用不同的参数频繁调用繁重的计算，则记忆化的内存开销可能会很大。</p>\n\n  <div class=\"reviewed\">最后复查时间：Mon Aug 14 2023</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/core/Pipe#pure\n - guide/change-detection-slow-computations#identifying-slow-computations\n - guide/change-detection-slow-computations#optimizing-slow-computations\n - guide/change-detection-slow-computations#slow-computations\n - https://en.wikipedia.org/wiki/Memoization\n - https://web.dev/avoid-large-complex-layouts-and-layout-thrashing/\n-->"}