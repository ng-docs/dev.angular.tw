{"id":"guide/template-typecheck","title":"樣板型別檢查","contents":"<div class=\"content\">\n  <h1 id=\"template-type-checking\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ae2ql03yh3m1g6p8o3z98c0yz\">樣板型別檢查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#template-type-checking\"><i class=\"material-icons\">link</i></a></h1>\n<h2 id=\"overview-of-template-type-checking\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccrmp1us4ib7oej01wq9j4cgb\">樣板型別檢查概述<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#overview-of-template-type-checking\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8q4dqd5pihjka8molmc3vvw58\">正如 TypeScript 在程式碼中捕獲型別錯誤一樣，Angular 也會檢查應用程式樣板中的表示式和繫結，並可以報告所發現的任何型別錯誤。Angular 當前有三種執行此操作的模式，具體取決於 <a href=\"guide/typescript-configuration\">TypeScript 設定檔案</a> 中的 <code>fullTemplateTypeCheck</code> 和 <code>strictTemplates</code> 標誌的值。</p>\n<h3 id=\"basic-mode\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cyewkm4rocs0snob14hk7566w\">基本模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#basic-mode\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bzszy8rq5pda9y7q4g98d65iu\">在最基本的型別檢查模式下，將 <code>fullTemplateTypeCheck</code> 標誌設定為 <code>false</code>，Angular 僅驗證樣板中的頂層表示式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b8zfrc5ym2zi9ccdyr0zn7vlv\">如果編寫 <code>&lt;map [city]=\"user.address.city\"&gt;</code>，則編譯器將驗證以下內容：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cgpbccl8ga8uj4z6h4c4qn843\"><code>user</code> 是該組件類別的屬性</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c10cgfmktwyxu118h3agftmpa\"><code>user</code> 是具有 <code>address</code> 屬性的物件</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8iyuur9xlazu7xt7i5buikqvn\"><code>user.address</code> 是具有 <code>city</code> 屬性的物件</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"88beer3go9y6gy0cry49s839p\">編譯器不會驗證 <code>user.address.city</code> 的值是否可賦值給 <code>&lt;map&gt;</code> 元件的輸入屬性 <code>city</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d104ccviuf2hkkvjfga0wdnh\">編譯器在此模式下也有一些主要限制：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a7ie9xeixtvr92p7p91cmvyi6\">重要的是，它不會檢查嵌入式檢視，比如 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>，<code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 和其它 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> 嵌入式檢視。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4tlq0s0139oihb23d10ty7b8a\">它無法弄清 <code>#refs</code> 的型別、通道的結果、事件繫結中 <code>$event</code> 的型別等等。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68i73heuucc85x2qryea5yogc\">在許多情況下，這些東西最終都以 <code>any</code> 型別結束，這可能導致表示式的後續部分不受檢查。</p>\n<h3 id=\"full-mode\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ep3onowtdv4457ibrlrzo1r0j\">完全模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#full-mode\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b4ibznyb1ulyg7uj83bxikoah\">如果將 <code>fullTemplateTypeCheck</code> 標誌設定為 <code>true</code>，則 Angular 在樣板中進行型別檢查時會更加主動。特別是：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b6yotwrk0atlv8kv0084uegko\">檢查嵌入式檢視（比如 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 內的 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5v1l7wk3iweefhcnvri13lch6\">通道具有正確的回傳型別</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cdoqx26e5w03c9x37u6rohoz\">對指令和通道的本地引用具有正確的型別（any 泛型引數除外，該通用引數將是 <code>any</code>）</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2cdgo07ojrwlmtmoli07ou3y0\">以下仍然具有 <code>any</code> 型別。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1f6y0a85e0ebohg1wijpm7itw\">對 DOM 元素的本地引用。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4yyh849rstt1c6uwkt726i8f0\"><code>$event</code> 物件</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68mzejgvn5qzi8jda1znixmjs\">安全導向表示式</li>\n</ul>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ax8au3p8amfs8d59hcx3qgcxs\"><code>fullTemplateTypeCheck</code> 標誌已經在 Angular 13 中棄用了。它被編譯器選項中的 <code>strictTemplates</code> 家族代替了。</p>\n</div>\n<p><a id=\"strict-mode\"></a></p>\n<h3 id=\"strict-mode\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ueri0caon87o1dinr48blf5\">嚴格模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#strict-mode\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72r5samaemlrdrxbany7h3wou\">Angular 延續了 <code>fullTemplateTypeCheck</code> 標誌的行為，並引入了第三個『嚴格模式』。嚴格模式是完全模式的超集，可以透過將 <code>strictTemplates</code> 標誌設定為 true 來訪問。該標誌取代 <code>fullTemplateTypeCheck</code> 標誌。在嚴格模式下，Angular 新增了超出 8 版型別檢查器的檢查。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8p47lae7fdckbade9n1lla7ag\"><strong>注意</strong>：<br>\n嚴格模式僅在使用 Ivy 時可用。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dsmp4dnofr93b622u8bro5yvf\">除了完全模式的行為之外，Angular 還會：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b03w8y5dguc8pcn9y36tmyqa7\">驗證元件/指令繫結是否可賦值給它們的 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4l1xbmixinwlt5c9e2hseys4\">驗證以上模式時，會遵守 TypeScript 的 <code>strictNullChecks</code> 標誌</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cy98cenvbu6cs7v46e7vpzu01\">推斷元件/指令的正確型別，包括泛型</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cpwgnaof3s3fzwuw8n69zld7\">推斷設定樣板上下文的型別（比如，允許對 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code> 進行正確的型別檢查）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b65hnlxihwiie8y63pmvqb62x\">在元件/指令、DOM 和動畫事件繫結中推斷 <code>$event</code> 的正確型別</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6pies7nhoqif6jzz3rd8l94je\">根據標籤（tag）名稱（比如，<code>document.createElement</code> 將為該標籤回傳正確的型別），推斷出對 DOM 元素的區域性引用的正確型別</li>\n</ul>\n<h2 id=\"checking-of-ngfor\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"50orodhawswb1w88qkw4xu3og\"><code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 檢查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#checking-of-ngfor\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7e8rxpg2aah1gv9vpx4mcxttx\">型別檢查的三種模式對嵌入式檢視的處理方式不同。考慮以下範例。</p>\n<code-example language=\"typescript\" header=\"User interface\">\n\ninterface User {\n  name: string;\n  address: {\n    city: string;\n    state: string;\n  }\n}\n\n</code-example>\n<code-example format=\"html\" language=\"html\">\n\n&lt;div *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let user of users\"&gt;\n  &lt;h2&gt;{{config.title}}&lt;/h2&gt;\n  &lt;span&gt;City: {{user.address.city}}&lt;/span&gt;\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5mr9nrgeyd11l6ifbhd6kg4f\"><code>&lt;h2&gt;</code> 和 <code>&lt;span&gt;</code> 在 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 嵌入式檢視中。在基本模式下，Angular 不會檢查它們中的任何一個。但是，在完全模式下，Angular 會檢查 <code>config</code> 和 <code>user</code> 是否存在，並假設為 <code>any</code> 的型別。在嚴格模式下，Angular 知道該 <code>user</code> 在 <code>&lt;span&gt;</code> 中是 <code>User</code> 型別，而 <code>address</code> 是與一個物件，它有一個 <code>string</code> 型別的屬性 <code>city</code>。</p>\n<p><a id=\"troubleshooting-template-errors\"></a></p>\n<h2 id=\"troubleshooting-template-errors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2f34q6agg26vapj70i4bteqdi\">排除樣板錯誤<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#troubleshooting-template-errors\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"89fgkjqg6umxgi8xclz87xpli\">使用嚴格模式，你可能會遇到在以前的兩種模式下都沒有出現過的樣板錯誤。這些錯誤通常表示樣板中的真正型別不對應，而以前的工具並未捕獲這些錯誤。在這種情況下，該錯誤訊息會使該問題在樣板中的位置清晰可見。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"934kapgavdr0z06mo6mkyzg3z\">當 Angular 函式庫的型別不完整或不正確，或者在以下情況下型別與預期不完全一致時，也可能存在誤報。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ce2pf65wabhh94sapzjyg1un\">當函式庫的型別錯誤或不完整時（比如，如果編寫函式庫的時候沒有注意 <code>strictNullChecks</code>，則可能缺少 <code>null | undefined</code>）</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8bijcyuy84nq0oa9f2ycdkkb9\">當函式庫的輸入型別太窄並且函式庫沒有為 Angular 新增適當的元資料來解決這個問題時。這通常在停用或使用其它通用布林輸入作為屬性時發生，比如 <code>&lt;input disabled&gt;</code>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8eyfcc7rvqywg4loiygtin4je\">在將 <code>$event.target</code> 用於 DOM 事件時（由於事件冒泡的可能性，DOM 型別中的 <code>$event.target</code> 不具有你可能期望的型別）</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccfruo19sk260pxkapwx1p8su\">如果發生此類誤報，則有以下幾種選擇：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7394vhdzwn3u48x3a5nr8nzpk\">在某些情況下，使用 <a href=\"guide/template-expression-operators#any-type-cast-function\"><code>$any()</code> 型別轉換函式</a>可以選擇不對部分表示式進行型別檢查</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3vkckts49xsaabphmv9j2gby7\">你可以透過在應用程式的 TypeScript 設定檔案 <code>tsconfig.json</code> 中設定 <code>strictTemplates: false</code> 來完全停用嚴格檢查</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cq09iconm1089gd2x3mb1m7j2\">透過將<em>嚴格性標誌</em>設定為 <code>false</code>，可以在保持其它方面的嚴格性的同時，單獨停用某些特定的型別檢查操作</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"el71ubisc6vp6j0g7de1p5tyj\">如果要一起使用 <code>strictTemplates</code> 和 <code>strictNullChecks</code>，則可以透過 <code>strictNullInputTypes</code> 來選擇性排除專門用於輸入繫結的嚴格空型別檢查</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dw38tbepm5dlzg59i3hnpwvvn\">除非另行說明，下面的每個選項都會設定為 <code>strictTemplates</code> 的值（當 <code>strictTemplates</code> 為真時是 <code>true</code>，其他值也一樣）。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bw50he656l7aqzh1r0sscuay3\">嚴格性標誌</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9u63kthtcirgqptp4sb36r3ei\">效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>strictInputTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8kv72359vk9egtfvoxlln6tb5\">檢查繫結表示式是否可賦值給\n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>欄位。還會影響指令泛型型別的推斷。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictInputAccessModifiers</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7hunavpprzumrjd4bk37q4kpi\">在將繫結表示式賦值給\n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>時，是否尊重私有、受保護、只讀等訪問修飾符。如果停用，則會忽略\n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code>的訪問修飾符；僅檢查型別。預設情況下，即使將\n<code>strictTemplates</code>設定為\n<code>true</code>，此選項也為\n<code>false</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictNullInputTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qoyi7kklbjtb3axnbs3z0l8z\">在檢查\n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>繫結時是否遵守\n<code>strictNullChecks</code>（根據\n<code>strictInputTypes</code>）。在使用未考慮\n<code>strictNullChecks</code>的函式庫時，關閉此選項可能會有用。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictAttributeTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ci5kehh82ps3x1166jpzax5u9\">是否檢查使用文字屬性進行的\n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>繫結。例如，\n<code-example format=\"html\" hidecopy=\"\" language=\"html\">\n  &lt;input matInput disabled=\"true\"&gt; \n</code-example>（將\n<code>disabled</code>屬性設定為字串\n<code>'true'</code>）與\n<code-example format=\"html\" hidecopy=\"\" language=\"html\">\n  &lt;input matInput [disabled]=\"true\"&gt; \n</code-example>（將\n<code>disabled</code>屬性設定為布林值\n<code>true</code>）。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictSafeNavigationTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dokhw7xgu0yhsebvo374ixjxa\">是否根據\n<code>user</code>的型別正確推斷安全導向操作的回傳型別（例如，\n<code>user?.name</code>）。如果停用，\n<code>user?.name</code>將是\n<code>any</code>型別。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictDomLocalRefTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"20v2t38xwbz18jtcy4y4pshl1\">是否為DOM元素的本地引用提供正確的型別。如果停用，對於\n<code>&lt;input #ref&gt;</code>，\n<code>ref</code>將是\n<code>any</code>型別。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictOutputEventTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eto15idtdh52nz0oyt000885w\">是否為元件/指令的\n<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>或動畫事件繫結的\n<code>$event</code>提供正確的型別。如果停用，\n<code>$event</code>將是\n<code>any</code>型別。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictDomEventTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b5e22q6wtlu0s8vgkf521s3m3\">是否為DOM事件繫結的\n<code>$event</code>提供正確的型別。如果停用，\n<code>$event</code>將是\n<code>any</code>型別。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictContextGenerics</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c56hcawau3hcsqm40y4khpljq\">是否正確推斷泛型元件的型別引數（包括任何泛型約束）。如果停用，任何型別引數將是\n<code>any</code>型別。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictLiteralTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jsry7pbbp6pzgputxlu7n3ih\">是否推斷樣板中宣告的物件和數組字面量的型別。如果停用，此類字面量的型別將是\n<code>any</code>。當\n<em>或者</em>\n<code>fullTemplateTypeCheck</code>或\n<code>strictTemplates</code>設定為\n<code>true</code>時，此標誌為\n<code>true</code>。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ab1qazpp3d3bhllo71n81u57\">如果使用這些標誌進行故障排除後仍然存在問題，可以透過停用 <code>strictTemplates</code> 退回到完全模式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ckrvuqtkb3u3l5ed49w4c6n8y\">如果這不起作用，則最後一種選擇是完全關閉 full 模式，並使用 <code>fullTemplateTypeCheck: false</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dcg70bsm7x0wfasb9lqs7fxjy\">你無法使用任何推薦方式解決的型別檢查錯誤可能是因為樣板型別檢查器本身存在錯誤。如果遇到需要退回到基本模式的錯誤，則很可能是這樣的錯誤。如果發生這種情況，請<a href=\"https://github.com/angular/angular/issues\">提出問題</a>，以便開發組解決。</p>\n<h2 id=\"inputs-and-type-checking\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7jzxluh9x4fz2i4iyesygqqbw\">輸入屬性與型別檢查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#inputs-and-type-checking\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2bciajnxqgrlcrf8dmc3tced6\">樣板型別檢查器會檢查繫結表示式的型別是否與相應指令輸入的型別相容。比如，請考慮以下元件：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport interface User {\n  name: string;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'user-detail',\n  template: '{{ user.name }}',\n})\nexport class UserDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() user: User;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cjynqbahxovk7xtcn81jjag87\"><code>AppComponent</code> 樣板按以下方式使用此元件：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&lt;user-detail [user]=\"selectedUser\"&gt;&lt;/user-detail&gt;',\n})\nexport class AppComponent {\n  selectedUser: User | null = null;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44pycudzjxpmhae289b4uj0ym\">這裡，在檢查 <code>AppComponent</code> 的樣板期間，<code>[user]=\"selectedUser\"</code> 繫結與 <code>UserDetailComponent.user</code> 輸入屬性相對應。因此，Angular 會將 <code>selectedUser</code> 屬性賦值給 <code>UserDetailComponent.user</code>，如果它們的型別不相容，則將導致錯誤。TypeScript 會根據其型別系統進行賦值檢查，並遵循在應用程式中設定的標誌（比如 <code>strictNullChecks</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1u50zijid2pb03xigo5foi9bj\">透過向樣板型別檢查器提出更具體的樣板內型別要求，可以避免一些執行時型別錯誤。透過在指令定義中提供各種『樣板守衛』功能，可以讓自定義指令的輸入型別要求儘可能具體。參閱本指南中的<a href=\"guide/structural-directives#directive-type-checks\">強化自定義指令的樣板型別檢查</a>。</p>\n<h3 id=\"strict-null-checks\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"19vfvznrdzmgd4rxncylpunf4\">嚴格的空檢查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#strict-null-checks\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"arlqbru4wbbtxslhgmf3019kc\">當你啟用 <code>strictTemplates</code> 和 TypeScript 標誌 <code>strictNullChecks</code>，在某些情況下可能會發生型別檢查錯誤，這些情況很難避免。比如：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7i6c6xnp3stz4mw7dj9ttgqvy\">一個可空值，該值繫結到未啟用 <code>strictNullChecks</code> 的庫中的指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1lceg5newheftbjjqs5wgkmts\">對於沒有使用 <code>strictNullChecks</code> 編譯的函式庫，其宣告檔案將不會指示欄位是否可以為 <code>null</code>。對於函式庫正確處理 <code>null</code> 的情況，這是有問題的，因為編譯器將根據宣告檔案進行空值檢查，而它省略了 <code>null</code> 型別。這樣，編譯器會產生型別檢查錯誤，因為它要遵守 <code>strictNullChecks</code>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dtlauvueb6srecf7xh0qzv93g\">使用\n<code>async</code>通道處理你知道會同步發出的Observable。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2uh2jo2mjaaqtqrm69gw7wlub\">當前\n<code>async</code>通道假設其訂閱的Observable可以是非同步的，這意味著可能尚未有可用的值。 在這種情況下，它仍然必須回傳一些東西——即\n<code>null</code>。 換句話說，\n<code>async</code>通道的回傳型別包括\n<code>null</code>，這可能導致在Observable已知會同步發出非空值的情況下出現錯誤。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54es7c2rgcymkqr9rfh05p9x0\">對於上述問題，有兩種潛在的解決方法：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"alt5eu3j4swtcwvvst24ld3f2\">在樣板中，包括非空斷言運算符 <code>!</code> 用在可為空的表示式的末尾，比如</p>\n<code-example format=\"html\" hidecopy=\"\" language=\"html\">\n\n&lt;user-detail [user]=\"user!\"&gt;&lt;/user-detail&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dbkite65r8wk63qgz0put9xf3\">在此範例中，編譯器忽略了空值的型別不對應，就像在TypeScript程式碼中一樣。 在\n<code>async</code>通道的情況下，請注意表示式需要用括號括起來，如</p>\n<code-example format=\"html\" hidecopy=\"\" language=\"html\">\n\n&lt;user-detail [user]=\"(user$ | <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a>)!\"&gt;&lt;/user-detail&gt;\n\n</code-example>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eyhczgdt8m5g8h33cex9x7crk\">完全停用 Angular 樣板中的嚴格空檢查。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bjawr46ac0gfas6dayt7h81ra\">當啟用 <code>strictTemplates</code> 時，仍然可以停用型別檢查的某些方面。將選項 <code>strictNullInputTypes</code> 設定為 <code>false</code> 將停用 Angular 樣板中的嚴格空檢查。此標誌會作用於應用程式中包含的所有元件。</p>\n</li>\n</ul>\n<h3 id=\"advice-for-library-authors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"douurwqg9us4hxg5ygyczmlmq\">給庫作者的建議<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#advice-for-library-authors\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5wcibrqmtnjg61si3trbfu7vs\">作為庫作者，你可以採取多種措施為使用者提供最佳體驗。首先，啟用 <code>strictNullChecks</code> 並在輸入的型別中包括 <code>null</code>（如果適用），可以與消費者溝通，看他們是否可以提供可空的值。\n此外，可以提供特定樣板型別檢查器的型別提示，請參閱本指南的<a href=\"guide/structural-directives#directive-type-checks\">為自定義指令改進樣板型別檢查</a>和<a href=\"guide/template-typecheck#input-setter-coercion\">輸入設定器強制轉型</a>部分。</p>\n<p><a id=\"input-setter-coercion\"></a></p>\n<h2 id=\"input-setter-coercion\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8zqnny1rhvxbdlmwt1hxevutl\">輸入 setter 強制型別轉換<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#input-setter-coercion\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cny0upv0sp05747pmgesywsa2\">有時，指令或元件的 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 最好更改繫結到它的值，通常使用此輸入的 getter / setter 對。比如，考慮以下自定義按鈕元件：</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d73vg8grv6l21gyaq6z003qsq\">考慮以下指令：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'submit-button',\n  template: `\n    &lt;div class=\"wrapper\"&gt;\n      &lt;button [disabled]=\"disabled\"&gt;Submit&lt;/button&gt;\n    &lt;/div&gt;\n  `,\n})\nclass SubmitButton {\n  private _disabled: boolean;\n\n  get disabled(): boolean {\n    return this._disabled;\n  }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  set disabled(value: boolean) {\n    this._disabled = value;\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5sb2k3pibgdmawslyhxogl8ls\">在這裡，元件的輸入 <code>disabled</code> 將傳給樣板中的 <code>&lt;button&gt;</code>。只要將 <code>boolean</code> 值繫結到輸入，所有這些工作都可以按預期進行。但是，假設使用者使用樣板中的這個輸入作為屬性：</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;submit-button disabled&gt;&lt;/submit-button&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5l4t8li6ctx9un463jtio0w6s\">這與繫結具有相同的效果：</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;submit-button [disabled]=\"''\"&gt;&lt;/submit-button&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5z8qppa5kwqqpr9qxtd9sngl2\">在執行時，輸入將設定為空字串，這不是 <code>boolean</code> 值。處理此問題的 Angular 元件庫通常將值『強制轉換』到 setter 中的正確型別中：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nset disabled(value: boolean) {\n  this._disabled = (value === '') || value;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6zac9zts80jqtoc7nlnfa2g5l\">最好在這裡將 <code>value</code> 的型別從 <code>boolean</code> 更改為 <code>boolean|''</code> 以對應 setter 實際會接受的一組值。TypeScript 4.3 之前的版本要求 getter 和 setter 的型別相同，因此，如果 getter 要回傳 <code>boolean</code> 則 setter 會卡在較窄的型別上。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"65yssidyasqhuv2vigsa2hof2\">如果消費者對樣板啟用了 Angular 的最嚴格的型別檢查功能，則會產生一個問題：空字串 <code>''</code> 實際上無法賦值給 <code>disabled</code> 欄位，使用屬性格式寫會產生型別錯誤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3zxi0i2rxswwc28kc6x7j6049\">作為解決此問題的一種取巧方式，Angular 支援對 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 檢查比宣告的輸入欄位更寬鬆的型別。透過向元件類別新增帶有 <code>ngAcceptInputType_</code> 字首的靜態屬性來啟用此功能：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass SubmitButton {\n  private _disabled: boolean;\n\n  get disabled(): boolean {\n    return this._disabled;\n  }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  set disabled(value: boolean) {\n    this._disabled = (value === '') || value;\n  }\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> ngAcceptInputType_disabled: boolean|'';\n}\n\n</code-example>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3dyxqvwaurp5zgjwkm3izu29a\">從 TypeScript 4.3 開始，setter 能夠宣告為接受 <code>boolean|''</code> 型別，這就讓輸入屬性 setter 強制型別轉換欄位過時了。因此，輸入屬性 setter 強制型別轉換欄位也就棄用了。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"du571pdlhlc7waqfydqddy4oe\">該欄位不需要值。它只要存在就會通知 Angular 的型別檢查器，<code>disabled</code> 輸入應被視為接受與 <code>boolean|''</code> 型別對應的繫結。字尾應為 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> <em>欄位</em>的名稱。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9mtm7uwh7yv4bsa8qnufjwxyn\">請注意，如果給定輸入存在 <code>ngAcceptInputType_</code> 覆蓋，則設定器應能夠處理任何覆蓋型別的值。</p>\n<h2 id=\"disabling-type-checking-using-any\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bldjm4zyg5yaly0v6npnm5j8e\">使用 <code>$any()</code> 停用型別檢查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#disabling-type-checking-using-any\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ra1e8v55i4yqajcmb9d8rh6z\">可以透過把繫結表示式包含在<a href=\"guide/template-expression-operators\">型別轉換偽函式 <code>$any()</code></a> 中來停用型別檢查。編譯器會像在 TypeScript 中使用 <code>&lt;any&gt;</code> 或 <code>as any</code> 進行型別轉換一樣對待它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b488m88d8qs2pcr8cyesamynd\">在以下範例中，將 <code>person</code> 強制轉換為 <code>any</code> 型別可以壓制錯誤 <code>Property address does not exist</code>。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '{{$any(person).address.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - extended-diagnostics\n - extended-diagnostics/NG8101\n - extended-diagnostics/NG8102\n - guide/angular-compiler-options\n - guide/deprecations\n - guide/strict-mode\n - guide/structural-directives\n - guide/typescript-configuration\n-->\n<!-- links from this doc:\n - api/common/NgFor\n - api/common/NgIf\n - api/core/Component\n - api/core/Input\n - api/core/Output\n - api/core/ng-template\n - api/platform-browser/animations/async\n - api/upgrade/static\n - guide/structural-directives#directive-type-checks\n - guide/template-expression-operators\n - guide/template-expression-operators#any-type-cast-function\n - guide/template-typecheck#advice-for-library-authors\n - guide/template-typecheck#basic-mode\n - guide/template-typecheck#checking-of-ngfor\n - guide/template-typecheck#disabling-type-checking-using-any\n - guide/template-typecheck#full-mode\n - guide/template-typecheck#input-setter-coercion\n - guide/template-typecheck#inputs-and-type-checking\n - guide/template-typecheck#overview-of-template-type-checking\n - guide/template-typecheck#strict-mode\n - guide/template-typecheck#strict-null-checks\n - guide/template-typecheck#template-type-checking\n - guide/template-typecheck#troubleshooting-template-errors\n - guide/typescript-configuration\n - https://github.com/angular/angular/issues\n-->"}