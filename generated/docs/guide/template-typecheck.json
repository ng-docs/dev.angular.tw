{"id":"guide/template-typecheck","title":"模板类型检查","contents":"<div class=\"content\">\n  <h1 id=\"template-type-checking\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ae2ql03yh3m1g6p8o3z98c0yz\">模板类型检查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#template-type-checking\"><i class=\"material-icons\">link</i></a></h1>\n<h2 id=\"overview-of-template-type-checking\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccrmp1us4ib7oej01wq9j4cgb\">模板类型检查概述<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#overview-of-template-type-checking\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8q4dqd5pihjka8molmc3vvw58\">正如 TypeScript 在代码中捕获类型错误一样，Angular 也会检查应用程序模板中的表达式和绑定，并可以报告所发现的任何类型错误。Angular 当前有三种执行此操作的模式，具体取决于 <a href=\"guide/typescript-configuration\">TypeScript 配置文件</a> 中的 <code>fullTemplateTypeCheck</code> 和 <code>strictTemplates</code> 标志的值。</p>\n<h3 id=\"basic-mode\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cyewkm4rocs0snob14hk7566w\">基本模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#basic-mode\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bzszy8rq5pda9y7q4g98d65iu\">在最基本的类型检查模式下，将 <code>fullTemplateTypeCheck</code> 标志设置为 <code>false</code>，Angular 仅验证模板中的顶层表达式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b8zfrc5ym2zi9ccdyr0zn7vlv\">如果编写 <code>&lt;map [city]=\"user.address.city\"&gt;</code>，则编译器将验证以下内容：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cgpbccl8ga8uj4z6h4c4qn843\"><code>user</code> 是该组件类的属性</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c10cgfmktwyxu118h3agftmpa\"><code>user</code> 是具有 <code>address</code> 属性的对象</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8iyuur9xlazu7xt7i5buikqvn\"><code>user.address</code> 是具有 <code>city</code> 属性的对象</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"88beer3go9y6gy0cry49s839p\">编译器不会验证 <code>user.address.city</code> 的值是否可赋值给 <code>&lt;map&gt;</code> 组件的输入属性 <code>city</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d104ccviuf2hkkvjfga0wdnh\">编译器在此模式下也有一些主要限制：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a7ie9xeixtvr92p7p91cmvyi6\">重要的是，它不会检查嵌入式视图，比如 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>，<code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 和其它 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> 嵌入式视图。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4tlq0s0139oihb23d10ty7b8a\">它无法弄清 <code>#refs</code> 的类型、管道的结果、事件绑定中 <code>$event</code> 的类型等等。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68i73heuucc85x2qryea5yogc\">在许多情况下，这些东西最终都以 <code>any</code> 类型结束，这可能导致表达式的后续部分不受检查。</p>\n<h3 id=\"full-mode\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ep3onowtdv4457ibrlrzo1r0j\">完全模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#full-mode\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b4ibznyb1ulyg7uj83bxikoah\">如果将 <code>fullTemplateTypeCheck</code> 标志设置为 <code>true</code>，则 Angular 在模板中进行类型检查时会更加主动。特别是：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b6yotwrk0atlv8kv0084uegko\">检查嵌入式视图（比如 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 内的 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5v1l7wk3iweefhcnvri13lch6\">管道具有正确的返回类型</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cdoqx26e5w03c9x37u6rohoz\">对指令和管道的本地引用具有正确的类型（any 泛型参数除外，该通用参数将是 <code>any</code>）</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2cdgo07ojrwlmtmoli07ou3y0\">以下仍然具有 <code>any</code> 类型。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1f6y0a85e0ebohg1wijpm7itw\">对 DOM 元素的本地引用。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4yyh849rstt1c6uwkt726i8f0\"><code>$event</code> 对象</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68mzejgvn5qzi8jda1znixmjs\">安全导航表达式</li>\n</ul>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ax8au3p8amfs8d59hcx3qgcxs\"><code>fullTemplateTypeCheck</code> 标志已经在 Angular 13 中弃用了。它被编译器选项中的 <code>strictTemplates</code> 家族代替了。</p>\n</div>\n<p><a id=\"strict-mode\"></a></p>\n<h3 id=\"strict-mode\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ueri0caon87o1dinr48blf5\">严格模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#strict-mode\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72r5samaemlrdrxbany7h3wou\">Angular 延续了 <code>fullTemplateTypeCheck</code> 标志的行为，并引入了第三个“严格模式”。严格模式是完全模式的超集，可以通过将 <code>strictTemplates</code> 标志设置为 true 来访问。该标志取代 <code>fullTemplateTypeCheck</code> 标志。在严格模式下，Angular 添加了超出 8 版类型检查器的检查。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8p47lae7fdckbade9n1lla7ag\"><strong>注意</strong>：<br>\n严格模式仅在使用 Ivy 时可用。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dsmp4dnofr93b622u8bro5yvf\">除了完全模式的行为之外，Angular 还会：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b03w8y5dguc8pcn9y36tmyqa7\">验证组件/指令绑定是否可赋值给它们的 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4l1xbmixinwlt5c9e2hseys4\">验证以上模式时，会遵守 TypeScript 的 <code>strictNullChecks</code> 标志</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cy98cenvbu6cs7v46e7vpzu01\">推断组件/指令的正确类型，包括泛型</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cpwgnaof3s3fzwuw8n69zld7\">推断配置模板上下文的类型（比如，允许对 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code> 进行正确的类型检查）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b65hnlxihwiie8y63pmvqb62x\">在组件/指令、DOM 和动画事件绑定中推断 <code>$event</code> 的正确类型</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6pies7nhoqif6jzz3rd8l94je\">根据标签（tag）名称（比如，<code>document.createElement</code> 将为该标签返回正确的类型），推断出对 DOM 元素的局部引用的正确类型</li>\n</ul>\n<h2 id=\"checking-of-ngfor\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"50orodhawswb1w88qkw4xu3og\"><code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 检查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#checking-of-ngfor\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7e8rxpg2aah1gv9vpx4mcxttx\">类型检查的三种模式对嵌入式视图的处理方式不同。考虑以下范例。</p>\n<code-example language=\"typescript\" header=\"User interface\">\n\ninterface User {\n  name: string;\n  address: {\n    city: string;\n    state: string;\n  }\n}\n\n</code-example>\n<code-example format=\"html\" language=\"html\">\n\n&lt;div *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let user of users\"&gt;\n  &lt;h2&gt;{{config.title}}&lt;/h2&gt;\n  &lt;span&gt;City: {{user.address.city}}&lt;/span&gt;\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5mr9nrgeyd11l6ifbhd6kg4f\"><code>&lt;h2&gt;</code> 和 <code>&lt;span&gt;</code> 在 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 嵌入式视图中。在基本模式下，Angular 不会检查它们中的任何一个。但是，在完全模式下，Angular 会检查 <code>config</code> 和 <code>user</code> 是否存在，并假设为 <code>any</code> 的类型。在严格模式下，Angular 知道该 <code>user</code> 在 <code>&lt;span&gt;</code> 中是 <code>User</code> 类型，而 <code>address</code> 是与一个对象，它有一个 <code>string</code> 类型的属性 <code>city</code>。</p>\n<p><a id=\"troubleshooting-template-errors\"></a></p>\n<h2 id=\"troubleshooting-template-errors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2f34q6agg26vapj70i4bteqdi\">排除模板错误<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#troubleshooting-template-errors\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"89fgkjqg6umxgi8xclz87xpli\">使用严格模式，你可能会遇到在以前的两种模式下都没有出现过的模板错误。这些错误通常表示模板中的真正类型不匹配，而以前的工具并未捕获这些错误。在这种情况下，该错误消息会使该问题在模板中的位置清晰可见。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"934kapgavdr0z06mo6mkyzg3z\">当 Angular 库的类型不完整或不正确，或者在以下情况下类型与预期不完全一致时，也可能存在误报。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ce2pf65wabhh94sapzjyg1un\">当库的类型错误或不完整时（比如，如果编写库的时候没有注意 <code>strictNullChecks</code>，则可能缺少 <code>null | undefined</code>）</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8bijcyuy84nq0oa9f2ycdkkb9\">当库的输入类型太窄并且库没有为 Angular 添加适当的元数据来解决这个问题时。这通常在禁用或使用其它通用布尔输入作为属性时发生，比如 <code>&lt;input disabled&gt;</code>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8eyfcc7rvqywg4loiygtin4je\">在将 <code>$event.target</code> 用于 DOM 事件时（由于事件冒泡的可能性，DOM 类型中的 <code>$event.target</code> 不具有你可能期望的类型）</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccfruo19sk260pxkapwx1p8su\">如果发生此类误报，则有以下几种选择：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7394vhdzwn3u48x3a5nr8nzpk\">在某些情况下，使用 <a href=\"guide/template-expression-operators#any-type-cast-function\"><code>$any()</code> 类型转换函数</a>可以选择不对部分表达式进行类型检查</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3vkckts49xsaabphmv9j2gby7\">你可以通过在应用程序的 TypeScript 配置文件 <code>tsconfig.json</code> 中设置 <code>strictTemplates: false</code> 来完全禁用严格检查</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cq09iconm1089gd2x3mb1m7j2\">通过将<em>严格性标志</em>设置为 <code>false</code>，可以在保持其它方面的严格性的同时，单独禁用某些特定的类型检查操作</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"el71ubisc6vp6j0g7de1p5tyj\">如果要一起使用 <code>strictTemplates</code> 和 <code>strictNullChecks</code>，则可以通过 <code>strictNullInputTypes</code> 来选择性排除专门用于输入绑定的严格空类型检查</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dw38tbepm5dlzg59i3hnpwvvn\">除非另行说明，下面的每个选项都会设置为 <code>strictTemplates</code> 的值（当 <code>strictTemplates</code> 为真时是 <code>true</code>，其他值也一样）。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bw50he656l7aqzh1r0sscuay3\">严格性标志</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9u63kthtcirgqptp4sb36r3ei\">效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>strictInputTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8kv72359vk9egtfvoxlln6tb5\">检查绑定表达式是否可赋值给\n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>字段。还会影响指令泛型类型的推断。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictInputAccessModifiers</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7hunavpprzumrjd4bk37q4kpi\">在将绑定表达式赋值给\n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>时，是否尊重私有、受保护、只读等访问修饰符。如果禁用，则会忽略\n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code>的访问修饰符；仅检查类型。默认情况下，即使将\n<code>strictTemplates</code>设置为\n<code>true</code>，此选项也为\n<code>false</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictNullInputTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qoyi7kklbjtb3axnbs3z0l8z\">在检查\n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>绑定时是否遵守\n<code>strictNullChecks</code>（根据\n<code>strictInputTypes</code>）。在使用未考虑\n<code>strictNullChecks</code>的库时，关闭此选项可能会有用。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictAttributeTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ci5kehh82ps3x1166jpzax5u9\">是否检查使用文本属性进行的\n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>绑定。例如，\n<code-example format=\"html\" hidecopy=\"\" language=\"html\">\n  &lt;input matInput disabled=\"true\"&gt; \n</code-example>（将\n<code>disabled</code>属性设置为字符串\n<code>'true'</code>）与\n<code-example format=\"html\" hidecopy=\"\" language=\"html\">\n  &lt;input matInput [disabled]=\"true\"&gt; \n</code-example>（将\n<code>disabled</code>属性设置为布尔值\n<code>true</code>）。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictSafeNavigationTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dokhw7xgu0yhsebvo374ixjxa\">是否根据\n<code>user</code>的类型正确推断安全导航操作的返回类型（例如，\n<code>user?.name</code>）。如果禁用，\n<code>user?.name</code>将是\n<code>any</code>类型。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictDomLocalRefTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"20v2t38xwbz18jtcy4y4pshl1\">是否为DOM元素的本地引用提供正确的类型。如果禁用，对于\n<code>&lt;input #ref&gt;</code>，\n<code>ref</code>将是\n<code>any</code>类型。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictOutputEventTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eto15idtdh52nz0oyt000885w\">是否为组件/指令的\n<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>或动画事件绑定的\n<code>$event</code>提供正确的类型。如果禁用，\n<code>$event</code>将是\n<code>any</code>类型。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictDomEventTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b5e22q6wtlu0s8vgkf521s3m3\">是否为DOM事件绑定的\n<code>$event</code>提供正确的类型。如果禁用，\n<code>$event</code>将是\n<code>any</code>类型。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictContextGenerics</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c56hcawau3hcsqm40y4khpljq\">是否正确推断泛型组件的类型参数（包括任何泛型约束）。如果禁用，任何类型参数将是\n<code>any</code>类型。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strictLiteralTypes</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jsry7pbbp6pzgputxlu7n3ih\">是否推断模板中声明的对象和数组字面量的类型。如果禁用，此类字面量的类型将是\n<code>any</code>。当\n<em>或者</em>\n<code>fullTemplateTypeCheck</code>或\n<code>strictTemplates</code>设置为\n<code>true</code>时，此标志为\n<code>true</code>。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ab1qazpp3d3bhllo71n81u57\">如果使用这些标志进行故障排除后仍然存在问题，可以通过禁用 <code>strictTemplates</code> 退回到完全模式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ckrvuqtkb3u3l5ed49w4c6n8y\">如果这不起作用，则最后一种选择是完全关闭 full 模式，并使用 <code>fullTemplateTypeCheck: false</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dcg70bsm7x0wfasb9lqs7fxjy\">你无法使用任何推荐方式解决的类型检查错误可能是因为模板类型检查器本身存在错误。如果遇到需要退回到基本模式的错误，则很可能是这样的错误。如果发生这种情况，请<a href=\"https://github.com/angular/angular/issues\">提出问题</a>，以便开发组解决。</p>\n<h2 id=\"inputs-and-type-checking\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7jzxluh9x4fz2i4iyesygqqbw\">输入属性与类型检查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#inputs-and-type-checking\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2bciajnxqgrlcrf8dmc3tced6\">模板类型检查器会检查绑定表达式的类型是否与相应指令输入的类型兼容。比如，请考虑以下组件：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport interface User {\n  name: string;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'user-detail',\n  template: '{{ user.name }}',\n})\nexport class UserDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() user: User;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cjynqbahxovk7xtcn81jjag87\"><code>AppComponent</code> 模板按以下方式使用此组件：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&lt;user-detail [user]=\"selectedUser\"&gt;&lt;/user-detail&gt;',\n})\nexport class AppComponent {\n  selectedUser: User | null = null;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44pycudzjxpmhae289b4uj0ym\">这里，在检查 <code>AppComponent</code> 的模板期间，<code>[user]=\"selectedUser\"</code> 绑定与 <code>UserDetailComponent.user</code> 输入属性相对应。因此，Angular 会将 <code>selectedUser</code> 属性赋值给 <code>UserDetailComponent.user</code>，如果它们的类型不兼容，则将导致错误。TypeScript 会根据其类型系统进行赋值检查，并遵循在应用程序中配置的标志（比如 <code>strictNullChecks</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1u50zijid2pb03xigo5foi9bj\">通过向模板类型检查器提出更具体的模板内类型要求，可以避免一些运行时类型错误。通过在指令定义中提供各种“模板守卫”功能，可以让自定义指令的输入类型要求尽可能具体。参阅本指南中的<a href=\"guide/structural-directives#directive-type-checks\">强化自定义指令的模板类型检查</a>。</p>\n<h3 id=\"strict-null-checks\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"19vfvznrdzmgd4rxncylpunf4\">严格的空检查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#strict-null-checks\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"arlqbru4wbbtxslhgmf3019kc\">当你启用 <code>strictTemplates</code> 和 TypeScript 标志 <code>strictNullChecks</code>，在某些情况下可能会发生类型检查错误，这些情况很难避免。比如：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7i6c6xnp3stz4mw7dj9ttgqvy\">一个可空值，该值绑定到未启用 <code>strictNullChecks</code> 的库中的指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1lceg5newheftbjjqs5wgkmts\">对于没有使用 <code>strictNullChecks</code> 编译的库，其声明文件将不会指示字段是否可以为 <code>null</code>。对于库正确处理 <code>null</code> 的情况，这是有问题的，因为编译器将根据声明文件进行空值检查，而它省略了 <code>null</code> 类型。这样，编译器会产生类型检查错误，因为它要遵守 <code>strictNullChecks</code>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dtlauvueb6srecf7xh0qzv93g\">使用\n<code>async</code>管道处理你知道会同步发出的Observable。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2uh2jo2mjaaqtqrm69gw7wlub\">当前\n<code>async</code>管道假设其订阅的Observable可以是异步的，这意味着可能尚未有可用的值。 在这种情况下，它仍然必须返回一些东西——即\n<code>null</code>。 换句话说，\n<code>async</code>管道的返回类型包括\n<code>null</code>，这可能导致在Observable已知会同步发出非空值的情况下出现错误。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54es7c2rgcymkqr9rfh05p9x0\">对于上述问题，有两种潜在的解决方法：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"alt5eu3j4swtcwvvst24ld3f2\">在模板中，包括非空断言运算符 <code>!</code> 用在可为空的表达式的末尾，比如</p>\n<code-example format=\"html\" hidecopy=\"\" language=\"html\">\n\n&lt;user-detail [user]=\"user!\"&gt;&lt;/user-detail&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dbkite65r8wk63qgz0put9xf3\">在此示例中，编译器忽略了空值的类型不匹配，就像在TypeScript代码中一样。 在\n<code>async</code>管道的情况下，请注意表达式需要用括号括起来，如</p>\n<code-example format=\"html\" hidecopy=\"\" language=\"html\">\n\n&lt;user-detail [user]=\"(user$ | <a href=\"api/platform-browser/animations/async\" class=\"code-anchor\">async</a>)!\"&gt;&lt;/user-detail&gt;\n\n</code-example>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eyhczgdt8m5g8h33cex9x7crk\">完全禁用 Angular 模板中的严格空检查。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bjawr46ac0gfas6dayt7h81ra\">当启用 <code>strictTemplates</code> 时，仍然可以禁用类型检查的某些方面。将选项 <code>strictNullInputTypes</code> 设置为 <code>false</code> 将禁用 Angular 模板中的严格空检查。此标志会作用于应用程序中包含的所有组件。</p>\n</li>\n</ul>\n<h3 id=\"advice-for-library-authors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"douurwqg9us4hxg5ygyczmlmq\">给库作者的建议<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#advice-for-library-authors\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5wcibrqmtnjg61si3trbfu7vs\">作为库作者，你可以采取多种措施为用户提供最佳体验。首先，启用 <code>strictNullChecks</code> 并在输入的类型中包括 <code>null</code>（如果适用），可以与消费者沟通，看他们是否可以提供可空的值。\n此外，可以提供特定模板类型检查器的类型提示，请参阅本指南的<a href=\"guide/structural-directives#directive-type-checks\">为自定义指令改进模板类型检查</a>和<a href=\"guide/template-typecheck#input-setter-coercion\">输入设置器强制转型</a>部分。</p>\n<p><a id=\"input-setter-coercion\"></a></p>\n<h2 id=\"input-setter-coercion\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8zqnny1rhvxbdlmwt1hxevutl\">输入 setter 强制类型转换<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#input-setter-coercion\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cny0upv0sp05747pmgesywsa2\">有时，指令或组件的 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 最好更改绑定到它的值，通常使用此输入的 getter / setter 对。比如，考虑以下自定义按钮组件：</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d73vg8grv6l21gyaq6z003qsq\">考虑以下指令：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'submit-button',\n  template: `\n    &lt;div class=\"wrapper\"&gt;\n      &lt;button [disabled]=\"disabled\"&gt;Submit&lt;/button&gt;\n    &lt;/div&gt;\n  `,\n})\nclass SubmitButton {\n  private _disabled: boolean;\n\n  get disabled(): boolean {\n    return this._disabled;\n  }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  set disabled(value: boolean) {\n    this._disabled = value;\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5sb2k3pibgdmawslyhxogl8ls\">在这里，组件的输入 <code>disabled</code> 将传给模板中的 <code>&lt;button&gt;</code>。只要将 <code>boolean</code> 值绑定到输入，所有这些工作都可以按预期进行。但是，假设使用者使用模板中的这个输入作为属性：</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;submit-button disabled&gt;&lt;/submit-button&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5l4t8li6ctx9un463jtio0w6s\">这与绑定具有相同的效果：</p>\n<code-example format=\"html\" language=\"html\">\n\n&lt;submit-button [disabled]=\"''\"&gt;&lt;/submit-button&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5z8qppa5kwqqpr9qxtd9sngl2\">在运行时，输入将设置为空字符串，这不是 <code>boolean</code> 值。处理此问题的 Angular 组件库通常将值“强制转换”到 setter 中的正确类型中：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nset disabled(value: boolean) {\n  this._disabled = (value === '') || value;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6zac9zts80jqtoc7nlnfa2g5l\">最好在这里将 <code>value</code> 的类型从 <code>boolean</code> 更改为 <code>boolean|''</code> 以匹配 setter 实际会接受的一组值。TypeScript 4.3 之前的版本要求 getter 和 setter 的类型相同，因此，如果 getter 要返回 <code>boolean</code> 则 setter 会卡在较窄的类型上。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"65yssidyasqhuv2vigsa2hof2\">如果消费者对模板启用了 Angular 的最严格的类型检查功能，则会产生一个问题：空字符串 <code>''</code> 实际上无法赋值给 <code>disabled</code> 字段，使用属性格式写会产生类型错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3zxi0i2rxswwc28kc6x7j6049\">作为解决此问题的一种取巧方式，Angular 支持对 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 检查比声明的输入字段更宽松的类型。通过向组件类添加带有 <code>ngAcceptInputType_</code> 前缀的静态属性来启用此功能：</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass SubmitButton {\n  private _disabled: boolean;\n\n  get disabled(): boolean {\n    return this._disabled;\n  }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  set disabled(value: boolean) {\n    this._disabled = (value === '') || value;\n  }\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> ngAcceptInputType_disabled: boolean|'';\n}\n\n</code-example>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3dyxqvwaurp5zgjwkm3izu29a\">从 TypeScript 4.3 开始，setter 能够声明为接受 <code>boolean|''</code> 类型，这就让输入属性 setter 强制类型转换字段过时了。因此，输入属性 setter 强制类型转换字段也就弃用了。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"du571pdlhlc7waqfydqddy4oe\">该字段不需要值。它只要存在就会通知 Angular 的类型检查器，<code>disabled</code> 输入应被视为接受与 <code>boolean|''</code> 类型匹配的绑定。后缀应为 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> <em>字段</em>的名称。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9mtm7uwh7yv4bsa8qnufjwxyn\">请注意，如果给定输入存在 <code>ngAcceptInputType_</code> 覆盖，则设置器应能够处理任何覆盖类型的值。</p>\n<h2 id=\"disabling-type-checking-using-any\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bldjm4zyg5yaly0v6npnm5j8e\">使用 <code>$any()</code> 禁用类型检查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#disabling-type-checking-using-any\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ra1e8v55i4yqajcmb9d8rh6z\">可以通过把绑定表达式包含在<a href=\"guide/template-expression-operators\">类型转换伪函数 <code>$any()</code></a> 中来禁用类型检查。编译器会像在 TypeScript 中使用 <code>&lt;any&gt;</code> 或 <code>as any</code> 进行类型转换一样对待它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b488m88d8qs2pcr8cyesamynd\">在以下范例中，将 <code>person</code> 强制转换为 <code>any</code> 类型可以压制错误 <code>Property address does not exist</code>。</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '{{$any(person).address.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - extended-diagnostics\n - extended-diagnostics/NG8101\n - extended-diagnostics/NG8102\n - guide/angular-compiler-options\n - guide/deprecations\n - guide/strict-mode\n - guide/structural-directives\n - guide/typescript-configuration\n-->\n<!-- links from this doc:\n - api/common/NgFor\n - api/common/NgIf\n - api/core/Component\n - api/core/Input\n - api/core/Output\n - api/core/ng-template\n - api/platform-browser/animations/async\n - api/upgrade/static\n - guide/structural-directives#directive-type-checks\n - guide/template-expression-operators\n - guide/template-expression-operators#any-type-cast-function\n - guide/template-typecheck#advice-for-library-authors\n - guide/template-typecheck#basic-mode\n - guide/template-typecheck#checking-of-ngfor\n - guide/template-typecheck#disabling-type-checking-using-any\n - guide/template-typecheck#full-mode\n - guide/template-typecheck#input-setter-coercion\n - guide/template-typecheck#inputs-and-type-checking\n - guide/template-typecheck#overview-of-template-type-checking\n - guide/template-typecheck#strict-mode\n - guide/template-typecheck#strict-null-checks\n - guide/template-typecheck#template-type-checking\n - guide/template-typecheck#troubleshooting-template-errors\n - guide/typescript-configuration\n - https://github.com/angular/angular/issues\n-->"}