{"id":"guide/http-test-requests","title":"HTTP 用戶端 - 測試請求","contents":"<div class=\"content\">\n  <h1 id=\"http-client---test-requests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"402t9l05zdu3d5qhx048eiy52\">HTTP 用戶端 - 測試請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#http-client---test-requests\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ir6otx5my6vqup1dchmzqdru\">如同所有的外部依賴一樣，你必須把 HTTP 後端也 Mock 掉，以便你的測試可以模擬這種與後端的互動。<code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing</code> 函式庫能讓這種 Mock 工作變得直截了當。</p>\n<h2 id=\"http-testing-library\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1dcjpq3nh81fjtt0iza1xzf8r\">HTTP 測試庫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#http-testing-library\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dlevf071wvrkmk0hm2x11juv\">Angular 的 HTTP 測試庫是專為其中的測試模式而設計的。在這種模式下，會首先在應用中執行程式碼併發起請求。然後，這個測試會期待發起或未發起過某個請求，並針對這些請求進行斷言，最終對每個所預期的請求進行重新整理（flush）來對這些請求提供回應。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"98r9tyag65xhx5e1zete6ah5u\">最終，測試可能會驗證這個應用不曾發起過非預期的請求。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4m5zg0xjvhojl1ai7bg8fmaov\">你可以在實時編碼環境中執行\n<live-example stackblitz=\"specs\" name=\"http\">\n 這些範例測試\n</live-example>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"pi307qc8gcljovysmnswtu43\">本章所講的這些測試位於 <code>src/testing/http-client.spec.ts</code> 中。在 <code>src/app/heroes/heroes.service.spec.ts</code> 中還有一些測試，用於測試那些呼叫了 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的資料服務。</p>\n</div>\n<h2 id=\"setup-for-testing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2nxzqy7mbd40ymngkm5xqi6cj\">搭建測試環境<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#setup-for-testing\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6loomchjppg9qtvxyw05pvnw1\">要開始測試那些透過 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 發起的請求，就要匯入 <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> 模組和模擬控制器（<code><a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a></code>）以及你測試所需的其他符號。</p>\n<code-example header=\"app/testing/http-client.spec.ts (imports)\" path=\"http/src/testing/http-client.spec.ts\" region=\"imports\">\n// Http testing module and mocking controller\nimport { <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>, <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing';\n\n// Other imports\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>, <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dxjb9q7n3lmif74u5af564wd7\">然後把 <code>HTTPClientTestingModule</code> 新增到 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 中，並繼續設定<em>被測服務</em>。</p>\n<code-example header=\"app/testing/http-client.spec.ts(setup)\" path=\"http/src/testing/http-client.spec.ts\" region=\"setup\">\ndescribe('<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> testing', () =&gt; {\n  let httpClient: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>;\n  let httpTestingController: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>;\n\n  beforeEach(() =&gt; {\n    TestBed.configureTestingModule({\n      imports: [ <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a> ]\n    });\n\n    // <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> the <a href=\"api/common/http\" class=\"code-anchor\">http</a> service and test controller for each test\n    httpClient = TestBed.inject(<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>);\n    httpTestingController = TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>);\n  });\n  /// Tests begin ///\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1filjeww8gzx9w1qaq9vl8x5h\">現在，在測試中發起的這些請求會發給這些測試用的後端（testing backend），而不是標準的後端。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68mzahglovclz0sj6wqabttjo\">這種設定還會呼叫 <code>TestBed.inject()</code>，來獲取注入的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務和模擬控制器，以便在測試期間引用它們。</p>\n<h2 id=\"expect-and-answer-requests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3fc3ir0a8kkkgfmefbmtli2sp\">期待並回答請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#expect-and-answer-requests\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5hjybnjlwguq2f469h1wb6pj6\">現在，你就可以編寫測試，等待 GET 請求並給出模擬回應。</p>\n<code-example header=\"app/testing/http-client.spec.ts (HttpClient.get)\" path=\"http/src/testing/http-client.spec.ts\" region=\"get-test\">\nit('can test HttpClient.get', () =&gt; {\n  const testData: <a href=\"api/router/Data\" class=\"code-anchor\">Data</a> = {name: 'Test <a href=\"api/router/Data\" class=\"code-anchor\">Data</a>'};\n\n  // Make an HTTP GET request\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>&gt;(testUrl)\n    .subscribe(data =&gt;\n      // When observable resolves, result should match test data\n      expect(data).toEqual(testData)\n    );\n\n  // The following `expectOne()` will match the request's URL.\n  // If no requests or <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> requests matched that URL\n  // `expectOne()` would throw.\n  const req = httpTestingController.expectOne('/data');\n\n  // Assert that the request is a GET.\n  expect(req.request.method).toEqual('GET');\n\n  // Respond with mock data, causing Observable to resolve.\n  // Subscribe callback asserts that correct data was returned.\n  req.flush(testData);\n\n  // Finally, assert that there are no outstanding requests.\n  httpTestingController.verify();\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xp1fhhvp6l5ue5w4cx6mtqw8\">最後一步，驗證沒有發起過預期之外的請求，足夠通用，因此你可以把它移到 <code>afterEach()</code> 中：</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"afterEach\">\nafterEach(() =&gt; {\n  // After every test, assert that there are no more pending requests.\n  httpTestingController.verify();\n});\n\n</code-example>\n<h3 id=\"custom-request-expectations\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ec7cvqaervzaxn9jg2j77vjte\">自定義對請求的預期<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#custom-request-expectations\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"baml57jl6hg2kjletztu16hx8\">如果僅根據 URL 對應還不夠，你還可以自行實現對應函式。比如，你可以驗證外發的請求是否帶有某個認證頭：</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"predicate\">\n// Expect one request with an authorization header\nconst req = httpTestingController.expectOne(\n  request =&gt; request.headers.has('Authorization')\n);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dtkxksczwqrby071k3dew75up\">像前面的 <code>expectOne()</code> 測試一樣，如果零或兩個以上的請求滿足了這個斷言，它就會丟擲異常。</p>\n<h3 id=\"handle-more-than-one-request\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2l3cglrx6p3vhlr4zzpjysjy\">處理多個請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#handle-more-than-one-request\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6y29m2w1qd5ehzum4u9uz1cps\">如果你需要在測試中對重複的請求進行回應，可以使用 <code>match()</code> API 來代替 <code>expectOne()</code>，它的引數不變，但會回傳一個與這些請求相對應的陣列。一旦回傳，這些請求就會從將來要對應的清單中移除，你要自己驗證和重新整理（flush）它。</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"multi-request\">\n// get all pending requests that match the given URL\nconst requests = httpTestingController.match(testUrl);\nexpect(requests.length).toEqual(3);\n\n// Respond to each request with different results\nrequests[0].flush([]);\nrequests[1].flush([testData[0]]);\nrequests[2].flush(testData);\n\n</code-example>\n<h2 id=\"test-for-errors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ookhabltha7elbwjra6nqv14\">對報錯進行測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#test-for-errors\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9tspntsrkmdixdnkivdvqfmh4\">你還要測試應用對於 HTTP 請求失敗時的防護。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7u8jzm3qa7wcrckie0kc3hnwl\">呼叫 <code>request.flush()</code> 並傳入一個錯誤訊息，如下所示。</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"404\">\nit('can test for 404 error', () =&gt; {\n  const emsg = 'deliberate 404 error';\n\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>[]&gt;(testUrl).subscribe({\n    next: () =&gt; fail('should have failed with the 404 error'),\n    error: (error: <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>) =&gt; {\n      expect(error.status).withContext('status').toEqual(404);\n      expect(error.error).withContext('message').toEqual(emsg);\n    },\n  });\n\n  const req = httpTestingController.expectOne(testUrl);\n\n  // Respond with mock error\n  req.flush(emsg, { status: 404, statusText: 'Not Found' });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b39fcdv4bfhgzxndz6omj512q\">另外，還可以用 <code>ProgressEvent</code> 來呼叫 <code>request.error()</code>。</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"network-error\">\nit('can test for network error', done =&gt; {\n  // Create mock ProgressEvent with type `error`, raised when something goes wrong\n  // at network level. e.g. Connection timeout, DNS error, offline, etc.\n  const mockError = new ProgressEvent('error');\n\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>[]&gt;(testUrl).subscribe({\n    next: () =&gt; fail('should have failed with the network error'),\n    error: (error: <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>) =&gt; {\n      expect(error.error).toBe(mockError);\n      done();\n    },\n  });\n\n  const req = httpTestingController.expectOne(testUrl);\n\n  // Respond with mock error\n  req.error(mockError);\n});\n\n</code-example>\n\n  <div class=\"reviewed\">最後複查時間：Mon Nov 14 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/testing-services\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/common/http\n - api/common/http/HttpClient\n - api/common/http/HttpErrorResponse\n - api/common/http/testing/HttpClientTestingModule\n - api/common/http/testing/HttpTestingController\n - api/core/Inject\n - api/core/testing/TestBed\n - api/forms/SelectMultipleControlValueAccessor\n - api/router/Data\n - guide/http-test-requests#custom-request-expectations\n - guide/http-test-requests#expect-and-answer-requests\n - guide/http-test-requests#handle-more-than-one-request\n - guide/http-test-requests#http-client---test-requests\n - guide/http-test-requests#http-testing-library\n - guide/http-test-requests#setup-for-testing\n - guide/http-test-requests#test-for-errors\n-->"}