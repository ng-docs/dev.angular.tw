{"id":"guide/http-test-requests","title":"HTTP 客户端 - 测试请求","contents":"<div class=\"content\">\n  <h1 id=\"http-client---test-requests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"402t9l05zdu3d5qhx048eiy52\">HTTP 客户端 - 测试请求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#http-client---test-requests\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ir6otx5my6vqup1dchmzqdru\">如同所有的外部依赖一样，你必须把 HTTP 后端也 Mock 掉，以便你的测试可以模拟这种与后端的互动。<code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing</code> 库能让这种 Mock 工作变得直截了当。</p>\n<h2 id=\"http-testing-library\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1dcjpq3nh81fjtt0iza1xzf8r\">HTTP 测试库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#http-testing-library\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dlevf071wvrkmk0hm2x11juv\">Angular 的 HTTP 测试库是专为其中的测试模式而设计的。在这种模式下，会首先在应用中执行代码并发起请求。然后，这个测试会期待发起或未发起过某个请求，并针对这些请求进行断言，最终对每个所预期的请求进行刷新（flush）来对这些请求提供响应。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"98r9tyag65xhx5e1zete6ah5u\">最终，测试可能会验证这个应用不曾发起过非预期的请求。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4m5zg0xjvhojl1ai7bg8fmaov\">你可以在实时编码环境中运行\n<live-example stackblitz=\"specs\" name=\"http\">\n 这些示例测试\n</live-example>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"pi307qc8gcljovysmnswtu43\">本章所讲的这些测试位于 <code>src/testing/http-client.spec.ts</code> 中。在 <code>src/app/heroes/heroes.service.spec.ts</code> 中还有一些测试，用于测试那些调用了 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的数据服务。</p>\n</div>\n<h2 id=\"setup-for-testing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2nxzqy7mbd40ymngkm5xqi6cj\">搭建测试环境<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#setup-for-testing\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6loomchjppg9qtvxyw05pvnw1\">要开始测试那些通过 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 发起的请求，就要导入 <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> 模块和模拟控制器（<code><a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a></code>）以及你测试所需的其他符号。</p>\n<code-example header=\"app/testing/http-client.spec.ts (imports)\" path=\"http/src/testing/http-client.spec.ts\" region=\"imports\">\n// Http testing module and mocking controller\nimport { <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>, <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing';\n\n// Other imports\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>, <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dxjb9q7n3lmif74u5af564wd7\">然后把 <code>HTTPClientTestingModule</code> 添加到 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 中，并继续设置<em>被测服务</em>。</p>\n<code-example header=\"app/testing/http-client.spec.ts(setup)\" path=\"http/src/testing/http-client.spec.ts\" region=\"setup\">\ndescribe('<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> testing', () =&gt; {\n  let httpClient: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>;\n  let httpTestingController: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>;\n\n  beforeEach(() =&gt; {\n    TestBed.configureTestingModule({\n      imports: [ <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a> ]\n    });\n\n    // <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> the <a href=\"api/common/http\" class=\"code-anchor\">http</a> service and test controller for each test\n    httpClient = TestBed.inject(<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>);\n    httpTestingController = TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>);\n  });\n  /// Tests begin ///\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1filjeww8gzx9w1qaq9vl8x5h\">现在，在测试中发起的这些请求会发给这些测试用的后端（testing backend），而不是标准的后端。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"68mzahglovclz0sj6wqabttjo\">这种设置还会调用 <code>TestBed.inject()</code>，来获取注入的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务和模拟控制器，以便在测试期间引用它们。</p>\n<h2 id=\"expect-and-answer-requests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3fc3ir0a8kkkgfmefbmtli2sp\">期待并回答请求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#expect-and-answer-requests\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5hjybnjlwguq2f469h1wb6pj6\">现在，你就可以编写测试，等待 GET 请求并给出模拟响应。</p>\n<code-example header=\"app/testing/http-client.spec.ts (HttpClient.get)\" path=\"http/src/testing/http-client.spec.ts\" region=\"get-test\">\nit('can test HttpClient.get', () =&gt; {\n  const testData: <a href=\"api/router/Data\" class=\"code-anchor\">Data</a> = {name: 'Test <a href=\"api/router/Data\" class=\"code-anchor\">Data</a>'};\n\n  // Make an HTTP GET request\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>&gt;(testUrl)\n    .subscribe(data =&gt;\n      // When observable resolves, result should match test data\n      expect(data).toEqual(testData)\n    );\n\n  // The following `expectOne()` will match the request's URL.\n  // If no requests or <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> requests matched that URL\n  // `expectOne()` would throw.\n  const req = httpTestingController.expectOne('/data');\n\n  // Assert that the request is a GET.\n  expect(req.request.method).toEqual('GET');\n\n  // Respond with mock data, causing Observable to resolve.\n  // Subscribe callback asserts that correct data was returned.\n  req.flush(testData);\n\n  // Finally, assert that there are no outstanding requests.\n  httpTestingController.verify();\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xp1fhhvp6l5ue5w4cx6mtqw8\">最后一步，验证没有发起过预期之外的请求，足够通用，因此你可以把它移到 <code>afterEach()</code> 中：</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"afterEach\">\nafterEach(() =&gt; {\n  // After every test, assert that there are no more pending requests.\n  httpTestingController.verify();\n});\n\n</code-example>\n<h3 id=\"custom-request-expectations\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ec7cvqaervzaxn9jg2j77vjte\">自定义对请求的预期<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#custom-request-expectations\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"baml57jl6hg2kjletztu16hx8\">如果仅根据 URL 匹配还不够，你还可以自行实现匹配函数。比如，你可以验证外发的请求是否带有某个认证头：</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"predicate\">\n// Expect one request with an authorization header\nconst req = httpTestingController.expectOne(\n  request =&gt; request.headers.has('Authorization')\n);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dtkxksczwqrby071k3dew75up\">像前面的 <code>expectOne()</code> 测试一样，如果零或两个以上的请求满足了这个断言，它就会抛出异常。</p>\n<h3 id=\"handle-more-than-one-request\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2l3cglrx6p3vhlr4zzpjysjy\">处理多个请求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#handle-more-than-one-request\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6y29m2w1qd5ehzum4u9uz1cps\">如果你需要在测试中对重复的请求进行响应，可以使用 <code>match()</code> API 来代替 <code>expectOne()</code>，它的参数不变，但会返回一个与这些请求相匹配的数组。一旦返回，这些请求就会从将来要匹配的列表中移除，你要自己验证和刷新（flush）它。</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"multi-request\">\n// get all pending requests that match the given URL\nconst requests = httpTestingController.match(testUrl);\nexpect(requests.length).toEqual(3);\n\n// Respond to each request with different results\nrequests[0].flush([]);\nrequests[1].flush([testData[0]]);\nrequests[2].flush(testData);\n\n</code-example>\n<h2 id=\"test-for-errors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ookhabltha7elbwjra6nqv14\">对报错进行测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#test-for-errors\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9tspntsrkmdixdnkivdvqfmh4\">你还要测试应用对于 HTTP 请求失败时的防护。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7u8jzm3qa7wcrckie0kc3hnwl\">调用 <code>request.flush()</code> 并传入一个错误信息，如下所示。</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"404\">\nit('can test for 404 error', () =&gt; {\n  const emsg = 'deliberate 404 error';\n\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>[]&gt;(testUrl).subscribe({\n    next: () =&gt; fail('should have failed with the 404 error'),\n    error: (error: <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>) =&gt; {\n      expect(error.status).withContext('status').toEqual(404);\n      expect(error.error).withContext('message').toEqual(emsg);\n    },\n  });\n\n  const req = httpTestingController.expectOne(testUrl);\n\n  // Respond with mock error\n  req.flush(emsg, { status: 404, statusText: 'Not Found' });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b39fcdv4bfhgzxndz6omj512q\">另外，还可以用 <code>ProgressEvent</code> 来调用 <code>request.error()</code>。</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"network-error\">\nit('can test for network error', done =&gt; {\n  // Create mock ProgressEvent with type `error`, raised when something goes wrong\n  // at network level. e.g. Connection timeout, DNS error, offline, etc.\n  const mockError = new ProgressEvent('error');\n\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>[]&gt;(testUrl).subscribe({\n    next: () =&gt; fail('should have failed with the network error'),\n    error: (error: <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>) =&gt; {\n      expect(error.error).toBe(mockError);\n      done();\n    },\n  });\n\n  const req = httpTestingController.expectOne(testUrl);\n\n  // Respond with mock error\n  req.error(mockError);\n});\n\n</code-example>\n\n  <div class=\"reviewed\">最后复查时间：Mon Nov 14 2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/testing-services\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/common/http\n - api/common/http/HttpClient\n - api/common/http/HttpErrorResponse\n - api/common/http/testing/HttpClientTestingModule\n - api/common/http/testing/HttpTestingController\n - api/core/Inject\n - api/core/testing/TestBed\n - api/forms/SelectMultipleControlValueAccessor\n - api/router/Data\n - guide/http-test-requests#custom-request-expectations\n - guide/http-test-requests#expect-and-answer-requests\n - guide/http-test-requests#handle-more-than-one-request\n - guide/http-test-requests#http-client---test-requests\n - guide/http-test-requests#http-testing-library\n - guide/http-test-requests#setup-for-testing\n - guide/http-test-requests#test-for-errors\n-->"}