{"id":"guide/practical-observable-usage","title":"可观察对象用法实战","contents":"<div class=\"content\">\n  <h1 id=\"practical-observable-usage\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2silmdi5l71sawwh9etadkl2\">可观察对象用法实战<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/practical-observable-usage#practical-observable-usage\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3npxtnjyuedhtxcjoggqdrk8\">这里示范了一些在某种领域中可观察对象会特别有用的例子。</p>\n<h2 id=\"type-ahead-suggestions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8upcc3m8iuhgxrgxylyx9wdgd\">输入提示（type-ahead）建议<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/practical-observable-usage#type-ahead-suggestions\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f0xxsv2jdiwigt3qskbhs8wvf\">可观察对象可以简化输入提示建议的实现方式。典型的输入提示要完成一系列独立的任务：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"empnj3ls073hvd33k7fcmsxdb\">从输入中监听数据</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4miil2ky480nav3grahp9w6l9\">移除输入值前后的空白字符，并确认它达到了最小长度</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bgwrg172cl1sldwbc5zcn8q6w\">防抖（这样才能防止连续按键时每次按键都发起 API 请求，而应该等到按键出现停顿时才发起）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43fzkl46bi9ffo76vq85uw640\">如果输入值没有变化，则不要发起请求（比如按某个字符，然后快速按退格）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drphrl2ikg44vpacse772oqgx\">如果已发出的 AJAX 请求的结果会因为后续的修改而变得无效，那就取消它</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5mfqw68lyz5ohufhe3itvil93\">完全用 JavaScript 的传统写法实现这个功能可能需要大量的工作。使用可观察对象，你可以使用这样一个 RxJS 操作符的简单序列：</p>\n<code-example header=\"Typeahead\" path=\"practical-observable-usage/src/typeahead.ts\">\nimport { fromEvent, Observable } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { debounceTime, distinctUntilChanged, filter, map, switchMap } from 'rxjs/operators';\n\nconst searchBox = document.getElementById('search-box') as HTMLInputElement;\n\nconst typeahead = fromEvent(searchBox, 'input').pipe(\n  map(e =&gt; (e.target as HTMLInputElement).value),\n  filter(text =&gt; text.length &gt; 2),\n  debounceTime(10),\n  distinctUntilChanged(),\n  switchMap(searchTerm =&gt; ajax(`/api/endpoint?search=${searchTerm}`))\n);\n\ntypeahead.subscribe(data =&gt; {\n  // Handle the data from the API\n});\n\n\n</code-example>\n<h2 id=\"exponential-backoff\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"wj3l6ztvx6hti78o035l3xzn\">指数化退避<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/practical-observable-usage#exponential-backoff\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yc7v7je75ips96s6ii7gqotb\">指数化退避是一种失败后重试 API 的技巧，它会在每次连续的失败之后让重试时间逐渐变长，超过最大重试次数之后就会彻底放弃。如果使用 Promise 对象和其它跟踪 AJAX 调用的方法会非常复杂，而使用可观察对象，这非常简单：</p>\n<code-example header=\"Exponential backoff\" path=\"practical-observable-usage/src/backoff.ts\">\nimport { timer } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { retry } from 'rxjs/operators';\n\nexport function backoff(maxTries: number, initialDelay: number) {\n    return retry({\n        count: maxTries,\n        delay: (error, retryCount) =&gt; timer(initialDelay * retryCount ** 2),\n      });\n  }\n\najax('/api/endpoint')\n  .pipe(backoff(3, 250))\n  .subscribe(function handleData(data) { /* ... */ });\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - guide/practical-observable-usage#exponential-backoff\n - guide/practical-observable-usage#practical-observable-usage\n - guide/practical-observable-usage#type-ahead-suggestions\n-->"}