{"id":"guide/practical-observable-usage","title":"可觀察物件用法實戰","contents":"<div class=\"content\">\n  <h1 id=\"practical-observable-usage\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2silmdi5l71sawwh9etadkl2\">可觀察物件用法實戰<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/practical-observable-usage#practical-observable-usage\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3npxtnjyuedhtxcjoggqdrk8\">這裡示範了一些在某種領域中可觀察物件會特別有用的例子。</p>\n<h2 id=\"type-ahead-suggestions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8upcc3m8iuhgxrgxylyx9wdgd\">輸入提示（type-ahead）建議<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/practical-observable-usage#type-ahead-suggestions\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f0xxsv2jdiwigt3qskbhs8wvf\">可觀察物件可以簡化輸入提示建議的實現方式。典型的輸入提示要完成一系列獨立的任務：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"empnj3ls073hvd33k7fcmsxdb\">從輸入中監聽資料</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4miil2ky480nav3grahp9w6l9\">移除輸入值前後的空白字元，並確認它達到了最小長度</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bgwrg172cl1sldwbc5zcn8q6w\">防抖（這樣才能防止連續按鍵時每次按鍵都發起 API 請求，而應該等到按鍵出現停頓時才發起）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43fzkl46bi9ffo76vq85uw640\">如果輸入值沒有變化，則不要發起請求（比如按某個字元，然後快速按退格）</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drphrl2ikg44vpacse772oqgx\">如果已發出的 AJAX 請求的結果會因為後續的修改而變得無效，那就取消它</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5mfqw68lyz5ohufhe3itvil93\">完全用 JavaScript 的傳統寫法實現這個功能可能需要大量的工作。使用可觀察物件，你可以使用這樣一個 RxJS 運算子的簡單序列：</p>\n<code-example header=\"Typeahead\" path=\"practical-observable-usage/src/typeahead.ts\">\nimport { fromEvent, Observable } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { debounceTime, distinctUntilChanged, filter, map, switchMap } from 'rxjs/operators';\n\nconst searchBox = document.getElementById('search-box') as HTMLInputElement;\n\nconst typeahead = fromEvent(searchBox, 'input').pipe(\n  map(e =&gt; (e.target as HTMLInputElement).value),\n  filter(text =&gt; text.length &gt; 2),\n  debounceTime(10),\n  distinctUntilChanged(),\n  switchMap(searchTerm =&gt; ajax(`/api/endpoint?search=${searchTerm}`))\n);\n\ntypeahead.subscribe(data =&gt; {\n  // Handle the data from the API\n});\n\n\n</code-example>\n<h2 id=\"exponential-backoff\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"wj3l6ztvx6hti78o035l3xzn\">指數化退避<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/practical-observable-usage#exponential-backoff\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yc7v7je75ips96s6ii7gqotb\">指數化退避是一種失敗後重試 API 的技巧，它會在每次連續的失敗之後讓重試時間逐漸變長，超過最大重試次數之後就會徹底放棄。如果使用 Promise 物件和其它跟蹤 AJAX 呼叫的方法會非常複雜，而使用可觀察物件，這非常簡單：</p>\n<code-example header=\"Exponential backoff\" path=\"practical-observable-usage/src/backoff.ts\">\nimport { timer } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { retry } from 'rxjs/operators';\n\nexport function backoff(maxTries: number, initialDelay: number) {\n    return retry({\n        count: maxTries,\n        delay: (error, retryCount) =&gt; timer(initialDelay * retryCount ** 2),\n      });\n  }\n\najax('/api/endpoint')\n  .pipe(backoff(3, 250))\n  .subscribe(function handleData(data) { /* ... */ });\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：Mon Feb 28 2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - guide/practical-observable-usage#exponential-backoff\n - guide/practical-observable-usage#practical-observable-usage\n - guide/practical-observable-usage#type-ahead-suggestions\n-->"}