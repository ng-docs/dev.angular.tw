{"id":"guide/view-encapsulation","title":"视图封装","contents":"<div class=\"content\">\n  <h1 id=\"view-encapsulation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"380hjm6ccy1kvz0uhgapjhrdr\">视图封装<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#view-encapsulation\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvzhqnbyovf521b744ialdk3q\">在 Angular 中，组件的样式可以封装在组件的宿主元素中，这样它们就不会影响应用程序的其余部分。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8lxxkmzr2wsnce7xm0zobrpi0\"><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 的装饰器提供了 <a href=\"api/core/Component#encapsulation\"><code>encapsulation</code></a> 选项，可用来控制如何基于<em>每个组件</em>应用视图封装。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4zod04s2r7sssi37m26i03qim\">从以下模式中选择：</p>\n<!-- vale off -->\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3fe6whjbmdtslgtp1har69ebd\">模式</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eb67p2cjumz2t9x2ixb8d7t85\">Angular 使用浏览器内置的 \n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM\">Shadow DOM API</a> 将组件的视图封装在一个 ShadowRoot 内，作为组件的宿主元素，并以隔离的方式应用提供的样式。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"agsppm4ugdd31r6iv7d5pj91\">Angular 修改组件的 CSS 选择器，以便它们仅应用于组件的视图，不影响应用程序中的其他元素，从而\n<em>模拟</em>了 Shadow DOM 的行为。有关更多详细信息，请参阅 \n<a href=\"guide/view-encapsulation#inspect-generated-css\">检查生成的 CSS</a>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"638p8n4oub84bp81xylt3fl6y\">Angular 不应用任何形式的视图封装，这意味着为组件指定的任何样式实际上都是全局应用的，并且可能影响应用程序中存在的任何 HTML 元素。这种模式本质上与将样式包含到 HTML 本身中是相同的。</td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"inspect-generated-css\"></a></p>\n<h2 id=\"inspecting-generated-css\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"70vxfplu8xwn1brvu4w3axmzn\">查看生成的 CSS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#inspecting-generated-css\"><i class=\"material-icons\">link</i></a></h2>\n<!-- vale on -->\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bdmqztd9upe2t6rn77ziqfjgj\">使用模拟视图封装时，Angular 会预处理所有组件的样式，以便它们仅应用于组件的视图。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1sj0ln990l41du3bbs5xzoaik\">在正运行的 Angular 应用程序的 DOM 中，使用模拟视图封装模式的组件所在的元素附加了一些额外的属性：</p>\n<code-example language=\"html\">\n\n&lt;hero-details _nghost-pmm-5&gt;\n  &lt;h2 _ngcontent-pmm-5&gt;Mister Fantastic&lt;/h2&gt;\n  &lt;hero-team _ngcontent-pmm-5 _nghost-pmm-6&gt;\n    &lt;h3 _ngcontent-pmm-6&gt;Team&lt;/h3&gt;\n  &lt;/hero-team&gt;\n&lt;/hero-details&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a11ilzuflc9jj7r18yl5krcsy\">有两种这样的属性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2e7a5u3w81azvyldqrbf228ud\">属性</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>_nghost</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"25tv64w2poxfifkdsfmgatuyu\">添加到包围组件视图的元素中，这在本地 Shadow DOM 封装中将是 ShadowRoots。这通常适用于组件的宿主元素。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>_ngcontent</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tkzh23v744w1qqgzst77j8xq\">添加到组件视图中的子元素，这些元素用于将元素与它们相应的模拟 ShadowRoots（具有匹配 \n<code>_nghost</code> 属性的宿主元素）进行匹配。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74p4mjg1huvx27hxwz7k2gi53\">这些属性的确切值是 Angular 的私有实现细节。它们是自动生成的，你不应在应用程序代码中引用它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2sqhsipky7fc5rivxairrukic\">它们以生成的组件样式为目标，这些样式会被注入到 DOM 的 <code>&lt;head&gt;</code> 部分：</p>\n<code-example format=\"css\" language=\"css\">\n\n[_nghost-pmm-5] {\n  display: block;\n  border: 1px solid black;\n}\nh3[_ngcontent-pmm-6] {\n  background-color: white;\n  border: 1px solid #777;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8z45gzr1jq0n4kx9sxg5xst17\">这些样式经过后期处理，以便每个 CSS 选择器都使用适当的 <code>_nghost</code> 或 <code>_ngcontent</code> 属性进行扩充。这些修改后的选择器可以确保样式以隔离和有针对性的方式应用于组件的视图。</p>\n<h2 id=\"mixing-encapsulation-modes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78nd5tsha6ch2h8fkjbnl6ju2\">混合封装模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#mixing-encapsulation-modes\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efdwtw7q7umlu6lvxj9gm2cb1\">如前所述，你可以在组件的装饰器中针对<em>每个组件</em>指定封装模式，这意味着在你的应用程序中，不同的组件可以使用不同的封装策略。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uoc5v2mhke4whqeaiwyx0ord\">尽管可能，但不建议这样做。如果真的需要，你应该知道使用不同封装模式的组件的样式会如何彼此交互：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3fe6whjbmdtslgtp1har69ebd\">模式</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3prlgfrx5eo2xqncnnob4crxu\">详情</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"evgabk5z3e0va63rwsprtbtvr\">组件的样式添加到文档的 \n<code>&lt;head&gt;</code> 中，使其在整个应用程序中可用，但它们的选择器只影响各自组件模板中的元素。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9h67nnq77or6bvmfi6vwh82xu\">组件的样式添加到文档的 \n<code>&lt;head&gt;</code> 中，使其在整个应用程序中可用，因此完全是全局的，并影响文档中任何匹配的元素。</td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8kmdojqpcq888vwaiak36p9uw\">组件的样式仅添加到影子 DOM 宿主中，确保它们只影响各自组件视图中的元素。</td>\n</tr>\n</tbody>\n</table>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"42abeo10ac4obz2dojfxu24lr\"><code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> 和 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 组件的样式也会添加到每个 <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> 组件的 shadow DOM 宿主中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"wymcqrwu7yecieldyay0jyzb\">这意味着带有 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 的组件的样式将影响 shadow DOM 中的匹配元素。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dyfwx5vdvo1mkty8pfx8b8azj\">这种方法乍一看似乎有违直觉，但如果没有它，带有 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 的组件将在使用 <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> 的组件内渲染不同的效果，因为其样式将不可用。</p>\n</div>\n<h3 id=\"examples\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f4iecnoqh39op5dvxqr6b3gip\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#examples\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"elk7ogo8xzbpvk4gnjgps2ggf\">本节展示了具有不同 <code><a href=\"api/core/ViewEncapsulation\" class=\"code-anchor\">ViewEncapsulation</a></code> 的组件的样式如何交互的示例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cab77uht6qrpq2ef3a1vykp3a\">请参阅 <live-example nodownload=\"\"></live-example> 以自己尝试这些组件。</p>\n<h4 id=\"no-encapsulation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cdxnr5ndq00hksbo55h8lrvv5\">无封装<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#no-encapsulation\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92fkhjqa6s7cmt2hq6j3m5idf\">第一个示例显示了一个具有 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 的组件。此组件将其模板元素着色为红色。</p>\n<code-example header=\"src/app/no-encapsulation.component.ts\" path=\"view-encapsulation/src/app/no-encapsulation.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-no-encapsulation',\n  template: `\n    &lt;h2&gt;None&lt;/h2&gt;\n    &lt;div class=\"none-message\"&gt;No encapsulation&lt;/div&gt;\n  `,\n  styles: ['h2, .none-message { color: red; }'],\n  encapsulation: <a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a>,\n})\nexport class NoEncapsulationComponent {}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c4j28e23ind7u947l410vbso5\">Angular 将此组件的样式作为全局样式添加到文档的 <code>&lt;head&gt;</code> 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6w2ml0649mgm6hmnbpa92ts3v\">如前所述，Angular 还会将这些样式添加到所有 shadow DOM 宿主。因此，样式在整个应用程序中都可用。</p>\n<div class=\"lightbox\">\n<img alt=\"component with no encapsulation\" src=\"generated/images/guide/view-encapsulation/no-encapsulation.png\" width=\"500\" height=\"101\">\n</div>\n<h4 id=\"emulated-encapsulation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"btmndcpayfogek5ic1656nvqy\">模拟封装<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#emulated-encapsulation\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"974214oeolxd9fqlcfr7g138t\">第二个示例显示了一个具有 <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> 的组件。此组件将其模板元素着色为绿色。</p>\n<code-example header=\"src/app/emulated-encapsulation.component.ts\" path=\"view-encapsulation/src/app/emulated-encapsulation.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-emulated-encapsulation',\n  template: `\n    &lt;h2&gt;Emulated&lt;/h2&gt;\n    &lt;div class=\"emulated-message\"&gt;Emulated encapsulation&lt;/div&gt;\n    &lt;app-no-encapsulation&gt;&lt;/app-no-encapsulation&gt;\n  `,\n  styles: ['h2, .emulated-message { color: green; }'],\n  encapsulation: <a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a>,\n  imports: [NoEncapsulationComponent],\n})\nexport class EmulatedEncapsulationComponent {}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ystzodd5eajatkrdat6n6u54\">与 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 类似，Angular 会将此组件的样式添加到文档的 <code>&lt;head&gt;</code> 中，但它们是带有“作用域”的样式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f2vh8a2av1c2boruwrfgsqair\">只有直接在该组件模板中的元素才会匹配其样式。由于来自 <code>EmulatedEncapsulationComponent</code> 的样式是特化的，因此它们会覆盖来自 <code>NoEncapsulationComponent</code> 的全局样式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9jzrcidebts7z6y70ofxgg058\">在此示例中，<code>EmulatedEncapsulationComponent</code> 包含着 <code>NoEncapsulationComponent</code>，但 <code>NoEncapsulationComponent</code> 仍然如预期般生效了，因为 <code>EmulatedEncapsulationComponent</code> 的“范围化”样式与其模板中的元素并不匹配。</p>\n<div class=\"lightbox\">\n<img alt=\"component with no encapsulation\" src=\"generated/images/guide/view-encapsulation/emulated-encapsulation.png\" width=\"500\" height=\"207\">\n</div>\n<h4 id=\"shadow-dom-encapsulation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8grkcz6jmje6tmbrjs7x8q2x2\">Shadow DOM 封装<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#shadow-dom-encapsulation\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"385ctppfguz84ktancrg20gdd\">第三个示例显示了一个具有 <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> 的组件。此组件会将其模板元素着色为蓝色。</p>\n<code-example header=\"src/app/shadow-dom-encapsulation.component.ts\" path=\"view-encapsulation/src/app/shadow-dom-encapsulation.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'app-shadow-dom-encapsulation',\n  template: `\n    &lt;h2&gt;ShadowDom&lt;/h2&gt;\n    &lt;div class=\"shadow-message\"&gt;Shadow DOM encapsulation&lt;/div&gt;\n    &lt;app-emulated-encapsulation&gt;&lt;/app-emulated-encapsulation&gt;\n    &lt;app-no-encapsulation&gt;&lt;/app-no-encapsulation&gt;\n  `,\n  styles: ['h2, .shadow-message { color: blue; }'],\n  encapsulation: <a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a>,\n  imports: [NoEncapsulationComponent, EmulatedEncapsulationComponent],\n})\nexport class ShadowDomEncapsulationComponent {}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ntkcl5ep5al9zaqliw0pvbuh\">Angular 仅将此组件的样式添加到 shadow DOM 宿主，因此它们在 shadow DOM 之外是不可见的。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5zit3qvjbbx40uoqpuhnpgdm\"><strong>注意</strong>：<br>\nAngular 还将 <code>NoEncapsulationComponent</code> 和 <code>EmulatedEncapsulationComponent</code> 的全局样式添加到了 shadow DOM 宿主中，因此这些样式仍然可用于该组件的模板中的元素。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3hem6l9caqiez1asphzjbpcik\">在这个例子中，<code>ShadowDomEncapsulationComponent</code> 包含一个 <code>NoEncapsulationComponent</code> 和 <code>EmulatedEncapsulationComponent</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eyxt9sn4p1w2wrjid6makv4ng\"><code>ShadowDomEncapsulationComponent</code> 组件添加的样式在该组件的整个 shadow DOM 中都可用，在 <code>NoEncapsulationComponent</code> 和 <code>EmulatedEncapsulationComponent</code> 中也是如此。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1bn7kwo0ux556d9dowje05ixq\"><code>EmulatedEncapsulationComponent</code> 具有特化的“范围化”样式，因此该组件模板的样式不受影响。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ei65g3trcrkfguxtf2sxet0ox\">由于 <code>ShadowDomEncapsulationComponent</code> 中的样式是在全局样式之后添加到 Shadow Host 中的，因此 <code>h2</code> 样式会覆盖 <code>NoEncapsulationComponent</code> 中的样式。结果是 <code>NoEncapsulationComponent</code> 中的 <code>&lt;h2&gt;</code> 元素被着色为蓝色而不是红色，这可能不是组件作者的本意。</p>\n<div class=\"lightbox\">\n<img alt=\"component with no encapsulation\" src=\"generated/images/guide/view-encapsulation/shadow-dom-encapsulation.png\" width=\"500\" height=\"413\">\n</div>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间：Fri Apr 21 2023</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/component-styles\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/Component#encapsulation\n - api/core/ViewEncapsulation\n - api/core/ViewEncapsulation#Emulated\n - api/core/ViewEncapsulation#None\n - api/core/ViewEncapsulation#ShadowDom\n - guide/view-encapsulation#emulated-encapsulation\n - guide/view-encapsulation#examples\n - guide/view-encapsulation#inspect-generated-css\n - guide/view-encapsulation#inspecting-generated-css\n - guide/view-encapsulation#mixing-encapsulation-modes\n - guide/view-encapsulation#no-encapsulation\n - guide/view-encapsulation#shadow-dom-encapsulation\n - guide/view-encapsulation#view-encapsulation\n - https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM\n-->"}