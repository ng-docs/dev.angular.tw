{"id":"guide/standalone-components","title":"獨立元件入門","contents":"<div class=\"content\">\n  <h1 id=\"getting-started-with-standalone-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44nde9ehz1fumjz2z2juyg2cr\">獨立元件入門<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#getting-started-with-standalone-components\"><i class=\"material-icons\">link</i></a></h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6bda3rt3e2ylt4n7v9b5j0zx9\"><strong>獨立元件</strong>提供了一種簡化的方式來建立 Angular 應用程式。獨立元件、指令和通道旨在透過減少對 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的需求來簡化創作體驗。現有應用程式可以選擇性地以增量方式採用新的獨立風格，而無需任何重大更改。</p>\n<h2 id=\"creating-standalone-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"18m1qja3ye7oav08800iwq0ng\">建立獨立元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#creating-standalone-components\"><i class=\"material-icons\">link</i></a></h2>\n<div class=\"video-container\">\n<video controls>\n      <source src=\"https://videos.angular.cn/x5PZwb4XurU.webm\" type=\"video/webm\">\n      <source src=\"https://videos.angular.cn/x5PZwb4XurU.mp4\" type=\"video/mp4\">\n      <track src=\"https://videos.angular.cn/x5PZwb4XurU.en.vtt\" label=\"English\" kind=\"subtitles\" srclang=\"en\">\n      <track src=\"https://videos.angular.cn/x5PZwb4XurU.cn.vtt\" label=\"簡體中文\" kind=\"subtitles\" srclang=\"zh-CN\" default>\n      <track src=\"https://videos.angular.cn/x5PZwb4XurU.tw.vtt\" label=\"正體中文\" kind=\"subtitles\" srclang=\"zh-TW\">\n    </video>\n</div>\n<h3 id=\"the-standalone-flag-and-component-imports\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"27v346llrmpay4zk6xu01z57a\"><code>standalone</code> 標誌和元件 <code>imports</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#the-standalone-flag-and-component-imports\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2d7gc7ylmp6ddvrs2uvw31pcr\">元件、指令和通道現在可以標記為 <code>standalone: true</code>。標記為獨立的 Angular 類不需要在 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中宣告（如果你嘗試，Angular 編譯器會報告錯誤）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ergxrr330e0cqanz8a0rqtdu\">獨立元件直接指定它們的依賴項，而不是透過 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 獲取它們。例如，如果 <code>PhotoGalleryComponent</code> 是獨立元件，它可以直接匯入另一個獨立元件 <code>ImageGridComponent</code>：</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'photo-gallery',\n  imports: [ImageGridComponent],\n  template: `\n    ... &lt;image-grid [images]=\"imageList\"&gt;&lt;/image-grid&gt;\n  `,\n})\nexport class PhotoGalleryComponent {\n  // component logic\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7yglrxkjgj5cqbi75yh8bck8y\"><code>imports</code> 也可用於引用獨立指令和通道。透過這種方式，可以編寫獨立元件，而無需建立 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 來管理樣板依賴項。</p>\n<h3 id=\"using-existing-ngmodules-in-a-standalone-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4z44izx5xlo16sk4z7tx3m840\">在獨立元件中使用現有的 NgModules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#using-existing-ngmodules-in-a-standalone-component\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccl1o3lnl4887guhgbpg35381\">編寫獨立元件時，你可能希望在元件的樣板中使用其他元件、指令或通道。其中某些依賴項可能不會標記為獨立，而是由現有的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 宣告和匯出。在這種情況下，你可以將 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 直接匯入到獨立元件中：</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'photo-gallery',\n  // an existing module is imported directly into a standalone component\n  imports: [MatButtonModule],\n  template: `\n    ...\n    &lt;button mat-button&gt;Next Page&lt;/button&gt;\n  `,\n})\nexport class PhotoGalleryComponent {\n  // logic\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xoj1lt8i34rldbgt5uhqmgc4\">你可以在樣板中將獨立元件與現有的基於 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的函式庫或依賴項一起使用。獨立元件可以充分利用現有的 Angular 函式庫生態系統。</p>\n<h2 id=\"using-standalone-components-in-ngmodule-based-applications\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csdyebx7ip7nm88rzhi0qi63f\">在基於 NgModule 的應用程式中使用獨立元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#using-standalone-components-in-ngmodule-based-applications\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92l5s4g499x8i968gpqhjyqon\">獨立元件也可以匯入到現有的基於 NgModules 的上下文中。這允許現有應用程式（今天使用 NgModules）逐步採用新的獨立風格的元件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c6h966wcshscf93fk4cljxxxg\">你可以像匯入 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 一樣匯入獨立元件（或指令或通道）- 使用 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code>：</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [AlbumComponent],\n  exports: [AlbumComponent], \n  imports: [PhotoGalleryComponent],\n})\nexport class AlbumModule {}\n</code-example>\n<h2 id=\"bootstrapping-an-application-using-a-standalone-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37516qx084m3046kwaynvicr9\">使用獨立元件引導應用程式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#bootstrapping-an-application-using-a-standalone-component\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4js1699m07ki50cw5p3l7bnsv\">透過使用獨立元件作為應用程式的根元件，可以在沒有任何 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的情況下引導 Angular 應用程式。這是使用 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> API 來完成的：</p>\n<code-example language=\"ts\">\n// in the main.ts file\nimport {<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>} from '@angular/platform-browser';\nimport {PhotoAppComponent} from './app/photo.app.component';\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent);\n</code-example>\n<h3 id=\"configuring-dependency-injection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1wsln13zy2pmixcg7na6ijsvv\">設定依賴注入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#configuring-dependency-injection\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqwb86673l9pn0e5e2zsd3l9i\">引導應用程式時，你通常希望設定 Angular 的依賴注入並提供設定值或服務以在整個應用程式中使用。你可以將這些作為提供者傳遞給 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code>：</p>\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    // ...\n  ]\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eklgtvkuw09xdx4zx2p0yauos\">獨立的引導操作基於顯式設定 <code><a href=\"api/core/Provider\" class=\"code-anchor\">Provider</a></code> 清單以進行依賴注入。在 Angular 中，帶有 <code>provide</code> 字首的函式可用於設定不同的系統，而不必匯入 NgModules。比如 <code><a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a></code> 可用於 <code>RouterModule.forRoot</code> 中以設定路由器：</p>\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([/* app routes */]),\n    // ...\n  ]\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4rfs9pkr2o0d28z459quhhly2\">許多第三方庫也已更新以支援這種 <code>provide</code> 設定模式。如果某個函式庫僅為其 DI 設定提供 NgModule API，你可以用 <code><a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a></code> 實用函式，來將它與 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> 和其他獨立上下文一起使用：</p>\n<code-example language=\"ts\">\nimport {LibraryModule} from 'ngmodule-based-library';\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    <a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a>(\n      LibraryModule.forRoot()\n    ),\n  ]\n});\n</code-example>\n<h2 id=\"routing-and-lazy-loading\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ymwmxmucdty68np7huxrwo79\">路由和延遲載入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#routing-and-lazy-loading\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7l4z33tr71e5euis1fmvs11mv\">路由器 API 進行了更新和簡化，以利用獨立元件的優勢：在許多常見的延遲載入場景中不再需要 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>。</p>\n<h3 id=\"lazy-loading-a-standalone-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1r3j1gudb23rl5uel2i0y2bdx\">延遲載入獨立元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-a-standalone-component\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3e8yei0xpkb81sixh9657tlx\">任何路由都可以用 <code>loadComponent</code> 延遲載入其路由到的獨立元件：</p>\n<code-example language=\"ts\">\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'admin', loadComponent: () =&gt; import('./admin/panel.component').then(mod =&gt; mod.AdminPanelComponent)},\n  // ...\n];\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b62j625z01nxq3wjn7c44scye\">只要載入的元件是獨立的，就可以用。</p>\n<h3 id=\"lazy-loading-many-routes-at-once\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1eu7r6cy2icc7ngk26zlfea2x\">一次延遲載入多個路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-many-routes-at-once\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"84ohngzj4taxg7usml1g04btk\"><code>loadChildren</code> 操作現在支援載入一組新的子 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>，而無需編寫延遲載入的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 來匯入 <code>RouterModule.forChild</code> 來宣告路由。當以這種方式載入的每個路由都使用獨立元件時，這會起作用。</p>\n<code-example language=\"ts\">\n// In the main application:\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'admin', loadChildren: () =&gt; import('./admin/routes').then(mod =&gt; mod.ADMIN_ROUTES)},\n  // ...\n];\n\n// In admin/routes.ts:\nexport const ADMIN_ROUTES: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'home', component: AdminHomeComponent},\n  {path: 'users', component: AdminUsersComponent},\n  // ...\n];\n</code-example>\n<h3 id=\"lazy-loading-and-default-exports\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dld3wxrs5ggzho8i62umgt0zz\">延遲載入和預設匯出<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-and-default-exports\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94wbas59bqa3f9gy1f48ws4k8\">使用 <code>loadChildren</code> 和 <code>loadComponent</code> 時，路由器會理解並使用 <code>default</code> 導出來自動解開動態 <code>import()</code> 呼叫。你可以利用這一點跳過 <code>.then()</code> 進行此類延遲載入操作。</p>\n<code-example language=\"ts\">\n// In the main application:\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'admin', loadChildren: () =&gt; import('./admin/routes')},\n  // ...\n];\n\n// In admin/routes.ts:\nexport default [\n  {path: 'home', component: AdminHomeComponent},\n  {path: 'users', component: AdminUsersComponent},\n  // ...\n] satisfies <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[];\n</code-example>\n<h3 id=\"providing-services-to-a-subset-of-routes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7rmyxkwkitaqko2f4bxd0keq\">為路由的子集提供服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#providing-services-to-a-subset-of-routes\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"q56bei3qzbqanj0sxgxh20bj\"><code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的延遲載入 API （ <code>loadChildren</code>）在載入路由的延遲載入的子項時會建立一個新的『模組』注入器。此屬性通常可用於僅嚮應用程式中的一部分路由提供服務。例如，如果 <code>/admin</code> 下的所有路由都使用 <code>loadChildren</code> 邊界來限定範圍，則可以僅向這些路由提供僅限管理的服務。執行此操作需要使用 <code>loadChildren</code> API，即使延遲載入有問題的路由不是必要的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1rbra9vs0y1aeoyn6ujsbbbzs\">路由器現在支援在 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> 上顯式指定其他 <code>providers</code>，這允許相同的範圍限定，而無需延遲載入或 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>。例如，<code>/admin</code> 路由結構中的範圍服務將類似於：</p>\n<code-example language=\"ts\">\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {\n    path: 'admin',\n    providers: [\n      AdminService,\n      {provide: ADMIN_API_KEY, useValue: '12345'},\n    ],\n    children: [\n      {path: 'users', component: AdminUsersComponent},\n      {path: 'teams', component: AdminTeamsComponent},\n    ],\n  },\n  // ... other application routes that don't\n  //     have access to ADMIN_API_KEY or AdminService.\n];\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b5i8zuatavam15qid942nyibl\">也可以將 <code>providers</code> 與額外路由設定的 <code>loadChildren</code> 結合使用，以實現與延遲載入帶有額外路由和路由級服務提供者的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 相同的效果。此範例設定與上面相同的提供者/子路由，但在延遲載入邊界之後：</p>\n<code-example language=\"ts\">\n// Main application:\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = {\n  // Lazy-load the admin routes.\n  {path: 'admin', loadChildren: () =&gt; import('./admin/routes').then(mod =&gt; mod.ADMIN_ROUTES)},\n  // ... rest of the routes\n}\n\n// In admin/routes.ts:\nexport const ADMIN_ROUTES: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [{\n  path: '',\n  pathMatch: 'prefix',\n  providers: [\n    AdminService,\n    {provide: ADMIN_API_KEY, useValue: 12345},\n  ],\n  children: [\n    {path: 'users', component: AdminUsersCmp},\n    {path: 'teams', component: AdminTeamsCmp},\n  ],\n}];\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24vb7mdokkl1hofaqn97srsb9\">請注意這裡使用了空路徑路由來定義供所有子路由共享的宿主 <code>providers</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vb96ororzlb6is86qyxzjdh2\"><code><a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a></code> 也可用於將現有的基於 NgModule 的 DI 設定匯入到路由 <code>providers</code> 中。</p>\n<h2 id=\"advanced-topics\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74227uv8w0mnb9jwmm0p94era\">高階主題<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#advanced-topics\"><i class=\"material-icons\">link</i></a></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"33z2ohbbbqwr4xbxermuj7igl\">本節會更詳細地介紹僅與更高階的使用模式相關的。第一次瞭解獨立元件、指令和通道時，你可以安全地跳過本節。</p>\n<h3 id=\"standalone-components-for-library-authors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3c5qn1z3lkpqmr6k4ksx0y5j\">針對庫作者的獨立元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#standalone-components-for-library-authors\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1n9jckhta36radetpdqagya9m\">獨立的元件、指令和通道可以從匯入它們的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中匯出：</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ImageCarouselComponent, ImageSlideComponent],\n  exports: [ImageCarouselComponent, ImageSlideComponent],\n})\nexport class CarouselModule {}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8kszlffe2nw2c39o7gqknseib\">此模式對於發布一組合作指令的 Angular 函式庫很有用。在上面的範例中，<code>ImageCarouselComponent</code> 和 <code>ImageSlideComponent</code> 需要出現在樣板中，以建立一個邏輯上的『輪播小部件』。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cp4acw51pipi18mpofwge5v7a\">作為發布 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的替代方案，庫作者可能希望匯出一個合作指令陣列：</p>\n<code-example language=\"ts\">\nexport const CAROUSEL_DIRECTIVES = [ImageCarouselComponent, ImageSlideComponent] as const;\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ar389fevc6i39o35on6azfjky\">這樣的陣列可以由使用 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的應用程式匯入並新增到 <code>@<a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code>。請注意 TypeScript 的 <code>as const</code> 構造的存在：它為 Angular 編譯器提供了正確編譯所需的額外訊息，並且是一種推薦的實踐（因為它使匯出的陣列從 TypeScript 的角度來看是不可變的）。</p>\n<h3 id=\"dependency-injection-and-injectors-hierarchy\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dzn0gp7mf7wuawenn4b4mfp9h\">依賴注入和注入器層次結構<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#dependency-injection-and-injectors-hierarchy\"><i class=\"material-icons\">link</i></a></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ll7w5g6p519duq60l3zyjx1e\">Angular 應用程式可以透過指定一組可用的提供者來設定依賴注入。在典型應用中，有兩種不同的注入器型別：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dz46v30cinlq3q1a40231wc2t\">具有在 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 或 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({providedIn: \"...\"})</code> 中設定的服務提供者的<strong>模組注入器</strong>。這些應用程式範圍的提供者對模組注入器中設定的所有元件以及其他服務可見。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yf65lhrfs8h9rvm7a3ge6fy5\">在 <code>@<a href=\"api/core/Directive#providers\" class=\"code-anchor\">Directive.providers</a></code> / <code>@Component.providers</code> 或 <code>@<a href=\"api/core/Component#viewProviders\" class=\"code-anchor\">Component.viewProviders</a></code> 中設定的<strong>節點注入器</strong>。這些提供者僅對給定元件及其所有子項可見。</li>\n</ul>\n<h4 id=\"environment-injectors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3dvfz1nc1jqhdfhl9jg7f0vb\">環境注入器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#environment-injectors\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5afl67b6ul1d9j61nb9kqw0kl\">使 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 變成可選的將需要一種新方法來用應用程式範圍的提供者（例如<a href=\"/api/common/http/HttpClient\">HttpClient</a>）設定『模組』注入器。在獨立應用程式（使用 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> 建立的）中，可以在引導過程中在 <code>providers</code> 選項中設定『模組』提供者：</p>\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    {provide: PhotosService, useClass: PhotosService},\n    // ...\n  ]\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"418mmyl28e5btkqp843flzsfp\">新的啟動 API 使我們能夠在不使用 \n<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的情況下設定『模組注入器』。在這種意義上，名稱中的『模組』部分已不再相關，因此我們決定引入一個新術語：『環境注入器』。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a48r2ejy52oxkpalkm878ysk5\">可以用以下方法之一設定環境注入器：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3k4m15qnuy225n2vuxds0v0i\"><code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>（在透過 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 引導的應用程式中）；</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dxid7ha5yhqkkfza9t93wdoih\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({provideIn: \"...\"})</code>（在基於 NgModule 以及『獨立』應用程式中）；</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9nwog0r66mppbi37feswepq3y\"><code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> 呼叫中的 <code>providers</code> 選項（在完全『獨立』的應用程式中）；</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9182carrdj0co327shfc2712f\"><code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> 設定中的 <code>providers</code> 欄位。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9of7x07qw0yyvf40p4xwleiev\">Angular v14 引入了一種新的 TypeScript 型別 <code><a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a></code> 來表示這種新命名。附帶的 <code><a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a></code> API 使得以程式設計方式建立環境注入器成為可能：</p>\n<code-example language=\"ts\">\nimport {<a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>} from '@angular/core';\n\nconst parentInjector = … // existing environment injector\nconst childInjector = <a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>([{provide: PhotosService, useClass: CustomPhotosService}], parentInjector);\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5hksnoxqwtxt1zlwncow49d64\">環境注入器還有一個額外的能力：它們可以在建立環境注入器時執行初始化邏輯（類似於建立模組注入器時執行的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 建構式函式）：</p>\n<code-example language=\"ts\">\nimport {<a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>, <a href=\"api/core/ENVIRONMENT_INITIALIZER\" class=\"code-anchor\">ENVIRONMENT_INITIALIZER</a>} from '@angular/core';\n\n<a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>([\n{provide: PhotosService, useClass: CustomPhotosService},\n{provide: <a href=\"api/core/ENVIRONMENT_INITIALIZER\" class=\"code-anchor\">ENVIRONMENT_INITIALIZER</a>, useValue: () =&gt; {\n        console.log(\"This function runs when this <a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a> gets created\");\n}}\n]);\n</code-example>\n<h4 id=\"standalone-injectors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3o8c23bhtqf8tb89xulubr2ag\">獨立注入器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#standalone-injectors\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b4e913smfjx2renry4m8g09nl\">實際上，依賴注入器層次結構在使用獨立元件的應用程式中稍微複雜一些。讓我們考慮以下範例：</p>\n<code-example language=\"ts\">\n// an existing \"datepicker\" component with an <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n&nbsp; &nbsp; &nbsp; &nbsp; selector: 'datepicker',\n&nbsp; &nbsp; &nbsp; &nbsp; template: '...',\n})\nclass DatePickerComponent {\n  constructor(private calendar: CalendarService) {}\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n&nbsp; &nbsp; &nbsp; &nbsp; declarations: [DatePickerComponent],\n&nbsp; &nbsp; &nbsp; &nbsp; exports: [DatePickerComponent],\n&nbsp; &nbsp; &nbsp; &nbsp; providers: [CalendarService],\n})\nclass DatePickerModule {\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n&nbsp; &nbsp; &nbsp; &nbsp; selector: 'date-modal',\n&nbsp; &nbsp; &nbsp; &nbsp; template: '&lt;datepicker&gt;&lt;/datepicker&gt;',\n&nbsp; &nbsp; &nbsp; &nbsp; standalone: true,\n&nbsp; &nbsp; &nbsp; &nbsp; imports: [DatePickerModule]\n})\nclass DateModalComponent {\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5aqp8j98cn2x49wqoqta2cx0a\">在上面的範例中，元件 <code>DateModalComponent</code> 是獨立的 - 它可以直接使用，並且沒有需要匯入才能使用它的 NgModule。但是，<code>DateModalComponent</code> 有一個依賴項 <code>DatePickerComponent</code>，它是透過其 NgModule（<code>DatePickerModule</code>）匯入的。此 NgModule 可以宣告 <code>DatePickerComponent</code> 正常執行所需的提供者（在本例中為：<code>CalendarService</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gaexkm3pojv7gum78jp3om1y\">當 Angular 建立一個獨立元件時，需要確保當前注入器具有獨立元件的所有必要服務依賴，包括基於 NgModule 的依賴。為了保證這一點，在某些情況下，Angular 將建立一個新的『獨立注入器』作為當前環境注入器的子級。今天，在所有已啟動的獨立元件中都會發生這種情況：它將是根環境注入器的子級。相同的規則適用於動態建立的（例如透過路由器或 \n<code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code> API）的獨立元件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ce39sbjyuoifgqm3steo6xgen\">建立了一個單獨的獨立注入器，以確保獨立元件匯入的提供者與應用程式的其餘部分『隔離』。這讓我們將獨立元件視為真正獨立的部分，不能將它們的實現細節『洩漏』給應用程式的其餘部分。</p>\n<h4 id=\"resolve-circular-dependencies-with-a-forward-class-reference\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"o5jeozrasd76el1zcztbmngl\">使用前向類別引用解決迴圈依賴<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#resolve-circular-dependencies-with-a-forward-class-reference\"><i class=\"material-icons\">link</i></a></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bmp3ierm3wcwjw6n0v5nonun5\">在 TypeScript 裡面，類別宣告的順序是很重要的。如果一個類別尚未定義，就不能引用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5reucw1ujmbqvnm50mzl0v80i\">這通常不是問題，但有時迴圈引用是不可避免的。例如，當類『A』引用類『B』而『B』也引用『A』時。其中之一必須首先定義。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bfqkh7c3nromqvuvx0vfbeb8s\">Angular 的 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> 函式建立了一個 Angular 稍後可以解析的間接引用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35rl4ixrwq5n32ep2s4tdrna6\">例如，當獨立父元件匯入獨立子元件時會發生這種情況，反之亦然。你可以使用 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a></code> 函式解決此迴圈依賴問題。</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true, \n  imports: [ChildComponent],\n  selector: 'app-parent',\n  template: `&lt;app-child [hideParent]=\"hideParent\"&gt;&lt;/app-child&gt;`,\n})\nexport class ParentComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hideParent: boolean;\n}\n\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  imports: [<a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; ParentComponent)],\n  selector: 'app-child',\n  template: `&lt;app-parent *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"!hideParent\"&gt;&lt;/app-parent&gt;`,\n})\nexport class ChildComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hideParent: boolean;\n}\n</code-example>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3e14ypmi1ztn3vgvtoli77h28\">這種型別的匯入可能會導致元件實例化期間出現無限遞迴。請確保這種遞迴具有停止條件，會在某種時刻停止。</p>\n</div>\n\n  \n</div>\n\n\n<!-- links to this doc:\n - api/common/NgOptimizedImage\n - api/core/Component\n - api/core/Directive\n - api/core/Pipe\n - api/core/createEnvironmentInjector\n - api/core/importProvidersFrom\n - api/platform-browser\n - api/platform-browser/bootstrapApplication\n - guide/architecture-components\n - guide/deprecations\n - guide/glossary\n - guide/pipe-template\n - guide/pipes\n - guide/pipes-transform-data\n - guide/standalone-migration\n - guide/update-to-version-15\n-->\n<!-- links from this doc:\n - /api/common/http/HttpClient\n - api/common/CommonModule\n - api/common/NgIf\n - api/core/Component\n - api/core/Component#viewProviders\n - api/core/Directive#providers\n - api/core/ENVIRONMENT_INITIALIZER\n - api/core/EnvironmentInjector\n - api/core/Injectable\n - api/core/Input\n - api/core/NgModule\n - api/core/NgModule#imports\n - api/core/NgModule#providers\n - api/core/Provider\n - api/core/ViewContainerRef\n - api/core/createEnvironmentInjector\n - api/core/forwardRef\n - api/core/importProvidersFrom\n - api/platform-browser/bootstrapApplication\n - api/router/ROUTES\n - api/router/Route\n - api/router/provideRouter\n - guide/standalone-components#advanced-topics\n - guide/standalone-components#bootstrapping-an-application-using-a-standalone-component\n - guide/standalone-components#configuring-dependency-injection\n - guide/standalone-components#creating-standalone-components\n - guide/standalone-components#dependency-injection-and-injectors-hierarchy\n - guide/standalone-components#environment-injectors\n - guide/standalone-components#getting-started-with-standalone-components\n - guide/standalone-components#lazy-loading-a-standalone-component\n - guide/standalone-components#lazy-loading-and-default-exports\n - guide/standalone-components#lazy-loading-many-routes-at-once\n - guide/standalone-components#providing-services-to-a-subset-of-routes\n - guide/standalone-components#resolve-circular-dependencies-with-a-forward-class-reference\n - guide/standalone-components#routing-and-lazy-loading\n - guide/standalone-components#standalone-components-for-library-authors\n - guide/standalone-components#standalone-injectors\n - guide/standalone-components#the-standalone-flag-and-component-imports\n - guide/standalone-components#using-existing-ngmodules-in-a-standalone-component\n - guide/standalone-components#using-standalone-components-in-ngmodule-based-applications\n-->"}
